diff --git a/.gitignore b/.gitignore
index 02dbb2b..dee78cd 100644
--- a/.gitignore
+++ b/.gitignore
@@ -11,3 +11,12 @@ vivado*.str
 
 # Ignore build directory
 build
+
+src/box_250mhz/reconic
+src/box_250mhz/vivado_ip
+src/box_250mhz/build.tcl
+src/box_250mhz/rdma_onic_plugin.sv
+src/box_250mhz/reconic_address_map.sv
+
+sim/axi_packets/__pycache__
+sim/axi_in_cmac*
\ No newline at end of file
diff --git a/board_files/Xilinx/au55c/LICENSE b/board_files/Xilinx/au55c/LICENSE
new file mode 100644
index 0000000..9c30aad
--- /dev/null
+++ b/board_files/Xilinx/au55c/LICENSE
@@ -0,0 +1,15 @@
+#########################################################################
+Copyright (C) 2021, Xilinx Inc - All rights reserved
+
+Licensed under the Apache License, Version 2.0 (the "License"). You may
+not use this file except in compliance with the License. A copy of the
+License is located at
+
+ http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+License for the specific language governing permissions and limitations
+under the License.
+#########################################################################
diff --git a/board_files/Xilinx/au55c/board.xml b/board_files/Xilinx/au55c/board.xml
new file mode 100644
index 0000000..7295ee1
--- /dev/null
+++ b/board_files/Xilinx/au55c/board.xml
@@ -0,0 +1,1266 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
+<board schema_version="2.2" vendor="xilinx.com" name="au55c" display_name="Alveo U55C Data Center Accelerator Card" url="http://www.xilinx.com/U55C" supports_ced="false" preset_file = "preset.xml">
+  <images>
+    <image name="au55c_image.png" display_name="Alveo U55C Data Center Accelerator Card" sub_type="board" resolution="high">
+      <description>Alveo U55C Data Center Accelerator Card</description>
+    </image>
+  </images>
+
+  <compatible_board_revisions>
+    <revision id="0">1.0</revision>
+  </compatible_board_revisions>
+
+  <file_version>1.0</file_version>
+
+  <description>Alveo U55C Data Center Accelerator Card </description>
+
+  <parameters>
+    <parameter name="heat_sink_type" value="medium" value_type="string"/>
+    <parameter name="heat_sink_temperature" value_type="range" value_min="20.0" value_max="30.0"/>
+  </parameters>
+
+  <jumpers>
+  </jumpers>
+
+  <power_rails>
+    <power_rail name="0V85_VCCINT" is_direct="TRUE">
+      <supply name="VCCINT"/>
+    </power_rail>
+    <power_rail name="0V85_VCCINT_IO" is_direct="TRUE">
+      <supply name="VCCINT_IO"/>
+      <supply name="VCCBRAM"/>
+    </power_rail>
+    <power_rail name="0V9_AVCC" is_direct="TRUE">
+      <supply name="MGTYAVCC"/>
+    </power_rail>
+    <power_rail name="1V2_AVTT" is_direct="TRUE">
+      <supply name="MGTYAVTT"/>
+    </power_rail>
+    <power_rail name="1V2_HBM" is_direct="TRUE">
+      <supply name="VCC_HBM"/>
+    </power_rail>
+    <power_rail name="2V5_VPP" is_direct="TRUE">
+      <supply name="VCCAUX_HBM"/>
+    </power_rail>
+    <power_rail name="1V8" is_direct="TRUE">
+      <supply name="VCCAUX"/>
+      <supply name="VCCAUX_IO"/>
+      <supply name="MGTYVCCAUX"/>
+      <supply name="VCCO18"/>
+      <supply name="VCCADC"/>
+    </power_rail>
+  </power_rails>
+
+  <data_properties>
+    <data_property_group name="OPERATING_CONDITIONS">
+
+      <data_property_group name="VOLTAGE">
+        <data_property name="0V85_VCCINT" value="0.85"/>
+        <data_property name="0V85_VCCINT_IO" value="0.85"/>
+        <data_property name="0V9_AVCC" value="0.9"/>
+        <data_property name="1V2_AVTT" value="1.2"/>
+        <data_property name="1V8" value="1.8"/>
+        <data_property name="1V2_HBM" value="1.2"/>
+        <data_property name="2V5_VPP" value="2.5"/>
+      </data_property_group>
+
+      <data_property_group name="SUPPLY_CURRENT_BUDGET">
+        <data_property name="0V85_VCCINT" value="100"/>
+        <data_property name="0V85_VCCINT_IO" value="30"/>
+        <data_property name="0V9_AVCC " value="4"/>
+        <data_property name="1V2_AVTT " value="12"/>
+        <data_property name="1V2_HBM " value="80"/>
+        <data_property name="2V5_VPP" value="0.3"/>
+        <data_property name="1V8" value="4"/>
+      </data_property_group>
+
+      <data_property name="THETAJA" value="0.75"/>
+      <data_property name="AMBIENT_TEMP" value="55"/>
+      <data_property name="DESIGN_POWER_BUDGET" value="123"/>
+
+    </data_property_group>
+  </data_properties>
+
+  <components>
+
+    <component name="part0" display_name="XCU55C FPGA" type="fpga" part_name="xcu55c-fsvh2892-2L-e" pin_map_file="part0_pins.xml" vendor="xilinx" spec_url="http://www.xilinx.com/U55C">
+      <description>XCU55C FPGA</description>
+
+
+    <interfaces>
+
+     <interface mode="slave" name="pcie_perstn" type="xilinx.com:signal:reset_rtl:1.0" of_component="pci_express">
+      <preferred_ips>
+            <preferred_ip vendor="xilinx.com" library="ip" name="xdma" order="0"/>
+            <preferred_ip vendor="xilinx.com" library="ip" name="qdma" order="1"/>
+       </preferred_ips>
+          <port_maps>
+            <port_map logical_port="RST" physical_port="pcie_perstn_rst" dir="in">
+              <pin_maps>
+                <pin_map port_index="0" component_pin="PCIE_PERST_LS_65"/>
+              </pin_maps>
+            </port_map>
+          </port_maps>
+          <parameters>
+            <parameter name="rst_polarity" value="0" />
+            <parameter name="type" value="PCIE_PERST" />
+          </parameters>
+        </interface>
+
+    <interface mode="master" name="hbm_cattrip" type="xilinx.com:interface:gpio_rtl:1.0" of_component="hbm_cattrip">
+          <preferred_ips>
+            <preferred_ip vendor="xilinx.com" library="ip" name="hbm" order="0"/>
+            <preferred_ip vendor="xilinx.com" library="ip" name="axi_gpio" order="1"/>
+          </preferred_ips>
+          <port_maps>
+            <port_map logical_port="O" physical_port="hbm_cattrip" dir="out">
+              <pin_maps>
+                <pin_map port_index="0" component_pin="HBM_CATTRIP_LS"/>
+              </pin_maps>
+            </port_map>
+          </port_maps>
+        </interface>
+
+        <!--
+    <interface mode="master" name="rs232_fpga_msp" type="xilinx.com:interface:uart_rtl:1.0" of_component="rs232_fpga_msp">
+          <preferred_ips>
+            <preferred_ip vendor="xilinx.com" library="ip" name="axi_uart16550" order="0"/>
+          </preferred_ips>
+          <port_maps>
+            <port_map logical_port="TxD" physical_port="rs232_uart_msp_txd" dir="out">
+            </port_map>
+            <port_map logical_port="RxD" physical_port="rs232_uart_msp_rxd" dir="in">
+            </port_map>
+          </port_maps>
+        </interface>
+
+    <interface mode="master" name="fpga_uart0" type="xilinx.com:interface:uart_rtl:1.0" of_component="fpga_uart0">
+          <port_maps>
+            <port_map logical_port="TxD" physical_port="rs232_uart_msp_txd" dir="out">
+            </port_map>
+            <port_map logical_port="RxD" physical_port="rs232_uart_msp_rxd" dir="in">
+            </port_map>
+          </port_maps>
+        </interface>
+      -->
+
+      <!-- Si5394 Satellite Controlelr Pins -->
+      <interface mode="master" name="reset_gpio2_si5394" type="xilinx.com:interface:gpio_rtl:1.0" of_component="reset_si5394" preset_proc="reset2_si5394_preset">
+        <preferred_ips>
+          <preferred_ip vendor="xilinx.com" library="ip" name="axi_gpio" order="0"/>
+        </preferred_ips>
+        <port_maps>
+          <port_map logical_port="TRI_O" physical_port="SI_RSTBB" dir="out">
+            <pin_maps>
+              <pin_map port_index="0" component_pin="SI_RSTBB"/>
+            </pin_maps>
+          </port_map>
+        </port_maps>
+      </interface>
+
+      <interface mode="master" name="gpio_si5394" type="xilinx.com:interface:gpio_rtl:1.0" of_component="gpio_si5394">
+        <preferred_ips>
+          <preferred_ip vendor="xilinx.com" library="ip" name="axi_gpio" order="0"/>
+        </preferred_ips>
+        <port_maps>
+          <port_map logical_port="TRI_I" physical_port="SI_INTRB_PLL_LOCK_IN_LOS" dir="in" left="2" right="0">
+            <pin_maps>
+              <pin_map port_index="0" component_pin="SI_INTRB"/>
+              <pin_map port_index="1" component_pin="SI_PLL_LOCK"/>
+              <pin_map port_index="2" component_pin="SI_IN_LOS"/>
+            </pin_maps>
+          </port_map>
+        </port_maps>
+      </interface>
+
+      <interface mode="master" name="msp_gpio" type="xilinx.com:interface:gpio_rtl:1.0" of_component="msp_gpio">
+        <preferred_ips>
+          <preferred_ip vendor="xilinx.com" library="ip" name="axi_gpio" order="0"/>
+        </preferred_ips>
+        <port_maps>
+          <port_map logical_port="TRI_I" physical_port="GPIO_MSP_i" dir="in" left="1" right="0">
+            <pin_maps>
+              <pin_map port_index="0" component_pin="MSP_GPIO0"/>
+              <pin_map port_index="1" component_pin="MSP_GPIO1"/>
+            </pin_maps>
+          </port_map>
+        </port_maps>
+      </interface>
+
+      <interface mode="master" name="iic_si5394" type="xilinx.com:interface:iic_rtl:1.0" of_component="iic_si5394">
+        <preferred_ips>
+          <preferred_ip vendor="xilinx.com" library="ip" name="axi_iic" order="0"/>
+        </preferred_ips>
+        <port_maps>
+          <port_map logical_port="SDA_I" physical_port="iic_si5394_sda_i" dir="inout">
+            <pin_maps>
+              <pin_map port_index="0" component_pin="I2C_SI5394_SDA"/>
+            </pin_maps>
+          </port_map>
+          <port_map logical_port="SDA_O" physical_port="iic_si5394_sda_o" dir="inout">
+            <pin_maps>
+              <pin_map port_index="0" component_pin="I2C_SI5394_SDA"/>
+            </pin_maps>
+          </port_map>
+          <port_map logical_port="SDA_T" physical_port="iic_si5394_sda_t" dir="inout">
+            <pin_maps>
+              <pin_map port_index="0" component_pin="I2C_SI5394_SDA"/>
+            </pin_maps>
+          </port_map>
+          <port_map logical_port="SCL_I" physical_port="iic_si5394_scl_i" dir="inout">
+            <pin_maps>
+              <pin_map port_index="0" component_pin="I2C_SI5394_SCL"/>
+            </pin_maps>
+          </port_map>
+          <port_map logical_port="SCL_O" physical_port="iic_si5394_scl_o" dir="inout">
+            <pin_maps>
+              <pin_map port_index="0" component_pin="I2C_SI5394_SCL"/>
+            </pin_maps>
+          </port_map>
+          <port_map logical_port="SCL_T" physical_port="iic_si5394_scl_t" dir="inout">
+            <pin_maps>
+              <pin_map port_index="0" component_pin="I2C_SI5394_SCL"/>
+            </pin_maps>
+          </port_map>
+        </port_maps>
+      </interface>
+
+
+      <interface mode="slave" name="qsfp0_refclk0" type="xilinx.com:interface:diff_clock_rtl:1.0" of_component="qsfp0">
+          <parameters>
+            <parameter name="frequency" value="161132812"/>
+          </parameters>
+            <preferred_ips>
+              <preferred_ip vendor="xilinx.com" library="ip" name="xxv_ethernet" order="0"/>
+              <preferred_ip vendor="xilinx.com" library="ip" name="usxgmii" order="1"/>
+              <preferred_ip vendor="xilinx.com" library="ip" name="l_ethernet" order="2"/>
+              <preferred_ip vendor="xilinx.com" library="ip" name="cmac_usplus" order="3"/>
+            </preferred_ips>
+          <port_maps>
+            <port_map logical_port="CLK_P" physical_port="qsfp0_refclk0_clk_p" dir="in">
+              <pin_maps>
+                <pin_map port_index="0" component_pin="SYNCE_CLK0_P"/>
+              </pin_maps>
+            </port_map>
+            <port_map logical_port="CLK_N" physical_port="qsfp0_refclk0_clk_n" dir="in">
+              <pin_maps>
+                <pin_map port_index="0" component_pin="SYNCE_CLK0_N"/>
+              </pin_maps>
+            </port_map>
+          </port_maps>
+        </interface>
+
+      <interface mode="slave" name="qsfp1_refclk0" type="xilinx.com:interface:diff_clock_rtl:1.0" of_component="qsfp1">
+          <parameters>
+            <parameter name="frequency" value="161132812"/>
+          </parameters>
+          <preferred_ips>
+            <preferred_ip vendor="xilinx.com" library="ip" name="xxv_ethernet" order="0"/>
+            <preferred_ip vendor="xilinx.com" library="ip" name="usxgmii" order="1"/>
+            <preferred_ip vendor="xilinx.com" library="ip" name="l_ethernet" order="2"/>
+            <preferred_ip vendor="xilinx.com" library="ip" name="cmac_usplus" order="3"/>
+           </preferred_ips>
+          <port_maps>
+            <port_map logical_port="CLK_P" physical_port="qsfp1_refclk0_clk_p" dir="in">
+              <pin_maps>
+                <pin_map port_index="0" component_pin="SYNCE_CLK1_P"/>
+              </pin_maps>
+            </port_map>
+            <port_map logical_port="CLK_N" physical_port="qsfp1_refclk0_clk_n" dir="in">
+              <pin_maps>
+                <pin_map port_index="0" component_pin="SYNCE_CLK1_N"/>
+              </pin_maps>
+            </port_map>
+          </port_maps>
+        </interface>
+
+  <!--
+    <interface mode="slave" name="slr0_freerun_clk" type="xilinx.com:interface:diff_clock_rtl:1.0" of_component="slr0_freerun_clk">
+     <parameters>
+            <parameter name="frequency" value="100000000"/>
+          </parameters>
+          <port_maps>
+            <port_map logical_port="CLK_P" physical_port="slr0_freerun_clk_p" dir="in">
+            </port_map>
+            <port_map logical_port="CLK_N" physical_port="slr0_freerun_clk_n" dir="in">
+            </port_map>
+          </port_maps>
+        </interface>
+
+    <interface mode="slave" name="slr1_freerun_clk" type="xilinx.com:interface:diff_clock_rtl:1.0" of_component="slr1_freerun_clk">
+     <parameters>
+            <parameter name="frequency" value="100000000"/>
+          </parameters>
+          <port_maps>
+            <port_map logical_port="CLK_P" physical_port="slr1_freerun_clk_p" dir="in">
+            </port_map>
+            <port_map logical_port="CLK_N" physical_port="slr1_freerun_clk_n" dir="in">
+            </port_map>
+          </port_maps>
+        </interface>
+      -->
+
+    <interface mode="slave" name="pcie_refclk" type="xilinx.com:interface:diff_clock_rtl:1.0" of_component="pcie_refclk" preset_proc="pcie_refclk_preset">
+      <parameters>
+        <parameter name="frequency" value="100000000"/>
+      </parameters>
+      <preferred_ips>
+        <preferred_ip vendor="xilinx.com" library="ip" name="util_ds_buf" order="0"/>
+        <preferred_ip vendor="xilinx.com" library="ip" name="clk_wiz" order="1"/>
+      </preferred_ips>
+      <port_maps>
+        <port_map logical_port="CLK_P" physical_port="pcie_mgt_clk_p" dir="in">
+          <pin_maps>
+            <pin_map port_index="0" component_pin="PCIE_REFCLK1_P"/>
+          </pin_maps>
+        </port_map>
+        <port_map logical_port="CLK_N" physical_port="pcie_mgt_clk_n" dir="in">
+          <pin_maps>
+            <pin_map port_index="0" component_pin="PCIE_REFCLK1_N"/>
+          </pin_maps>
+        </port_map>
+      </port_maps>
+    </interface>
+
+    <interface mode="master" name="pci_express_x4" type="xilinx.com:interface:pcie_7x_mgt_rtl:1.0" of_component="pci_express" preset_proc="pciex4_preset">
+          <preferred_ips>
+              <preferred_ip vendor="xilinx.com" library="ip" name="xdma" order="0"/>
+              <preferred_ip vendor="xilinx.com" library="ip" name="qdma" order="1"/>
+              <preferred_ip vendor="xilinx.com" library="ip" name="pcie4c_uscale_plus" order="2"/>
+          </preferred_ips>
+          <port_maps>
+            <port_map logical_port="txn" physical_port="pcie_tx0_nx4" dir="out" left="3" right="0">
+                <pin_maps>
+                  <pin_map port_index="0" component_pin="pcie_tx0_n"/>
+                  <pin_map port_index="1" component_pin="pcie_tx1_n"/>
+                  <pin_map port_index="2" component_pin="pcie_tx2_n"/>
+                  <pin_map port_index="3" component_pin="pcie_tx3_n"/>
+                </pin_maps>
+            </port_map>
+            <port_map logical_port="rxn" physical_port="pcie_rx0_nx4" dir="in" left="3" right="0">
+                <pin_maps>
+                  <pin_map port_index="0" component_pin="pcie_rx0_n"/>
+                  <pin_map port_index="1" component_pin="pcie_rx1_n"/>
+                  <pin_map port_index="2" component_pin="pcie_rx2_n"/>
+                  <pin_map port_index="3" component_pin="pcie_rx3_n"/>
+                </pin_maps>
+            </port_map>
+            <port_map logical_port="txp" physical_port="pcie_tx0_px4" dir="out" left="3" right="0">
+                <pin_maps>
+                  <pin_map port_index="0" component_pin="pcie_tx0_p"/>
+                  <pin_map port_index="1" component_pin="pcie_tx1_p"/>
+                  <pin_map port_index="2" component_pin="pcie_tx2_p"/>
+                  <pin_map port_index="3" component_pin="pcie_tx3_p"/>
+                </pin_maps>
+            </port_map>
+            <port_map logical_port="rxp" physical_port="pcie_rx0_px4" dir="in" left="3" right="0">
+                <pin_maps>
+                  <pin_map port_index="0" component_pin="pcie_rx0_p"/>
+                  <pin_map port_index="1" component_pin="pcie_rx1_p"/>
+                  <pin_map port_index="2" component_pin="pcie_rx2_p"/>
+                  <pin_map port_index="3" component_pin="pcie_rx3_p"/>
+                </pin_maps>
+            </port_map>
+          </port_maps>
+          <parameters>
+            <parameter name="block_location" value="PCIE4C_X1Y1" />
+          </parameters>
+        </interface>
+
+    <interface mode="master" name="pci_express_x8" type="xilinx.com:interface:pcie_7x_mgt_rtl:1.0" of_component="pci_express" preset_proc="pciex8_preset">
+          <preferred_ips>
+              <preferred_ip vendor="xilinx.com" library="ip" name="xdma" order="0"/>
+              <preferred_ip vendor="xilinx.com" library="ip" name="qdma" order="1"/>
+              <preferred_ip vendor="xilinx.com" library="ip" name="pcie4c_uscale_plus" order="2"/>
+          </preferred_ips>
+          <port_maps>
+            <port_map logical_port="txn" physical_port="pcie_tx0_nx8" dir="out" left="7" right="0">
+              <pin_maps>
+                  <pin_map port_index="0" component_pin="pcie_tx0_n"/>
+                  <pin_map port_index="1" component_pin="pcie_tx1_n"/>
+                  <pin_map port_index="2" component_pin="pcie_tx2_n"/>
+                  <pin_map port_index="3" component_pin="pcie_tx3_n"/>
+                  <pin_map port_index="4" component_pin="pcie_tx4_n"/>
+                  <pin_map port_index="5" component_pin="pcie_tx5_n"/>
+                  <pin_map port_index="6" component_pin="pcie_tx6_n"/>
+                  <pin_map port_index="7" component_pin="pcie_tx7_n"/>
+                </pin_maps>
+            </port_map>
+            <port_map logical_port="rxn" physical_port="pcie_rx0_nx8" dir="in" left="7" right="0">
+              <pin_maps>
+                  <pin_map port_index="0" component_pin="pcie_rx0_n"/>
+                  <pin_map port_index="1" component_pin="pcie_rx1_n"/>
+                  <pin_map port_index="2" component_pin="pcie_rx2_n"/>
+                  <pin_map port_index="3" component_pin="pcie_rx3_n"/>
+                  <pin_map port_index="4" component_pin="pcie_rx4_n"/>
+                  <pin_map port_index="5" component_pin="pcie_rx5_n"/>
+                  <pin_map port_index="6" component_pin="pcie_rx6_n"/>
+                  <pin_map port_index="7" component_pin="pcie_rx7_n"/>
+                </pin_maps>
+            </port_map>
+            <port_map logical_port="txp" physical_port="pcie_tx0_px8" dir="out" left="7" right="0">
+                <pin_maps>
+                    <pin_map port_index="0" component_pin="pcie_tx0_p"/>
+                    <pin_map port_index="1" component_pin="pcie_tx1_p"/>
+                    <pin_map port_index="2" component_pin="pcie_tx2_p"/>
+                    <pin_map port_index="3" component_pin="pcie_tx3_p"/>
+                    <pin_map port_index="4" component_pin="pcie_tx4_p"/>
+                    <pin_map port_index="5" component_pin="pcie_tx5_p"/>
+                    <pin_map port_index="6" component_pin="pcie_tx6_p"/>
+                    <pin_map port_index="7" component_pin="pcie_tx7_p"/>
+                  </pin_maps>
+            </port_map>
+            <port_map logical_port="rxp" physical_port="pcie_rx0_px8" dir="in" left="7" right="0">
+                <pin_maps>
+                    <pin_map port_index="0" component_pin="pcie_rx0_p"/>
+                    <pin_map port_index="1" component_pin="pcie_rx1_p"/>
+                    <pin_map port_index="2" component_pin="pcie_rx2_p"/>
+                    <pin_map port_index="3" component_pin="pcie_rx3_p"/>
+                    <pin_map port_index="4" component_pin="pcie_rx4_p"/>
+                    <pin_map port_index="5" component_pin="pcie_rx5_p"/>
+                    <pin_map port_index="6" component_pin="pcie_rx6_p"/>
+                    <pin_map port_index="7" component_pin="pcie_rx7_p"/>
+                  </pin_maps>
+            </port_map>
+          </port_maps>
+          <parameters>
+            <parameter name="block_location" value="PCIE4C_X1Y1" />
+          </parameters>
+        </interface>
+
+
+    <interface mode="master" name="pci_express_x16" type="xilinx.com:interface:pcie_7x_mgt_rtl:1.0" of_component="pci_express" preset_proc="pciex16_preset">
+          <preferred_ips>
+              <preferred_ip vendor="xilinx.com" library="ip" name="xdma" order="0"/>
+              <preferred_ip vendor="xilinx.com" library="ip" name="qdma" order="1"/>
+              <preferred_ip vendor="xilinx.com" library="ip" name="pcie4c_uscale_plus" order="2"/>
+          </preferred_ips>
+          <port_maps>
+            <port_map logical_port="txn" physical_port="pcie_tx0_nx16" dir="out" left="15" right="0">
+              <pin_maps>
+                <pin_map port_index="0"  component_pin="pcie_tx0_n"/>
+                <pin_map port_index="1"  component_pin="pcie_tx1_n"/>
+                <pin_map port_index="2"  component_pin="pcie_tx2_n"/>
+                <pin_map port_index="3"  component_pin="pcie_tx3_n"/>
+                <pin_map port_index="4"  component_pin="pcie_tx4_n"/>
+                <pin_map port_index="5"  component_pin="pcie_tx5_n"/>
+                <pin_map port_index="6"  component_pin="pcie_tx6_n"/>
+                <pin_map port_index="7"  component_pin="pcie_tx7_n"/>
+                <pin_map port_index="8"  component_pin="pcie_tx8_n"/>
+                <pin_map port_index="9"  component_pin="pcie_tx9_n"/>
+                <pin_map port_index="10" component_pin="pcie_tx10_n"/>
+                <pin_map port_index="11" component_pin="pcie_tx11_n"/>
+                <pin_map port_index="12" component_pin="pcie_tx12_n"/>
+                <pin_map port_index="13" component_pin="pcie_tx13_n"/>
+                <pin_map port_index="14" component_pin="pcie_tx14_n"/>
+                <pin_map port_index="15" component_pin="pcie_tx15_n"/>
+              </pin_maps>
+            </port_map>
+
+            <port_map logical_port="rxn" physical_port="pcie_rx0_nx16" dir="in" left="15" right="0">
+              <pin_maps>
+                <pin_map port_index="0"  component_pin="pcie_rx0_n"/>
+                <pin_map port_index="1"  component_pin="pcie_rx1_n"/>
+                <pin_map port_index="2"  component_pin="pcie_rx2_n"/>
+                <pin_map port_index="3"  component_pin="pcie_rx3_n"/>
+                <pin_map port_index="4"  component_pin="pcie_rx4_n"/>
+                <pin_map port_index="5"  component_pin="pcie_rx5_n"/>
+                <pin_map port_index="6"  component_pin="pcie_rx6_n"/>
+                <pin_map port_index="7"  component_pin="pcie_rx7_n"/>
+                <pin_map port_index="8"  component_pin="pcie_rx8_n"/>
+                <pin_map port_index="9"  component_pin="pcie_rx9_n"/>
+                <pin_map port_index="10" component_pin="pcie_rx10_n"/>
+                <pin_map port_index="11" component_pin="pcie_rx11_n"/>
+                <pin_map port_index="12" component_pin="pcie_rx12_n"/>
+                <pin_map port_index="13" component_pin="pcie_rx13_n"/>
+                <pin_map port_index="14" component_pin="pcie_rx14_n"/>
+                <pin_map port_index="15" component_pin="pcie_rx15_n"/>
+              </pin_maps>
+            </port_map>
+
+            <port_map logical_port="txp" physical_port="pcie_tx0_px16" dir="out" left="15" right="0">
+              <pin_maps>
+                <pin_map port_index="0"  component_pin="pcie_tx0_p"/>
+                <pin_map port_index="1"  component_pin="pcie_tx1_p"/>
+                <pin_map port_index="2"  component_pin="pcie_tx2_p"/>
+                <pin_map port_index="3"  component_pin="pcie_tx3_p"/>
+                <pin_map port_index="4"  component_pin="pcie_tx4_p"/>
+                <pin_map port_index="5"  component_pin="pcie_tx5_p"/>
+                <pin_map port_index="6"  component_pin="pcie_tx6_p"/>
+                <pin_map port_index="7"  component_pin="pcie_tx7_p"/>
+                <pin_map port_index="8"  component_pin="pcie_tx8_p"/>
+                <pin_map port_index="9"  component_pin="pcie_tx9_p"/>
+                <pin_map port_index="10" component_pin="pcie_tx10_p"/>
+                <pin_map port_index="11" component_pin="pcie_tx11_p"/>
+                <pin_map port_index="12" component_pin="pcie_tx12_p"/>
+                <pin_map port_index="13" component_pin="pcie_tx13_p"/>
+                <pin_map port_index="14" component_pin="pcie_tx14_p"/>
+                <pin_map port_index="15" component_pin="pcie_tx15_p"/>
+              </pin_maps>
+            </port_map>
+
+            <port_map logical_port="rxp" physical_port="pcie_rx0_px16" dir="in" left="15" right="0">
+              <pin_maps>
+                <pin_map port_index="0"  component_pin="pcie_rx0_p"/>
+                <pin_map port_index="1"  component_pin="pcie_rx1_p"/>
+                <pin_map port_index="2"  component_pin="pcie_rx2_p"/>
+                <pin_map port_index="3"  component_pin="pcie_rx3_p"/>
+                <pin_map port_index="4"  component_pin="pcie_rx4_p"/>
+                <pin_map port_index="5"  component_pin="pcie_rx5_p"/>
+                <pin_map port_index="6"  component_pin="pcie_rx6_p"/>
+                <pin_map port_index="7"  component_pin="pcie_rx7_p"/>
+                <pin_map port_index="8"  component_pin="pcie_rx8_p"/>
+                <pin_map port_index="9"  component_pin="pcie_rx9_p"/>
+                <pin_map port_index="10" component_pin="pcie_rx10_p"/>
+                <pin_map port_index="11" component_pin="pcie_rx11_p"/>
+                <pin_map port_index="12" component_pin="pcie_rx12_p"/>
+                <pin_map port_index="13" component_pin="pcie_rx13_p"/>
+                <pin_map port_index="14" component_pin="pcie_rx14_p"/>
+                <pin_map port_index="15" component_pin="pcie_rx15_p"/>
+                </pin_maps>
+            </port_map>
+          </port_maps>
+          <parameters>
+            <parameter name="block_location" value="PCIE4C_X1Y1" />
+          </parameters>
+        </interface>
+
+        <interface mode="master" name="qsfp0_1x" type="xilinx.com:interface:gt_rtl:1.0" of_component="qsfp0" preset_proc="qsfp0_1x_preset">
+          <description>1-lane GT interface over QSFP0</description>
+          <preferred_ips>
+            <preferred_ip vendor="xilinx.com" library="ip" name="xxv_ethernet" order="0"/>
+            <preferred_ip vendor="xilinx.com" library="ip" name="usxgmii" order="1"/>
+          </preferred_ips>
+          <port_maps>
+                  <port_map logical_port="GTX_N" physical_port="qsfp0_txn1" dir="out" >
+                    <pin_maps>
+                      <pin_map port_index="0" component_pin="QSFP28_0_TX1_N"/>
+                    </pin_maps>
+                  </port_map>
+                  <port_map logical_port="GTX_P" physical_port="qsfp0_txp1" dir="out" >
+                    <pin_maps>
+                      <pin_map port_index="0" component_pin="QSFP28_0_TX1_P"/>
+                    </pin_maps>
+                  </port_map>
+                  <port_map logical_port="GRX_N" physical_port="qsfp0_rxn1" dir="in" >
+                    <pin_maps>
+                      <pin_map port_index="0" component_pin="QSFP28_0_RX1_N"/>
+                    </pin_maps>
+                  </port_map>
+                  <port_map logical_port="GRX_P" physical_port="qsfp0_rxp1" dir="in" >
+                    <pin_maps>
+                      <pin_map port_index="0" component_pin="QSFP28_0_RX1_P"/>
+                    </pin_maps>
+                  </port_map>
+                </port_maps>
+                 <parameters>
+                  <parameter name="gt_loc" value="" />
+                </parameters>
+              </interface>
+
+          <interface mode="master" name="qsfp0_2x" type="xilinx.com:interface:gt_rtl:1.0" of_component="qsfp0" preset_proc="qsfp0_2x_preset">
+            <description>2-lane GT interface over QSFP0</description>
+            <preferred_ips>
+              <preferred_ip vendor="xilinx.com" library="ip" name="xxv_ethernet" order="0"/>
+              <preferred_ip vendor="xilinx.com" library="ip" name="usxgmii" order="1"/>
+              <preferred_ip vendor="xilinx.com" library="ip" name="l_ethernet" order="2"/>
+             </preferred_ips>
+            <port_maps>
+                    <port_map logical_port="GTX_N" physical_port="qsfp0_txn2" dir="out" left="1" right="0">
+                      <pin_maps>
+                        <pin_map port_index="0" component_pin="QSFP28_0_TX1_N"/>
+                        <pin_map port_index="1" component_pin="QSFP28_0_TX2_N"/>
+                      </pin_maps>
+                    </port_map>
+                    <port_map logical_port="GTX_P" physical_port="qsfp0_txp2" dir="out" left="1" right="0">
+                      <pin_maps>
+                        <pin_map port_index="0" component_pin="QSFP28_0_TX1_P"/>
+                        <pin_map port_index="1" component_pin="QSFP28_0_TX2_P"/>
+                     </pin_maps>
+                    </port_map>
+                    <port_map logical_port="GRX_N" physical_port="qsfp0_rxn2" dir="in" left="1" right="0">
+                      <pin_maps>
+                        <pin_map port_index="0" component_pin="QSFP28_0_RX1_N"/>
+                        <pin_map port_index="1" component_pin="QSFP28_0_RX2_N"/>
+                     </pin_maps>
+                    </port_map>
+                    <port_map logical_port="GRX_P" physical_port="qsfp0_rxp2" dir="in" left="1" right="0">
+                      <pin_maps>
+                        <pin_map port_index="0" component_pin="QSFP28_0_RX1_P"/>
+                        <pin_map port_index="1" component_pin="QSFP28_0_RX2_P"/>
+                      </pin_maps>
+                    </port_map>
+                  </port_maps>
+                    <parameters>
+                    <parameter name="gt_loc" value="" />
+                  </parameters>
+                </interface>
+
+        <interface mode="master" name="qsfp0_3x" type="xilinx.com:interface:gt_rtl:1.0" of_component="qsfp0" preset_proc="qsfp0_3x_preset">
+          <description>3-lane GT interface over QSFP0</description>
+          <preferred_ips>
+            <preferred_ip vendor="xilinx.com" library="ip" name="xxv_ethernet" order="0"/>
+            <preferred_ip vendor="xilinx.com" library="ip" name="usxgmii" order="1"/>
+         </preferred_ips>
+          <port_maps>
+                  <port_map logical_port="GTX_N" physical_port="qsfp0_txn3" dir="out" left="2" right="0">
+                    <pin_maps>
+                      <pin_map port_index="0" component_pin="QSFP28_0_TX1_N"/>
+                      <pin_map port_index="1" component_pin="QSFP28_0_TX2_N"/>
+                      <pin_map port_index="2" component_pin="QSFP28_0_TX3_N"/>
+                   </pin_maps>
+                  </port_map>
+                  <port_map logical_port="GTX_P" physical_port="qsfp0_txp3" dir="out" left="2" right="0">
+                    <pin_maps>
+                      <pin_map port_index="0" component_pin="QSFP28_0_TX1_P"/>
+                      <pin_map port_index="1" component_pin="QSFP28_0_TX2_P"/>
+                      <pin_map port_index="2" component_pin="QSFP28_0_TX3_P"/>
+                    </pin_maps>
+                  </port_map>
+                  <port_map logical_port="GRX_N" physical_port="qsfp0_rxn3" dir="in" left="2" right="0">
+                    <pin_maps>
+                      <pin_map port_index="0" component_pin="QSFP28_0_RX1_N"/>
+                      <pin_map port_index="1" component_pin="QSFP28_0_RX2_N"/>
+                      <pin_map port_index="2" component_pin="QSFP28_0_RX3_N"/>
+                    </pin_maps>
+                  </port_map>
+                  <port_map logical_port="GRX_P" physical_port="qsfp0_rxp3" dir="in" left="2" right="0">
+                    <pin_maps>
+                      <pin_map port_index="0" component_pin="QSFP28_0_RX1_P"/>
+                      <pin_map port_index="1" component_pin="QSFP28_0_RX2_P"/>
+                      <pin_map port_index="2" component_pin="QSFP28_0_RX3_P"/>
+                    </pin_maps>
+                  </port_map>
+                </port_maps>
+                  <parameters>
+                  <parameter name="gt_loc" value="" />
+                </parameters>
+              </interface>
+
+        <interface mode="master" name="qsfp0_4x" type="xilinx.com:interface:gt_rtl:1.0" of_component="qsfp0" preset_proc="qsfp0_4x_preset">
+        <description>4-lane GT interface over QSFP0</description>
+        <preferred_ips>
+          <preferred_ip vendor="xilinx.com" library="ip" name="xxv_ethernet" order="0"/>
+          <preferred_ip vendor="xilinx.com" library="ip" name="usxgmii" order="1"/>
+          <preferred_ip vendor="xilinx.com" library="ip" name="l_ethernet" order="2"/>
+          <preferred_ip vendor="xilinx.com" library="ip" name="cmac_usplus" order="3"/>
+        </preferred_ips>
+        <port_maps>
+                <port_map logical_port="GTX_N" physical_port="qsfp0_txn4" dir="out" left="3" right="0">
+                  <pin_maps>
+                    <pin_map port_index="0" component_pin="QSFP28_0_TX1_N"/>
+                    <pin_map port_index="1" component_pin="QSFP28_0_TX2_N"/>
+                    <pin_map port_index="2" component_pin="QSFP28_0_TX3_N"/>
+                    <pin_map port_index="3" component_pin="QSFP28_0_TX4_N"/>
+                  </pin_maps>
+                </port_map>
+                <port_map logical_port="GTX_P" physical_port="qsfp0_txp4" dir="out" left="3" right="0">
+                  <pin_maps>
+                    <pin_map port_index="0" component_pin="QSFP28_0_TX1_P"/>
+                    <pin_map port_index="1" component_pin="QSFP28_0_TX2_P"/>
+                    <pin_map port_index="2" component_pin="QSFP28_0_TX3_P"/>
+                    <pin_map port_index="3" component_pin="QSFP28_0_TX4_P"/>
+                  </pin_maps>
+                </port_map>
+                <port_map logical_port="GRX_N" physical_port="qsfp0_rxn4" dir="in" left="3" right="0">
+                  <pin_maps>
+                    <pin_map port_index="0" component_pin="QSFP28_0_RX1_N"/>
+                    <pin_map port_index="1" component_pin="QSFP28_0_RX2_N"/>
+                    <pin_map port_index="2" component_pin="QSFP28_0_RX3_N"/>
+                    <pin_map port_index="3" component_pin="QSFP28_0_RX4_N"/>
+                  </pin_maps>
+                </port_map>
+                <port_map logical_port="GRX_P" physical_port="qsfp0_rxp4" dir="in" left="3" right="0">
+                  <pin_maps>
+                    <pin_map port_index="0" component_pin="QSFP28_0_RX1_P"/>
+                    <pin_map port_index="1" component_pin="QSFP28_0_RX2_P"/>
+                    <pin_map port_index="2" component_pin="QSFP28_0_RX3_P"/>
+                    <pin_map port_index="3" component_pin="QSFP28_0_RX4_P"/>
+                  </pin_maps>
+                </port_map>
+              </port_maps>
+               <parameters>
+                <parameter name="gt_loc" value="" />
+              </parameters>
+            </interface>
+
+        <interface mode="master" name="qsfp1_1x" type="xilinx.com:interface:gt_rtl:1.0" of_component="qsfp1" preset_proc="qsfp1_1x_preset">
+          <description>1-lane GT interface over QSFP0</description>
+          <preferred_ips>
+            <preferred_ip vendor="xilinx.com" library="ip" name="xxv_ethernet" order="0"/>
+            <preferred_ip vendor="xilinx.com" library="ip" name="usxgmii" order="1"/>
+          </preferred_ips>
+          <port_maps>
+                  <port_map logical_port="GTX_N" physical_port="qsfp1_txn1" dir="out" >
+                    <pin_maps>
+                      <pin_map port_index="0" component_pin="QSFP28_1_TX1_N"/>
+                    </pin_maps>
+                  </port_map>
+                  <port_map logical_port="GTX_P" physical_port="qsfp1_txp1" dir="out" >
+                    <pin_maps>
+                      <pin_map port_index="0" component_pin="QSFP28_1_TX1_P"/>
+                    </pin_maps>
+                  </port_map>
+                  <port_map logical_port="GRX_N" physical_port="qsfp1_rxn1" dir="in" >
+                    <pin_maps>
+                      <pin_map port_index="0" component_pin="QSFP28_1_RX1_N"/>
+                    </pin_maps>
+                  </port_map>
+                  <port_map logical_port="GRX_P" physical_port="qsfp1_rxp1" dir="in" >
+                    <pin_maps>
+                      <pin_map port_index="0" component_pin="QSFP28_1_RX1_P"/>
+                    </pin_maps>
+                  </port_map>
+                </port_maps>
+                  <parameters>
+                  <parameter name="gt_loc" value="" />
+                </parameters>
+              </interface>
+
+        <interface mode="master" name="qsfp1_2x" type="xilinx.com:interface:gt_rtl:1.0" of_component="qsfp1" preset_proc="qsfp1_2x_preset">
+          <description>2-lane GT interface over QSFP0</description>
+          <preferred_ips>
+            <preferred_ip vendor="xilinx.com" library="ip" name="xxv_ethernet" order="0"/>
+            <preferred_ip vendor="xilinx.com" library="ip" name="usxgmii" order="1"/>
+            <preferred_ip vendor="xilinx.com" library="ip" name="l_ethernet" order="2"/>
+            </preferred_ips>
+          <port_maps>
+                  <port_map logical_port="GTX_N" physical_port="qsfp1_txn2" dir="out" left="1" right="0">
+                    <pin_maps>
+                      <pin_map port_index="0" component_pin="QSFP28_1_TX1_N"/>
+                      <pin_map port_index="1" component_pin="QSFP28_1_TX2_N"/>
+                    </pin_maps>
+                  </port_map>
+                  <port_map logical_port="GTX_P" physical_port="qsfp1_txp2" dir="out" left="1" right="0">
+                    <pin_maps>
+                      <pin_map port_index="0" component_pin="QSFP28_1_TX1_P"/>
+                      <pin_map port_index="1" component_pin="QSFP28_1_TX2_P"/>
+                    </pin_maps>
+                  </port_map>
+                  <port_map logical_port="GRX_N" physical_port="qsfp1_rxn2" dir="in" left="1" right="0">
+                    <pin_maps>
+                      <pin_map port_index="0" component_pin="QSFP28_1_RX1_N"/>
+                      <pin_map port_index="1" component_pin="QSFP28_1_RX2_N"/>
+                    </pin_maps>
+                  </port_map>
+                  <port_map logical_port="GRX_P" physical_port="qsfp1_rxp2" dir="in" left="1" right="0">
+                    <pin_maps>
+                      <pin_map port_index="0" component_pin="QSFP28_1_RX1_P"/>
+                      <pin_map port_index="1" component_pin="QSFP28_1_RX2_P"/>
+                    </pin_maps>
+                  </port_map>
+                </port_maps>
+                  <parameters>
+                  <parameter name="gt_loc" value="" />
+                </parameters>
+              </interface>
+
+        <interface mode="master" name="qsfp1_3x" type="xilinx.com:interface:gt_rtl:1.0" of_component="qsfp1" preset_proc="qsfp1_3x_preset">
+          <description>3-lane GT interface over QSFP0</description>
+          <preferred_ips>
+            <preferred_ip vendor="xilinx.com" library="ip" name="xxv_ethernet" order="0"/>
+            <preferred_ip vendor="xilinx.com" library="ip" name="usxgmii" order="1"/>
+          </preferred_ips>
+          <port_maps>
+                  <port_map logical_port="GTX_N" physical_port="qsfp1_txn3" dir="out" left="2" right="0">
+                    <pin_maps>
+                      <pin_map port_index="0" component_pin="QSFP28_1_TX1_N"/>
+                      <pin_map port_index="1" component_pin="QSFP28_1_TX2_N"/>
+                      <pin_map port_index="2" component_pin="QSFP28_1_TX3_N"/>
+                    </pin_maps>
+                  </port_map>
+                  <port_map logical_port="GTX_P" physical_port="qsfp1_txp3" dir="out" left="2" right="0">
+                    <pin_maps>
+                      <pin_map port_index="0" component_pin="QSFP28_1_TX1_P"/>
+                      <pin_map port_index="1" component_pin="QSFP28_1_TX2_P"/>
+                      <pin_map port_index="2" component_pin="QSFP28_1_TX3_P"/>
+                    </pin_maps>
+                  </port_map>
+                  <port_map logical_port="GRX_N" physical_port="qsfp1_rxn3" dir="in" left="2" right="0">
+                    <pin_maps>
+                      <pin_map port_index="0" component_pin="QSFP28_1_RX1_N"/>
+                      <pin_map port_index="1" component_pin="QSFP28_1_RX2_N"/>
+                      <pin_map port_index="2" component_pin="QSFP28_1_RX3_N"/>
+                    </pin_maps>
+                  </port_map>
+                  <port_map logical_port="GRX_P" physical_port="qsfp1_rxp3" dir="in" left="2" right="0">
+                    <pin_maps>
+                      <pin_map port_index="0" component_pin="QSFP28_1_RX1_P"/>
+                      <pin_map port_index="1" component_pin="QSFP28_1_RX2_P"/>
+                      <pin_map port_index="2" component_pin="QSFP28_1_RX3_P"/>
+                    </pin_maps>
+                  </port_map>
+                </port_maps>
+                  <parameters>
+                  <parameter name="gt_loc" value="" />
+                </parameters>
+              </interface>
+
+        <interface mode="master" name="qsfp1_4x" type="xilinx.com:interface:gt_rtl:1.0" of_component="qsfp1" preset_proc="qsfp1_4x_preset">
+        <description>4-lane GT interface over QSFP0</description>
+        <preferred_ips>
+          <preferred_ip vendor="xilinx.com" library="ip" name="xxv_ethernet" order="0"/>
+          <preferred_ip vendor="xilinx.com" library="ip" name="usxgmii" order="1"/>
+          <preferred_ip vendor="xilinx.com" library="ip" name="l_ethernet" order="2"/>
+          <preferred_ip vendor="xilinx.com" library="ip" name="cmac_usplus" order="3"/>
+        </preferred_ips>
+        <port_maps>
+                <port_map logical_port="GTX_N" physical_port="qsfp1_txn4" dir="out" left="3" right="0">
+                  <pin_maps>
+                    <pin_map port_index="0" component_pin="QSFP28_1_TX1_N"/>
+                    <pin_map port_index="1" component_pin="QSFP28_1_TX2_N"/>
+                    <pin_map port_index="2" component_pin="QSFP28_1_TX3_N"/>
+                    <pin_map port_index="3" component_pin="QSFP28_1_TX4_N"/>
+                  </pin_maps>
+                </port_map>
+                <port_map logical_port="GTX_P" physical_port="qsfp1_txp4" dir="out" left="3" right="0">
+                  <pin_maps>
+                    <pin_map port_index="0" component_pin="QSFP28_1_TX1_P"/>
+                    <pin_map port_index="1" component_pin="QSFP28_1_TX2_P"/>
+                    <pin_map port_index="2" component_pin="QSFP28_1_TX3_P"/>
+                    <pin_map port_index="3" component_pin="QSFP28_1_TX4_P"/>
+                  </pin_maps>
+                </port_map>
+                <port_map logical_port="GRX_N" physical_port="qsfp1_rxn4" dir="in" left="3" right="0">
+                  <pin_maps>
+                    <pin_map port_index="0" component_pin="QSFP28_1_RX1_N"/>
+                    <pin_map port_index="1" component_pin="QSFP28_1_RX2_N"/>
+                    <pin_map port_index="2" component_pin="QSFP28_1_RX3_N"/>
+                    <pin_map port_index="3" component_pin="QSFP28_1_RX4_N"/>
+                  </pin_maps>
+                </port_map>
+                <port_map logical_port="GRX_P" physical_port="qsfp1_rxp4" dir="in" left="3" right="0">
+                  <pin_maps>
+                    <pin_map port_index="0" component_pin="QSFP28_1_RX1_P"/>
+                    <pin_map port_index="1" component_pin="QSFP28_1_RX2_P"/>
+                    <pin_map port_index="2" component_pin="QSFP28_1_RX3_P"/>
+                    <pin_map port_index="3" component_pin="QSFP28_1_RX4_P"/>
+                  </pin_maps>
+                </port_map>
+              </port_maps>
+                <parameters>
+                  <parameter name="gt_loc" value="" />
+                </parameters>
+            </interface>
+
+    </interfaces>
+
+    </component>
+
+  <component name="hbm_cattrip" display_name="HBM CATTRIP (Mandatory)" type="chip" sub_type="led" major_group="General Purpose Input or Output">
+      <description>HBM_CATTRIP Active hgh indicator to Satellite controller to indicate the HBM has exceded its maximum allowable temperature.</description>
+      <preferred_ips>
+        <preferred_ip vendor="xilinx.com" library="ip" name="hbm" order="0"/>
+      </preferred_ips>
+    </component>
+
+    <!--
+  <component name="rs232_fpga_msp" display_name="MSP_UART" type="chip" sub_type="uart" major_group="Miscellaneous">
+      <description>SC-to-UART Bridge, which allows serial communication to SC </description>
+      <pins>
+        <pin index="0" name="rs232_fpga_uart_msp_TX" iostandard="LVCMOS18"/>
+        <pin index="1" name="rs232_fpga_uart_msp_RX" iostandard="LVCMOS18"/>
+      </pins>
+    </component>
+
+  <component name="fpga_uart0" display_name="FPGA_UART0" type="chip" sub_type="uart" major_group="Miscellaneous">
+      <description>FPGA UART0 </description>
+      <pins>
+        <pin index="0" name="fpga_uart0_TX" iostandard="LVCMOS18"/>
+        <pin index="1" name="fpga_uart0_RX" iostandard="LVCMOS18"/>
+      </pins>
+    </component>
+  -->
+
+  <component name="qsfp0_refclk0" display_name="QSFP reference differential clock input 0" type="chip" sub_type="system_clock" major_group="High Speed Tranceivers" part_name="SI5394" vendor="Silicon Labs" spec_url="www.silabs.com">
+      <description>1.2V LVDS differential 161 MHz oscillator used as a GT reference clock on the board</description>
+      <parameters>
+        <parameter name="frequency" value="161132812"/>
+      </parameters>
+      <preferred_ips>
+        <preferred_ip vendor="xilinx.com" library="ip" name="xxv_ethernet" order="0"/>
+      </preferred_ips>
+    </component>
+
+  <component name="qsfp1_refclk0" display_name="QSFP reference differential clock input 1" type="chip" sub_type="system_clock" major_group="High Speed Tranceivers" part_name="SI5394" vendor="Silicon Labs" spec_url="www.silabs.com">
+      <description>1.2V LVDS differential 161 MHz oscillator used as a GT reference clock on the board</description>
+      <parameters>
+        <parameter name="frequency" value="161132812"/>
+      </parameters>
+      <preferred_ips>
+        <preferred_ip vendor="xilinx.com" library="ip" name="xxv_ethernet" order="0"/>
+      </preferred_ips>
+    </component>
+
+    <!--
+  <component name="slr0_freerun_clk" display_name="100MHz differential clock input" type="chip" sub_type="system_clock" major_group="Clock Sources" part_name="SI53306-B-GM" vendor="Silicon Labs" spec_url="www.silabs.com">
+      <description>1.2V LVDS differential 100 MHz oscillator used as Freerunning differential clock on the board</description>
+      <parameters>
+        <parameter name="frequency" value="100000000"/>
+      </parameters>
+    </component>
+
+    <component name="slr1_freerun_clk" display_name="100MHz differential clock input" type="chip" sub_type="system_clock" major_group="Clock Sources" part_name="SI53306-B-GM" vendor="Silicon Labs" spec_url="www.silabs.com">
+      <description>1.2V LVDS differential 100 MHz oscillator used as Freerunning differential clock on the board</description>
+      <parameters>
+        <parameter name="frequency" value="100000000"/>
+      </parameters>
+    </component>
+  -->
+
+  <component name="reset_si5394" display_name="Reset to SI5394" type="chip" sub_type="led" major_group="General Purpose Input or Output" part_name="SI5394" vendor="Silicon Labs" spec_url="www.silabs.com">
+    <description>GPIO reset to SI5394 (SI_RSTBB) </description>
+  </component>
+
+  <component name="gpio_si5394" display_name="GPIO from SI5394" type="chip" sub_type="led" major_group="General Purpose Input or Output" part_name="SI5394" vendor="Silicon Labs" spec_url="www.silabs.com">
+    <description>GPIO from SI5394 (SI_INTRB, SI_PLL_LOCK, SI_IN_LOS)</description>
+  </component>
+
+  <component name="msp_gpio" display_name="GPIO from MSP" type="chip" sub_type="led" major_group="General Purpose Input or Output">
+    <description>GPIO signals from MSP Satellite Controller to the CMS</description>
+    <preferred_ips>
+      <preferred_ip vendor="xilinx.com" library="ip" name="cms_subsystem" order="0"/>
+    </preferred_ips>
+  </component>
+
+  <component name="iic_si5394" display_name="I2C SI5394" type="chip" sub_type="mux" major_group="Miscellaneous" part_name="SI5394" vendor="Silicon Labs" spec_url="www.silabs.com">
+    <description>I2C to SI5394</description>
+  </component>
+
+  <component name="pcie_refclk" display_name="PCIe MGT reference Clock" type="chip" sub_type="mgt_clock" major_group="High Speed Tranceivers" part_name="pcie_8lane_edge" vendor="Clock" spec_url="">
+      <description>Clock input from PCI Express edge connector</description>
+      <parameters>
+        <parameter name="frequency" value="100000000"/>
+      </parameters>
+      <preferred_ips>
+        <preferred_ip vendor="xilinx.com" library="ip" name="util_ds_buf" order="0"/>
+        <preferred_ip vendor="xilinx.com" library="ip" name="clk_wiz" order="1"/>
+      </preferred_ips>
+    </component>
+
+  <component name="pci_express" display_name="PCI Express" type="chip" sub_type="chip" major_group="High Speed Tranceivers">
+      <description>PCI Express</description>
+
+      <component_modes>
+
+    <component_mode name="pci_express_x4" display_name="pci_express x4 ">
+          <interfaces>
+            <interface name="pci_express_x4"/>
+            <interface name="pcie_perstn" optional="true"/>
+          </interfaces>
+          <preferred_ips>
+            <preferred_ip vendor="xilinx.com" library="ip" name="xdma" order="0"/>
+            <preferred_ip vendor="xilinx.com" library="ip" name="qdma" order="1"/>
+            <preferred_ip vendor="xilinx.com" library="ip" name="pcie4c_uscale_plus" order="2"/>
+          </preferred_ips>
+        </component_mode>
+
+    <component_mode name="pci_express_x8" display_name="pci_express x8 ">
+          <interfaces>
+            <interface name="pci_express_x8"/>
+            <interface name="pcie_perstn" optional="true"/>
+          </interfaces>
+          <preferred_ips>
+            <preferred_ip vendor="xilinx.com" library="ip" name="xdma" order="0"/>
+            <preferred_ip vendor="xilinx.com" library="ip" name="qdma" order="1"/>
+            <preferred_ip vendor="xilinx.com" library="ip" name="pcie4c_uscale_plus" order="2"/>
+          </preferred_ips>
+        </component_mode>
+
+
+    <component_mode name="pci_express_x16" display_name="pci_express x16 ">
+          <interfaces>
+            <interface name="pci_express_x16"/>
+            <interface name="pcie_perstn" optional="true"/>
+          </interfaces>
+          <preferred_ips>
+            <preferred_ip vendor="xilinx.com" library="ip" name="xdma" order="0"/>
+            <preferred_ip vendor="xilinx.com" library="ip" name="qdma" order="1"/>
+            <preferred_ip vendor="xilinx.com" library="ip" name="pcie4c_uscale_plus" order="2"/>
+          </preferred_ips>
+        </component_mode>
+
+      </component_modes>
+
+    </component>
+
+    <component name="qsfp0" display_name="QSFP Connector" type="chip" sub_type="sfp" major_group="High Speed Tranceivers" part_name="M88E1111_BAB1C000" vendor="Marvell" spec_url="www.marvell.com">
+          <description>QSFP Connector 0</description>
+
+        <component_modes>
+
+          <component_mode name="qsfp0_1x_161" display_name="qsfp0_1x_161">
+                <interfaces>
+                  <interface name="qsfp0_1x"/>
+                  <interface name="qsfp0_refclk0" optional="true"/>
+                </interfaces>
+                <preferred_ips>
+                  <preferred_ip vendor="xilinx.com" library="ip" name="xxv_ethernet" order="0"/>
+                  <preferred_ip vendor="xilinx.com" library="ip" name="usxgmii" order="1"/>
+                </preferred_ips>
+              </component_mode>
+
+          <component_mode name="qsfp0_2x_161" display_name="qsfp0_2x_161">
+              <interfaces>
+                <interface name="qsfp0_2x"/>
+                <interface name="qsfp0_refclk0" optional="true"/>
+               </interfaces>
+              <preferred_ips>
+                <preferred_ip vendor="xilinx.com" library="ip" name="xxv_ethernet" order="0"/>
+                <preferred_ip vendor="xilinx.com" library="ip" name="usxgmii" order="1"/>
+                <preferred_ip vendor="xilinx.com" library="ip" name="l_ethernet" order="1"/>
+              </preferred_ips>
+            </component_mode>
+
+          <component_mode name="qsfp0_3x_161" display_name="qsfp0_3x_161">
+              <interfaces>
+                <interface name="qsfp0_3x"/>
+                <interface name="qsfp0_refclk0" optional="true"/>
+              </interfaces>
+              <preferred_ips>
+                <preferred_ip vendor="xilinx.com" library="ip" name="xxv_ethernet" order="0"/>
+                <preferred_ip vendor="xilinx.com" library="ip" name="usxgmii" order="1"/>
+              </preferred_ips>
+           </component_mode>
+
+        <component_mode name="qsfp0_4x_161" display_name="qsfp0_4x_161">
+              <interfaces>
+                <interface name="qsfp0_4x"/>
+                <interface name="qsfp0_refclk0" optional="true"/>
+              </interfaces>
+              <preferred_ips>
+                <preferred_ip vendor="xilinx.com" library="ip" name="xxv_ethernet" order="0"/>
+                <preferred_ip vendor="xilinx.com" library="ip" name="usxgmii" order="1"/>
+                <preferred_ip vendor="xilinx.com" library="ip" name="l_ethernet" order="2"/>
+                <preferred_ip vendor="xilinx.com" library="ip" name="cmac_usplus" order="3"/>
+              </preferred_ips>
+            </component_mode>
+
+        </component_modes>
+      </component>
+
+    <component name="qsfp1" display_name="QSFP Connector" type="chip" sub_type="sfp" major_group="High Speed Tranceivers" part_name="M88E1111_BAB1C000" vendor="Marvell" spec_url="www.marvell.com">
+          <description>QSFP Connector 1</description>
+
+        <component_modes>
+
+          <component_mode name="qsfp1_1x_161" display_name="qsfp1_1x_161">
+            <interfaces>
+              <interface name="qsfp1_1x"/>
+              <interface name="qsfp1_refclk0" optional="true"/>
+            </interfaces>
+            <preferred_ips>
+              <preferred_ip vendor="xilinx.com" library="ip" name="xxv_ethernet" order="0"/>
+              <preferred_ip vendor="xilinx.com" library="ip" name="usxgmii" order="1"/>
+            </preferred_ips>
+          </component_mode>
+
+        <component_mode name="qsfp1_2x_161" display_name="qsfp1_2x_161">
+            <interfaces>
+              <interface name="qsfp1_2x"/>
+              <interface name="qsfp1_refclk0" optional="true"/>
+            </interfaces>
+            <preferred_ips>
+              <preferred_ip vendor="xilinx.com" library="ip" name="xxv_ethernet" order="0"/>
+              <preferred_ip vendor="xilinx.com" library="ip" name="usxgmii" order="1"/>
+              <preferred_ip vendor="xilinx.com" library="ip" name="l_ethernet" order="1"/>
+            </preferred_ips>
+          </component_mode>
+
+        <component_mode name="qsfp1_3x_161" display_name="qsfp1_3x_161">
+            <interfaces>
+              <interface name="qsfp1_3x"/>
+              <interface name="qsfp1_refclk0" optional="true"/>
+            </interfaces>
+            <preferred_ips>
+              <preferred_ip vendor="xilinx.com" library="ip" name="xxv_ethernet" order="0"/>
+              <preferred_ip vendor="xilinx.com" library="ip" name="usxgmii" order="1"/>
+            </preferred_ips>
+        </component_mode>
+
+        <component_mode name="qsfp1_4x_161" display_name="qsfp1_4x_161">
+              <interfaces>
+                <interface name="qsfp1_4x"/>
+                <interface name="qsfp1_refclk0" optional="true"/>
+              </interfaces>
+              <preferred_ips>
+                <preferred_ip vendor="xilinx.com" library="ip" name="xxv_ethernet" order="0"/>
+                <preferred_ip vendor="xilinx.com" library="ip" name="usxgmii" order="1"/>
+                <preferred_ip vendor="xilinx.com" library="ip" name="l_ethernet" order="2"/>
+                <preferred_ip vendor="xilinx.com" library="ip" name="cmac_usplus" order="3"/>
+              </preferred_ips>
+            </component_mode>
+
+        </component_modes>
+      </component>
+
+ </components>
+
+
+  <jtag_chains>
+    <jtag_chain name="chain1">
+      <position name="0" component="part0"/>
+    </jtag_chain>
+  </jtag_chains>
+
+  <connections>
+
+  <connection name="part0_hbm_cattrip" component1="part0" component2="hbm_cattrip">
+      <connection_map name="part0_hbm_cattrip" typical_delay="5" c1_st_index="2" c1_end_index="2" c2_st_index="0" c2_end_index="0"/>
+    </connection>
+
+  <connection name="part0_pcie_perstn" component1="part0" component2="pcie_perstn">
+      <connection_map name="part0_pcie_perstn_1" c1_st_index="0" c1_end_index="0" c2_st_index="0" c2_end_index="0"/>
+    </connection>
+
+  <connection name="part0_qsfp28_leds" component1="part0" component2="qsfp28_leds">
+      <connection_map name="part0_qsfp28_leds" typical_delay="5" c1_st_index="3" c1_end_index="8" c2_st_index="0" c2_end_index="5"/>
+    </connection>
+
+  <connection name="part0_reset_si5394" component1="part0" component2="reset_si5394">
+     <connection_map name="part0_reset_si5394" typical_delay="5" c1_st_index="11" c1_end_index="11" c2_st_index="0" c2_end_index="0"/>
+  </connection>
+
+  <connection name="part0_gpio_si5394" component1="part0" component2="gpio_si5394">
+     <connection_map name="part0_gpio_si5394" typical_delay="5" c1_st_index="12" c1_end_index="14" c2_st_index="0" c2_end_index="2"/>
+    </connection>
+
+  <connection name="part0_msp_gpio" component1="part0" component2="msp_gpio">
+      <connection_map name="part0_msp_gpio" typical_delay="5" c1_st_index="17" c1_end_index="18" c2_st_index="0" c2_end_index="1"/>
+    </connection>
+
+  <connection name="part0_iic_si5394" component1="part0" component2="iic_si5394">
+      <connection_map name="part0_iic_si5394" typical_delay="5" c1_st_index="15" c1_end_index="16" c2_st_index="0" c2_end_index="1"/>
+    </connection>
+
+  <connection name="part0_pcie_refclk" component1="part0" component2="pcie_refclk">
+      <connection_map name="part0_pcie_refclk" typical_delay="5" c1_st_index="700" c1_end_index="701" c2_st_index="0" c2_end_index="1"/>
+    </connection>
+
+  <connection name="part0_pci_express" component1="part0" component2="pci_express">
+      <connection_map name="part0_pcie_express_1" c1_st_index="702" c1_end_index="765" c2_st_index="0" c2_end_index="63"/>
+    </connection>
+
+   <connection name="part0_qsfp0_refclk0" component1="part0" component2="qsfp0_refclk0">
+      <connection_map name="part0_qsfp0_refclk0" typical_delay="5" c1_st_index="100" c1_end_index="101" c2_st_index="0" c2_end_index="1"/>
+    </connection>
+
+   <connection name="part0_qsfp1_refclk0" component1="part0" component2="qsfp1_refclk0">
+      <connection_map name="part0_qsfp1_refclk0" typical_delay="5" c1_st_index="102" c1_end_index="103" c2_st_index="0" c2_end_index="1"/>
+    </connection>
+
+  <connection name="part0_qsfp0_gt" component1="part0" component2="qsfp0">
+      <connection_map name="part0_qsfp0_gt" typical_delay="5" c1_st_index="800" c1_end_index="815" c2_st_index="0" c2_end_index="15"/>
+    </connection>
+
+  <connection name="part0_qsfp1_gt" component1="part0" component2="qsfp1">
+      <connection_map name="part0_qsfp1_gt" typical_delay="5" c1_st_index="850" c1_end_index="865" c2_st_index="0" c2_end_index="15"/>
+    </connection>
+
+  </connections>
+
+<ip_associated_rules>
+    <ip_associated_rule name="default">
+      <ip vendor="xilinx.com" library="ip" name="xdma" version="*" ip_interface="sys_rst_n">
+        <associated_board_interfaces>
+          <associated_board_interface name="pcie_perstn" order="0"/>
+        </associated_board_interfaces>
+      </ip>
+      <ip vendor="xilinx.com" library="ip" name="pcie4_uscale_plus" version="*" ip_interface="sys_rst_n">
+        <associated_board_interfaces>
+          <associated_board_interface name="pcie_perstn" order="0"/>
+        </associated_board_interfaces>
+      </ip>
+      <ip vendor="xilinx.com" library="ip" name="qdma" version="*" ip_interface="sys_rst_n">
+        <associated_board_interfaces>
+          <associated_board_interface name="pcie_perstn" order="0"/>
+        </associated_board_interfaces>
+      </ip>
+      <ip vendor="xilinx.com" library="ip" name="hbm" version="*" ip_interface="DRAM_0_STAT_CATTRIP">
+        <associated_board_interfaces>
+          <associated_board_interface name="hbm_cattrip" order="0"/>
+        </associated_board_interfaces>
+      </ip>
+      <ip vendor="xilinx.com" library="ip" name="util_ds_buf" version="*" ip_interface="CLK_IN_D">
+        <associated_board_interfaces>
+          <associated_board_interface name="pcie_refclk" order="0"/>
+        <!--  <associated_board_interface name="cmc_clk" order="1"/>
+          <associated_board_interface name="hbm_clk" order="2"/> -->
+        </associated_board_interfaces>
+      </ip>
+      <ip vendor="xilinx.com" library="ip" name="clk_wiz" version="*" ip_interface="CLK_IN_D">
+        <associated_board_interfaces>
+        <!--  <associated_board_interface name="cmc_clk" order="0"/> -->
+          <associated_board_interface name="pcie_refclk" order="0"/>
+        <!--  <associated_board_interface name="hbm_clk" order="2"/> -->
+        </associated_board_interfaces>
+      </ip>
+
+
+      <ip vendor="xilinx.com" library="ip" name="xxv_ethernet" version="*" ip_interface="gt_serial_port">
+        <associated_board_interfaces>
+          <associated_board_interface name="qsfp0_1x" order="0"/>
+          <associated_board_interface name="qsfp0_2x" order="1"/>
+          <associated_board_interface name="qsfp0_3x" order="2"/>
+          <associated_board_interface name="qsfp0_4x" order="3"/>
+          <associated_board_interface name="qsfp1_1x" order="4"/>
+          <associated_board_interface name="qsfp1_2x" order="5"/>
+          <associated_board_interface name="qsfp1_3x" order="6"/>
+          <associated_board_interface name="qsfp1_4x" order="7"/>
+        </associated_board_interfaces>
+      </ip>
+      <ip vendor="xilinx.com" library="ip" name="usxgmii" version="*" ip_interface="gt_serial_port">
+        <associated_board_interfaces>
+          <associated_board_interface name="qsfp0_1x" order="0"/>
+          <associated_board_interface name="qsfp0_2x" order="1"/>
+          <associated_board_interface name="qsfp0_3x" order="2"/>
+          <associated_board_interface name="qsfp0_4x" order="3"/>
+          <associated_board_interface name="qsfp1_1x" order="4"/>
+          <associated_board_interface name="qsfp1_2x" order="5"/>
+          <associated_board_interface name="qsfp1_3x" order="6"/>
+          <associated_board_interface name="qsfp1_4x" order="7"/>
+        </associated_board_interfaces>
+      </ip>
+      <ip vendor="xilinx.com" library="ip" name="l_ethernet" version="*" ip_interface="gt_serial_port">
+        <associated_board_interfaces>
+          <associated_board_interface name="qsfp0_2x" order="0"/>
+          <associated_board_interface name="qsfp0_4x" order="1"/>
+          <associated_board_interface name="qsfp1_2x" order="2"/>
+          <associated_board_interface name="qsfp1_4x" order="3"/>
+        </associated_board_interfaces>
+      </ip>
+      <ip vendor="xilinx.com" library="ip" name="cmac_usplus" version="*" ip_interface="gt_serial_port">
+        <associated_board_interfaces>
+          <associated_board_interface name="qsfp0_4x" order="0"/>
+          <associated_board_interface name="qsfp1_4x" order="1"/>
+        </associated_board_interfaces>
+      </ip>
+
+      <ip vendor="xilinx.com" library="ip" name="xxv_ethernet" version="*" ip_interface="gt_ref_clk">
+        <associated_board_interfaces>
+          <associated_board_interface name="qsfp0_refclk0" order="0"/>
+          <associated_board_interface name="qsfp1_refclk0" order="1"/>
+        </associated_board_interfaces>
+      </ip>
+      <ip vendor="xilinx.com" library="ip" name="usxgmii" version="*" ip_interface="gt_ref_clk">
+        <associated_board_interfaces>
+          <associated_board_interface name="qsfp0_refclk0" order="0"/>
+          <associated_board_interface name="qsfp1_refclk0" order="1"/>
+        </associated_board_interfaces>
+      </ip>
+      <ip vendor="xilinx.com" library="ip" name="l_ethernet" version="*" ip_interface="gt_ref_clk">
+        <associated_board_interfaces>
+          <associated_board_interface name="qsfp0_refclk0" order="0"/>
+          <associated_board_interface name="qsfp1_refclk0" order="1"/>
+        </associated_board_interfaces>
+      </ip>
+      <ip vendor="xilinx.com" library="ip" name="cmac_usplus" version="*" ip_interface="gt_ref_clk">
+        <associated_board_interfaces>
+          <associated_board_interface name="qsfp0_refclk0" order="0"/>
+          <associated_board_interface name="qsfp1_refclk0" order="1"/>
+        </associated_board_interfaces>
+      </ip>
+    </ip_associated_rule>
+  </ip_associated_rules>
+
+</board>
diff --git a/board_files/Xilinx/au55c/changelog.txt b/board_files/Xilinx/au55c/changelog.txt
new file mode 100644
index 0000000..d34cf58
--- /dev/null
+++ b/board_files/Xilinx/au55c/changelog.txt
@@ -0,0 +1,3 @@
+######### AU55C change log ##############
+1.0
+AU55C Initial board support
diff --git a/board_files/Xilinx/au55c/part0_pins.xml b/board_files/Xilinx/au55c/part0_pins.xml
new file mode 100644
index 0000000..5d2fc5c
--- /dev/null
+++ b/board_files/Xilinx/au55c/part0_pins.xml
@@ -0,0 +1,202 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
+<!-- Copyright (C) 2021, Xilinx Inc - All rights reserved
+ Licensed under the Apache License, Version 2.0 (the "License"). You may
+ not use this file except in compliance with the License. A copy of the
+ License is located at
+     http://www.apache.org/licenses/LICENSE-2.0
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ License for the specific language governing permissions and limitations
+ under the License. -->
+
+<part_info part_name="xcu55c-fsvh2892-2L-e">
+
+  <pins>
+
+    <pin index="0" name="PCIE_PERST_LS_65"    iostandard="LVCMOS18" loc="BF41"/>
+    <pin index="1" name="PEX_PWRBRKN_FPGA_65" iostandard="LVCMOS18" loc="BG43"/>
+    <pin index="2" name="HBM_CATTRIP_LS"      iostandard="LVCMOS18" loc="BE45"/>
+
+    <!-- QSFP28 Activity LED pins -->
+    <pin index="3" name="QSFP28_0_ACTIVITY_LED"    iostandard="LVCMOS18" loc="BL13" drive="8"/>
+    <pin index="4" name="QSFP28_0_LINK_STAT_LEDG"  iostandard="LVCMOS18" loc="BK11" drive="8"/>
+    <pin index="5" name="QSFP28_0_LINK_STAT_LEDY"  iostandard="LVCMOS18" loc="BJ11" drive="8"/>
+    <pin index="6" name="QSFP28_1_ACTIVITY_LED"    iostandard="LVCMOS18" loc="BK14" drive="8"/>
+    <pin index="7" name="QSFP28_1_LINK_STAT_LEDG"  iostandard="LVCMOS18" loc="BK15" drive="8"/>
+    <pin index="8" name="QSFP28_1_LINK_STAT_LEDY"  iostandard="LVCMOS18" loc="BL12" drive="8"/>
+
+    <!-- FPGA to Sattellite Controller CMS UART Interface Pins-->
+    <pin index="9"  name="FPGA_TXD_MSP_65" iostandard="LVCMOS18" loc="BH42"/>
+    <pin index="10" name="FPGA_RXD_MSP_65" iostandard="LVCMOS18" loc="BJ42"/>
+
+    <!-- Si5394B pins-->
+    <pin index="11" name="SI_RSTBB"    iostandard="LVCMOS18" loc="BM8" />
+    <pin index="12" name="SI_INTRB"    iostandard="LVCMOS18" loc="BM9" />
+    <pin index="13" name="SI_PLL_LOCK" iostandard="LVCMOS18" loc="BN10"/>
+    <pin index="14" name="SI_IN_LOS"   iostandard="LVCMOS18" loc="BM10"/>
+    <pin index="15" name="I2C_SI5394_SCL" iostandard="LVCMOS18" loc="BM14"/>
+    <pin index="16" name="I2C_SI5394_SDA" iostandard="LVCMOS18" loc="BN14"/>
+
+    <!-- General perpose IO interconnect pins -->
+    <pin index="17" name="MSP_GPIO0" iostandard="LVCMOS18" loc="BE46"/>
+    <pin index="18" name="MSP_GPIO1" iostandard="LVCMOS18" loc="BH46"/>
+    <pin index="19" name="MSP_GPIO2" iostandard="LVCMOS18" loc="BF45"/>
+    <pin index="20" name="MSP_GPIO3" iostandard="LVCMOS18" loc="BF46"/>
+
+    <pin index="21"  name ="CPU_RESET_FPGA"    iostandard="LVCMOS18" loc="BG45"/>
+    <pin index="22"  name ="RSTN_68"           iostandard="LVCMOS18" loc="BM12"/>
+
+    <!-- Onboard Clocks -->
+    <pin index="100"  name ="SYNCE_CLK0_N" loc="AD43"/>
+    <pin index="101"  name ="SYNCE_CLK0_P" loc="AD42"/>
+    <pin index="102"  name ="SYNCE_CLK1_N" loc="AB43"/>
+    <pin index="103"  name ="SYNCE_CLK1_P" loc="AB42"/>
+
+    <pin index="104"  name ="SYSCLK2_P" iostandard="LVDS" loc="BK10"  dqs_bias="TRUE"/>
+    <pin index="105"  name ="SYSCLK2_N" iostandard="LVDS" loc="BL10"  dqs_bias="TRUE"/>
+    <pin index="106"  name ="SYSCLK3_P" iostandard="LVDS" loc="BK43"  dqs_bias="TRUE"/>
+    <pin index="107"  name ="SYSCLK3_N" iostandard="LVDS" loc="BK44"  dqs_bias="TRUE"/>
+
+    <pin index="108"  name ="PPS_IN_FPGA" iostandard="LVCMOS18" loc="BJ33"/>
+    <pin index="109"  name ="PPS_IN_FPGA" iostandard="LVCMOS18" loc="BH32"/>
+
+    <pin index="110"  name ="NS1_REFCLK0_N" loc="AL41"/>
+    <pin index="111"  name ="NS1_REFCLK0_P" loc="AL40"/>
+    <pin index="112"  name ="NS1_SYSCLK5_N" loc="AK43"/>
+    <pin index="113"  name ="NS1_SYSCLK5_P" loc="AK42"/>
+    <pin index="114"  name ="NS2_REFCLK0_N" loc="AR41"/>
+    <pin index="115"  name ="NS2_REFCLK0_P" loc="AR40"/>
+    <pin index="116"  name ="NS2_SYSCLK6_N" loc="AP43"/>
+    <pin index="117"  name ="NS2_SYSCLK6_P" loc="AP42"/>
+
+    <pin index="118"  name ="TESTCLK_OUT" iostandard="LVCMOS18" loc="BN42"/>
+
+    <!-- PCIe Clocks-->
+    <pin index="694" name ="PCIE_SYSCLK0_N" loc="AK12"/>
+    <pin index="695" name ="PCIE_SYSCLK0_P" loc="AK13"/>
+    <pin index="696" name ="PCIE_SYSCLK1_N" loc="AP12"/>
+    <pin index="697" name ="PCIE_SYSCLK1_P" loc="AP13"/>
+
+    <pin index="698" name ="PCIE_REFCLK0_N" loc="AL14"/>
+    <pin index="699" name ="PCIE_REFCLK0_P" loc="AL15"/>
+    <pin index="700" name ="PCIE_REFCLK1_N" loc="AR14"/>
+    <pin index="701" name ="PCIE_REFCLK1_P" loc="AR15"/>
+
+    <!-- PCIe Connector -->
+
+    <pin index="702" name ="pcie_rx0_n"    loc="AL1" />
+    <pin index="703" name ="pcie_rx0_p"    loc="AL2" />
+    <pin index="704" name ="pcie_rx1_n"    loc="AM3" />
+    <pin index="705" name ="pcie_rx1_p"    loc="AM4" />
+    <pin index="706" name ="pcie_rx2_n"    loc="AN5" />
+    <pin index="707" name ="pcie_rx2_p"    loc="AN6" />
+    <pin index="708" name ="pcie_rx3_n"    loc="AN1" />
+    <pin index="709" name ="pcie_rx3_p"    loc="AN2" />
+    <pin index="710" name ="pcie_rx4_n"    loc="AP3" />
+    <pin index="711" name ="pcie_rx4_p"    loc="AP4" />
+    <pin index="712" name ="pcie_rx5_n"    loc="AR1" />
+    <pin index="713" name ="pcie_rx5_p"    loc="AR2" />
+    <pin index="714" name ="pcie_rx6_n"    loc="AT3" />
+    <pin index="715" name ="pcie_rx6_p"    loc="AT4" />
+    <pin index="716" name ="pcie_rx7_n"    loc="AU1" />
+    <pin index="717" name ="pcie_rx7_p"    loc="AU2" />
+    <pin index="718" name ="pcie_rx8_n"    loc="AV3" />
+    <pin index="719" name ="pcie_rx8_p"    loc="AV4" />
+    <pin index="720" name ="pcie_rx9_n"    loc="AW5" />
+    <pin index="721" name ="pcie_rx9_p"    loc="AW6" />
+    <pin index="722" name ="pcie_rx10_n"   loc="AW1" />
+    <pin index="723" name ="pcie_rx10_p"   loc="AW2" />
+    <pin index="724" name ="pcie_rx11_n"   loc="AY3" />
+    <pin index="725" name ="pcie_rx11_p"   loc="AY4" />
+    <pin index="726" name ="pcie_rx12_n"   loc="BA5" />
+    <pin index="727" name ="pcie_rx12_p"   loc="BA6" />
+    <pin index="728" name ="pcie_rx13_n"   loc="BA1" />
+    <pin index="729" name ="pcie_rx13_p"   loc="BA2" />
+    <pin index="730" name ="pcie_rx14_n"   loc="BB3" />
+    <pin index="731" name ="pcie_rx14_p"   loc="BB4" />
+    <pin index="732" name ="pcie_rx15_n"   loc="BC1" />
+    <pin index="733" name ="pcie_rx15_p"   loc="BC2" />
+
+    <pin index="734" name ="pcie_tx0_n"    loc="AL10"/>
+    <pin index="735" name ="pcie_tx0_p"    loc="AL11"/>
+    <pin index="736" name ="pcie_tx1_n"    loc="AM8" />
+    <pin index="737" name ="pcie_tx1_p"    loc="AM9" />
+    <pin index="738" name ="pcie_tx2_n"    loc="AN10"/>
+    <pin index="739" name ="pcie_tx2_p"    loc="AN11"/>
+    <pin index="740" name ="pcie_tx3_n"    loc="AP8" />
+    <pin index="741" name ="pcie_tx3_p"    loc="AP9" />
+    <pin index="742" name ="pcie_tx4_n"    loc="AR10"/>
+    <pin index="743" name ="pcie_tx4_p"    loc="AR11"/>
+    <pin index="744" name ="pcie_tx5_n"    loc="AR6" />
+    <pin index="745" name ="pcie_tx5_p"    loc="AR7" />
+    <pin index="746" name ="pcie_tx6_n"    loc="AT8" />
+    <pin index="747" name ="pcie_tx6_p"    loc="AT9" />
+    <pin index="748" name ="pcie_tx7_n"    loc="AU10"/>
+    <pin index="749" name ="pcie_tx7_p"    loc="AU11"/>
+    <pin index="750" name ="pcie_tx8_n"    loc="AU6" />
+    <pin index="751" name ="pcie_tx8_p"    loc="AU7" />
+    <pin index="752" name ="pcie_tx9_n"    loc="AV8" />
+    <pin index="753" name ="pcie_tx9_p"    loc="AV9" />
+    <pin index="754" name ="pcie_tx10_n"   loc="AW10"/>
+    <pin index="755" name ="pcie_tx10_p"   loc="AW11"/>
+    <pin index="756" name ="pcie_tx11_n"   loc="AY8" />
+    <pin index="757" name ="pcie_tx11_p"   loc="AY9" />
+    <pin index="758" name ="pcie_tx12_n"   loc="BA10"/>
+    <pin index="759" name ="pcie_tx12_p"   loc="BA11"/>
+    <pin index="760" name ="pcie_tx13_n"   loc="BB8" />
+    <pin index="761" name ="pcie_tx13_p"   loc="BB9" />
+    <pin index="762" name ="pcie_tx14_n"   loc="BC10"/>
+    <pin index="763" name ="pcie_tx14_p"   loc="BC11"/>
+    <pin index="764" name ="pcie_tx15_n"   loc="BC6" />
+    <pin index="765" name ="pcie_tx15_p"   loc="BC7" />
+
+
+    <!-- QSFP28 Connector 0 -->
+    <!-- These pins connect to MGT site 130 X0Y24~27  -->
+    <pin index="800" name ="QSFP28_0_RX1_N" loc="AD52"/>
+    <pin index="801" name ="QSFP28_0_RX2_N" loc="AC54"/>
+    <pin index="802" name ="QSFP28_0_RX3_N" loc="AC50"/>
+    <pin index="803" name ="QSFP28_0_RX4_N" loc="AB52"/>
+
+    <pin index="804" name ="QSFP28_0_RX1_P" loc="AD51"/>
+    <pin index="805" name ="QSFP28_0_RX2_P" loc="AC53"/>
+    <pin index="806" name ="QSFP28_0_RX3_P" loc="AC49"/>
+    <pin index="807" name ="QSFP28_0_RX4_P" loc="AB51"/>
+
+    <pin index="808" name ="QSFP28_0_TX1_N" loc="AD47"/>
+    <pin index="809" name ="QSFP28_0_TX2_N" loc="AC45"/>
+    <pin index="810" name ="QSFP28_0_TX3_N" loc="AB47"/>
+    <pin index="811" name ="QSFP28_0_TX4_N" loc="AA49"/>
+
+    <pin index="812" name ="QSFP28_0_TX1_P" loc="AD46"/>
+    <pin index="813" name ="QSFP28_0_TX2_P" loc="AC44"/>
+    <pin index="814" name ="QSFP28_0_TX3_P" loc="AB46"/>
+    <pin index="815" name ="QSFP28_0_TX4_P" loc="AA48"/>
+
+    <!-- QSFP28 Connector 1 -->
+    <!-- These pins connect to MGT site 131 X0Y28~31  -->
+    <pin index="850" name ="QSFP28_1_RX1_N" loc="AA54"/>
+    <pin index="851" name ="QSFP28_1_RX2_N" loc="Y52"/>
+    <pin index="852" name ="QSFP28_1_RX3_N" loc="W54"/>
+    <pin index="853" name ="QSFP28_1_RX4_N" loc="V52"/>
+
+    <pin index="854" name ="QSFP28_1_RX1_P" loc="AA53"/>
+    <pin index="855" name ="QSFP28_1_RX2_P" loc="Y51"/>
+    <pin index="856" name ="QSFP28_1_RX3_P" loc="W53"/>
+    <pin index="857" name ="QSFP28_1_RX4_P" loc="V51"/>
+
+    <pin index="858" name ="QSFP28_1_TX1_N" loc="AA45"/>
+    <pin index="859" name ="QSFP28_1_TX2_N" loc="Y47"/>
+    <pin index="860" name ="QSFP28_1_TX3_N" loc="W49"/>
+    <pin index="861" name ="QSFP28_1_TX4_N" loc="W45"/>
+
+    <pin index="862" name ="QSFP28_1_TX1_P" loc="AA44"/>
+    <pin index="863" name ="QSFP28_1_TX2_P" loc="Y46"/>
+    <pin index="864" name ="QSFP28_1_TX3_P" loc="W48"/>
+    <pin index="865" name ="QSFP28_1_TX4_P" loc="W44"/>
+
+
+  </pins>
+
+</part_info>
diff --git a/board_files/Xilinx/au55c/preset.xml b/board_files/Xilinx/au55c/preset.xml
new file mode 100644
index 0000000..1ea3fbf
--- /dev/null
+++ b/board_files/Xilinx/au55c/preset.xml
@@ -0,0 +1,396 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
+<!-- Copyright (C) 2021, Xilinx Inc - All rights reserved
+ Licensed under the Apache License, Version 2.0 (the "License"). You may
+ not use this file except in compliance with the License. A copy of the
+ License is located at
+     http://www.apache.org/licenses/LICENSE-2.0
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ License for the specific language governing permissions and limitations
+ under the License. -->
+
+<ip_presets schema="1.0">
+
+<ip_preset preset_proc_name="reset_si5394_preset">
+  <ip vendor="xilinx.com" library="ip" name="axi_gpio">
+    <user_parameters>
+    <user_parameter name="CONFIG.C_DOUT_DEFAULT" value="0x00000001"/>
+    </user_parameters>
+  </ip>
+  </ip_preset>
+
+  <ip_preset preset_proc_name="reset2_si5394_preset">
+  <ip vendor="xilinx.com" library="ip" name="axi_gpio">
+    <user_parameters>
+    <user_parameter name="CONFIG.C_DOUT_DEFAULT_2" value="0x00000001"/>
+    </user_parameters>
+  </ip>
+  </ip_preset>
+
+<ip_preset preset_proc_name="pcie_refclk_preset">
+    <ip vendor="xilinx.com" library="ip" name="util_ds_buf">
+      <user_parameters>
+        <user_parameter name="CONFIG.C_BUF_TYPE" value="IBUFDSGTE" />
+        <user_parameter name="CONFIG.C_SIZE" value="1" />
+      </user_parameters>
+    </ip>
+  </ip_preset>
+
+<ip_preset preset_proc_name="pciex4_preset">
+  <ip vendor="xilinx.com" library="ip" name="xdma">
+    <user_parameters>
+    <user_parameter name="CONFIG.pl_link_cap_max_link_speed" value="8.0_GT/s" />
+    <user_parameter name="CONFIG.pl_link_cap_max_link_width" value="X4" />
+    <user_parameter name="CONFIG.mode_selection" value="Advanced" />
+    <user_parameter name="CONFIG.en_gt_selection" value="true" />
+    <user_parameter name="CONFIG.select_quad" value="GTY_Quad_227" />
+    </user_parameters>
+  </ip>
+
+  <ip vendor="xilinx.com" library="ip" name="qdma">
+    <user_parameters>
+    <user_parameter name="CONFIG.pl_link_cap_max_link_speed" value="8.0_GT/s" />
+    <user_parameter name="CONFIG.pl_link_cap_max_link_width" value="X4" />
+    <user_parameter name="CONFIG.mode_selection" value="Advanced" />
+    <user_parameter name="CONFIG.en_gt_selection" value="true" />
+    <user_parameter name="CONFIG.select_quad" value="GTY_Quad_227" />
+    </user_parameters>
+  </ip>
+
+
+  <ip vendor="xilinx.com" library="ip" name="pcie4c_uscale_plus">
+    <user_parameters>
+      <!-- <user_parameter name="CONFIG.pcie_blk_locn" value="X1Y1" /> -->
+      <user_parameter name="CONFIG.pl_link_cap_max_link_speed" value="8.0_GT/s" />
+      <user_parameter name="CONFIG.pl_link_cap_max_link_width" value="X4" />
+      <user_parameter name="CONFIG.mode_selection" value="Advanced" />
+      <user_parameter name="CONFIG.en_gt_selection" value="true" />
+      <user_parameter name="CONFIG.select_quad" value="GTY_Quad_227" />
+    </user_parameters>
+  </ip>
+
+
+</ip_preset>
+
+<ip_preset preset_proc_name="pciex8_preset">
+  <ip vendor="xilinx.com" library="ip" name="xdma">
+    <user_parameters>
+
+    <user_parameter name="CONFIG.pl_link_cap_max_link_speed" value="8.0_GT/s" />
+    <user_parameter name="CONFIG.pl_link_cap_max_link_width" value="X8" />
+    <user_parameter name="CONFIG.mode_selection" value="Advanced" />
+    <user_parameter name="CONFIG.en_gt_selection" value="true" />
+    <user_parameter name="CONFIG.select_quad" value="GTY_Quad_227" />
+    </user_parameters>
+    </ip>
+
+  <ip vendor="xilinx.com" library="ip" name="qdma">
+    <user_parameters>
+    <user_parameter name="CONFIG.pl_link_cap_max_link_speed" value="8.0_GT/s" />
+    <user_parameter name="CONFIG.pl_link_cap_max_link_width" value="X8" />
+    <user_parameter name="CONFIG.mode_selection" value="Advanced" />
+    <user_parameter name="CONFIG.en_gt_selection" value="true" />
+    <user_parameter name="CONFIG.select_quad" value="GTY_Quad_227" />
+    </user_parameters>
+    </ip>
+
+  <ip vendor="xilinx.com" library="ip" name="pcie4c_uscale_plus">
+    <user_parameters>
+
+      <!-- <user_parameter name="CONFIG.pcie_blk_locn" value="X1Y1" /> -->
+      <user_parameter name="CONFIG.pl_link_cap_max_link_speed" value="8.0_GT/s" />
+      <user_parameter name="CONFIG.pl_link_cap_max_link_width" value="X8" />
+      <user_parameter name="CONFIG.mode_selection" value="Advanced" />
+      <user_parameter name="CONFIG.en_gt_selection" value="true" />
+      <user_parameter name="CONFIG.select_quad" value="GTY_Quad_227" />
+    </user_parameters>
+  </ip>
+
+</ip_preset>
+
+<ip_preset preset_proc_name="pciex16_preset">
+  <ip vendor="xilinx.com" library="ip" name="xdma">
+    <user_parameters>
+    <user_parameter name="CONFIG.pl_link_cap_max_link_speed" value="8.0_GT/s" />
+    <user_parameter name="CONFIG.pl_link_cap_max_link_width" value="X16" />
+    <user_parameter name="CONFIG.mode_selection" value="Advanced" />
+    <user_parameter name="CONFIG.en_gt_selection" value="true" />
+    <user_parameter name="CONFIG.select_quad" value="GTY_Quad_227" />
+    </user_parameters>
+    </ip>
+
+  <ip vendor="xilinx.com" library="ip" name="qdma">
+    <user_parameters>
+    <user_parameter name="CONFIG.pl_link_cap_max_link_speed" value="8.0_GT/s" />
+    <user_parameter name="CONFIG.pl_link_cap_max_link_width" value="X16" />
+    <user_parameter name="CONFIG.mode_selection" value="Advanced" />
+    <user_parameter name="CONFIG.en_gt_selection" value="true" />
+    <user_parameter name="CONFIG.select_quad" value="GTY_Quad_227" />
+    </user_parameters>
+    </ip>
+
+  <ip vendor="xilinx.com" library="ip" name="pcie4c_uscale_plus">
+    <user_parameters>
+
+      <!-- <user_parameter name="CONFIG.pcie_blk_locn" value="X1Y1" />         -->
+      <user_parameter name="CONFIG.pl_link_cap_max_link_speed" value="8.0_GT/s" />
+      <user_parameter name="CONFIG.pl_link_cap_max_link_width" value="X16" />
+      <user_parameter name="CONFIG.mode_selection" value="Advanced" />
+      <user_parameter name="CONFIG.en_gt_selection" value="true" />
+      <user_parameter name="CONFIG.select_quad" value="GTY_Quad_227" />
+    </user_parameters>
+  </ip>
+
+</ip_preset>
+
+<!-- QSFP0 Connector -->
+
+<ip_preset preset_proc_name="qsfp0_1x_preset">
+
+    <ip vendor="xilinx.com" library="ip" name="xxv_ethernet">
+    <user_parameters>
+      <!-- <user_parameter name="CONFIG.GT_REF_CLK_FREQ" value="161.1328125" /> -->
+      <user_parameter name="CONFIG.NUM_OF_CORES" value="1" />
+      <user_parameter name="CONFIG.GT_TYPE" value="GTY" />
+      <user_parameter name="CONFIG.LINE_RATE" value="10" />
+      <user_parameter name="CONFIG.GT_GROUP_SELECT" value="Quad_X0Y3" />
+      <user_parameter name="CONFIG.BASE_R_KR" value="BASE-R" />
+    </user_parameters>
+    </ip>
+
+    <ip vendor="xilinx.com" library="ip" name="usxgmii">
+    <user_parameters>
+      <user_parameter name="CONFIG.NUM_OF_CORES" value="1" />
+      <user_parameter name="CONFIG.GT_TYPE" value="GTY" />
+      <user_parameter name="CONFIG.GT_GROUP_SELECT" value="Quad_X0Y3" />
+    </user_parameters>
+    </ip>
+
+
+ </ip_preset>
+
+<ip_preset preset_proc_name="qsfp0_2x_preset">
+
+  <ip vendor="xilinx.com" library="ip" name="xxv_ethernet">
+    <user_parameters>
+      <user_parameter name="CONFIG.NUM_OF_CORES" value="2" />
+      <user_parameter name="CONFIG.GT_TYPE" value="GTY" />
+      <user_parameter name="CONFIG.LINE_RATE" value="10" />
+      <user_parameter name="CONFIG.GT_GROUP_SELECT" value="Quad_X0Y3" />
+      <user_parameter name="CONFIG.BASE_R_KR" value="BASE-R" />
+    </user_parameters>
+    </ip>
+
+    <ip vendor="xilinx.com" library="ip" name="usxgmii">
+    <user_parameters>
+      <user_parameter name="CONFIG.NUM_OF_CORES" value="2" />
+      <user_parameter name="CONFIG.GT_TYPE" value="GTY" />
+      <user_parameter name="CONFIG.GT_GROUP_SELECT" value="Quad_X0Y3" />
+    </user_parameters>
+    </ip>
+
+    <ip vendor="xilinx.com" library="ip" name="l_ethernet">
+    <user_parameters>
+      <!-- <user_parameter name="CONFIG.GT_REF_CLK_FREQ" value="161.1328125" /> -->
+      <user_parameter name="CONFIG.LINE_RATE" value="40" />
+      <user_parameter name="CONFIG.GT_TYPE" value="GTY" />
+      <user_parameter name="CONFIG.GT_GROUP_SELECT" value="Quad_X0Y3" />
+      <user_parameter name="CONFIG.BASE_R_KR" value="BASE-R" />
+    </user_parameters>
+    </ip>
+
+
+</ip_preset>
+
+<ip_preset preset_proc_name="qsfp0_3x_preset">
+
+    <ip vendor="xilinx.com" library="ip" name="xxv_ethernet">
+    <user_parameters>
+      <user_parameter name="CONFIG.NUM_OF_CORES" value="3" />
+      <user_parameter name="CONFIG.GT_TYPE" value="GTY" />
+      <user_parameter name="CONFIG.LINE_RATE" value="10" />
+      <user_parameter name="CONFIG.GT_GROUP_SELECT" value="Quad_X0Y3" />
+      <user_parameter name="CONFIG.BASE_R_KR" value="BASE-R" />
+    </user_parameters>
+    </ip>
+
+    <ip vendor="xilinx.com" library="ip" name="usxgmii">
+    <user_parameters>
+      <user_parameter name="CONFIG.NUM_OF_CORES" value="3" />
+      <user_parameter name="CONFIG.GT_TYPE" value="GTY" />
+      <user_parameter name="CONFIG.GT_GROUP_SELECT" value="Quad_X0Y3" />
+    </user_parameters>
+    </ip>
+
+</ip_preset>
+
+
+<ip_preset preset_proc_name="qsfp0_4x_preset">
+
+     <ip vendor="xilinx.com" library="ip" name="xxv_ethernet">
+       <user_parameters>
+         <user_parameter name="CONFIG.NUM_OF_CORES" value="4" />
+         <user_parameter name="CONFIG.GT_TYPE" value="GTY" />
+         <user_parameter name="CONFIG.LINE_RATE" value="10" />
+         <user_parameter name="CONFIG.GT_GROUP_SELECT" value="Quad_X0Y3" />
+         <user_parameter name="CONFIG.BASE_R_KR" value="BASE-R" />
+       </user_parameters>
+     </ip>
+
+     <ip vendor="xilinx.com" library="ip" name="usxgmii">
+       <user_parameters>
+       <user_parameter name="CONFIG.NUM_OF_CORES" value="4" />
+       <user_parameter name="CONFIG.GT_TYPE" value="GTY" />
+       <user_parameter name="CONFIG.GT_GROUP_SELECT" value="Quad_X0Y3" />
+       </user_parameters>
+     </ip>
+
+
+     <ip vendor="xilinx.com" library="ip" name="l_ethernet">
+       <user_parameters>
+       <!-- <user_parameter name="CONFIG.GT_REF_CLK_FREQ" value="161.1328125" /> -->
+         <user_parameter name="CONFIG.LINE_RATE" value="40" />
+         <user_parameter name="CONFIG.GT_TYPE" value="GTY" />
+         <user_parameter name="CONFIG.GT_GROUP_SELECT" value="Quad_X0Y3" />
+         <user_parameter name="CONFIG.BASE_R_KR" value="BASE-R" />
+       </user_parameters>
+     </ip>
+
+     <ip vendor="xilinx.com" library="ip" name="cmac_usplus">
+       <user_parameters>
+       <!--<user_parameter name="CONFIG.GT_REF_CLK_FREQ" value="161.1328125" />-->
+       <user_parameter name="CONFIG.GT_TYPE" value="GTY" />
+       <user_parameter name="CONFIG.CMAC_CAUI4_MODE" value="1" />
+       <user_parameter name="CONFIG.NUM_LANES" value="4x25" />
+       <user_parameter name="CONFIG.CMAC_CORE_SELECT" value="CMACE4_X0Y3" />
+       <!--<user_parameter name="CONFIG.GT_GROUP_SELECT" value= "Quad_X0Y7" />-->
+       <user_parameter name="CONFIG.GT_GROUP_SELECT" value= "X0Y24~X0Y27" />
+       <user_parameter name="CONFIG.RS_FEC_TRANSCODE_BYPASS" value= "0" />
+       </user_parameters>
+     </ip>
+
+   </ip_preset>
+
+<!-- QSFP1 Connector -->
+
+  <ip_preset preset_proc_name="qsfp1_1x_preset">
+
+    <ip vendor="xilinx.com" library="ip" name="xxv_ethernet">
+    <user_parameters>
+      <user_parameter name="CONFIG.NUM_OF_CORES" value="1" />
+      <user_parameter name="CONFIG.GT_TYPE" value="GTY" />
+      <user_parameter name="CONFIG.LINE_RATE" value="10" />
+      <user_parameter name="CONFIG.GT_GROUP_SELECT" value="Quad_X0Y4" />
+      <user_parameter name="CONFIG.BASE_R_KR" value="BASE-R" />
+    </user_parameters>
+    </ip>
+
+    <ip vendor="xilinx.com" library="ip" name="usxgmii">
+    <user_parameters>
+      <user_parameter name="CONFIG.NUM_OF_CORES" value="1" />
+      <user_parameter name="CONFIG.GT_TYPE" value="GTY" />
+      <user_parameter name="CONFIG.GT_GROUP_SELECT" value="Quad_X0Y4" />
+    </user_parameters>
+    </ip>
+
+  </ip_preset>
+
+  <ip_preset preset_proc_name="qsfp1_2x_preset">
+
+  <ip vendor="xilinx.com" library="ip" name="xxv_ethernet">
+    <user_parameters>
+        <user_parameter name="CONFIG.NUM_OF_CORES" value="2" />
+        <user_parameter name="CONFIG.GT_TYPE" value="GTY" />
+        <user_parameter name="CONFIG.LINE_RATE" value="10" />
+        <user_parameter name="CONFIG.GT_GROUP_SELECT" value="Quad_X0Y4" />
+        <user_parameter name="CONFIG.BASE_R_KR" value="BASE-R" />
+    </user_parameters>
+    </ip>
+
+    <ip vendor="xilinx.com" library="ip" name="usxgmii">
+    <user_parameters>
+      <user_parameter name="CONFIG.NUM_OF_CORES" value="2" />
+      <user_parameter name="CONFIG.GT_TYPE" value="GTY" />
+      <user_parameter name="CONFIG.GT_GROUP_SELECT" value="Quad_X0Y4" />
+    </user_parameters>
+    </ip>
+
+    <ip vendor="xilinx.com" library="ip" name="l_ethernet">
+    <user_parameters>
+      <!-- <user_parameter name="CONFIG.GT_REF_CLK_FREQ" value="161.1328125" /> -->
+        <user_parameter name="CONFIG.LINE_RATE" value="40" />
+        <user_parameter name="CONFIG.GT_TYPE" value="GTY" />
+        <user_parameter name="CONFIG.GT_GROUP_SELECT" value="Quad_X0Y4" />
+        <user_parameter name="CONFIG.BASE_R_KR" value="BASE-R" />
+    </user_parameters>
+    </ip>
+
+  </ip_preset>
+
+  <ip_preset preset_proc_name="qsfp1_3x_preset">
+
+    <ip vendor="xilinx.com" library="ip" name="xxv_ethernet">
+    <user_parameters>
+        <user_parameter name="CONFIG.NUM_OF_CORES" value="3" />
+        <user_parameter name="CONFIG.GT_TYPE" value="GTY" />
+        <user_parameter name="CONFIG.LINE_RATE" value="10" />
+        <user_parameter name="CONFIG.GT_GROUP_SELECT" value="Quad_X0Y4" />
+        <user_parameter name="CONFIG.BASE_R_KR" value="BASE-R" />
+    </user_parameters>
+    </ip>
+
+    <ip vendor="xilinx.com" library="ip" name="usxgmii">
+    <user_parameters>
+      <user_parameter name="CONFIG.NUM_OF_CORES" value="3" />
+      <user_parameter name="CONFIG.GT_TYPE" value="GTY" />
+      <user_parameter name="CONFIG.GT_GROUP_SELECT" value="Quad_X0Y4" />
+    </user_parameters>
+    </ip>
+
+  </ip_preset>
+
+   <ip_preset preset_proc_name="qsfp1_4x_preset">
+    <ip vendor="xilinx.com" library="ip" name="xxv_ethernet">
+      <user_parameters>
+        <user_parameter name="CONFIG.NUM_OF_CORES" value="4" />
+        <user_parameter name="CONFIG.GT_TYPE" value="GTY" />
+        <user_parameter name="CONFIG.LINE_RATE" value="10" />
+        <user_parameter name="CONFIG.GT_GROUP_SELECT" value="Quad_X0Y4" />
+        <user_parameter name="CONFIG.BASE_R_KR" value="BASE-R" />
+      </user_parameters>
+    </ip>
+
+    <ip vendor="xilinx.com" library="ip" name="usxgmii">
+      <user_parameters>
+      <user_parameter name="CONFIG.NUM_OF_CORES" value="4" />
+      <user_parameter name="CONFIG.GT_TYPE" value="GTY" />
+      <user_parameter name="CONFIG.GT_GROUP_SELECT" value="Quad_X0Y4" />
+      </user_parameters>
+    </ip>
+
+
+    <ip vendor="xilinx.com" library="ip" name="l_ethernet">
+      <user_parameters>
+      <!-- <user_parameter name="CONFIG.GT_REF_CLK_FREQ" value="161.1328125" /> -->
+        <user_parameter name="CONFIG.LINE_RATE" value="40" />
+        <user_parameter name="CONFIG.GT_TYPE" value="GTY" />
+        <user_parameter name="CONFIG.GT_GROUP_SELECT" value="Quad_X0Y4" />
+        <user_parameter name="CONFIG.BASE_R_KR" value="BASE-R" />
+      </user_parameters>
+    </ip>
+
+
+    <ip vendor="xilinx.com" library="ip" name="cmac_usplus">
+      <user_parameters>
+      <user_parameter name="CONFIG.GT_TYPE" value="GTY" />
+      <user_parameter name="CONFIG.CMAC_CAUI4_MODE" value="1" />
+      <user_parameter name="CONFIG.NUM_LANES" value="4x25" />
+      <user_parameter name="CONFIG.CMAC_CORE_SELECT" value="CMACE4_X0Y4" />
+      <user_parameter name="CONFIG.GT_GROUP_SELECT" value= "X0Y28~X0Y31" />
+      <user_parameter name="CONFIG.RS_FEC_TRANSCODE_BYPASS" value= "0" />
+      </user_parameters>
+    </ip>
+  </ip_preset>
+
+</ip_presets>
diff --git a/board_files/Xilinx/au55c/xitem.json b/board_files/Xilinx/au55c/xitem.json
new file mode 100644
index 0000000..44048a5
--- /dev/null
+++ b/board_files/Xilinx/au55c/xitem.json
@@ -0,0 +1,34 @@
+{
+  "config": {
+    "items": [
+      {
+        "infra": {
+          "name": "au55c",
+          "display": "Alveo U55C Data Center Accelerator Card",
+          "revision": "1.0",
+          "description": "Alveo U55C Data Center Accelerator Card",
+          "company": "xilinx.com",
+          "company_display": "Xilinx",
+          "author": "",
+          "contributors": [
+            {
+              "group": "Xilinx",
+              "url": "www.xilinx.com"
+            }
+          ],
+          "category": "Accelerator Cards/Alveo",
+          "logo": "",
+          "website": "https://www.xilinx.com/products/boards-and-kits/alveo/u55c.html",
+          "search-keywords": [
+            "au55c",
+            "xilinx.com",
+            "board",
+            "Accelerator Cards/Alveo"
+          ]
+        }
+      }
+    ]
+  },
+  "_major": 1,
+  "_minor": 0
+}
diff --git a/constr/au250/general.xdc b/constr/au250/general.xdc
index 6269b52..daeab3c 100644
--- a/constr/au250/general.xdc
+++ b/constr/au250/general.xdc
@@ -1,6 +1,6 @@
 # *************************************************************************
 #
-# Copyright 2020 Xilinx, Inc.
+# Copyright 2023 Xilinx, Inc.
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
@@ -15,6 +15,11 @@
 # limitations under the License.
 #
 # *************************************************************************
+set_property LOC MMCM_X0Y2 [get_cells ddr4_inst/inst/u_ddr4_infrastructure/gen_mmcme4.u_mmcme_adv_inst]
+set_property CLOCK_DEDICATED_ROUTE BACKBONE [get_pins ddr4_inst/inst/u_ddr4_infrastructure/gen_mmcme4.u_mmcme_adv_inst/CLKIN1]
+set_property INTERNAL_VREF 0.84 [get_iobanks 63]
+set_property INTERNAL_VREF 0.84 [get_iobanks 62]
+set_property INTERNAL_VREF 0.84 [get_iobanks 61]
 set_property CONFIG_VOLTAGE 1.8 [current_design]
 set_property BITSTREAM.CONFIG.CONFIGFALLBACK Enable [current_design]
 set_property BITSTREAM.GENERAL.COMPRESS TRUE [current_design]
@@ -24,4 +29,4 @@ set_property BITSTREAM.CONFIG.CONFIGRATE 72.9 [current_design]
 set_property BITSTREAM.CONFIG.EXTMASTERCCLK_EN disable [current_design]
 set_property BITSTREAM.CONFIG.SPI_FALL_EDGE YES [current_design]
 set_property BITSTREAM.CONFIG.UNUSEDPIN Pullup [current_design]
-set_property BITSTREAM.CONFIG.SPI_32BIT_ADDR Yes [current_design]
+set_property BITSTREAM.CONFIG.SPI_32BIT_ADDR Yes [current_design]
\ No newline at end of file
diff --git a/constr/au55c/general.xdc b/constr/au55c/general.xdc
new file mode 100644
index 0000000..102f812
--- /dev/null
+++ b/constr/au55c/general.xdc
@@ -0,0 +1,33 @@
+# *************************************************************************
+#
+# Copyright 2021 Xilinx, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# *************************************************************************
+set_property CONFIG_VOLTAGE 1.8 [current_design]
+set_property BITSTREAM.CONFIG.CONFIGFALLBACK Enable [current_design]
+set_property BITSTREAM.GENERAL.COMPRESS TRUE [current_design]
+set_property CONFIG_MODE SPIx4 [current_design]
+set_property BITSTREAM.CONFIG.SPI_BUSWIDTH 4 [current_design]
+set_property BITSTREAM.CONFIG.CONFIGRATE 63.8 [current_design]
+set_property BITSTREAM.CONFIG.EXTMASTERCCLK_EN disable [current_design]
+set_property BITSTREAM.CONFIG.SPI_FALL_EDGE YES [current_design]
+set_property BITSTREAM.CONFIG.UNUSEDPIN Pullup [current_design]
+set_property BITSTREAM.CONFIG.SPI_32BIT_ADDR Yes [current_design]
+set_operating_conditions -design_power_budget 100
+
+# Manually connecting the Debug Hub clock pin to a valid clock source (100MHz reference clock in this case).
+# Read AR72607 for details.
+set_property C_USER_SCAN_CHAIN 1 [get_debug_cores dbg_hub]
+connect_debug_port dbg_hub/clk [get_nets ref_clk_100mhz]
diff --git a/constr/au55c/pins.xdc b/constr/au55c/pins.xdc
new file mode 100644
index 0000000..9887317
--- /dev/null
+++ b/constr/au55c/pins.xdc
@@ -0,0 +1,52 @@
+# *************************************************************************
+#
+# Copyright 2021 Xilinx, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# *************************************************************************
+
+set_property -dict {PACKAGE_PIN BF41 IOSTANDARD LVCMOS18} [get_ports pcie_rstn]
+
+set_property PACKAGE_PIN AR14 [get_ports pcie_refclk_n]
+set_property PACKAGE_PIN AR15 [get_ports pcie_refclk_p]
+
+set num_ports [llength [get_ports qsfp_refclk_p]]
+if {$num_ports >= 1} {
+#    IO pins AD42, AD43 are on IO Bank 130 for use with GTY X0Y24~27
+    set_property PACKAGE_PIN AD43 [get_ports qsfp_refclk_n[0]]
+    set_property PACKAGE_PIN AD42 [get_ports qsfp_refclk_p[0]]
+
+#    set_property PACKAGE_PIN BL13     [get_ports qsfp_activity_led[0]]
+#    set_property IOSTANDARD  LVCMOS18 [get_ports qsfp_activity_led[0]]
+#    set_property PACKAGE_PIN BK11     [get_ports qsfp_link_stat_ledg[0]]
+#    set_property IOSTANDARD  LVCMOS18 [get_ports qsfp_link_stat_ledg[0]]
+#    set_property PACKAGE_PIN BJ11     [get_ports qsfp_link_stat_ledy[0]]
+#    set_property IOSTANDARD  LVCMOS18 [get_ports qsfp_link_stat_ledy[0]]
+}
+if {$num_ports >= 2} {
+#    IO pins AB43, AB42 are on IO Bank 131 for use with GTY X0Y28~31
+    set_property PACKAGE_PIN AB43 [get_ports qsfp_refclk_n[1]]
+    set_property PACKAGE_PIN AB42 [get_ports qsfp_refclk_p[1]]
+
+#    set_property PACKAGE_PIN BK14     [get_ports qsfp_activity_led[1]]
+#    set_property IOSTANDARD  LVCMOS18 [get_ports qsfp_activity_led[1]]
+#    set_property PACKAGE_PIN BK15     [get_ports qsfp_link_stat_ledg[1]]
+#    set_property IOSTANDARD  LVCMOS18 [get_ports qsfp_link_stat_ledg[1]]
+#    set_property PACKAGE_PIN BL12     [get_ports qsfp_link_stat_ledy[1]]
+#    set_property IOSTANDARD  LVCMOS18 [get_ports qsfp_link_stat_ledy[1]]
+}
+
+# Fix the CATTRIP issue for custom flow
+# Read AR72926 for details.
+set_property -dict {PACKAGE_PIN BE45 IOSTANDARD LVCMOS18 PULLDOWN TRUE} [get_ports hbm_cattrip]
diff --git a/constr/au55c/timing.xdc b/constr/au55c/timing.xdc
new file mode 100644
index 0000000..1916aac
--- /dev/null
+++ b/constr/au55c/timing.xdc
@@ -0,0 +1,39 @@
+# *************************************************************************
+#
+# Copyright 2020 Xilinx, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# *************************************************************************
+create_clock -period 10.000 -name pcie_refclk [get_ports pcie_refclk_p]
+
+set_false_path -through [get_ports pcie_rstn]
+
+foreach axis_aclk [get_clocks -of_object [get_nets axis_aclk*]] {
+    foreach cmac_clk [get_clocks -of_object [get_nets cmac_clk*]] {
+        set_max_delay -datapath_only -from $axis_aclk -to $cmac_clk 4.000
+        set_max_delay -datapath_only -from $cmac_clk -to $axis_aclk 3.103
+    }
+}
+
+create_pblock pblock_packet_adapter_tx
+add_cells_to_pblock [get_pblocks pblock_packet_adapter_tx] [get_cells -quiet {cmac_port*.packet_adapter_inst/tx_inst}]
+resize_pblock [get_pblocks pblock_packet_adapter_tx] -add {CLOCKREGION_X0Y4:CLOCKREGION_X1Y5}
+
+create_pblock pblock_packet_adapter_rx
+add_cells_to_pblock [get_pblocks pblock_packet_adapter_rx] [get_cells -quiet {cmac_port*.packet_adapter_inst/rx_inst}]
+resize_pblock [get_pblocks pblock_packet_adapter_rx] -add {CLOCKREGION_X2Y4:CLOCKREGION_X3Y5}
+
+create_pblock pblock_qdma_subsystem
+add_cells_to_pblock [get_pblocks pblock_qdma_subsystem] [get_cells -quiet {qdma_subsystem_inst}]
+resize_pblock [get_pblocks pblock_qdma_subsystem] -add {SLR0}
\ No newline at end of file
diff --git a/plugin/p2p/build_box_322mhz.tcl b/plugin/p2p/build_box_322mhz.tcl
index 185f5af..d9ecb11 100644
--- a/plugin/p2p/build_box_322mhz.tcl
+++ b/plugin/p2p/build_box_322mhz.tcl
@@ -16,3 +16,4 @@
 #
 # *************************************************************************
 read_verilog -quiet -sv p2p_322mhz.sv
+read_verilog -quiet {box_322mhz/box_322mhz_address_map_inst.vh box_322mhz/user_plugin_322mhz_inst.vh}
diff --git a/script/board_settings/au55c.tcl b/script/board_settings/au55c.tcl
new file mode 100644
index 0000000..0bcec1f
--- /dev/null
+++ b/script/board_settings/au55c.tcl
@@ -0,0 +1,22 @@
+
+# *************************************************************************
+#
+# Copyright 2021 Xilinx, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# *************************************************************************
+
+set part xcu55c-fsvh2892-2L-e
+set board_part xilinx.com:au55c:part0:1.0
+set zynq_family 0
diff --git a/script/build.tcl b/script/build.tcl
index c689eb6..44d39e6 100644
--- a/script/build.tcl
+++ b/script/build.tcl
@@ -87,7 +87,7 @@ array set build_options {
     -overwrite   0
     -rebuild     0
     -jobs        8
-    -synth_ip    1
+    -synth_ip    0
     -impl        0
     -post_impl   0
     -user_plugin ""
@@ -223,6 +223,11 @@ if {![file exists ${ip_build_dir}/manage_ip/]} {
 # Run synthesis for each IP
 set ip_dict [dict create]
 dict for {module module_dir} $module_dict {
+    if {[string equal $module mem_ctrl]} {
+        set module_dir ${module_dir}/${board}
+        puts "DEBUG: The current module is mem_ctrl, and the directory is ${module_dir}"
+    }
+
     set ip_tcl_dir ${module_dir}/vivado_ip
 
     # Check the existence of "$ip_tcl_dir" and "${ip_tcl_dir}/vivado_ip.tcl"
@@ -314,6 +319,7 @@ if {$zynq_family} {
     append verilog_define " " "__zynq_family__"
 }
 set_property verilog_define $verilog_define [current_fileset]
+set_property verilog_define "__${board}__ WORK_DIR=\\\\\"${root_dir}/sim\\\\\"" [get_filesets sim_1]
 
 # Read IPs from finished IP runs
 # - Some IPs are board-specific and will be ignored for other board targets
@@ -366,6 +372,23 @@ read_verilog -quiet [glob -nocomplain -directory $src_dir "*.{v,vh}"]
 read_verilog -quiet -sv [glob -nocomplain -directory $src_dir "*.sv"]
 read_vhdl -quiet [glob -nocomplain -directory $src_dir "*.vhd"]
 
+# Read the HBM block diagram
+source ${src_dir}/mem_ctrl/hbm_bd.tcl
+make_wrapper -files [get_files ${top_build_dir}/open_nic_shell.srcs/sources_1/bd/hbm_bd/hbm_bd.bd] -top
+add_files -norecurse ${top_build_dir}/open_nic_shell.gen/sources_1/bd/hbm_bd/hdl/hbm_bd_wrapper.v
+
+# Add simulation sources
+cd ${root_dir}
+set file_path "${root_dir}/sim/file_list.txt"
+set file_id [open $file_path r]
+while {[gets $file_id line] >= 0} {
+    add_files -norecurse $line -fileset sim_1
+}
+close $file_id
+set_property include_dirs "sim/tb/include" [get_filesets sim_1]
+add_files -norecurse "sim/tb/open_nic_tb.sv"  -fileset sim_1
+set_property top board [get_filesets sim_1]
+
 # Set vivado generic
 set design_params(-build_timestamp) "32'h$design_params(-build_timestamp)"
 set generic ""
@@ -395,7 +418,8 @@ read_xdc ${build_dir}/run_params.xdc
 # Implement design
 if {$impl} {
     update_compile_order -fileset sources_1
-    _do_impl $jobs {"Vivado Implementation Defaults"}
+    #_do_impl $jobs {"Vivado Implementation Defaults"}
+    _do_impl $jobs {"Performance_Retiming"}
 }
 
 if {$post_impl} {
diff --git a/sim/axi_file_tools/axi_stream.sv b/sim/axi_file_tools/axi_stream.sv
new file mode 100644
index 0000000..c2eb4f5
--- /dev/null
+++ b/sim/axi_file_tools/axi_stream.sv
@@ -0,0 +1,47 @@
+`timescale 1ns / 1ps
+
+interface axis #(parameter w_data = 512, parameter w_user = 0) (input logic clk);
+    localparam int w_keep = w_data / 8;
+
+    logic              tvalid;
+    logic [w_data-1:0] tdata;
+    logic [w_keep-1:0] tkeep;
+    logic              tlast;
+    logic [w_user-1:0] tuser;
+    logic              tready;
+
+    modport master (
+        input tready,
+        output tvalid, tdata, tkeep, tlast, tuser
+    );
+
+    modport slave (
+        input tvalid, tdata, tkeep, tlast, tuser,
+        output tready
+    );
+
+    task reset;
+        tvalid <= 1'b0;
+        tdata  <=  'b0;
+        tkeep  <=  'b0;
+        tlast  <= 1'b0;
+        tuser  <=  'b0;
+        // tready <= 1'b0;
+    endtask
+
+    task send_beat;
+        input logic [w_data-1:0] data;
+        input logic [w_keep-1:0] keep;
+        input logic              last;
+        tvalid <= 1'b1;
+        tdata  <= data;
+        tkeep  <= keep;
+        tlast  <= last;
+        if (!tready) @(posedge tready);
+    endtask
+
+    task send_user;
+        input logic [w_user-1:0] user;
+        tuser <= user;
+    endtask
+endinterface
\ No newline at end of file
diff --git a/sim/axi_file_tools/file_reader.svh b/sim/axi_file_tools/file_reader.svh
new file mode 100644
index 0000000..e437e3e
--- /dev/null
+++ b/sim/axi_file_tools/file_reader.svh
@@ -0,0 +1,62 @@
+class FileReader #(int w_data = 512, int w_user = 48);
+    localparam int w_keep = w_data / 8;
+
+    virtual axis #(.w_data(w_data), .w_user(w_user)) bus;
+    int file;
+    int is_finished;
+
+    function new (string location, virtual axis #(.w_data(w_data), .w_user(w_user)) bus);
+        this.bus  = bus;
+        file = $fopen(location, "r");
+        is_finished = 0;
+    endfunction
+
+    function int get_finished;
+        return is_finished;
+    endfunction
+
+    task send_beat;
+        input string       line;
+        logic [w_data-1:0] data;
+        logic [w_keep-1:0] keep;
+        logic              last;
+
+        string split_line[] = StringUtils#(3)::split_line(line);
+        data = StringUtils#(w_data)::string_to_vector(split_line[0]);
+        keep = StringUtils#(w_keep)::string_to_vector(split_line[1]);
+        last = split_line[2].atobin();
+
+        bus.send_beat(data, keep, last);
+        @(negedge bus.clk);
+        bus.tvalid <= 1'b0;
+    endtask
+
+    task send_user;
+        input string line;
+        logic [w_user-1:0] user = StringUtils#(w_user)::string_to_vector(line);
+        bus.send_user(user);
+    endtask
+
+    task start;
+        string line, command, value;
+        integer tmp;
+
+        if (!file) return;
+        while (!$feof(file)) begin
+            tmp     = $fgets(line, file);
+            command = line.substr(0, 0);
+            value   = line.substr(1, line.len() - 2);
+            if (StringUtils#(0)::contains(AXIS_COMMANDS, command) == 1'b0)
+                continue;
+
+            if      (command == "!") send_beat(value);
+            else if (command == "?") send_user(value);
+            else begin
+                make_delay(value, command, tmp);
+                repeat (tmp) @(negedge bus.clk);
+            end
+        end
+        $fclose(file);
+        is_finished = 1;
+    endtask
+endclass
\ No newline at end of file
diff --git a/sim/axi_file_tools/file_writer.svh b/sim/axi_file_tools/file_writer.svh
new file mode 100644
index 0000000..36a6fce
--- /dev/null
+++ b/sim/axi_file_tools/file_writer.svh
@@ -0,0 +1,51 @@
+class FileWriter #(int w_data = 512, int w_user = 48);
+    localparam int w_keep  = w_data / 8;
+
+    virtual axis #(.w_data(w_data), .w_user(w_user)) bus;
+    int file;
+    static int is_finished = 0;
+
+    function new (string location, virtual axis #(.w_data(w_data), .w_user(w_user)) bus);
+        this.bus  = bus;
+        file = $fopen(location, "w");
+    endfunction
+
+    static function finish;
+        is_finished = 1;
+    endfunction
+
+    task write_beat;
+        string line;
+        string values [0:2];
+
+        values[0] = StringUtils#(w_data)::vector_to_string(bus.tdata);
+        values[1] = StringUtils#(w_keep)::vector_to_string(bus.tkeep);
+        values[2].bintoa(bus.tlast);
+
+        line = {"!", StringUtils#(3)::merge_line(values), "\n"};
+        $fwrite(file, line);
+        if (bus.tlast) begin
+            $fwrite(file, "\n");
+        end
+    endtask
+
+    task write_user;
+        string line;
+        line = {"?", StringUtils#(w_user)::vector_to_string(bus.tuser), "\n"};
+        $fwrite(file, line);
+    endtask
+
+    task start;
+        if (!file) return;
+        bus.tready <= 1'b1;
+        while (!is_finished) begin
+            @(negedge bus.clk);
+            if (bus.tvalid) begin
+                if (bus.tlast == 1'b1) write_user();
+                write_beat();
+            end
+        end
+        bus.tready <= 1'b0;
+        $fclose(file);
+    endtask
+endclass
\ No newline at end of file
diff --git a/sim/axi_file_tools/make_delay.svh b/sim/axi_file_tools/make_delay.svh
new file mode 100644
index 0000000..f9da5e8
--- /dev/null
+++ b/sim/axi_file_tools/make_delay.svh
@@ -0,0 +1,25 @@
+task automatic make_delay;
+    input  string   line;
+    input  string   command;
+    output integer  wait_cycles;
+    realtime current_time;
+    integer  delay;
+    delay = line.atoi();
+    wait_cycles = 0;
+
+    if (command == "+") begin  // Relative time (nanoseconds)
+        #(delay);
+        wait_cycles = 1;
+    end
+
+    else if (command == "@") begin  // Absolute time (nanoseconds)
+        current_time = $realtime;
+        if (delay > current_time) begin
+            #($ceil(delay - current_time));
+            wait_cycles =  1;
+        end
+    end
+
+    else  // Otherwise it's relative clock cycles
+        wait_cycles = delay;
+endtask
\ No newline at end of file
diff --git a/sim/axi_file_tools/open_nic_file_tools.sv b/sim/axi_file_tools/open_nic_file_tools.sv
new file mode 100644
index 0000000..26e17b7
--- /dev/null
+++ b/sim/axi_file_tools/open_nic_file_tools.sv
@@ -0,0 +1,24 @@
+package open_nic_file_tools;
+    parameter int W_DATA = 512;
+    parameter int W_KEEP = W_DATA / 8;
+
+    // Names of the axi files read and written by the testbench
+    parameter string AXIS_DMA_IN  = "axi_in_dma";
+    parameter string AXIS_DMA_OUT = "axi_out_dma";
+    parameter string AXIS_PHY_IN  = "axi_in_phy";
+    parameter string AXIS_PHY_OUT = "axi_out_phy";
+    parameter string AXIL_IN      = "axi_in_registers";
+    parameter string AXIL_OUT     = "axi_out_registers";
+
+    // Special characters in the axi files
+    parameter string HEX_CHARACTERS = "0123456789abcdefABCDEF-";
+    parameter string TIME_COMMANDS = "@+*";
+    parameter string AXIS_COMMANDS = {"?!", TIME_COMMANDS};
+    parameter string AXIL_COMMANDS = {"!", TIME_COMMANDS};
+
+    `include "make_delay.svh"
+    `include "string_utils.svh"
+    `include "file_reader.svh"
+    `include "file_writer.svh"
+    // `include "file_registers.svh"
+endpackage
\ No newline at end of file
diff --git a/sim/axi_file_tools/string_utils.svh b/sim/axi_file_tools/string_utils.svh
new file mode 100644
index 0000000..0d2dd95
--- /dev/null
+++ b/sim/axi_file_tools/string_utils.svh
@@ -0,0 +1,61 @@
+virtual class StringUtils #(int w = 512);
+    static function logic [w-1:0] string_to_vector (input string data);
+        logic [w-1:0] out;
+        string char;
+        for (int i = w, j = 0; i > 0 && j < data.len(); i -= 4, j++) begin
+            char = data.substr(j, j);
+            while (contains(HEX_CHARACTERS, char) == 1'b0) begin
+                j++;
+                char = data.substr(j, j);
+            end
+            out[i-1-:4] = data.substr(j, j).atohex();
+        end
+        return out;
+    endfunction
+
+    static function string vector_to_string (input logic [w-1:0] data);
+        string out;
+        string tmp;
+        for (int i = w; i > 0; i -= 4) begin
+            tmp.hextoa(data[i-1-:4]);
+            out = {out, tmp};
+        end
+        return out;
+    endfunction
+
+    typedef string strings_t [0:w-1];
+    static function strings_t split_line (input string line);
+        strings_t out;
+        string tmp, char;
+        for (int i = 0, j = 0; i < line.len(); i++) begin
+            char = line.substr(i, i);
+            if (char == ",") begin
+                out[j] = tmp;
+                tmp = "";
+                j++;
+                continue;
+            end
+            if (contains(HEX_CHARACTERS, char) == 1'b0)
+                continue;
+            tmp = {tmp, line.substr(i, i)};
+            if (i == line.len() - 1)
+                out[j] = tmp;
+        end
+        return out;
+    endfunction
+
+    static function string merge_line (input string words [0:w-1]);
+        string out;
+        out = words[0];
+        for (int i = 1; i < w; i++)
+            out = {out, ", ", words[i]};
+        return out;
+    endfunction
+
+    static function logic contains (input string line, input string char);
+        for (int i = 0; i < line.len(); i++)
+            if (char == line.substr(i, i))
+                return 1'b1;
+        return 1'b0;
+    endfunction
+endclass
\ No newline at end of file
diff --git a/sim/axi_packets/__init__.py b/sim/axi_packets/__init__.py
new file mode 100644
index 0000000..a7e29ab
--- /dev/null
+++ b/sim/axi_packets/__init__.py
@@ -0,0 +1,107 @@
+from scapy.layers.l2 import Ether
+
+# from .axi_lite import set_transaction
+from .axi_stream import packets_to_axis, set_delay
+from .packets import *
+from .simulation import interface_manager
+
+
+# PACKET OPERATIONS
+
+
+def send_packets(name: str, packets: Ether | list[Ether]) -> None:
+    """
+    Sends the packets to the interface with the given name
+
+    Args:
+        name (str): the name of the interface to which the packets are sent
+        packets (Ether | list[Ether]): packets to send, only one is fine as well
+    """
+    if not isinstance(packets, list):
+        packets = [packets]
+    axis = packets_to_axis(name, packets)
+    interface_manager.add_sent_packets(name, axis)
+
+
+def expect_packets(name: str, packets: Ether | list[Ether]) -> None:
+    """
+    Adds the packets to the list of expected ones for the given interface
+
+    Args:
+        name (str): the name of the interface from which the packets are expected
+        packets (Ether | list[Ether]): packets to expect, only one is fine as well
+    """
+
+    if not isinstance(packets, list):
+        packets = [packets]
+    interface_manager.add_expected_packets(name, packets)
+
+
+# REGISTER OPERATIONS
+
+
+# def regrwrite(write_addr: str, write_data: str) -> None:
+#     """
+#     Writes data in the register at the given address
+
+#     Args:
+#         write_addr (str): the register address in hexadecimal format
+#         write_data (str): the data to be written in hexadecimal format
+#     """
+#     axil = set_transaction(write_addr = write_addr, write_data = write_data)
+#     interface_manager.add_sent_packets("registers", axil)
+
+
+# def regread(read_addr: str, expected_data: str) -> None:
+#     """
+#     Makes the simulation read at the given address
+
+#     Args:
+#         read_addr (str): the register address in hexadecimal format
+#         expected_data (str): the expected data to be read in hexadecimal format
+#     """
+#     axil = axi_lite.set_transaction(read_addr = read_addr)
+#     interface_manager.add_sent_packets("registers", axil)
+#     packet = f"{read_addr} -> {expected_data}\n".replace("_", "")
+#     interface_manager.add_expected_packets("registers", [packet])
+
+
+# DELAY GENERATION
+
+
+def make_cycles_delay(name: str, amount: int) -> None:
+    """
+    Adds a delay to the simulation of the given interface, measured in clock cycles
+
+    Args:
+        name (str): the name of the interface to which the delay is added
+        amount (int): The amount of clock cycles to wait for. If 0 or less, a random amount is selected
+    """
+    axis = axi_stream.set_delay("*", amount)
+    interface_manager.add_sent_packets(name, axis)
+
+
+def make_relative_delay(name: str, amount: int) -> None:
+    """
+    Adds a delay to the simulation of the given interface, measured in nanoseconds
+
+    Args:
+        name (str): the name of the interface to which the delay is added
+        amount (int): The amount of nanoseconds to wait for. If 0 or less, a random amount is selected
+    """
+    axis = axi_stream.set_delay("+", amount)
+    interface_manager.add_sent_packets(name, axis)
+
+
+def make_absolute_delay(name: str, time: int) -> None:
+    """
+    Makes the simulation of the given interface wait until the given time, in nanoseconds
+
+    Args:
+        name (str): the name of the interface to which the delay is added
+        time (int): The time to wait until. Must be greater than 0
+    """
+    if time < 0:
+        raise ValueError
+    axis = axi_stream.set_delay("@", time)
+    interface_manager.add_sent_packets(name, axis)
diff --git a/sim/axi_packets/axi_stream.py b/sim/axi_packets/axi_stream.py
new file mode 100644
index 0000000..b831b66
--- /dev/null
+++ b/sim/axi_packets/axi_stream.py
@@ -0,0 +1,144 @@
+import io
+import random
+
+from scapy.layers.l2 import Ether
+
+
+W_TDATA = 64
+W_TUSER = 2
+W_TKEEP = W_TDATA // 8
+box = ""
+current_qid = 0
+max_qid = 0
+
+
+def set_globals(user_box, num_queues):
+    global box, max_qid
+    box = user_box
+    max_qid = num_queues
+
+
+def _set_beat(file, packet):
+    # divide the packet into beats
+    beats = []
+    raw_packet = bytes(packet)
+    num_beats = len(raw_packet) // W_TDATA
+    for i in range(num_beats):
+        beat_index = i * W_TDATA
+        beats.append(raw_packet[beat_index:beat_index + W_TDATA])
+    
+    # if it needs another beat
+    last_beat = None
+    if len(raw_packet) % W_TDATA != 0:
+        last_beat = raw_packet[num_beats * W_TDATA:]
+
+    # add in the beats except the last one
+    for i, beat in enumerate(beats):
+        tdata = beat[::-1].hex()
+        tkeep = 'f' * W_TKEEP * 2
+        if not last_beat and i == num_beats - 1:
+            file.write(f"!{tdata}, {tkeep}, 1\n")
+        else:
+            file.write(f"!{tdata}, {tkeep}, 0\n")
+
+    # handle the last beat
+    if last_beat:
+        last_keep = 0
+        for i in range(len(last_beat)):
+            last_keep |= (1 << i)
+        num_bytes = (last_keep.bit_length() + 7) // 8
+        tdata = last_beat[::-1].rjust(W_TDATA, b'\x00').hex()
+        tkeep = last_keep.to_bytes(num_bytes, byteorder = 'little')[::-1].rjust(W_TKEEP, b'\x00').hex()
+        file.write(f"!{tdata}, {tkeep}, 1\n")
+
+
+def _set_plugin_tuser(file, name, packet):
+    tuser_size = len(bytes(packet)).to_bytes(W_TUSER, byteorder = 'big').hex()
+    tuser_src = 0
+    tuser_dst = 0
+
+    interface_type = name[:3]
+    interface_index = int(name[3]) + 1
+    masked_value = interface_index & 0xFFFF
+    if interface_type == "dma":
+        tuser_src |= masked_value
+    else:  # phy
+        tuser_src |= (masked_value << 6)
+
+    tuser_src = f"{tuser_src:04x}"
+    tuser_dst = f"{tuser_dst:04x}"
+    file.write(f"?{tuser_size}{tuser_src}{tuser_dst}\n")
+
+
+def _set_full_tuser(file, name, packet):
+    global current_qid
+    packet_size = len(bytes(packet))
+    tuser_size = format(packet_size, f'032b')
+    tuser_qid = format(current_qid, f'011b')
+    tuser_mty = format(W_TDATA - packet_size % W_TDATA, f'06b')
+
+    tuser = tuser_size + tuser_qid + tuser_mty
+    tuser += '000'  # Pad to 52 bits for the testbench
+    hex_tuser = hex(int(tuser, 2))[2:].zfill(13)
+    file.write(f"?{hex_tuser}\n")
+
+    current_qid += 1
+    if current_qid == max_qid:
+        current_qid = 0
+
+
+def set_delay(mode, amount=0, random_amount=False):
+    if random_amount or amount <= 0:
+        amount = random.randint(1, 1000)
+    return f"{mode}{amount}\n"
+
+
+def packets_to_axis(name, packets):
+    file = io.StringIO()
+    for packet in packets:
+        if box == "__250mhz__":
+            _set_plugin_tuser(file, name, packet)
+        elif box == "__full__":
+            _set_full_tuser(file, name, packet)
+        else:
+            file.write("?0\n")
+        _set_beat(file, packet)
+        file.write("\n")
+    return file.getvalue()
+
+
+def axis_to_packets(file, name):
+    packets, tdata = [], []
+    mty = 0
+    is_full_dma = box == "__full__" and name[:3] == "dma"
+    for line in file:
+        if not line:
+            continue
+
+        # tdata, tkeep, tlast fields
+        if line.startswith("!"):
+            beat = line[1:].replace(" ", "").split(',')
+            tdata.append(bytes.fromhex(beat[0])[::-1])
+            tkeep = bytes.fromhex(beat[1])[::-1]
+            tlast = int(beat[2])
+
+            # create the scapy packet in the last beat
+            if tlast == 1:
+                if is_full_dma:
+                    null_bytes = mty
+                else:
+                    null_bytes = 0
+                    for byte in tkeep:
+                        for i in range(8):
+                            if (byte & (1 << i)) == 0:
+                                null_bytes += 1
+                packet = b''.join(tdata)[:-null_bytes]
+                packets.append(Ether(packet))
+                tdata = []
+
+        elif line.startswith("?") and is_full_dma:
+            clean_line = line[1:].replace(" ", "")
+            tuser = bin(int(clean_line, 16))[2:].zfill(52)
+            mty = int(tuser[44:49], 2)
+
+    return packets
diff --git a/sim/axi_packets/headers.py b/sim/axi_packets/headers.py
new file mode 100644
index 0000000..e890eef
--- /dev/null
+++ b/sim/axi_packets/headers.py
@@ -0,0 +1,50 @@
+from scapy.layers.inet import IP
+from scapy.layers.l2 import ARP, Dot1Q, Ether
+
+
+def make_mac_hdr(src_mac=None, dst_mac=None, ether_type=None, **kwargs):
+    hdr = Ether()
+    if src_mac:
+        hdr.src = src_mac
+    if dst_mac:
+        hdr.dst = dst_mac
+    if ether_type:
+        hdr.type = ether_type
+    return hdr
+
+
+def make_ip_hdr(src_ip=None, dst_ip=None, ttl=None, **kwargs):
+    hdr = IP()
+    if src_ip:
+        hdr[IP].src = src_ip
+    if dst_ip:
+        hdr[IP].dst = dst_ip
+    if ttl:
+        hdr[IP].ttl = ttl
+    return hdr
+
+
+def make_arp_hdr(op=None, src_mac=None, dst_mac=None, src_ip=None, dst_ip=None, **kwargs):
+    hdr = ARP()
+    if op:
+        hdr.op = op
+    if src_mac:
+        hdr.hwsrc = src_mac
+    if dst_mac:
+        hdr.hwdst = dst_mac
+    if src_ip:
+        hdr.psrc = src_ip
+    if dst_ip:
+        hdr.pdst = dst_ip
+    return hdr
+
+
+def make_vlan_hdr(vlan=None, id=None, prio=None, **kwargs):
+    hdr = Dot1Q()
+    if vlan:
+        hdr.vlan = vlan
+    if id:
+        hdr.id = id
+    if prio:
+        hdr.prio = prio
+    return hdr
diff --git a/sim/axi_packets/packets.py b/sim/axi_packets/packets.py
new file mode 100644
index 0000000..8de035f
--- /dev/null
+++ b/sim/axi_packets/packets.py
@@ -0,0 +1,208 @@
+from scapy.layers.inet import ICMP
+from scapy.packet import Raw
+from scapy.volatile import RandString
+
+from .headers import *
+
+
+def _generate_load(length):
+    return Raw(RandString(length))
+
+
+def make_ip_pkt(
+        pkt_len: int = 60, src_mac: str = None, dst_mac: str = None,
+        src_ip: str = None, dst_ip: str = None, ttl: int = None
+) -> Ether:
+    """
+    Creates an ip packet of the given length with a random payload
+
+    Args:
+        pkt_len (int, optional): length in bytes of the packet including the header. Defaults to 60
+        src_mac (str, optional): source mac address
+        dst_mac (str, optional): destination mac address
+        src_ip (str, optional): source ip address
+        dst_ip (str, optional): destination ip address
+        ttl (int, optional): time to live
+
+    Returns:
+        Ether: the resulting ethernet frame
+    """
+    if pkt_len < 60:
+        pkt_len = 60
+    pkt = (make_mac_hdr(src_mac = src_mac, dst_mac = dst_mac) /
+           make_ip_hdr(src_ip = src_ip, dst_ip = dst_ip, ttl = ttl) /
+           _generate_load(pkt_len - 34))
+    return pkt
+
+
+def make_vlan_pkt(
+        pkt_len: int = 60, src_mac: str = None, dst_mac: str = None,
+        vlan: int = None, id: int = None, prio: int = None,
+        src_ip: str = None, dst_ip: str = None, ttl: int = None
+) -> Ether:
+    """
+    Creates a vlan packet of the given length with a random payload
+
+    Args:
+        pkt_len (int, optional): length in bytes of the packet including the header. Defaults to 60
+        src_mac (str, optional): source mac address
+        dst_mac (str, optional): destination mac address
+        vlan (int, optional): vlan id
+        id (int, optional): vlan id
+        prio (int, optional): frame's priority
+        src_ip (str, optional): source ip address
+        dst_ip (str, optional): destination ip address
+        ttl (int, optional): time to live
+
+    Returns:
+        Ether: the resulting scapy packet
+    """
+    if pkt_len < 60:
+        pkt_len = 60
+    pkt = (make_mac_hdr(src_mac = src_mac, dst_mac = dst_mac) /
+           make_vlan_hdr(vlan = vlan, id = id, prio = prio,) /
+           make_ip_hdr(src_ip = src_ip, dst_ip = dst_ip, ttl = ttl) /
+           _generate_load(pkt_len - 34))
+    return pkt
+
+
+def make_icmp_reply_pkt(
+        data: bytearray = None, src_mac: str = None, dst_mac: str = None,
+        src_ip: str = None, dst_ip: str = None, ttl: int = None
+) -> Ether:
+    """
+    Creates an icmp reply packet with the given data
+
+    Args:
+        data (bytearray, optional): the contents of the packet
+        src_mac (str, optional): source mac address
+        dst_mac (str, optional): destination mac address
+        src_ip (str, optional): source ip address
+        dst_ip (str, optional): destination ip address
+        ttl (int, optional): time to live
+
+    Returns:
+        Ether: the resulting scapy packet
+    """
+    pkt = (make_mac_hdr(src_mac = src_mac, dst_mac = dst_mac) /
+           make_ip_hdr(src_ip = src_ip, dst_ip = dst_ip, ttl = ttl) /
+           ICMP(type = "echo-reply"))
+    if data:
+        pkt = pkt / data
+    else:
+        pkt = pkt / ("\x00" * 56)
+    return pkt
+
+
+def make_icmp_request_pkt(
+        src_mac: str = None, dst_mac: str = None,
+        src_ip: str = None, dst_ip: str = None, ttl: int = None
+) -> Ether:
+    """
+    Creates an icmp echo request packet
+
+    Args:
+        src_mac (str, optional): source mac address
+        dst_mac (str, optional): destination mac address
+        src_ip (str, optional): source ip address
+        dst_ip (str, optional): destination ip address
+        ttl (int, optional): time to live
+
+    Returns:
+        Ether: the resulting scapy packet
+    """
+    pkt = (make_mac_hdr(src_mac = src_mac, dst_mac = dst_mac) /
+           make_ip_hdr(src_ip = src_ip, dst_ip = dst_ip, ttl = ttl) /
+           ICMP(type = "echo-request") /
+           ("\x00" * 56))
+    return pkt
+
+
+def make_icmp_ttl_exceed_pkt(
+        src_mac: str = None, dst_mac: str = None,
+        src_ip: str = None, dst_ip: str = None, ttl: int = None
+) -> Ether:
+    """
+    Creates an icmp ttl exceeded packet
+
+    Args:
+        src_mac (str, optional): source mac address
+        dst_mac (str, optional): destination mac address
+        src_ip (str, optional): source ip address
+        dst_ip (str, optional): destination ip address
+        ttl (int, optional): time to live
+
+    Returns:
+        Ether: the resulting scapy packet
+    """
+    pkt = (make_mac_hdr(src_mac = src_mac, dst_mac = dst_mac) /
+           make_ip_hdr(src_ip = src_ip, dst_ip = dst_ip, ttl = ttl) /
+           ICMP(type = 11, code = 0))
+    return pkt
+
+
+def make_icmp_host_unreach_pkt(
+        src_mac: str = None, dst_mac: str = None,
+        src_ip: str = None, dst_ip: str = None, ttl: int = None
+) -> Ether:
+    """
+    creates an icmp host unreachable packet
+
+    args:
+        src_mac (str, optional): source mac address
+        dst_mac (str, optional): destination mac address
+        src_ip (str, optional): source ip address
+        dst_ip (str, optional): destination ip address
+        ttl (int, optional): time to live
+
+    returns:
+        Ether: the resulting scapy packet
+    """
+    pkt = (make_mac_hdr(src_mac = src_mac, dst_mac = dst_mac) /
+           make_ip_hdr(src_ip = src_ip, dst_ip = dst_ip, ttl = ttl) /
+           ICMP(type = 3, code = 0))
+    return pkt
+
+
+def make_arp_request_pkt(
+        src_mac: str = None, dst_mac: str = None,
+        src_ip: str = None, dst_ip: str = None,
+) -> Ether:
+    """
+    Creates an arp request packet
+
+    Args:
+        src_mac (str, optional): source mac address
+        dst_mac (str, optional): destination mac address
+        src_ip (str, optional): source ip address
+        dst_ip (str, optional): destination ip address
+
+    Returns:
+        Ether: the resulting scapy packet
+    """
+    pkt = (make_mac_hdr(src_mac = src_mac, dst_mac = dst_mac) /
+           make_arp_hdr(op = "who-has", src_ip = src_ip, dst_ip = dst_ip) /
+           ("\x00" * 18))
+    return pkt
+
+
+def make_arp_reply_pkt(
+        src_mac: str = None, dst_mac: str = None,
+        src_ip: str = None, dst_ip: str = None,
+) -> Ether:
+    """
+    Creates an arp reply packet
+
+    Args:
+        src_mac (str, optional): source mac address
+        dst_mac (str, optional): destination mac address
+        src_ip (str, optional): source ip address
+        dst_ip (str, optional): destination ip address
+
+    Returns:
+        Ether: the resulting scapy packet
+    """
+    pkt = (make_mac_hdr(src_mac = src_mac, dst_mac = dst_mac) /
+           make_arp_hdr(op = "is-at", src_ip = src_ip, dst_ip = dst_ip) /
+           ("\x00" * 18))
+    return pkt
diff --git a/sim/axi_packets/simulation.py b/sim/axi_packets/simulation.py
new file mode 100644
index 0000000..d62da01
--- /dev/null
+++ b/sim/axi_packets/simulation.py
@@ -0,0 +1,121 @@
+# import difflib
+# import logging
+import os
+
+# from .axi_lite import get_transactions
+from .axi_stream import axis_to_packets, set_globals
+
+
+NUM_CMAC_PORT = 1
+NUM_QDMA = 1
+NUM_PHYS_FUNC = 1
+NUM_QUEUE = 512
+USER_BOX = "__full__"
+SIM_LOCATION = os.environ["PWD"]
+
+
+class SimulationError(Exception):
+    pass
+
+
+class InterfacesManager:
+
+    def __init__(self):
+        self.received_packets = dict()
+        self.expected_packets = dict()
+        self.interfaces = dict()
+        self.sim_location = None
+        self.box = None
+
+    def _get_interface_names(self):
+        for i in range(NUM_CMAC_PORT):
+            yield f"cmac{i}"
+        if self.box == "__250mhz__":
+            interfaces_range = NUM_QDMA * NUM_PHYS_FUNC
+        # for i in range(interfaces_range):
+            # yield f"dma{i}"
+        # yield "registers"
+
+    def open_interfaces(self):
+        self.box = USER_BOX
+        self.sim_location = SIM_LOCATION
+        set_globals(self.box, NUM_QUEUE)
+        for interface_name in self._get_interface_names():
+            self.interfaces[interface_name] = open(f"{self.sim_location}/axi_in_{interface_name}.txt", 'w')
+            self.expected_packets[interface_name] = []
+
+    def close_interfaces(self):
+        for interface_file in self.interfaces.values():
+            interface_file.close()
+
+    def _get_interface(self, name):
+        if name not in self.interfaces.keys():
+            # log.error(f"Invalid interface name {name}")
+            return
+        return self.interfaces[name]
+
+    def add_sent_packets(self, name, text):
+        file = self._get_interface(name)
+        if file:
+            file.write(text)
+
+    # def add_expected_packets(self, name, packets):
+    #     file = self._get_interface(name)
+    #     if file:
+    #         self.expected_packets[name].extend(packets)
+
+    # def add_received_packets(self):
+    #     for interface_name in self._get_interface_names():
+    #         file = open(f"{self.sim_location}/axi_out_{interface_name}.txt", 'r')
+    #         if interface_name == "registers":
+    #             packets = get_transactions(file)
+    #         else:
+    #             packets = axis_to_packets(file, interface_name)
+    #         self.received_packets[interface_name] = packets
+    #         file.close()
+
+    # @staticmethod
+    # def _compare_packet_lists(received_packets, expected_packets, interface_name=None):
+    #     differ = difflib.Differ()
+    #     correct = True
+    #     for received, expected in zip(received_packets, expected_packets):
+    #         if interface_name:
+    #             received = received.show2(dump = True)
+    #             expected = expected.show2(dump = True)
+    #         if received == expected:
+    #             continue
+    #         correct = False
+    #         difference = list(differ.compare(received.splitlines(), expected.splitlines()))
+    #         difference_string = '\n'.join(difference)
+    #         if interface_name:
+    #             log.warning(f"Packet mismatch for {interface_name}:\n{difference_string}")
+    #         else:
+    #             log.warning(f"Register mismatch:\n{difference_string}")
+
+    #     difference = len(received_packets) - len(expected_packets)
+    #     if interface_name and difference != 0:
+    #         if difference > 0:
+    #             log.warning(f"Received {difference} more packets than expected for interface {interface_name}")
+    #         elif difference < 0:
+    #             log.warning(f"Expected {-difference} more packet than received from interface {interface_name}")
+    #     return correct
+
+    # def compare_packets(self):
+    #     packets_correct = True
+    #     for interface_name in self._get_interface_names():
+    #         expected_packets = self.expected_packets[interface_name]
+    #         if not expected_packets or interface_name == "registers":
+    #             continue
+    #         received_values = self.received_packets[interface_name]
+    #         result = self._compare_packet_lists(received_values, expected_packets, interface_name = interface_name)
+    #         packets_correct = packets_correct and result
+    #     if packets_correct:
+    #         log.info("All packets were as expected")
+
+    #     expected_values = self.expected_packets["registers"]
+    #     if expected_values:
+    #         received_values = self.received_packets["registers"]
+    #         if self._compare_packet_lists(received_values, expected_values):
+    #             log.info("All register values were as expected")
+
+interface_manager = InterfacesManager()
diff --git a/sim/file_list.txt b/sim/file_list.txt
new file mode 100644
index 0000000..eb1224f
--- /dev/null
+++ b/sim/file_list.txt
@@ -0,0 +1,15 @@
+sim/tb/RP_model/pcie_4_c_rp.v
+sim/tb/RP_model/sys_clk_gen.v
+sim/tb/RP_model/sys_clk_gen_ds.v
+sim/tb/usrapp/usp_pci_exp_usrapp_cfg.v
+sim/tb/usrapp/usp_pci_exp_usrapp_com.v
+sim/tb/usrapp/usp_pci_exp_usrapp_rx.v
+sim/tb/usrapp/usp_pci_exp_usrapp_tx.sv
+sim/tb/RP_model/xilinx_pcie_uscale_rp.v
+sim/tb/RP_model/xp4c_usp_smsw_model_core_top.v
+sim/axi_file_tools/axi_stream.sv
+sim/axi_file_tools/file_reader.svh
+sim/axi_file_tools/file_writer.svh
+sim/axi_file_tools/make_delay.svh
+sim/axi_file_tools/open_nic_file_tools.sv
+sim/axi_file_tools/string_utils.svh
diff --git a/sim/generate_cmac_packets.py b/sim/generate_cmac_packets.py
new file mode 100644
index 0000000..e6c3258
--- /dev/null
+++ b/sim/generate_cmac_packets.py
@@ -0,0 +1,8 @@
+import axi_packets
+
+packet = axi_packets.make_ip_pkt(128)
+
+axi_packets.interface_manager.open_interfaces()
+axi_packets.send_packets("cmac0", packet)
+axi_packets.interface_manager.close_interfaces()
+
diff --git a/sim/tb/RP_model/pcie_4_c_rp.v b/sim/tb/RP_model/pcie_4_c_rp.v
new file mode 100644
index 0000000..a984773
--- /dev/null
+++ b/sim/tb/RP_model/pcie_4_c_rp.v
@@ -0,0 +1,1800 @@
+
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2025 Advanced Micro Devices, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : PCI Express DMA 
+// File       : pcie_4_c_rp.v
+// Version    : 5.0
+//-----------------------------------------------------------------------------
+//-----------------------------------------------------------------------------
+// 
+//      Root Port Model
+//
+//-----------------------------------------------------------------------------
+
+`timescale 1ps/1ps
+
+
+module pcie_4_c_rp #(
+
+   parameter  integer     LANES = 16, //16,
+   parameter [4:0]        PL_LINK_CAP_MAX_LINK_WIDTH=5'd16,//16,
+   parameter [3:0]        PL_LINK_CAP_MAX_LINK_SPEED=4'd4,//4,
+   parameter              KESTREL_512_HLF = "FALSE",
+   parameter              AXI4_DATA_WIDTH = 512, 
+   parameter              AXI4_TKEEP_WIDTH = 512/32, 
+   parameter              AXISTEN_IF_EXT_512= (AXI4_DATA_WIDTH == 512) ? "TRUE" : "FALSE",
+   parameter              IMPL_TARGET = "HARD",
+   parameter [1:0]        PL_SIM_FAST_LINK_TRAINING=2'b11,
+   parameter              PL_UPSTREAM_FACING="FALSE",
+   parameter  [1:0]       CRM_USER_CLK_FREQ=2'd3,
+   parameter              CRM_CORE_CLK_FREQ= 2,//2,
+   parameter              PL_DEEMPH_SOURCE_SELECT="TRUE",
+   parameter              TL_COMPLETION_RAM_SIZE=2'b01,    
+   parameter              AXISTEN_IF_RX_PARITY_EN="FALSE",    
+   parameter              AXISTEN_IF_TX_PARITY_EN="FALSE",     
+   parameter              LL_TX_TLP_PARITY_CHK="FALSE",      
+   parameter              LL_RX_TLP_PARITY_GEN="FALSE",    
+   parameter              AXISTEN_IF_ENABLE_CLIENT_TAG="FALSE",  
+   parameter [15:0]    PL_USER_SPARE=16'h3,
+   parameter              AXI4_CQ_TUSER_WIDTH = 183,
+   parameter              AXI4_CC_TUSER_WIDTH = 81,
+   parameter              AXI4_RQ_TUSER_WIDTH = 137,
+   parameter              AXI4_RC_TUSER_WIDTH = 161,
+   parameter              AXI4_CQ_TREADY_WIDTH = 22,
+   parameter              AXI4_CC_TREADY_WIDTH = 4,
+   parameter              AXI4_RQ_TREADY_WIDTH = 4,
+   parameter              AXI4_RC_TREADY_WIDTH = 22
+   )(
+    input  wire           pl_gen2_upstream_prefer_deemph
+   ,output wire           pl_eq_in_progress
+   ,output wire [1:0]     pl_eq_phase
+   ,input  wire           pl_eq_reset_eieos_count
+   ,input  wire           pl_redo_eq
+   ,input  wire           pl_redo_eq_speed
+   ,output wire           pl_eq_mismatch
+   ,output wire           pl_redo_eq_pending
+   ,output wire [AXI4_DATA_WIDTH-1:0] m_axis_cq_tdata
+   ,input  wire [AXI4_DATA_WIDTH-1:0] s_axis_cc_tdata
+   ,input  wire [AXI4_DATA_WIDTH-1:0] s_axis_rq_tdata
+   ,output wire [AXI4_DATA_WIDTH-1:0] m_axis_rc_tdata
+   ,output wire [AXI4_CQ_TUSER_WIDTH-1:0] m_axis_cq_tuser
+   ,input  wire [AXI4_CC_TUSER_WIDTH-1:0] s_axis_cc_tuser
+   ,output wire           m_axis_cq_tlast
+   ,input  wire           s_axis_rq_tlast
+   ,output wire           m_axis_rc_tlast
+   ,input  wire           s_axis_cc_tlast
+   ,input  wire [1:0]     pcie_cq_np_req
+   ,output wire [5:0]     pcie_cq_np_req_count
+   ,input  wire [AXI4_RQ_TUSER_WIDTH-1:0] s_axis_rq_tuser
+   ,output wire [AXI4_RC_TUSER_WIDTH-1:0] m_axis_rc_tuser
+   ,output wire [AXI4_TKEEP_WIDTH-1:0] m_axis_cq_tkeep
+   ,input  wire [AXI4_TKEEP_WIDTH-1:0] s_axis_cc_tkeep
+   ,input  wire [AXI4_TKEEP_WIDTH-1:0] s_axis_rq_tkeep
+   ,output wire [AXI4_TKEEP_WIDTH-1:0] m_axis_rc_tkeep
+   ,output wire           m_axis_cq_tvalid
+   ,input  wire           s_axis_cc_tvalid
+   ,input  wire           s_axis_rq_tvalid
+   ,output wire           m_axis_rc_tvalid
+   ,input  wire [AXI4_CQ_TREADY_WIDTH-1:0] m_axis_cq_tready
+   ,output wire [AXI4_CC_TREADY_WIDTH-1:0] s_axis_cc_tready
+   ,output wire [AXI4_RQ_TREADY_WIDTH-1:0] s_axis_rq_tready
+   ,input  wire [AXI4_RC_TREADY_WIDTH-1:0] m_axis_rc_tready
+   ,output wire [5:0]     pcie_rq_seq_num0
+   ,output wire           pcie_rq_seq_num_vld0
+   ,output wire [5:0]     pcie_rq_seq_num1
+   ,output wire           pcie_rq_seq_num_vld1
+   ,output wire [7:0]     pcie_rq_tag0
+   ,output wire           pcie_rq_tag_vld0
+   ,output wire [7:0]     pcie_rq_tag1
+   ,output wire           pcie_rq_tag_vld1
+   ,output wire [3:0]     pcie_tfc_nph_av
+   ,output wire [3:0]     pcie_tfc_npd_av
+   ,output wire [3:0]     pcie_rq_tag_av
+   ,input  wire [9:0]     cfg_mgmt_addr
+   ,input  wire [7:0]     cfg_mgmt_function_number
+   ,input  wire           cfg_mgmt_write
+   ,input  wire [31:0]    cfg_mgmt_write_data
+   ,input  wire [3:0]     cfg_mgmt_byte_enable
+   ,input  wire           cfg_mgmt_read
+   ,output wire [31:0]    cfg_mgmt_read_data
+   ,output wire           cfg_mgmt_read_write_done
+   ,input  wire           cfg_mgmt_debug_access
+   ,output wire           cfg_phy_link_down
+   ,output wire [1:0]     cfg_phy_link_status
+   ,output wire [2:0]     cfg_negotiated_width
+   ,output wire [1:0]     cfg_current_speed
+   ,output wire [1:0]     cfg_max_payload
+   ,output wire [2:0]     cfg_max_read_req
+   ,output wire [15:0]    cfg_function_status
+   ,output wire [11:0]    cfg_function_power_state
+   ,output wire [1:0]     cfg_link_power_state
+   ,output wire           cfg_err_cor_out
+   ,output wire           cfg_err_nonfatal_out
+   ,output wire           cfg_err_fatal_out
+   ,output wire           cfg_local_error_valid
+   ,output wire [4:0]     cfg_local_error_out
+   ,output wire [5:0]     cfg_ltssm_state
+   ,output wire [1:0]     cfg_rx_pm_state
+   ,output wire [1:0]     cfg_tx_pm_state
+   ,output wire [3:0]     cfg_rcb_status
+   ,output wire [1:0]     cfg_obff_enable
+   ,output wire           cfg_pl_status_change
+   ,output wire [3:0]     cfg_tph_requester_enable
+   ,output wire [11:0]    cfg_tph_st_mode
+   ,output wire           cfg_msg_received
+   ,output wire [7:0]     cfg_msg_received_data
+   ,output wire [4:0]     cfg_msg_received_type
+   ,input  wire           cfg_msg_transmit
+   ,input  wire [2:0]     cfg_msg_transmit_type
+   ,input  wire [31:0]    cfg_msg_transmit_data
+   ,output wire           cfg_msg_transmit_done
+   ,output wire [7:0]     cfg_fc_ph
+   ,output wire [11:0]    cfg_fc_pd
+   ,output wire [7:0]     cfg_fc_nph
+   ,output wire [11:0]    cfg_fc_npd
+   ,output wire [7:0]     cfg_fc_cplh
+   ,output wire [11:0]    cfg_fc_cpld
+   ,input  wire [2:0]     cfg_fc_sel
+   ,input  wire           cfg_fc_vc_sel
+   ,input  wire           cfg_hot_reset_in
+   ,output wire           cfg_hot_reset_out
+   ,input  wire           cfg_config_space_enable
+   ,input  wire [63:0]    cfg_dsn
+   ,input  wire [15:0]    cfg_dev_id_pf0
+   ,input  wire [15:0]    cfg_dev_id_pf1
+   ,input  wire [15:0]    cfg_dev_id_pf2
+   ,input  wire [15:0]    cfg_dev_id_pf3
+   ,input  wire [15:0]    cfg_vend_id
+   ,input  wire [7:0]     cfg_rev_id_pf0
+   ,input  wire [7:0]     cfg_rev_id_pf1
+   ,input  wire [7:0]     cfg_rev_id_pf2
+   ,input  wire [7:0]     cfg_rev_id_pf3
+   ,input  wire [15:0]    cfg_subsys_id_pf0
+   ,input  wire [15:0]    cfg_subsys_id_pf1
+   ,input  wire [15:0]    cfg_subsys_id_pf2
+   ,input  wire [15:0]    cfg_subsys_id_pf3
+   ,input  wire [15:0]    cfg_subsys_vend_id
+   ,input  wire [7:0]     cfg_ds_port_number
+   ,input  wire [7:0]     cfg_ds_bus_number
+   ,input  wire [4:0]     cfg_ds_device_number
+   ,output wire [7:0]     cfg_bus_number
+   ,input  wire           cfg_power_state_change_ack
+   ,output wire           cfg_power_state_change_interrupt
+   ,input  wire           cfg_err_cor_in
+   ,input  wire           cfg_err_uncor_in
+   ,input  wire [3:0]     cfg_flr_done
+   ,output wire [3:0]     cfg_flr_in_process
+   ,input  wire           cfg_req_pm_transition_l23_ready
+   ,input  wire           cfg_link_training_enable
+   ,input  wire [3:0]     cfg_interrupt_int
+   ,output wire           cfg_interrupt_sent
+   ,input  wire [3:0]     cfg_interrupt_pending
+   ,output wire [3:0]     cfg_interrupt_msi_enable
+   ,input  wire [31:0]    cfg_interrupt_msi_int
+   ,output wire           cfg_interrupt_msi_sent
+   ,output wire           cfg_interrupt_msi_fail
+   ,output wire [11:0]    cfg_interrupt_msi_mmenable
+   ,input  wire [31:0]    cfg_interrupt_msi_pending_status
+   ,input  wire [1:0]     cfg_interrupt_msi_pending_status_function_num
+   ,input  wire           cfg_interrupt_msi_pending_status_data_enable
+   ,output wire           cfg_interrupt_msi_mask_update
+   ,input  wire [1:0]     cfg_interrupt_msi_select
+   ,output wire [31:0]    cfg_interrupt_msi_data
+   ,output wire [3:0]     cfg_interrupt_msix_enable
+   ,output wire [3:0]     cfg_interrupt_msix_mask
+   ,input  wire [63:0]    cfg_interrupt_msix_address
+   ,input  wire [31:0]    cfg_interrupt_msix_data
+   ,input  wire           cfg_interrupt_msix_int
+   ,input  wire [1:0]     cfg_interrupt_msix_vec_pending
+   ,output wire           cfg_interrupt_msix_vec_pending_status
+   ,input  wire [2:0]     cfg_interrupt_msi_attr
+   ,input  wire           cfg_interrupt_msi_tph_present
+   ,input  wire [1:0]     cfg_interrupt_msi_tph_type
+   ,input  wire [7:0]     cfg_interrupt_msi_tph_st_tag
+   ,input  wire [7:0]     cfg_interrupt_msi_function_number
+   ,output wire           cfg_ext_read_received
+   ,output wire           cfg_ext_write_received
+   ,output wire [9:0]     cfg_ext_register_number
+   ,output wire [7:0]     cfg_ext_function_number
+   ,output wire [31:0]    cfg_ext_write_data
+   ,output wire [3:0]     cfg_ext_write_byte_enable
+   ,input  wire [31:0]    cfg_ext_read_data
+   ,input  wire           cfg_ext_read_data_valid
+   ,output wire [251:0]   cfg_vf_flr_in_process
+   ,input  wire           cfg_vf_flr_done
+   ,input  wire [7:0]     cfg_vf_flr_func_num
+   ,output wire [503:0]   cfg_vf_status
+   ,output wire [755:0]   cfg_vf_power_state 
+   ,output wire [251:0]   cfg_vf_tph_requester_enable
+   ,output wire [755:0]   cfg_vf_tph_st_mode
+   ,output wire [251:0]   cfg_interrupt_msix_vf_enable
+   ,output wire [251:0]   cfg_interrupt_msix_vf_mask
+   ,input  wire           cfg_pm_aspm_l1_entry_reject
+   ,input  wire           cfg_pm_aspm_tx_l0s_entry_disable
+   ,output wire           cfg_vc1_enable
+   ,output wire           cfg_vc1_negotiation_pending
+   ,input  wire [7:0]     user_tph_stt_func_num
+   ,input  wire [5:0]     user_tph_stt_index
+   ,input  wire           user_tph_stt_rd_en
+   ,output wire [7:0]     user_tph_stt_rd_data
+   ,input  wire [1:0]     conf_req_type
+   ,input  wire [3:0]     conf_req_reg_num
+   ,input  wire [31:0]    conf_req_data
+   ,input  wire           conf_req_valid
+   ,output wire           conf_req_ready
+   ,output wire [31:0]    conf_resp_rdata
+   ,output wire           conf_resp_valid
+/*
+   ,output wire           conf_mcap_design_switch
+   ,output wire           conf_mcap_eos
+   ,output wire           conf_mcap_in_use_by_pcie
+   ,input  wire           conf_mcap_request_by_conf
+   ,output wire [255:0]   dbg_data0_out
+   ,output wire [31:0]    dbg_ctrl0_out
+   ,input  wire [5:0]     dbg_sel0
+   ,output wire [255:0]   dbg_data1_out
+   ,output wire [31:0]    dbg_ctrl1_out
+   ,input  wire [5:0]     dbg_sel1
+   ,input  wire           drp_clk
+   ,input  wire           drp_en
+   ,input  wire           drp_we
+   ,input  wire [9:0]     drp_addr
+   ,input  wire [15:0]    drp_di
+   ,output wire           drp_rdy
+   ,output wire [15:0]    drp_do
+   ,input  wire           scanmode_n
+   ,input  wire           scanenable_n
+   ,input  wire [149:0]   scanin
+   ,output wire [149:0]   scanout
+   ,output wire           pcie_perst0_b
+   ,output wire           pcie_perst1_b
+   ,input  wire           pmv_enable_n
+   ,input  wire [2:0]     pmv_select
+   ,input  wire [1:0]     pmv_divide
+   ,output wire           pmv_out
+   ,input  wire [31:0]    user_spare_in
+   ,output wire [31:0]    user_spare_out
+*/
+   ,output wire           user_clk
+   ,output wire           user_reset
+   ,output wire           user_lnk_up
+   ,input  wire           sys_clk
+   ,input  wire           sys_clk_gt
+   ,input  wire           sys_reset
+   ,input  wire [LANES-1:0]     pci_exp_rxp
+   ,input  wire [LANES-1:0]     pci_exp_rxn
+   ,output wire [LANES-1:0]     pci_exp_txp
+   ,output wire [LANES-1:0]     pci_exp_txn
+   ,output wire           core_clk
+     //-----------------------------------------------------------------------
+     // CCIX TX Interface
+     // Data from CCIX protocol processing block
+     //-----------------------------------------------------------------------
+   ,input wire [255:0]   s_axis_ccix_tx_tdata // 256-bit data
+   ,input wire           s_axis_ccix_tx_tvalid // Valid
+   ,input wire [45:0]    s_axis_ccix_tx_tuser // tuser bus
+                         // [0] = is_sop0, [1] = is_sop0_ptr,
+                         // [2] = is_sop1, [3] = is_sop1_ptr,
+                         // [4] = is_eop0, [7:5] = is_eop0_ptr,
+                         // [8] = is_eop1, [11:9] = is_eop1_ptr,
+                         // [13:12] = discontinue, [45:14] = odd parity
+   ,output wire          ccix_tx_credit // Flow control credits to CCIX protocol processing block
+     //-----------------------------------------------------------------------
+     // CCIX RX Interface
+     // Data to downstream CCIX protocol processing block
+     //-----------------------------------------------------------------------
+   ,output wire [255:0]  m_axis_ccix_rx_tdata // 256-bit data
+   ,output wire          m_axis_ccix_rx_tvalid // Valid
+   ,output wire [45:0]   m_axis_ccix_rx_tuser // tuser bus
+                         // [0] = is_sop0, [1] = is_sop0_ptr,
+                         // [2] = is_sop1, [3] = is_sop1_ptr,
+                         // [4] = is_eop0, [7:5] = is_eop0_ptr,
+                         // [8] = is_eop1, [11:9] = is_eop1_ptr,
+                         // [13:12] = discontinue, [45:14] = odd parity
+   ,input wire           ccix_rx_credit // Flow control credits from CCIX protocol processing block
+   ,output wire [7:0]    ccix_rx_credit_av // Current value of available credit maintained by the bridge
+   ,input wire           ccix_optimized_tlp_tx_and_rx_enable
+
+  );
+
+    localparam            TCQ = 100;
+    localparam  integer   PHY_REFCLK_FREQ=0;                 // 0 - 100 MHz, 1 - 125 MHz,  2 - 250 MHz;
+    localparam            AXISTEN_IF_EXT_512_INTFC_RAM_STYLE="BRAM";
+    localparam            FPGA_FAMILY="USM";
+    localparam            FPGA_XCVR="Y";
+    localparam  integer   PIPE_PIPELINE_STAGES=0;
+    localparam            CRM_MCAP_CLK_FREQ=1'b0;
+    localparam  [1:0]     AXISTEN_IF_WIDTH=(AXI4_DATA_WIDTH == 64) ? 2'b00 : (AXI4_DATA_WIDTH == 128) ? 2'b01 : (AXI4_DATA_WIDTH == 256) ? 2'b10 : 2'b11;
+    localparam            AXISTEN_IF_EXT_512_CQ_STRADDLE="FALSE";
+    localparam            AXISTEN_IF_EXT_512_CC_STRADDLE="FALSE";
+    localparam            AXISTEN_IF_EXT_512_RQ_STRADDLE="FALSE";
+    localparam            AXISTEN_IF_EXT_512_RC_STRADDLE="FALSE";
+    localparam  [1:0]     AXISTEN_IF_CQ_ALIGNMENT_MODE=2'b00;
+    localparam  [1:0]     AXISTEN_IF_CC_ALIGNMENT_MODE=2'b00;
+    localparam  [1:0]     AXISTEN_IF_RQ_ALIGNMENT_MODE=2'b00;
+    localparam  [1:0]     AXISTEN_IF_RC_ALIGNMENT_MODE=2'b00;
+    localparam            AXISTEN_IF_RC_STRADDLE="FALSE";
+    localparam            AXISTEN_IF_ENABLE_RX_MSG_INTFC="FALSE";
+    localparam  [17:0]    AXISTEN_IF_ENABLE_MSG_ROUTE=18'h0;
+    localparam            AXISTEN_IF_ENABLE_256_TAGS="TRUE";
+    localparam  [23:0]    AXISTEN_IF_COMPL_TIMEOUT_REG0=24'hBEBC20;
+    localparam  [27:0]    AXISTEN_IF_COMPL_TIMEOUT_REG1=28'h2FAF080;
+    localparam            AXISTEN_IF_LEGACY_MODE_ENABLE="FALSE";
+    localparam            AXISTEN_IF_ENABLE_MESSAGE_RID_CHECK="TRUE";
+    localparam            AXISTEN_IF_MSIX_TO_RAM_PIPELINE="FALSE";
+    localparam            AXISTEN_IF_MSIX_FROM_RAM_PIPELINE="FALSE";
+
+    localparam            AXISTEN_IF_MSIX_RX_PARITY_EN="TRUE";
+    localparam            AXISTEN_IF_ENABLE_INTERNAL_MSIX_TABLE="FALSE";
+
+    localparam            AXISTEN_IF_SIM_SHORT_CPL_TIMEOUT="FALSE";
+    localparam            AXISTEN_IF_CQ_EN_POISONED_MEM_WR="FALSE";
+    localparam            AXISTEN_IF_RQ_CC_REGISTERED_TREADY="TRUE";
+    localparam  [15:0]    PM_ASPML0S_TIMEOUT=16'h1500;
+    localparam  [19:0]    PM_ASPML1_ENTRY_DELAY= (CRM_CORE_CLK_FREQ == 2) ? 20'h7D0 : 20'h3E8; 
+    localparam  [31:0]    PM_L1_REENTRY_DELAY= (CRM_CORE_CLK_FREQ == 2) ? 32'hC350 :  32'h61A8;
+    localparam            PM_ENABLE_SLOT_POWER_CAPTURE="TRUE";
+    localparam  [19:0]    PM_PME_SERVICE_TIMEOUT_DELAY=20'h0;
+    localparam  [15:0]    PM_PME_TURNOFF_ACK_DELAY=16'h100;
+    localparam            PL_DISABLE_DC_BALANCE="FALSE";
+    localparam            PL_DISABLE_EI_INFER_IN_L0="FALSE";
+    localparam  integer   PL_N_FTS=255;
+    localparam            PL_DISABLE_UPCONFIG_CAPABLE="FALSE";
+    localparam            PL_DISABLE_RETRAIN_ON_FRAMING_ERROR="FALSE";
+    localparam            PL_DISABLE_RETRAIN_ON_EB_ERROR="FALSE";
+    localparam  [15:0]    PL_DISABLE_RETRAIN_ON_SPECIFIC_FRAMING_ERROR=16'b0000000000000000;
+    localparam  [7:0]     PL_REPORT_ALL_PHY_ERRORS=8'b00000000;
+    localparam  [1:0]     PL_DISABLE_LFSR_UPDATE_ON_SKP=2'b00;
+    localparam  [31:0]    PL_LANE0_EQ_CONTROL=32'h3400;
+    localparam  [31:0]    PL_LANE1_EQ_CONTROL=32'h3400;
+    localparam  [31:0]    PL_LANE2_EQ_CONTROL=32'h3400;
+    localparam  [31:0]    PL_LANE3_EQ_CONTROL=32'h3400;
+    localparam  [31:0]    PL_LANE4_EQ_CONTROL=32'h3400;
+    localparam  [31:0]    PL_LANE5_EQ_CONTROL=32'h3400;
+    localparam  [31:0]    PL_LANE6_EQ_CONTROL=32'h3400;
+    localparam  [31:0]    PL_LANE7_EQ_CONTROL=32'h3400;
+    localparam  [31:0]    PL_LANE8_EQ_CONTROL=32'h3400;
+    localparam  [31:0]    PL_LANE9_EQ_CONTROL=32'h3400;
+    localparam  [31:0]    PL_LANE10_EQ_CONTROL=32'h3400;
+    localparam  [31:0]    PL_LANE11_EQ_CONTROL=32'h3400;
+    localparam  [31:0]    PL_LANE12_EQ_CONTROL=32'h3400;
+    localparam  [31:0]    PL_LANE13_EQ_CONTROL=32'h3400;
+    localparam  [31:0]    PL_LANE14_EQ_CONTROL=32'h3400;
+    localparam  [31:0]    PL_LANE15_EQ_CONTROL=32'h3400;
+    localparam  [1:0]     PL_EQ_BYPASS_PHASE23=2'b01;
+    localparam  [4:0]     PL_EQ_ADAPT_ITER_COUNT=5'h2;
+    localparam  [1:0]     PL_EQ_ADAPT_REJECT_RETRY_COUNT=2'h1;
+    localparam            PL_EQ_SHORT_ADAPT_PHASE="FALSE";
+    localparam  [1:0]     PL_EQ_ADAPT_DISABLE_COEFF_CHECK=2'b0;
+    localparam  [1:0]     PL_EQ_ADAPT_DISABLE_PRESET_CHECK=2'b0;
+    localparam  [7:0]     PL_EQ_DEFAULT_TX_PRESET=8'h44;
+    localparam  [5:0]     PL_EQ_DEFAULT_RX_PRESET_HINT=6'h33;
+    localparam  [1:0]     PL_EQ_RX_ADAPT_EQ_PHASE0=2'b00;
+    localparam  [1:0]     PL_EQ_RX_ADAPT_EQ_PHASE1=2'b00;
+    localparam            PL_EQ_DISABLE_MISMATCH_CHECK ="TRUE";
+    localparam  [1:0]     PL_RX_L0S_EXIT_TO_RECOVERY=2'b00;
+    localparam            PL_EQ_TX_8G_EQ_TS2_ENABLE="FALSE";
+    localparam            PL_DISABLE_AUTO_EQ_SPEED_CHANGE_TO_GEN4="FALSE";
+    localparam            PL_DISABLE_AUTO_EQ_SPEED_CHANGE_TO_GEN3="FALSE";
+    localparam            PL_DISABLE_AUTO_SPEED_CHANGE_TO_GEN2="FALSE";
+    localparam            PL_DESKEW_ON_SKIP_IN_GEN12="FALSE";
+    localparam            PL_INFER_EI_DISABLE_REC_RC="FALSE";
+    localparam            PL_INFER_EI_DISABLE_REC_SPD="FALSE";
+    localparam            PL_INFER_EI_DISABLE_LPBK_ACTIVE="TRUE";
+    localparam  [3:0]     PL_RX_ADAPT_TIMER_RRL_GEN3=4'h0;
+    localparam  [1:0]     PL_RX_ADAPT_TIMER_RRL_CLOBBER_TX_TS=2'b00;
+    localparam  [3:0]     PL_RX_ADAPT_TIMER_RRL_GEN4=4'h0;
+    localparam  [3:0]     PL_RX_ADAPT_TIMER_CLWS_GEN3=4'h0;
+    localparam  [1:0]     PL_RX_ADAPT_TIMER_CLWS_CLOBBER_TX_TS=2'b00;
+    localparam  [3:0]     PL_RX_ADAPT_TIMER_CLWS_GEN4=4'h0;
+    localparam            PL_DISABLE_LANE_REVERSAL="FALSE";
+    localparam            PL_CFG_STATE_ROBUSTNESS_ENABLE="FALSE";
+    localparam            PL_REDO_EQ_SOURCE_SELECT="TRUE";
+    localparam            PL_EXIT_LOOPBACK_ON_EI_ENTRY="TRUE";
+    localparam            PL_QUIESCE_GUARANTEE_DISABLE="FALSE";
+    localparam            PL_SRIS_ENABLE="FALSE";
+    localparam  [6:0]     PL_SRIS_SKPOS_GEN_SPD_VEC=7'h0;
+    localparam  [6:0]     PL_SRIS_SKPOS_REC_SPD_VEC=7'h0;
+    localparam            LL_ACK_TIMEOUT_EN="FALSE";
+    localparam  [8:0]     LL_ACK_TIMEOUT=9'h0;
+    localparam  integer   LL_ACK_TIMEOUT_FUNC=0;
+    localparam            LL_REPLAY_TIMEOUT_EN="FALSE";
+    localparam  [8:0]     LL_REPLAY_TIMEOUT=9'h0;
+    localparam  integer   LL_REPLAY_TIMEOUT_FUNC=0;
+    localparam            LL_REPLAY_TO_RAM_PIPELINE="FALSE";
+    localparam            LL_REPLAY_FROM_RAM_PIPELINE="FALSE";
+    localparam            LL_DISABLE_SCHED_TX_NAK="FALSE";
+    localparam  [15:0]    LL_USER_SPARE=16'h18;
+    localparam            IS_SWITCH_PORT="FALSE";
+    localparam            CFG_BYPASS_MODE_ENABLE="FALSE";
+    localparam  [1:0]     TL_PF_ENABLE_REG=2'h0;
+    localparam  [11:0]    TL_CREDITS_CD=12'h1C0;
+    localparam  [7:0]     TL_CREDITS_CH=8'h20;
+    localparam  [1:0]     TL_COMPLETION_RAM_NUM_TLPS=2'b00;
+    localparam  [11:0]    TL_CREDITS_NPD=12'h4;
+    localparam  [7:0]     TL_CREDITS_NPH=8'h20;
+    localparam  [11:0]    TL_CREDITS_PD=12'he0;
+    localparam  [7:0]     TL_CREDITS_PH=8'h20;
+    localparam            TL_RX_COMPLETION_TO_RAM_WRITE_PIPELINE="FALSE";
+    localparam            TL_RX_COMPLETION_TO_RAM_READ_PIPELINE="FALSE";
+    localparam            TL_RX_COMPLETION_FROM_RAM_READ_PIPELINE="FALSE";
+    localparam            TL_POSTED_RAM_SIZE=1'b1;
+    localparam            TL_RX_POSTED_TO_RAM_WRITE_PIPELINE="FALSE";
+    localparam            TL_RX_POSTED_TO_RAM_READ_PIPELINE="FALSE";
+    localparam            TL_RX_POSTED_FROM_RAM_READ_PIPELINE="FALSE";
+    localparam            TL_TX_MUX_STRICT_PRIORITY="TRUE";
+    localparam            TL_TX_TLP_STRADDLE_ENABLE="FALSE";
+    localparam            TL_TX_TLP_TERMINATE_PARITY="FALSE";
+    localparam  [4:0]     TL_FC_UPDATE_MIN_INTERVAL_TLP_COUNT=5'h8;
+    localparam  [4:0]     TL_FC_UPDATE_MIN_INTERVAL_TIME=5'h2;
+    localparam  [15:0]    TL_USER_SPARE=16'h0;
+    localparam  [23:0]    PF0_CLASS_CODE=24'h000000;
+    localparam  [23:0]    PF1_CLASS_CODE=24'h000000;
+    localparam  [23:0]    PF2_CLASS_CODE=24'h000000;
+    localparam  [23:0]    PF3_CLASS_CODE=24'h000000;
+    localparam  [2:0]     PF0_INTERRUPT_PIN=3'h1;
+    localparam  [2:0]     PF1_INTERRUPT_PIN=3'h1;
+    localparam  [2:0]     PF2_INTERRUPT_PIN=3'h1;
+    localparam  [2:0]     PF3_INTERRUPT_PIN=3'h1;
+    localparam  [7:0]     PF0_CAPABILITY_POINTER=8'h80;
+    localparam  [7:0]     PF1_CAPABILITY_POINTER=8'h80;
+    localparam  [7:0]     PF2_CAPABILITY_POINTER=8'h80;
+    localparam  [7:0]     PF3_CAPABILITY_POINTER=8'h80;
+    localparam  [7:0]     VF0_CAPABILITY_POINTER=8'h80;
+    localparam            LEGACY_CFG_EXTEND_INTERFACE_ENABLE="FALSE";
+    localparam            EXTENDED_CFG_EXTEND_INTERFACE_ENABLE="FALSE";
+    localparam            TL2CFG_IF_PARITY_CHK="FALSE";
+    localparam            HEADER_TYPE_OVERRIDE="FALSE";
+    localparam  [2:0]     PF0_BAR0_CONTROL=3'b100;
+    localparam  [2:0]     PF1_BAR0_CONTROL=3'b100;
+    localparam  [2:0]     PF2_BAR0_CONTROL=3'b100;
+    localparam  [2:0]     PF3_BAR0_CONTROL=3'b100;
+    localparam  [5:0]     PF0_BAR0_APERTURE_SIZE=6'b000100;
+    localparam  [5:0]     PF1_BAR0_APERTURE_SIZE=6'b000011;
+    localparam  [5:0]     PF2_BAR0_APERTURE_SIZE=6'b000011;
+    localparam  [5:0]     PF3_BAR0_APERTURE_SIZE=6'b000011;
+    localparam  [2:0]     PF0_BAR1_CONTROL=3'b0;
+    localparam  [2:0]     PF1_BAR1_CONTROL=3'b0;
+    localparam  [2:0]     PF2_BAR1_CONTROL=3'b0;
+    localparam  [2:0]     PF3_BAR1_CONTROL=3'b0;
+    localparam  [4:0]     PF0_BAR1_APERTURE_SIZE=5'b0;
+    localparam  [4:0]     PF1_BAR1_APERTURE_SIZE=5'b0;
+    localparam  [4:0]     PF2_BAR1_APERTURE_SIZE=5'b0;
+    localparam  [4:0]     PF3_BAR1_APERTURE_SIZE=5'b0;
+    localparam  [2:0]     PF0_BAR2_CONTROL=3'b100;
+    localparam  [2:0]     PF1_BAR2_CONTROL=3'b100;
+    localparam  [2:0]     PF2_BAR2_CONTROL=3'b100;
+    localparam  [2:0]     PF3_BAR2_CONTROL=3'b100;
+    localparam  [4:0]     PF0_BAR2_APERTURE_SIZE=6'b00011;
+    localparam  [4:0]     PF1_BAR2_APERTURE_SIZE=6'b00011;
+    localparam  [4:0]     PF2_BAR2_APERTURE_SIZE=6'b00011;
+    localparam  [4:0]     PF3_BAR2_APERTURE_SIZE=6'b00011;
+    localparam  [2:0]     PF0_BAR3_CONTROL=3'b0;
+    localparam  [2:0]     PF1_BAR3_CONTROL=3'b0;
+    localparam  [2:0]     PF2_BAR3_CONTROL=3'b0;
+    localparam  [2:0]     PF3_BAR3_CONTROL=3'b0;
+    localparam  [4:0]     PF0_BAR3_APERTURE_SIZE=5'b00011;
+    localparam  [4:0]     PF1_BAR3_APERTURE_SIZE=5'b00011;
+    localparam  [4:0]     PF2_BAR3_APERTURE_SIZE=5'b00011;
+    localparam  [4:0]     PF3_BAR3_APERTURE_SIZE=5'b00011;
+    localparam  [2:0]     PF0_BAR4_CONTROL=3'b100;
+    localparam  [2:0]     PF1_BAR4_CONTROL=3'b100;
+    localparam  [2:0]     PF2_BAR4_CONTROL=3'b100;
+    localparam  [2:0]     PF3_BAR4_CONTROL=3'b100;
+    localparam  [4:0]     PF0_BAR4_APERTURE_SIZE=6'b00011;
+    localparam  [4:0]     PF1_BAR4_APERTURE_SIZE=6'b00011;
+    localparam  [4:0]     PF2_BAR4_APERTURE_SIZE=6'b00011;
+    localparam  [4:0]     PF3_BAR4_APERTURE_SIZE=6'b00011;
+    localparam  [2:0]     PF0_BAR5_CONTROL=3'b0;
+    localparam  [2:0]     PF1_BAR5_CONTROL=3'b0;
+    localparam  [2:0]     PF2_BAR5_CONTROL=3'b0;
+    localparam  [2:0]     PF3_BAR5_CONTROL=3'b0;
+    localparam  [4:0]     PF0_BAR5_APERTURE_SIZE=5'b00011;
+    localparam  [4:0]     PF1_BAR5_APERTURE_SIZE=5'b00011;
+    localparam  [4:0]     PF2_BAR5_APERTURE_SIZE=5'b00011;
+    localparam  [4:0]     PF3_BAR5_APERTURE_SIZE=5'b00011;
+    localparam            PF0_EXPANSION_ROM_ENABLE="FALSE";
+    localparam            PF1_EXPANSION_ROM_ENABLE="FALSE";
+    localparam            PF2_EXPANSION_ROM_ENABLE="FALSE";
+    localparam            PF3_EXPANSION_ROM_ENABLE="FALSE";
+    localparam  [4:0]     PF0_EXPANSION_ROM_APERTURE_SIZE=5'b00011;
+    localparam  [4:0]     PF1_EXPANSION_ROM_APERTURE_SIZE=5'b00011;
+    localparam  [4:0]     PF2_EXPANSION_ROM_APERTURE_SIZE=5'b00011;
+    localparam  [4:0]     PF3_EXPANSION_ROM_APERTURE_SIZE=5'b00011;
+    localparam  [7:0]     PF0_PCIE_CAP_NEXTPTR=8'h0;
+    localparam  [7:0]     PF1_PCIE_CAP_NEXTPTR=8'h0;
+    localparam  [7:0]     PF2_PCIE_CAP_NEXTPTR=8'h0;
+    localparam  [7:0]     PF3_PCIE_CAP_NEXTPTR=8'h0;
+    localparam  [7:0]     VFG0_PCIE_CAP_NEXTPTR=8'h0;
+    localparam  [7:0]     VFG1_PCIE_CAP_NEXTPTR=8'h0;
+    localparam  [7:0]     VFG2_PCIE_CAP_NEXTPTR=8'h0;
+    localparam  [7:0]     VFG3_PCIE_CAP_NEXTPTR=8'h0;
+    localparam  [2:0]     PF0_DEV_CAP_MAX_PAYLOAD_SIZE=3'b011;
+    localparam  [2:0]     PF1_DEV_CAP_MAX_PAYLOAD_SIZE=3'b011;
+    localparam  [2:0]     PF2_DEV_CAP_MAX_PAYLOAD_SIZE=3'b011;
+    localparam  [2:0]     PF3_DEV_CAP_MAX_PAYLOAD_SIZE=3'b011;
+    localparam            PF0_DEV_CAP_EXT_TAG_SUPPORTED="TRUE";
+    localparam  integer   PF0_DEV_CAP_ENDPOINT_L0S_LATENCY=0;
+    localparam  integer   PF0_DEV_CAP_ENDPOINT_L1_LATENCY=0;
+    localparam            PF0_DEV_CAP_FUNCTION_LEVEL_RESET_CAPABLE="TRUE";
+    localparam  integer   PF0_LINK_CAP_ASPM_SUPPORT=0;
+    localparam  [0:0]     PF0_LINK_CONTROL_RCB=1'b0;
+    localparam            PF0_LINK_STATUS_SLOT_CLOCK_CONFIG="TRUE";
+    localparam  integer   PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN1=7;
+    localparam  integer   PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN2=7;
+    localparam  integer   PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN3=7;
+    localparam  integer   PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN4=7;
+    localparam  integer   PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN1=7;
+    localparam  integer   PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN2=7;
+    localparam  integer   PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN3=7;
+    localparam  integer   PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN4=7;
+    localparam  integer   PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN1=7;
+    localparam  integer   PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN2=7;
+    localparam  integer   PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN3=7;
+    localparam  integer   PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN4=7;
+    localparam  integer   PF0_LINK_CAP_L1_EXIT_LATENCY_GEN1=7;
+    localparam  integer   PF0_LINK_CAP_L1_EXIT_LATENCY_GEN2=7;
+    localparam  integer   PF0_LINK_CAP_L1_EXIT_LATENCY_GEN3=7;
+    localparam  integer   PF0_LINK_CAP_L1_EXIT_LATENCY_GEN4=7;
+    localparam            PF0_DEV_CAP2_CPL_TIMEOUT_DISABLE="TRUE";
+    localparam            PF0_DEV_CAP2_32B_ATOMIC_COMPLETER_SUPPORT="TRUE";
+    localparam            PF0_DEV_CAP2_64B_ATOMIC_COMPLETER_SUPPORT="TRUE";
+    localparam            PF0_DEV_CAP2_128B_CAS_ATOMIC_COMPLETER_SUPPORT="TRUE";
+    localparam            PF0_DEV_CAP2_LTR_SUPPORT="FALSE";
+    localparam            PF0_DEV_CAP2_TPH_COMPLETER_SUPPORT="FALSE";
+    localparam  [1:0]     PF0_DEV_CAP2_OBFF_SUPPORT=2'b00;
+    localparam            PF0_DEV_CAP2_ARI_FORWARD_ENABLE="FALSE";
+    localparam  [7:0]     PF0_MSI_CAP_NEXTPTR=8'h0;
+    localparam  [7:0]     PF1_MSI_CAP_NEXTPTR=8'h0;
+    localparam  [7:0]     PF2_MSI_CAP_NEXTPTR=8'h0;
+    localparam  [7:0]     PF3_MSI_CAP_NEXTPTR=8'h0;
+    localparam            PF0_MSI_CAP_PERVECMASKCAP="FALSE";
+    localparam            PF1_MSI_CAP_PERVECMASKCAP="FALSE";
+    localparam            PF2_MSI_CAP_PERVECMASKCAP="FALSE";
+    localparam            PF3_MSI_CAP_PERVECMASKCAP="FALSE";
+    localparam  integer   PF0_MSI_CAP_MULTIMSGCAP=0;
+    localparam  integer   PF1_MSI_CAP_MULTIMSGCAP=0;
+    localparam  integer   PF2_MSI_CAP_MULTIMSGCAP=0;
+    localparam  integer   PF3_MSI_CAP_MULTIMSGCAP=0;
+    localparam  [7:0]     PF0_MSIX_CAP_NEXTPTR=8'h0;
+    localparam  [7:0]     PF1_MSIX_CAP_NEXTPTR=8'h0;
+    localparam  [7:0]     PF2_MSIX_CAP_NEXTPTR=8'h0;
+    localparam  [7:0]     PF3_MSIX_CAP_NEXTPTR=8'h0;
+    localparam  [7:0]     VFG0_MSIX_CAP_NEXTPTR=8'h0;
+    localparam  [7:0]     VFG1_MSIX_CAP_NEXTPTR=8'h0;
+    localparam  [7:0]     VFG2_MSIX_CAP_NEXTPTR=8'h0;
+    localparam  [7:0]     VFG3_MSIX_CAP_NEXTPTR=8'h0;
+    localparam  integer   PF0_MSIX_CAP_PBA_BIR=0;
+    localparam  integer   PF1_MSIX_CAP_PBA_BIR=0;
+    localparam  integer   PF2_MSIX_CAP_PBA_BIR=0;
+    localparam  integer   PF3_MSIX_CAP_PBA_BIR=0;
+    localparam  integer   VFG0_MSIX_CAP_PBA_BIR=0;
+    localparam  integer   VFG1_MSIX_CAP_PBA_BIR=0;
+    localparam  integer   VFG2_MSIX_CAP_PBA_BIR=0;
+    localparam  integer   VFG3_MSIX_CAP_PBA_BIR=0;
+    localparam  [28:0]    PF0_MSIX_CAP_PBA_OFFSET=29'h50;
+    localparam  [28:0]    PF1_MSIX_CAP_PBA_OFFSET=29'h50;
+    localparam  [28:0]    PF2_MSIX_CAP_PBA_OFFSET=29'h50;
+    localparam  [28:0]    PF3_MSIX_CAP_PBA_OFFSET=29'h50;
+    localparam  [28:0]    VFG0_MSIX_CAP_PBA_OFFSET=29'h50;
+    localparam  [28:0]    VFG1_MSIX_CAP_PBA_OFFSET=29'h50;
+    localparam  [28:0]    VFG2_MSIX_CAP_PBA_OFFSET=29'h50;
+    localparam  [28:0]    VFG3_MSIX_CAP_PBA_OFFSET=29'h50;
+    localparam  integer   PF0_MSIX_CAP_TABLE_BIR=0;
+    localparam  integer   PF1_MSIX_CAP_TABLE_BIR=0;
+    localparam  integer   PF2_MSIX_CAP_TABLE_BIR=0;
+    localparam  integer   PF3_MSIX_CAP_TABLE_BIR=0;
+    localparam  integer   VFG0_MSIX_CAP_TABLE_BIR=0;
+    localparam  integer   VFG1_MSIX_CAP_TABLE_BIR=0;
+    localparam  integer   VFG2_MSIX_CAP_TABLE_BIR=0;
+    localparam  integer   VFG3_MSIX_CAP_TABLE_BIR=0;
+    localparam  [28:0]    PF0_MSIX_CAP_TABLE_OFFSET=29'h40;
+    localparam  [28:0]    PF1_MSIX_CAP_TABLE_OFFSET=29'h40;
+    localparam  [28:0]    PF2_MSIX_CAP_TABLE_OFFSET=29'h40;
+    localparam  [28:0]    PF3_MSIX_CAP_TABLE_OFFSET=29'h40;
+    localparam  [28:0]    VFG0_MSIX_CAP_TABLE_OFFSET=29'h40;
+    localparam  [28:0]    VFG1_MSIX_CAP_TABLE_OFFSET=29'h40;
+    localparam  [28:0]    VFG2_MSIX_CAP_TABLE_OFFSET=29'h40;
+    localparam  [28:0]    VFG3_MSIX_CAP_TABLE_OFFSET=29'h40;
+    localparam  [10:0]    PF0_MSIX_CAP_TABLE_SIZE=11'h0;
+    localparam  [10:0]    PF1_MSIX_CAP_TABLE_SIZE=11'h0;
+    localparam  [10:0]    PF2_MSIX_CAP_TABLE_SIZE=11'h0;
+    localparam  [10:0]    PF3_MSIX_CAP_TABLE_SIZE=11'h0;
+    localparam  [10:0]    VFG0_MSIX_CAP_TABLE_SIZE=11'h0;
+    localparam  [10:0]    VFG1_MSIX_CAP_TABLE_SIZE=11'h0;
+    localparam  [10:0]    VFG2_MSIX_CAP_TABLE_SIZE=11'h0;
+    localparam  [10:0]    VFG3_MSIX_CAP_TABLE_SIZE=11'h0;
+    localparam  [5:0]     PF0_MSIX_VECTOR_COUNT=6'h4;
+    localparam  [7:0]     PF0_PM_CAP_ID=8'h1;
+    localparam  [7:0]     PF0_PM_CAP_NEXTPTR=8'h0;
+    localparam  [7:0]     PF1_PM_CAP_NEXTPTR=8'h0;
+    localparam  [7:0]     PF2_PM_CAP_NEXTPTR=8'h0;
+    localparam  [7:0]     PF3_PM_CAP_NEXTPTR=8'h0;
+    localparam            PF0_PM_CAP_PMESUPPORT_D3HOT="TRUE";
+    localparam            PF0_PM_CAP_PMESUPPORT_D1="TRUE";
+    localparam            PF0_PM_CAP_PMESUPPORT_D0="TRUE";
+    localparam            PF0_PM_CAP_SUPP_D1_STATE="TRUE";
+    localparam  [2:0]     PF0_PM_CAP_VER_ID=3'h3;
+    localparam            PF0_PM_CSR_NOSOFTRESET="TRUE";
+    localparam            PM_ENABLE_L23_ENTRY="FALSE";
+    localparam  [7:0]     DNSTREAM_LINK_NUM=8'h0;
+    localparam            AUTO_FLR_RESPONSE="FALSE";
+    localparam  [11:0]    PF0_DSN_CAP_NEXTPTR=12'h10C;
+    localparam  [11:0]    PF1_DSN_CAP_NEXTPTR=12'h10C;
+    localparam  [11:0]    PF2_DSN_CAP_NEXTPTR=12'h10C;
+    localparam  [11:0]    PF3_DSN_CAP_NEXTPTR=12'h10C;
+    localparam            DSN_CAP_ENABLE="FALSE";
+    localparam  [3:0]     PF0_VC_CAP_VER=4'h1;
+    localparam  [11:0]    PF0_VC_CAP_NEXTPTR=12'h0;
+    localparam            PF0_VC_CAP_ENABLE="TRUE";
+    localparam  [11:0]    PF0_SECONDARY_PCIE_CAP_NEXTPTR=12'h0;
+    localparam  [11:0]    PF0_AER_CAP_NEXTPTR=12'h0;
+    localparam  [11:0]    PF1_AER_CAP_NEXTPTR=12'h0;
+    localparam  [11:0]    PF2_AER_CAP_NEXTPTR=12'h0;
+    localparam  [11:0]    PF3_AER_CAP_NEXTPTR=12'h0;
+    localparam            PF0_AER_CAP_ECRC_GEN_AND_CHECK_CAPABLE="FALSE";
+    localparam            ARI_CAP_ENABLE="TRUE";
+    localparam  [11:0]    PF0_ARI_CAP_NEXTPTR=12'h0;
+    localparam  [11:0]    PF1_ARI_CAP_NEXTPTR=12'h0;
+    localparam  [11:0]    PF2_ARI_CAP_NEXTPTR=12'h0;
+    localparam  [11:0]    PF3_ARI_CAP_NEXTPTR=12'h0;
+    localparam  [11:0]    VFG0_ARI_CAP_NEXTPTR=12'h0;
+    localparam  [11:0]    VFG1_ARI_CAP_NEXTPTR=12'h0;
+    localparam  [11:0]    VFG2_ARI_CAP_NEXTPTR=12'h0;
+    localparam  [11:0]    VFG3_ARI_CAP_NEXTPTR=12'h0;
+    localparam  [3:0]     PF0_ARI_CAP_VER=4'h1;
+    localparam  [7:0]     PF0_ARI_CAP_NEXT_FUNC=8'h0;
+    localparam  [7:0]     PF1_ARI_CAP_NEXT_FUNC=8'h0;
+    localparam  [7:0]     PF2_ARI_CAP_NEXT_FUNC=8'h0;
+    localparam  [7:0]     PF3_ARI_CAP_NEXT_FUNC=8'h0;
+    localparam  [11:0]    PF0_LTR_CAP_NEXTPTR=12'h0;
+    localparam  [3:0]     PF0_LTR_CAP_VER=4'h1;
+    localparam  [9:0]     PF0_LTR_CAP_MAX_SNOOP_LAT=10'h0;
+    localparam  [9:0]     PF0_LTR_CAP_MAX_NOSNOOP_LAT=10'h0;
+    localparam            LTR_TX_MESSAGE_ON_LTR_ENABLE="FALSE";
+    localparam            LTR_TX_MESSAGE_ON_FUNC_POWER_STATE_CHANGE="FALSE";
+    localparam  [9:0]     LTR_TX_MESSAGE_MINIMUM_INTERVAL=10'h250;
+    localparam  [3:0]     SRIOV_CAP_ENABLE=4'h0;
+    localparam  [11:0]    PF0_SRIOV_CAP_NEXTPTR=12'h0;
+    localparam  [11:0]    PF1_SRIOV_CAP_NEXTPTR=12'h0;
+    localparam  [11:0]    PF2_SRIOV_CAP_NEXTPTR=12'h0;
+    localparam  [11:0]    PF3_SRIOV_CAP_NEXTPTR=12'h0;
+    localparam  [3:0]     PF0_SRIOV_CAP_VER=4'h1;
+    localparam  [3:0]     PF1_SRIOV_CAP_VER=4'h1;
+    localparam  [3:0]     PF2_SRIOV_CAP_VER=4'h1;
+    localparam  [3:0]     PF3_SRIOV_CAP_VER=4'h1;
+    localparam            PF0_SRIOV_ARI_CAPBL_HIER_PRESERVED="FALSE";
+    localparam            PF1_SRIOV_ARI_CAPBL_HIER_PRESERVED="FALSE";
+    localparam            PF2_SRIOV_ARI_CAPBL_HIER_PRESERVED="FALSE";
+    localparam            PF3_SRIOV_ARI_CAPBL_HIER_PRESERVED="FALSE";
+    localparam  [15:0]    PF0_SRIOV_CAP_INITIAL_VF=16'h0;
+    localparam  [15:0]    PF1_SRIOV_CAP_INITIAL_VF=16'h0;
+    localparam  [15:0]    PF2_SRIOV_CAP_INITIAL_VF=16'h0;
+    localparam  [15:0]    PF3_SRIOV_CAP_INITIAL_VF=16'h0;
+    localparam  [15:0]    PF0_SRIOV_CAP_TOTAL_VF=16'h0;
+    localparam  [15:0]    PF1_SRIOV_CAP_TOTAL_VF=16'h0;
+    localparam  [15:0]    PF2_SRIOV_CAP_TOTAL_VF=16'h0;
+    localparam  [15:0]    PF3_SRIOV_CAP_TOTAL_VF=16'h0;
+    localparam  [15:0]    PF0_SRIOV_FUNC_DEP_LINK=16'h0;
+    localparam  [15:0]    PF1_SRIOV_FUNC_DEP_LINK=16'h0;
+    localparam  [15:0]    PF2_SRIOV_FUNC_DEP_LINK=16'h0;
+    localparam  [15:0]    PF3_SRIOV_FUNC_DEP_LINK=16'h0;
+    localparam  [15:0]    PF0_SRIOV_FIRST_VF_OFFSET=16'h0;
+    localparam  [15:0]    PF1_SRIOV_FIRST_VF_OFFSET=16'h0;
+    localparam  [15:0]    PF2_SRIOV_FIRST_VF_OFFSET=16'h0;
+    localparam  [15:0]    PF3_SRIOV_FIRST_VF_OFFSET=16'h0;
+    localparam  [15:0]    PF0_SRIOV_VF_DEVICE_ID=16'h0;
+    localparam  [15:0]    PF1_SRIOV_VF_DEVICE_ID=16'h0;
+    localparam  [15:0]    PF2_SRIOV_VF_DEVICE_ID=16'h0;
+    localparam  [15:0]    PF3_SRIOV_VF_DEVICE_ID=16'h0;
+    localparam  [31:0]    PF0_SRIOV_SUPPORTED_PAGE_SIZE=32'h0;
+    localparam  [31:0]    PF1_SRIOV_SUPPORTED_PAGE_SIZE=32'h0;
+    localparam  [31:0]    PF2_SRIOV_SUPPORTED_PAGE_SIZE=32'h0;
+    localparam  [31:0]    PF3_SRIOV_SUPPORTED_PAGE_SIZE=32'h0;
+    localparam  [2:0]     PF0_SRIOV_BAR0_CONTROL=3'b100;
+    localparam  [2:0]     PF1_SRIOV_BAR0_CONTROL=3'b100;
+    localparam  [2:0]     PF2_SRIOV_BAR0_CONTROL=3'b100;
+    localparam  [2:0]     PF3_SRIOV_BAR0_CONTROL=3'b100;
+    localparam  [4:0]     PF0_SRIOV_BAR0_APERTURE_SIZE=6'b000011;
+    localparam  [4:0]     PF1_SRIOV_BAR0_APERTURE_SIZE=6'b000011;
+    localparam  [4:0]     PF2_SRIOV_BAR0_APERTURE_SIZE=6'b000011;
+    localparam  [4:0]     PF3_SRIOV_BAR0_APERTURE_SIZE=6'b000011;
+    localparam  [2:0]     PF0_SRIOV_BAR1_CONTROL=3'b0;
+    localparam  [2:0]     PF1_SRIOV_BAR1_CONTROL=3'b0;
+    localparam  [2:0]     PF2_SRIOV_BAR1_CONTROL=3'b0;
+    localparam  [2:0]     PF3_SRIOV_BAR1_CONTROL=3'b0;
+    localparam  [4:0]     PF0_SRIOV_BAR1_APERTURE_SIZE=5'b0;
+    localparam  [4:0]     PF1_SRIOV_BAR1_APERTURE_SIZE=5'b0;
+    localparam  [4:0]     PF2_SRIOV_BAR1_APERTURE_SIZE=5'b0;
+    localparam  [4:0]     PF3_SRIOV_BAR1_APERTURE_SIZE=5'b0;
+    localparam  [2:0]     PF0_SRIOV_BAR2_CONTROL=3'b100;
+    localparam  [2:0]     PF1_SRIOV_BAR2_CONTROL=3'b100;
+    localparam  [2:0]     PF2_SRIOV_BAR2_CONTROL=3'b100;
+    localparam  [2:0]     PF3_SRIOV_BAR2_CONTROL=3'b100;
+    localparam  [4:0]     PF0_SRIOV_BAR2_APERTURE_SIZE=6'b000011;
+    localparam  [4:0]     PF1_SRIOV_BAR2_APERTURE_SIZE=6'b000011;
+    localparam  [4:0]     PF2_SRIOV_BAR2_APERTURE_SIZE=6'b000011;
+    localparam  [4:0]     PF3_SRIOV_BAR2_APERTURE_SIZE=6'b000011;
+    localparam  [2:0]     PF0_SRIOV_BAR3_CONTROL=3'b0;
+    localparam  [2:0]     PF1_SRIOV_BAR3_CONTROL=3'b0;
+    localparam  [2:0]     PF2_SRIOV_BAR3_CONTROL=3'b0;
+    localparam  [2:0]     PF3_SRIOV_BAR3_CONTROL=3'b0;
+    localparam  [4:0]     PF0_SRIOV_BAR3_APERTURE_SIZE=5'b00011;
+    localparam  [4:0]     PF1_SRIOV_BAR3_APERTURE_SIZE=5'b00011;
+    localparam  [4:0]     PF2_SRIOV_BAR3_APERTURE_SIZE=5'b00011;
+    localparam  [4:0]     PF3_SRIOV_BAR3_APERTURE_SIZE=5'b00011;
+    localparam  [2:0]     PF0_SRIOV_BAR4_CONTROL=3'b100;
+    localparam  [2:0]     PF1_SRIOV_BAR4_CONTROL=3'b100;
+    localparam  [2:0]     PF2_SRIOV_BAR4_CONTROL=3'b100;
+    localparam  [2:0]     PF3_SRIOV_BAR4_CONTROL=3'b100;
+    localparam  [4:0]     PF0_SRIOV_BAR4_APERTURE_SIZE=6'b000011;
+    localparam  [4:0]     PF1_SRIOV_BAR4_APERTURE_SIZE=6'b000011;
+    localparam  [4:0]     PF2_SRIOV_BAR4_APERTURE_SIZE=6'b000011;
+    localparam  [4:0]     PF3_SRIOV_BAR4_APERTURE_SIZE=6'b000011;
+    localparam  [2:0]     PF0_SRIOV_BAR5_CONTROL=3'b0;
+    localparam  [2:0]     PF1_SRIOV_BAR5_CONTROL=3'b0;
+    localparam  [2:0]     PF2_SRIOV_BAR5_CONTROL=3'b0;
+    localparam  [2:0]     PF3_SRIOV_BAR5_CONTROL=3'b0;
+    localparam  [4:0]     PF0_SRIOV_BAR5_APERTURE_SIZE=5'b00011;
+    localparam  [4:0]     PF1_SRIOV_BAR5_APERTURE_SIZE=5'b00011;
+    localparam  [4:0]     PF2_SRIOV_BAR5_APERTURE_SIZE=5'b00011;
+    localparam  [4:0]     PF3_SRIOV_BAR5_APERTURE_SIZE=5'b00011;
+    localparam  [11:0]    PF0_TPHR_CAP_NEXTPTR=12'h0;
+    localparam  [11:0]    PF1_TPHR_CAP_NEXTPTR=12'h0;
+    localparam  [11:0]    PF2_TPHR_CAP_NEXTPTR=12'h0;
+    localparam  [11:0]    PF3_TPHR_CAP_NEXTPTR=12'h0;
+    localparam  [11:0]    VFG0_TPHR_CAP_NEXTPTR=12'h0;
+    localparam  [11:0]    VFG1_TPHR_CAP_NEXTPTR=12'h0;
+    localparam  [11:0]    VFG2_TPHR_CAP_NEXTPTR=12'h0;
+    localparam  [11:0]    VFG3_TPHR_CAP_NEXTPTR=12'h0;
+    localparam  [3:0]     PF0_TPHR_CAP_VER=4'h1;
+    localparam            PF0_TPHR_CAP_INT_VEC_MODE="TRUE";
+    localparam            PF0_TPHR_CAP_DEV_SPECIFIC_MODE="TRUE";
+    localparam  [1:0]     PF0_TPHR_CAP_ST_TABLE_LOC=2'h0;
+    localparam  [10:0]    PF0_TPHR_CAP_ST_TABLE_SIZE=11'h0;
+    localparam  [2:0]     PF0_TPHR_CAP_ST_MODE_SEL=3'h0;
+    localparam  [2:0]     PF1_TPHR_CAP_ST_MODE_SEL=3'h0;
+    localparam  [2:0]     PF2_TPHR_CAP_ST_MODE_SEL=3'h0;
+    localparam  [2:0]     PF3_TPHR_CAP_ST_MODE_SEL=3'h0;
+    localparam  [2:0]     VFG0_TPHR_CAP_ST_MODE_SEL=3'h0;
+    localparam  [2:0]     VFG1_TPHR_CAP_ST_MODE_SEL=3'h0;
+    localparam  [2:0]     VFG2_TPHR_CAP_ST_MODE_SEL=3'h0;
+    localparam  [2:0]     VFG3_TPHR_CAP_ST_MODE_SEL=3'h0;
+    localparam            PF0_TPHR_CAP_ENABLE="FALSE";
+    localparam            TPH_TO_RAM_PIPELINE="FALSE";
+    localparam            TPH_FROM_RAM_PIPELINE="FALSE";
+    localparam            MCAP_ENABLE="FALSE";
+    localparam            MCAP_CONFIGURE_OVERRIDE="FALSE";
+    localparam  [11:0]    MCAP_CAP_NEXTPTR=12'h0;
+    localparam  [15:0]    MCAP_VSEC_ID=16'h0;
+    localparam  [3:0]     MCAP_VSEC_REV=4'h0;
+    localparam  [11:0]    MCAP_VSEC_LEN=12'h2C;
+    localparam  [31:0]    MCAP_FPGA_BITSTREAM_VERSION=32'h0;
+    localparam            MCAP_INTERRUPT_ON_MCAP_EOS="FALSE";
+    localparam            MCAP_INTERRUPT_ON_MCAP_ERROR="FALSE";
+    localparam            MCAP_INPUT_GATE_DESIGN_SWITCH="FALSE";
+    localparam            MCAP_EOS_DESIGN_SWITCH="FALSE";
+    localparam            MCAP_GATE_MEM_ENABLE_DESIGN_SWITCH="FALSE";
+    localparam            MCAP_GATE_IO_ENABLE_DESIGN_SWITCH="FALSE";
+    localparam  [31:0]    SIM_JTAG_IDCODE=32'h0;
+    localparam  [7:0]     DEBUG_AXIST_DISABLE_FEATURE_BIT=8'h0;
+    localparam            DEBUG_TL_DISABLE_RX_TLP_ORDER_CHECKS="FALSE";
+    localparam            DEBUG_TL_DISABLE_FC_TIMEOUT="FALSE";
+    localparam            DEBUG_PL_DISABLE_SCRAMBLING="FALSE";
+    localparam            DEBUG_PL_DISABLE_REC_ENTRY_ON_DYNAMIC_DSKEW_FAIL ="FALSE";
+    localparam            DEBUG_PL_DISABLE_REC_ENTRY_ON_RX_BUFFER_UNDER_OVER_FLOW ="FALSE";
+    localparam            DEBUG_PL_DISABLE_LES_UPDATE_ON_SKP_ERROR="FALSE";
+    localparam            DEBUG_PL_DISABLE_LES_UPDATE_ON_SKP_PARITY_ERROR="FALSE";
+    localparam            DEBUG_PL_DISABLE_LES_UPDATE_ON_DEFRAMER_ERROR="FALSE";
+    localparam            DEBUG_PL_SIM_RESET_LFSR="FALSE";
+    localparam  [15:0]    DEBUG_PL_SPARE=16'h0;
+    localparam  [15:0]    DEBUG_LL_SPARE=16'h0;
+    localparam  [15:0]    DEBUG_TL_SPARE=16'h0;
+    localparam  [15:0]    DEBUG_AXI4ST_SPARE=16'h0;
+    localparam  [15:0]    DEBUG_CFG_SPARE=16'h0;
+    localparam  [3:0]     DEBUG_CAR_SPARE=4'h0;
+    localparam            TEST_MODE_PIN_CHAR="FALSE";
+    localparam            SPARE_BIT0=1'b0;
+    localparam            SPARE_BIT1=1'b0;
+    localparam            SPARE_BIT2=1'b0;
+    localparam            SPARE_BIT3="FALSE";
+    localparam            SPARE_BIT4=1'b0;
+    localparam            SPARE_BIT5=1'b0;
+    localparam            SPARE_BIT6=1'b0;
+    localparam            SPARE_BIT7=1'b0;
+    localparam            SPARE_BIT8=1'b0;
+    localparam  [7:0]     SPARE_BYTE0=8'h0;
+    localparam  [7:0]     SPARE_BYTE1=8'h0;
+    localparam  [7:0]     SPARE_BYTE2=8'h0;
+    localparam  [7:0]     SPARE_BYTE3=8'h0;
+    localparam  [31:0]    SPARE_WORD0=32'h0;
+    localparam  [31:0]    SPARE_WORD1=32'h0;
+    localparam  [31:0]    SPARE_WORD2=32'h0;
+    localparam  [31:0]    SPARE_WORD3=32'h0;
+   localparam [7:0]     AXISTEN_IF_CCIX_RX_CREDIT_LIMIT	= 8'h08
+   ;localparam [7:0]     AXISTEN_IF_CCIX_TX_CREDIT_LIMIT	= 8'h08
+   ;localparam           AXISTEN_IF_CCIX_TX_REGISTERED_TREADY	= "FALSE"
+   ;localparam           CCIX_DIRECT_ATTACH_MODE	= "FALSE"
+   ;localparam           CCIX_ENABLE	= "TRUE"
+   ;localparam [15:0]    CCIX_VENDOR_ID	= 16'h2692
+   ;localparam [4:0]     PF0_ATS_CAP_INV_QUEUE_DEPTH	= 5'h00
+   ;localparam [11:0]    PF0_ATS_CAP_NEXTPTR	= 12'h000
+   ;localparam           PF0_ATS_CAP_ON	= "FALSE"
+   ;localparam [11:0]    PF0_PRI_CAP_NEXTPTR	= 12'h000
+   ;localparam           PF0_PRI_CAP_ON	= "FALSE"
+   ;localparam [31:0]    PF0_PRI_OST_PR_CAPACITY	= 32'h00000000
+   ;localparam [3:0]     PF0_VC_ARB_CAPABILITY	= 4'h0
+   ;localparam [7:0]     PF0_VC_ARB_TBL_OFFSET	= 8'h00
+   ;localparam           PF0_VC_EXTENDED_COUNT	= "FALSE"
+   ;localparam           PF0_VC_LOW_PRIORITY_EXTENDED_COUNT	= "FALSE"
+   ;localparam [4:0]     PF1_ATS_CAP_INV_QUEUE_DEPTH	= 5'h00
+   ;localparam [11:0]    PF1_ATS_CAP_NEXTPTR	= 12'h000
+   ;localparam           PF1_ATS_CAP_ON	= "FALSE"
+   ;localparam [11:0]    PF1_PRI_CAP_NEXTPTR	= 12'h000
+   ;localparam           PF1_PRI_CAP_ON	= "FALSE"
+   ;localparam [31:0]    PF1_PRI_OST_PR_CAPACITY	= 32'h00000000
+   ;localparam [4:0]     PF2_ATS_CAP_INV_QUEUE_DEPTH	= 5'h00
+   ;localparam [11:0]    PF2_ATS_CAP_NEXTPTR	= 12'h000
+   ;localparam           PF2_ATS_CAP_ON	= "FALSE"
+   ;localparam [11:0]    PF2_PRI_CAP_NEXTPTR	= 12'h000
+   ;localparam           PF2_PRI_CAP_ON	= "FALSE"
+   ;localparam [31:0]    PF2_PRI_OST_PR_CAPACITY	= 32'h00000000
+   ;localparam [4:0]     PF3_ATS_CAP_INV_QUEUE_DEPTH	= 5'h00
+   ;localparam [11:0]    PF3_ATS_CAP_NEXTPTR	= 12'h000
+   ;localparam           PF3_ATS_CAP_ON	= "FALSE"
+   ;localparam [11:0]    PF3_PRI_CAP_NEXTPTR	= 12'h000
+   ;localparam           PF3_PRI_CAP_ON	= "FALSE"
+   ;localparam [31:0]    PF3_PRI_OST_PR_CAPACITY	= 32'h00000000
+   ;localparam           PL_CTRL_SKP_GEN_ENABLE	= "FALSE"
+   ;localparam           PL_CTRL_SKP_PARITY_AND_CRC_CHECK_DISABLE	= "TRUE"
+   ;localparam [15:0]    PL_USER_SPARE2	= 16'h0000
+   ;localparam [11:0]    TL_CREDITS_CD_VC1	= 12'h000
+   ;localparam [7:0]     TL_CREDITS_CH_VC1	= 8'h00
+   ;localparam [11:0]    TL_CREDITS_NPD_VC1	= 12'h000
+   ;localparam [7:0]     TL_CREDITS_NPH_VC1	= 8'h01
+   ;localparam [11:0]    TL_CREDITS_PD_VC1	= 12'h3e0
+   ;localparam [7:0]     TL_CREDITS_PH_VC1	= 8'h20
+   ;localparam [4:0]     TL_FC_UPDATE_MIN_INTERVAL_TIME_VC1	= 5'h02
+   ;localparam [4:0]     TL_FC_UPDATE_MIN_INTERVAL_TLP_COUNT_VC1	= 5'h08
+   ;localparam           TL_FEATURE_ENABLE_FC_SCALING	= "FALSE"
+   ;localparam [4:0]     VFG0_ATS_CAP_INV_QUEUE_DEPTH	= 5'h00
+   ;localparam [11:0]    VFG0_ATS_CAP_NEXTPTR	= 12'h000
+   ;localparam           VFG0_ATS_CAP_ON	= "FALSE"
+   ;localparam [4:0]     VFG1_ATS_CAP_INV_QUEUE_DEPTH	= 5'h00
+   ;localparam [11:0]    VFG1_ATS_CAP_NEXTPTR	= 12'h000
+   ;localparam           VFG1_ATS_CAP_ON	= "FALSE"
+   ;localparam [4:0]     VFG2_ATS_CAP_INV_QUEUE_DEPTH	= 5'h00
+   ;localparam [11:0]    VFG2_ATS_CAP_NEXTPTR	= 12'h000
+   ;localparam           VFG2_ATS_CAP_ON	= "FALSE"
+   ;localparam [4:0]     VFG3_ATS_CAP_INV_QUEUE_DEPTH	= 5'h00
+   ;localparam [11:0]    VFG3_ATS_CAP_NEXTPTR	= 12'h000
+   ;localparam           VFG3_ATS_CAP_ON	= "FALSE";
+
+xp4c_usp_smsw_model_core_top #(
+
+    .TCQ(TCQ)
+   ,.IMPL_TARGET(IMPL_TARGET)
+   ,.AXISTEN_IF_EXT_512_INTFC_RAM_STYLE(AXISTEN_IF_EXT_512_INTFC_RAM_STYLE)
+   ,.FPGA_FAMILY(FPGA_FAMILY)
+   ,.FPGA_XCVR(FPGA_XCVR)  
+   ,.PL_EQ_BYPASS_PHASE23(PL_EQ_BYPASS_PHASE23)
+   ,.AXISTEN_IF_EXT_512(AXISTEN_IF_EXT_512)
+   ,.PL_SIM_FAST_LINK_TRAINING(PL_SIM_FAST_LINK_TRAINING)
+   ,.PL_DEEMPH_SOURCE_SELECT(PL_DEEMPH_SOURCE_SELECT)
+   ,.PL_UPSTREAM_FACING(PL_UPSTREAM_FACING)
+   ,.PL_LINK_CAP_MAX_LINK_WIDTH(PL_LINK_CAP_MAX_LINK_WIDTH)
+   ,.PL_LINK_CAP_MAX_LINK_SPEED(PL_LINK_CAP_MAX_LINK_SPEED)
+   ,.PHY_REFCLK_FREQ(PHY_REFCLK_FREQ)
+   ,.CRM_CORE_CLK_FREQ_500(CRM_CORE_CLK_FREQ == 2 ? "TRUE" : "FALSE")
+   ,.CRM_USER_CLK_FREQ(CRM_USER_CLK_FREQ)
+   ,.CRM_MCAP_CLK_FREQ(CRM_MCAP_CLK_FREQ)
+   ,.AXISTEN_IF_WIDTH(AXISTEN_IF_WIDTH)
+   ,.AXI4_DATA_WIDTH(AXI4_DATA_WIDTH)
+   ,.AXI4_TKEEP_WIDTH(AXI4_TKEEP_WIDTH)
+   ,.AXI4_CQ_TUSER_WIDTH(AXI4_CQ_TUSER_WIDTH)
+   ,.AXI4_CC_TUSER_WIDTH(AXI4_CC_TUSER_WIDTH)
+   ,.AXI4_RQ_TUSER_WIDTH(AXI4_RQ_TUSER_WIDTH)
+   ,.AXI4_RC_TUSER_WIDTH(AXI4_RC_TUSER_WIDTH)
+   ,.AXI4_CQ_TREADY_WIDTH(AXI4_CQ_TREADY_WIDTH)
+   ,.AXI4_CC_TREADY_WIDTH(AXI4_CC_TREADY_WIDTH)
+   ,.AXI4_RQ_TREADY_WIDTH(AXI4_RQ_TREADY_WIDTH)
+   ,.AXI4_RC_TREADY_WIDTH(AXI4_RC_TREADY_WIDTH)
+
+   ,.AXISTEN_IF_EXT_512_CQ_STRADDLE(AXISTEN_IF_EXT_512_CQ_STRADDLE)
+   ,.AXISTEN_IF_EXT_512_CC_STRADDLE(AXISTEN_IF_EXT_512_CC_STRADDLE)
+   ,.AXISTEN_IF_EXT_512_RQ_STRADDLE(AXISTEN_IF_EXT_512_RQ_STRADDLE)
+   ,.AXISTEN_IF_EXT_512_RC_STRADDLE(AXISTEN_IF_EXT_512_RC_STRADDLE)
+   ,.AXISTEN_IF_CQ_ALIGNMENT_MODE(AXISTEN_IF_CQ_ALIGNMENT_MODE)
+   ,.AXISTEN_IF_CC_ALIGNMENT_MODE(AXISTEN_IF_CC_ALIGNMENT_MODE)
+   ,.AXISTEN_IF_RQ_ALIGNMENT_MODE(AXISTEN_IF_RQ_ALIGNMENT_MODE)
+   ,.AXISTEN_IF_RC_ALIGNMENT_MODE(AXISTEN_IF_RC_ALIGNMENT_MODE)
+   ,.AXISTEN_IF_RC_STRADDLE(AXISTEN_IF_RC_STRADDLE)
+   ,.AXISTEN_IF_ENABLE_RX_MSG_INTFC(AXISTEN_IF_ENABLE_RX_MSG_INTFC)
+   ,.AXISTEN_IF_ENABLE_MSG_ROUTE(AXISTEN_IF_ENABLE_MSG_ROUTE)
+   ,.AXISTEN_IF_RX_PARITY_EN(AXISTEN_IF_RX_PARITY_EN)
+   ,.AXISTEN_IF_TX_PARITY_EN(AXISTEN_IF_TX_PARITY_EN)
+   ,.AXISTEN_IF_ENABLE_CLIENT_TAG(AXISTEN_IF_ENABLE_CLIENT_TAG)
+   ,.AXISTEN_IF_ENABLE_256_TAGS(AXISTEN_IF_ENABLE_256_TAGS)
+   ,.AXISTEN_IF_COMPL_TIMEOUT_REG0(AXISTEN_IF_COMPL_TIMEOUT_REG0)
+   ,.AXISTEN_IF_COMPL_TIMEOUT_REG1(AXISTEN_IF_COMPL_TIMEOUT_REG1)
+   ,.AXISTEN_IF_LEGACY_MODE_ENABLE(AXISTEN_IF_LEGACY_MODE_ENABLE)
+   ,.AXISTEN_IF_ENABLE_MESSAGE_RID_CHECK(AXISTEN_IF_ENABLE_MESSAGE_RID_CHECK)
+   ,.AXISTEN_IF_MSIX_TO_RAM_PIPELINE(AXISTEN_IF_MSIX_TO_RAM_PIPELINE)
+   ,.AXISTEN_IF_MSIX_FROM_RAM_PIPELINE(AXISTEN_IF_MSIX_FROM_RAM_PIPELINE)
+   ,.AXISTEN_IF_MSIX_RX_PARITY_EN(AXISTEN_IF_MSIX_RX_PARITY_EN)
+   ,.AXISTEN_IF_ENABLE_INTERNAL_MSIX_TABLE(AXISTEN_IF_ENABLE_INTERNAL_MSIX_TABLE)
+   ,.AXISTEN_IF_SIM_SHORT_CPL_TIMEOUT(AXISTEN_IF_SIM_SHORT_CPL_TIMEOUT)
+   ,.AXISTEN_IF_CQ_EN_POISONED_MEM_WR(AXISTEN_IF_CQ_EN_POISONED_MEM_WR)
+   ,.AXISTEN_IF_RQ_CC_REGISTERED_TREADY(AXISTEN_IF_RQ_CC_REGISTERED_TREADY)
+   ,.PM_ASPML0S_TIMEOUT(PM_ASPML0S_TIMEOUT)
+   ,.PM_L1_REENTRY_DELAY(PM_L1_REENTRY_DELAY)
+   ,.PM_ASPML1_ENTRY_DELAY(PM_ASPML1_ENTRY_DELAY)
+   ,.PM_ENABLE_SLOT_POWER_CAPTURE(PM_ENABLE_SLOT_POWER_CAPTURE)
+   ,.PM_PME_SERVICE_TIMEOUT_DELAY(PM_PME_SERVICE_TIMEOUT_DELAY)
+   ,.PM_PME_TURNOFF_ACK_DELAY(PM_PME_TURNOFF_ACK_DELAY)
+   ,.PL_DISABLE_DC_BALANCE(PL_DISABLE_DC_BALANCE)
+   ,.PL_DISABLE_EI_INFER_IN_L0(PL_DISABLE_EI_INFER_IN_L0)
+   ,.PL_N_FTS(PL_N_FTS)
+   ,.PL_DISABLE_UPCONFIG_CAPABLE(PL_DISABLE_UPCONFIG_CAPABLE)
+   ,.PL_DISABLE_RETRAIN_ON_FRAMING_ERROR(PL_DISABLE_RETRAIN_ON_FRAMING_ERROR)
+   ,.PL_DISABLE_RETRAIN_ON_EB_ERROR(PL_DISABLE_RETRAIN_ON_EB_ERROR)
+   ,.PL_DISABLE_RETRAIN_ON_SPECIFIC_FRAMING_ERROR(PL_DISABLE_RETRAIN_ON_SPECIFIC_FRAMING_ERROR)
+   ,.PL_REPORT_ALL_PHY_ERRORS(PL_REPORT_ALL_PHY_ERRORS)
+   ,.PL_DISABLE_LFSR_UPDATE_ON_SKP(PL_DISABLE_LFSR_UPDATE_ON_SKP)
+   ,.PL_LANE0_EQ_CONTROL(PL_LANE0_EQ_CONTROL)
+   ,.PL_LANE1_EQ_CONTROL(PL_LANE1_EQ_CONTROL)
+   ,.PL_LANE2_EQ_CONTROL(PL_LANE2_EQ_CONTROL)
+   ,.PL_LANE3_EQ_CONTROL(PL_LANE3_EQ_CONTROL)
+   ,.PL_LANE4_EQ_CONTROL(PL_LANE4_EQ_CONTROL)
+   ,.PL_LANE5_EQ_CONTROL(PL_LANE5_EQ_CONTROL)
+   ,.PL_LANE6_EQ_CONTROL(PL_LANE6_EQ_CONTROL)
+   ,.PL_LANE7_EQ_CONTROL(PL_LANE7_EQ_CONTROL)
+   ,.PL_LANE8_EQ_CONTROL(PL_LANE8_EQ_CONTROL)
+   ,.PL_LANE9_EQ_CONTROL(PL_LANE9_EQ_CONTROL)
+   ,.PL_LANE10_EQ_CONTROL(PL_LANE10_EQ_CONTROL)
+   ,.PL_LANE11_EQ_CONTROL(PL_LANE11_EQ_CONTROL)
+   ,.PL_LANE12_EQ_CONTROL(PL_LANE12_EQ_CONTROL)
+   ,.PL_LANE13_EQ_CONTROL(PL_LANE13_EQ_CONTROL)
+   ,.PL_LANE14_EQ_CONTROL(PL_LANE14_EQ_CONTROL)
+   ,.PL_LANE15_EQ_CONTROL(PL_LANE15_EQ_CONTROL)
+   ,.PL_EQ_ADAPT_ITER_COUNT(PL_EQ_ADAPT_ITER_COUNT)
+   ,.PL_EQ_ADAPT_REJECT_RETRY_COUNT(PL_EQ_ADAPT_REJECT_RETRY_COUNT)
+   ,.PL_EQ_SHORT_ADAPT_PHASE(PL_EQ_SHORT_ADAPT_PHASE)
+   ,.PL_EQ_ADAPT_DISABLE_COEFF_CHECK(PL_EQ_ADAPT_DISABLE_COEFF_CHECK)
+   ,.PL_EQ_ADAPT_DISABLE_PRESET_CHECK(PL_EQ_ADAPT_DISABLE_PRESET_CHECK)
+   ,.PL_EQ_DEFAULT_TX_PRESET(PL_EQ_DEFAULT_TX_PRESET)
+   ,.PL_EQ_DEFAULT_RX_PRESET_HINT(PL_EQ_DEFAULT_RX_PRESET_HINT)
+   ,.PL_EQ_RX_ADAPT_EQ_PHASE0(PL_EQ_RX_ADAPT_EQ_PHASE0)
+   ,.PL_EQ_RX_ADAPT_EQ_PHASE1(PL_EQ_RX_ADAPT_EQ_PHASE1)
+   ,.PL_EQ_DISABLE_MISMATCH_CHECK(PL_EQ_DISABLE_MISMATCH_CHECK)
+   ,.PL_RX_L0S_EXIT_TO_RECOVERY(PL_RX_L0S_EXIT_TO_RECOVERY)
+   ,.PL_EQ_TX_8G_EQ_TS2_ENABLE(PL_EQ_TX_8G_EQ_TS2_ENABLE)
+   ,.PL_DISABLE_AUTO_EQ_SPEED_CHANGE_TO_GEN4(PL_DISABLE_AUTO_EQ_SPEED_CHANGE_TO_GEN4)
+   ,.PL_DISABLE_AUTO_EQ_SPEED_CHANGE_TO_GEN3(PL_DISABLE_AUTO_EQ_SPEED_CHANGE_TO_GEN3)
+   ,.PL_DISABLE_AUTO_SPEED_CHANGE_TO_GEN2(PL_DISABLE_AUTO_SPEED_CHANGE_TO_GEN2)
+   ,.PL_DESKEW_ON_SKIP_IN_GEN12(PL_DESKEW_ON_SKIP_IN_GEN12)
+   ,.PL_INFER_EI_DISABLE_REC_RC(PL_INFER_EI_DISABLE_REC_RC)
+   ,.PL_INFER_EI_DISABLE_REC_SPD(PL_INFER_EI_DISABLE_REC_SPD)
+   ,.PL_INFER_EI_DISABLE_LPBK_ACTIVE(PL_INFER_EI_DISABLE_LPBK_ACTIVE)
+   ,.PL_RX_ADAPT_TIMER_RRL_GEN3(PL_RX_ADAPT_TIMER_RRL_GEN3)
+   ,.PL_RX_ADAPT_TIMER_RRL_CLOBBER_TX_TS(PL_RX_ADAPT_TIMER_RRL_CLOBBER_TX_TS)
+   ,.PL_RX_ADAPT_TIMER_RRL_GEN4(PL_RX_ADAPT_TIMER_RRL_GEN4)
+   ,.PL_RX_ADAPT_TIMER_CLWS_GEN3(PL_RX_ADAPT_TIMER_CLWS_GEN3)
+   ,.PL_RX_ADAPT_TIMER_CLWS_CLOBBER_TX_TS(PL_RX_ADAPT_TIMER_CLWS_CLOBBER_TX_TS)
+   ,.PL_RX_ADAPT_TIMER_CLWS_GEN4(PL_RX_ADAPT_TIMER_CLWS_GEN4)
+   ,.PL_DISABLE_LANE_REVERSAL(PL_DISABLE_LANE_REVERSAL)
+   ,.PL_CFG_STATE_ROBUSTNESS_ENABLE(PL_CFG_STATE_ROBUSTNESS_ENABLE)
+   ,.PL_REDO_EQ_SOURCE_SELECT(PL_REDO_EQ_SOURCE_SELECT)
+   ,.PL_EXIT_LOOPBACK_ON_EI_ENTRY(PL_EXIT_LOOPBACK_ON_EI_ENTRY)
+   ,.PL_QUIESCE_GUARANTEE_DISABLE(PL_QUIESCE_GUARANTEE_DISABLE)
+   ,.PL_SRIS_ENABLE(PL_SRIS_ENABLE)
+   ,.PL_SRIS_SKPOS_GEN_SPD_VEC(PL_SRIS_SKPOS_GEN_SPD_VEC)
+   ,.PL_SRIS_SKPOS_REC_SPD_VEC(PL_SRIS_SKPOS_REC_SPD_VEC)
+   ,.PL_USER_SPARE(PL_USER_SPARE)
+   ,.LL_ACK_TIMEOUT_EN(LL_ACK_TIMEOUT_EN)
+   ,.LL_ACK_TIMEOUT(LL_ACK_TIMEOUT)
+   ,.LL_ACK_TIMEOUT_FUNC(LL_ACK_TIMEOUT_FUNC)
+   ,.LL_REPLAY_TIMEOUT_EN(LL_REPLAY_TIMEOUT_EN)
+   ,.LL_REPLAY_TIMEOUT(LL_REPLAY_TIMEOUT)
+   ,.LL_REPLAY_TIMEOUT_FUNC(LL_REPLAY_TIMEOUT_FUNC)
+   ,.LL_REPLAY_TO_RAM_PIPELINE(LL_REPLAY_TO_RAM_PIPELINE)
+   ,.LL_REPLAY_FROM_RAM_PIPELINE(LL_REPLAY_FROM_RAM_PIPELINE)
+   ,.LL_DISABLE_SCHED_TX_NAK(LL_DISABLE_SCHED_TX_NAK)
+   ,.LL_TX_TLP_PARITY_CHK(LL_TX_TLP_PARITY_CHK)
+   ,.LL_RX_TLP_PARITY_GEN(LL_RX_TLP_PARITY_GEN)
+   ,.LL_USER_SPARE(LL_USER_SPARE)
+   ,.IS_SWITCH_PORT(IS_SWITCH_PORT)
+   ,.CFG_BYPASS_MODE_ENABLE(CFG_BYPASS_MODE_ENABLE)
+   ,.TL_PF_ENABLE_REG(TL_PF_ENABLE_REG)
+   ,.TL_CREDITS_CD(TL_CREDITS_CD)
+   ,.TL_CREDITS_CH(TL_CREDITS_CH)
+   ,.TL_COMPLETION_RAM_SIZE(TL_COMPLETION_RAM_SIZE)
+   ,.TL_COMPLETION_RAM_NUM_TLPS(TL_COMPLETION_RAM_NUM_TLPS)
+   ,.TL_CREDITS_NPD(TL_CREDITS_NPD)
+   ,.TL_CREDITS_NPH(TL_CREDITS_NPH)
+   ,.TL_CREDITS_PD(TL_CREDITS_PD)
+   ,.TL_CREDITS_PH(TL_CREDITS_PH)
+   ,.TL_RX_COMPLETION_TO_RAM_WRITE_PIPELINE(TL_RX_COMPLETION_TO_RAM_WRITE_PIPELINE)
+   ,.TL_RX_COMPLETION_TO_RAM_READ_PIPELINE(TL_RX_COMPLETION_TO_RAM_READ_PIPELINE)
+   ,.TL_RX_COMPLETION_FROM_RAM_READ_PIPELINE(TL_RX_COMPLETION_FROM_RAM_READ_PIPELINE)
+   ,.TL_POSTED_RAM_SIZE(TL_POSTED_RAM_SIZE)
+   ,.TL_RX_POSTED_TO_RAM_WRITE_PIPELINE(TL_RX_POSTED_TO_RAM_WRITE_PIPELINE)
+   ,.TL_RX_POSTED_TO_RAM_READ_PIPELINE(TL_RX_POSTED_TO_RAM_READ_PIPELINE)
+   ,.TL_RX_POSTED_FROM_RAM_READ_PIPELINE(TL_RX_POSTED_FROM_RAM_READ_PIPELINE)
+   ,.TL_TX_MUX_STRICT_PRIORITY(TL_TX_MUX_STRICT_PRIORITY)
+   ,.TL_TX_TLP_STRADDLE_ENABLE(TL_TX_TLP_STRADDLE_ENABLE)
+   ,.TL_TX_TLP_TERMINATE_PARITY(TL_TX_TLP_TERMINATE_PARITY)
+   ,.TL_FC_UPDATE_MIN_INTERVAL_TLP_COUNT(TL_FC_UPDATE_MIN_INTERVAL_TLP_COUNT)
+   ,.TL_FC_UPDATE_MIN_INTERVAL_TIME(TL_FC_UPDATE_MIN_INTERVAL_TIME)
+   ,.TL_USER_SPARE(TL_USER_SPARE)
+   ,.PF0_CLASS_CODE(PF0_CLASS_CODE)
+   ,.PF1_CLASS_CODE(PF1_CLASS_CODE)
+   ,.PF2_CLASS_CODE(PF2_CLASS_CODE)
+   ,.PF3_CLASS_CODE(PF3_CLASS_CODE)
+   ,.PF0_INTERRUPT_PIN(PF0_INTERRUPT_PIN)
+   ,.PF1_INTERRUPT_PIN(PF1_INTERRUPT_PIN)
+   ,.PF2_INTERRUPT_PIN(PF2_INTERRUPT_PIN)
+   ,.PF3_INTERRUPT_PIN(PF3_INTERRUPT_PIN)
+   ,.PF0_CAPABILITY_POINTER(PF0_CAPABILITY_POINTER)
+   ,.PF1_CAPABILITY_POINTER(PF1_CAPABILITY_POINTER)
+   ,.PF2_CAPABILITY_POINTER(PF2_CAPABILITY_POINTER)
+   ,.PF3_CAPABILITY_POINTER(PF3_CAPABILITY_POINTER)
+   ,.VF0_CAPABILITY_POINTER(VF0_CAPABILITY_POINTER)
+   ,.LEGACY_CFG_EXTEND_INTERFACE_ENABLE(LEGACY_CFG_EXTEND_INTERFACE_ENABLE)
+   ,.EXTENDED_CFG_EXTEND_INTERFACE_ENABLE(EXTENDED_CFG_EXTEND_INTERFACE_ENABLE)
+   ,.TL2CFG_IF_PARITY_CHK(TL2CFG_IF_PARITY_CHK)
+   ,.HEADER_TYPE_OVERRIDE(HEADER_TYPE_OVERRIDE)
+   ,.PF0_BAR0_CONTROL(PF0_BAR0_CONTROL)
+   ,.PF1_BAR0_CONTROL(PF1_BAR0_CONTROL)
+   ,.PF2_BAR0_CONTROL(PF2_BAR0_CONTROL)
+   ,.PF3_BAR0_CONTROL(PF3_BAR0_CONTROL)
+   ,.PF0_BAR0_APERTURE_SIZE(PF0_BAR0_APERTURE_SIZE)
+   ,.PF1_BAR0_APERTURE_SIZE(PF1_BAR0_APERTURE_SIZE)
+   ,.PF2_BAR0_APERTURE_SIZE(PF2_BAR0_APERTURE_SIZE)
+   ,.PF3_BAR0_APERTURE_SIZE(PF3_BAR0_APERTURE_SIZE)
+   ,.PF0_BAR1_CONTROL(PF0_BAR1_CONTROL)
+   ,.PF1_BAR1_CONTROL(PF1_BAR1_CONTROL)
+   ,.PF2_BAR1_CONTROL(PF2_BAR1_CONTROL)
+   ,.PF3_BAR1_CONTROL(PF3_BAR1_CONTROL)
+   ,.PF0_BAR1_APERTURE_SIZE(PF0_BAR1_APERTURE_SIZE)
+   ,.PF1_BAR1_APERTURE_SIZE(PF1_BAR1_APERTURE_SIZE)
+   ,.PF2_BAR1_APERTURE_SIZE(PF2_BAR1_APERTURE_SIZE)
+   ,.PF3_BAR1_APERTURE_SIZE(PF3_BAR1_APERTURE_SIZE)
+   ,.PF0_BAR2_CONTROL(PF0_BAR2_CONTROL)
+   ,.PF1_BAR2_CONTROL(PF1_BAR2_CONTROL)
+   ,.PF2_BAR2_CONTROL(PF2_BAR2_CONTROL)
+   ,.PF3_BAR2_CONTROL(PF3_BAR2_CONTROL)
+   ,.PF0_BAR2_APERTURE_SIZE(PF0_BAR2_APERTURE_SIZE)
+   ,.PF1_BAR2_APERTURE_SIZE(PF1_BAR2_APERTURE_SIZE)
+   ,.PF2_BAR2_APERTURE_SIZE(PF2_BAR2_APERTURE_SIZE)
+   ,.PF3_BAR2_APERTURE_SIZE(PF3_BAR2_APERTURE_SIZE)
+   ,.PF0_BAR3_CONTROL(PF0_BAR3_CONTROL)
+   ,.PF1_BAR3_CONTROL(PF1_BAR3_CONTROL)
+   ,.PF2_BAR3_CONTROL(PF2_BAR3_CONTROL)
+   ,.PF3_BAR3_CONTROL(PF3_BAR3_CONTROL)
+   ,.PF0_BAR3_APERTURE_SIZE(PF0_BAR3_APERTURE_SIZE)
+   ,.PF1_BAR3_APERTURE_SIZE(PF1_BAR3_APERTURE_SIZE)
+   ,.PF2_BAR3_APERTURE_SIZE(PF2_BAR3_APERTURE_SIZE)
+   ,.PF3_BAR3_APERTURE_SIZE(PF3_BAR3_APERTURE_SIZE)
+   ,.PF0_BAR4_CONTROL(PF0_BAR4_CONTROL)
+   ,.PF1_BAR4_CONTROL(PF1_BAR4_CONTROL)
+   ,.PF2_BAR4_CONTROL(PF2_BAR4_CONTROL)
+   ,.PF3_BAR4_CONTROL(PF3_BAR4_CONTROL)
+   ,.PF0_BAR4_APERTURE_SIZE(PF0_BAR4_APERTURE_SIZE)
+   ,.PF1_BAR4_APERTURE_SIZE(PF1_BAR4_APERTURE_SIZE)
+   ,.PF2_BAR4_APERTURE_SIZE(PF2_BAR4_APERTURE_SIZE)
+   ,.PF3_BAR4_APERTURE_SIZE(PF3_BAR4_APERTURE_SIZE)
+   ,.PF0_BAR5_CONTROL(PF0_BAR5_CONTROL)
+   ,.PF1_BAR5_CONTROL(PF1_BAR5_CONTROL)
+   ,.PF2_BAR5_CONTROL(PF2_BAR5_CONTROL)
+   ,.PF3_BAR5_CONTROL(PF3_BAR5_CONTROL)
+   ,.PF0_BAR5_APERTURE_SIZE(PF0_BAR5_APERTURE_SIZE)
+   ,.PF1_BAR5_APERTURE_SIZE(PF1_BAR5_APERTURE_SIZE)
+   ,.PF2_BAR5_APERTURE_SIZE(PF2_BAR5_APERTURE_SIZE)
+   ,.PF3_BAR5_APERTURE_SIZE(PF3_BAR5_APERTURE_SIZE)
+   ,.PF0_EXPANSION_ROM_ENABLE(PF0_EXPANSION_ROM_ENABLE)
+   ,.PF1_EXPANSION_ROM_ENABLE(PF1_EXPANSION_ROM_ENABLE)
+   ,.PF2_EXPANSION_ROM_ENABLE(PF2_EXPANSION_ROM_ENABLE)
+   ,.PF3_EXPANSION_ROM_ENABLE(PF3_EXPANSION_ROM_ENABLE)
+   ,.PF0_EXPANSION_ROM_APERTURE_SIZE(PF0_EXPANSION_ROM_APERTURE_SIZE)
+   ,.PF1_EXPANSION_ROM_APERTURE_SIZE(PF1_EXPANSION_ROM_APERTURE_SIZE)
+   ,.PF2_EXPANSION_ROM_APERTURE_SIZE(PF2_EXPANSION_ROM_APERTURE_SIZE)
+   ,.PF3_EXPANSION_ROM_APERTURE_SIZE(PF3_EXPANSION_ROM_APERTURE_SIZE)
+   ,.PF0_PCIE_CAP_NEXTPTR(PF0_PCIE_CAP_NEXTPTR)
+   ,.PF1_PCIE_CAP_NEXTPTR(PF1_PCIE_CAP_NEXTPTR)
+   ,.PF2_PCIE_CAP_NEXTPTR(PF2_PCIE_CAP_NEXTPTR)
+   ,.PF3_PCIE_CAP_NEXTPTR(PF3_PCIE_CAP_NEXTPTR)
+   ,.VFG0_PCIE_CAP_NEXTPTR(VFG0_PCIE_CAP_NEXTPTR)
+   ,.VFG1_PCIE_CAP_NEXTPTR(VFG1_PCIE_CAP_NEXTPTR)
+   ,.VFG2_PCIE_CAP_NEXTPTR(VFG2_PCIE_CAP_NEXTPTR)
+   ,.VFG3_PCIE_CAP_NEXTPTR(VFG3_PCIE_CAP_NEXTPTR)
+   ,.PF0_DEV_CAP_MAX_PAYLOAD_SIZE(PF0_DEV_CAP_MAX_PAYLOAD_SIZE)
+   ,.PF1_DEV_CAP_MAX_PAYLOAD_SIZE(PF1_DEV_CAP_MAX_PAYLOAD_SIZE)
+   ,.PF2_DEV_CAP_MAX_PAYLOAD_SIZE(PF2_DEV_CAP_MAX_PAYLOAD_SIZE)
+   ,.PF3_DEV_CAP_MAX_PAYLOAD_SIZE(PF3_DEV_CAP_MAX_PAYLOAD_SIZE)
+   ,.PF0_DEV_CAP_EXT_TAG_SUPPORTED(PF0_DEV_CAP_EXT_TAG_SUPPORTED)
+   ,.PF0_DEV_CAP_ENDPOINT_L0S_LATENCY(PF0_DEV_CAP_ENDPOINT_L0S_LATENCY)
+   ,.PF0_DEV_CAP_ENDPOINT_L1_LATENCY(PF0_DEV_CAP_ENDPOINT_L1_LATENCY)
+   ,.PF0_DEV_CAP_FUNCTION_LEVEL_RESET_CAPABLE(PF0_DEV_CAP_FUNCTION_LEVEL_RESET_CAPABLE)
+   ,.PF0_LINK_CAP_ASPM_SUPPORT(PF0_LINK_CAP_ASPM_SUPPORT)
+   ,.PF0_LINK_CONTROL_RCB(PF0_LINK_CONTROL_RCB)
+   ,.PF0_LINK_STATUS_SLOT_CLOCK_CONFIG(PF0_LINK_STATUS_SLOT_CLOCK_CONFIG)
+   ,.PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN1(PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN1)
+   ,.PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN2(PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN2)
+   ,.PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN3(PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN3)
+   ,.PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN4(PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN4)
+   ,.PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN1(PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN1)
+   ,.PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN2(PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN2)
+   ,.PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN3(PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN3)
+   ,.PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN4(PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN4)
+   ,.PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN1(PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN1)
+   ,.PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN2(PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN2)
+   ,.PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN3(PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN3)
+   ,.PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN4(PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN4)
+   ,.PF0_LINK_CAP_L1_EXIT_LATENCY_GEN1(PF0_LINK_CAP_L1_EXIT_LATENCY_GEN1)
+   ,.PF0_LINK_CAP_L1_EXIT_LATENCY_GEN2(PF0_LINK_CAP_L1_EXIT_LATENCY_GEN2)
+   ,.PF0_LINK_CAP_L1_EXIT_LATENCY_GEN3(PF0_LINK_CAP_L1_EXIT_LATENCY_GEN3)
+   ,.PF0_LINK_CAP_L1_EXIT_LATENCY_GEN4(PF0_LINK_CAP_L1_EXIT_LATENCY_GEN4)
+   ,.PF0_DEV_CAP2_CPL_TIMEOUT_DISABLE(PF0_DEV_CAP2_CPL_TIMEOUT_DISABLE)
+   ,.PF0_DEV_CAP2_32B_ATOMIC_COMPLETER_SUPPORT(PF0_DEV_CAP2_32B_ATOMIC_COMPLETER_SUPPORT)
+   ,.PF0_DEV_CAP2_64B_ATOMIC_COMPLETER_SUPPORT(PF0_DEV_CAP2_64B_ATOMIC_COMPLETER_SUPPORT)
+   ,.PF0_DEV_CAP2_128B_CAS_ATOMIC_COMPLETER_SUPPORT(PF0_DEV_CAP2_128B_CAS_ATOMIC_COMPLETER_SUPPORT)
+   ,.PF0_DEV_CAP2_LTR_SUPPORT(PF0_DEV_CAP2_LTR_SUPPORT)
+   ,.PF0_DEV_CAP2_TPH_COMPLETER_SUPPORT(PF0_DEV_CAP2_TPH_COMPLETER_SUPPORT)
+   ,.PF0_DEV_CAP2_OBFF_SUPPORT(PF0_DEV_CAP2_OBFF_SUPPORT)
+   ,.PF0_DEV_CAP2_ARI_FORWARD_ENABLE(PF0_DEV_CAP2_ARI_FORWARD_ENABLE)
+   ,.PF0_MSI_CAP_NEXTPTR(PF0_MSI_CAP_NEXTPTR)
+   ,.PF1_MSI_CAP_NEXTPTR(PF1_MSI_CAP_NEXTPTR)
+   ,.PF2_MSI_CAP_NEXTPTR(PF2_MSI_CAP_NEXTPTR)
+   ,.PF3_MSI_CAP_NEXTPTR(PF3_MSI_CAP_NEXTPTR)
+   ,.PF0_MSI_CAP_PERVECMASKCAP(PF0_MSI_CAP_PERVECMASKCAP)
+   ,.PF1_MSI_CAP_PERVECMASKCAP(PF1_MSI_CAP_PERVECMASKCAP)
+   ,.PF2_MSI_CAP_PERVECMASKCAP(PF2_MSI_CAP_PERVECMASKCAP)
+   ,.PF3_MSI_CAP_PERVECMASKCAP(PF3_MSI_CAP_PERVECMASKCAP)
+   ,.PF0_MSI_CAP_MULTIMSGCAP(PF0_MSI_CAP_MULTIMSGCAP)
+   ,.PF1_MSI_CAP_MULTIMSGCAP(PF1_MSI_CAP_MULTIMSGCAP)
+   ,.PF2_MSI_CAP_MULTIMSGCAP(PF2_MSI_CAP_MULTIMSGCAP)
+   ,.PF3_MSI_CAP_MULTIMSGCAP(PF3_MSI_CAP_MULTIMSGCAP)
+   ,.PF0_MSIX_CAP_NEXTPTR(PF0_MSIX_CAP_NEXTPTR)
+   ,.PF1_MSIX_CAP_NEXTPTR(PF1_MSIX_CAP_NEXTPTR)
+   ,.PF2_MSIX_CAP_NEXTPTR(PF2_MSIX_CAP_NEXTPTR)
+   ,.PF3_MSIX_CAP_NEXTPTR(PF3_MSIX_CAP_NEXTPTR)
+   ,.VFG0_MSIX_CAP_NEXTPTR(VFG0_MSIX_CAP_NEXTPTR)
+   ,.VFG1_MSIX_CAP_NEXTPTR(VFG1_MSIX_CAP_NEXTPTR)
+   ,.VFG2_MSIX_CAP_NEXTPTR(VFG2_MSIX_CAP_NEXTPTR)
+   ,.VFG3_MSIX_CAP_NEXTPTR(VFG3_MSIX_CAP_NEXTPTR)
+   ,.PF0_MSIX_CAP_PBA_BIR(PF0_MSIX_CAP_PBA_BIR)
+   ,.PF1_MSIX_CAP_PBA_BIR(PF1_MSIX_CAP_PBA_BIR)
+   ,.PF2_MSIX_CAP_PBA_BIR(PF2_MSIX_CAP_PBA_BIR)
+   ,.PF3_MSIX_CAP_PBA_BIR(PF3_MSIX_CAP_PBA_BIR)
+   ,.VFG0_MSIX_CAP_PBA_BIR(VFG0_MSIX_CAP_PBA_BIR)
+   ,.VFG1_MSIX_CAP_PBA_BIR(VFG1_MSIX_CAP_PBA_BIR)
+   ,.VFG2_MSIX_CAP_PBA_BIR(VFG2_MSIX_CAP_PBA_BIR)
+   ,.VFG3_MSIX_CAP_PBA_BIR(VFG3_MSIX_CAP_PBA_BIR)
+   ,.PF0_MSIX_CAP_PBA_OFFSET(PF0_MSIX_CAP_PBA_OFFSET)
+   ,.PF1_MSIX_CAP_PBA_OFFSET(PF1_MSIX_CAP_PBA_OFFSET)
+   ,.PF2_MSIX_CAP_PBA_OFFSET(PF2_MSIX_CAP_PBA_OFFSET)
+   ,.PF3_MSIX_CAP_PBA_OFFSET(PF3_MSIX_CAP_PBA_OFFSET)
+   ,.VFG0_MSIX_CAP_PBA_OFFSET(VFG0_MSIX_CAP_PBA_OFFSET)
+   ,.VFG1_MSIX_CAP_PBA_OFFSET(VFG1_MSIX_CAP_PBA_OFFSET)
+   ,.VFG2_MSIX_CAP_PBA_OFFSET(VFG2_MSIX_CAP_PBA_OFFSET)
+   ,.VFG3_MSIX_CAP_PBA_OFFSET(VFG3_MSIX_CAP_PBA_OFFSET)
+   ,.PF0_MSIX_CAP_TABLE_BIR(PF0_MSIX_CAP_TABLE_BIR)
+   ,.PF1_MSIX_CAP_TABLE_BIR(PF1_MSIX_CAP_TABLE_BIR)
+   ,.PF2_MSIX_CAP_TABLE_BIR(PF2_MSIX_CAP_TABLE_BIR)
+   ,.PF3_MSIX_CAP_TABLE_BIR(PF3_MSIX_CAP_TABLE_BIR)
+   ,.VFG0_MSIX_CAP_TABLE_BIR(VFG0_MSIX_CAP_TABLE_BIR)
+   ,.VFG1_MSIX_CAP_TABLE_BIR(VFG1_MSIX_CAP_TABLE_BIR)
+   ,.VFG2_MSIX_CAP_TABLE_BIR(VFG2_MSIX_CAP_TABLE_BIR)
+   ,.VFG3_MSIX_CAP_TABLE_BIR(VFG3_MSIX_CAP_TABLE_BIR)
+   ,.PF0_MSIX_CAP_TABLE_OFFSET(PF0_MSIX_CAP_TABLE_OFFSET)
+   ,.PF1_MSIX_CAP_TABLE_OFFSET(PF1_MSIX_CAP_TABLE_OFFSET)
+   ,.PF2_MSIX_CAP_TABLE_OFFSET(PF2_MSIX_CAP_TABLE_OFFSET)
+   ,.PF3_MSIX_CAP_TABLE_OFFSET(PF3_MSIX_CAP_TABLE_OFFSET)
+   ,.VFG0_MSIX_CAP_TABLE_OFFSET(VFG0_MSIX_CAP_TABLE_OFFSET)
+   ,.VFG1_MSIX_CAP_TABLE_OFFSET(VFG1_MSIX_CAP_TABLE_OFFSET)
+   ,.VFG2_MSIX_CAP_TABLE_OFFSET(VFG2_MSIX_CAP_TABLE_OFFSET)
+   ,.VFG3_MSIX_CAP_TABLE_OFFSET(VFG3_MSIX_CAP_TABLE_OFFSET)
+   ,.PF0_MSIX_CAP_TABLE_SIZE(PF0_MSIX_CAP_TABLE_SIZE)
+   ,.PF1_MSIX_CAP_TABLE_SIZE(PF1_MSIX_CAP_TABLE_SIZE)
+   ,.PF2_MSIX_CAP_TABLE_SIZE(PF2_MSIX_CAP_TABLE_SIZE)
+   ,.PF3_MSIX_CAP_TABLE_SIZE(PF3_MSIX_CAP_TABLE_SIZE)
+   ,.VFG0_MSIX_CAP_TABLE_SIZE(VFG0_MSIX_CAP_TABLE_SIZE)
+   ,.VFG1_MSIX_CAP_TABLE_SIZE(VFG1_MSIX_CAP_TABLE_SIZE)
+   ,.VFG2_MSIX_CAP_TABLE_SIZE(VFG2_MSIX_CAP_TABLE_SIZE)
+   ,.VFG3_MSIX_CAP_TABLE_SIZE(VFG3_MSIX_CAP_TABLE_SIZE)
+   ,.PF0_MSIX_VECTOR_COUNT(PF0_MSIX_VECTOR_COUNT)
+   ,.PF0_PM_CAP_ID(PF0_PM_CAP_ID)
+   ,.PF0_PM_CAP_NEXTPTR(PF0_PM_CAP_NEXTPTR)
+   ,.PF1_PM_CAP_NEXTPTR(PF1_PM_CAP_NEXTPTR)
+   ,.PF2_PM_CAP_NEXTPTR(PF2_PM_CAP_NEXTPTR)
+   ,.PF3_PM_CAP_NEXTPTR(PF3_PM_CAP_NEXTPTR)
+   ,.PF0_PM_CAP_PMESUPPORT_D3HOT(PF0_PM_CAP_PMESUPPORT_D3HOT)
+   ,.PF0_PM_CAP_PMESUPPORT_D1(PF0_PM_CAP_PMESUPPORT_D1)
+   ,.PF0_PM_CAP_PMESUPPORT_D0(PF0_PM_CAP_PMESUPPORT_D0)
+   ,.PF0_PM_CAP_SUPP_D1_STATE(PF0_PM_CAP_SUPP_D1_STATE)
+   ,.PF0_PM_CAP_VER_ID(PF0_PM_CAP_VER_ID)
+   ,.PF0_PM_CSR_NOSOFTRESET(PF0_PM_CSR_NOSOFTRESET)
+   ,.PM_ENABLE_L23_ENTRY(PM_ENABLE_L23_ENTRY)
+   ,.DNSTREAM_LINK_NUM(DNSTREAM_LINK_NUM)
+   ,.AUTO_FLR_RESPONSE(AUTO_FLR_RESPONSE)
+   ,.PF0_DSN_CAP_NEXTPTR(PF0_DSN_CAP_NEXTPTR)
+   ,.PF1_DSN_CAP_NEXTPTR(PF1_DSN_CAP_NEXTPTR)
+   ,.PF2_DSN_CAP_NEXTPTR(PF2_DSN_CAP_NEXTPTR)
+   ,.PF3_DSN_CAP_NEXTPTR(PF3_DSN_CAP_NEXTPTR)
+   ,.DSN_CAP_ENABLE(DSN_CAP_ENABLE)
+   ,.PF0_VC_CAP_VER(PF0_VC_CAP_VER)
+   ,.PF0_VC_CAP_NEXTPTR(PF0_VC_CAP_NEXTPTR)
+   ,.PF0_VC_CAP_ENABLE(PF0_VC_CAP_ENABLE)
+   ,.PF0_SECONDARY_PCIE_CAP_NEXTPTR(PF0_SECONDARY_PCIE_CAP_NEXTPTR)
+   ,.PF0_AER_CAP_NEXTPTR(PF0_AER_CAP_NEXTPTR)
+   ,.PF1_AER_CAP_NEXTPTR(PF1_AER_CAP_NEXTPTR)
+   ,.PF2_AER_CAP_NEXTPTR(PF2_AER_CAP_NEXTPTR)
+   ,.PF3_AER_CAP_NEXTPTR(PF3_AER_CAP_NEXTPTR)
+   ,.PF0_AER_CAP_ECRC_GEN_AND_CHECK_CAPABLE(PF0_AER_CAP_ECRC_GEN_AND_CHECK_CAPABLE)
+   ,.ARI_CAP_ENABLE(ARI_CAP_ENABLE)
+   ,.PF0_ARI_CAP_NEXTPTR(PF0_ARI_CAP_NEXTPTR)
+   ,.PF1_ARI_CAP_NEXTPTR(PF1_ARI_CAP_NEXTPTR)
+   ,.PF2_ARI_CAP_NEXTPTR(PF2_ARI_CAP_NEXTPTR)
+   ,.PF3_ARI_CAP_NEXTPTR(PF3_ARI_CAP_NEXTPTR)
+   ,.VFG0_ARI_CAP_NEXTPTR(VFG0_ARI_CAP_NEXTPTR)
+   ,.VFG1_ARI_CAP_NEXTPTR(VFG1_ARI_CAP_NEXTPTR)
+   ,.VFG2_ARI_CAP_NEXTPTR(VFG2_ARI_CAP_NEXTPTR)
+   ,.VFG3_ARI_CAP_NEXTPTR(VFG3_ARI_CAP_NEXTPTR)
+   ,.PF0_ARI_CAP_VER(PF0_ARI_CAP_VER)
+   ,.PF0_ARI_CAP_NEXT_FUNC(PF0_ARI_CAP_NEXT_FUNC)
+   ,.PF1_ARI_CAP_NEXT_FUNC(PF1_ARI_CAP_NEXT_FUNC)
+   ,.PF2_ARI_CAP_NEXT_FUNC(PF2_ARI_CAP_NEXT_FUNC)
+   ,.PF3_ARI_CAP_NEXT_FUNC(PF3_ARI_CAP_NEXT_FUNC)
+   ,.PF0_LTR_CAP_NEXTPTR(PF0_LTR_CAP_NEXTPTR)
+   ,.PF0_LTR_CAP_VER(PF0_LTR_CAP_VER)
+   ,.PF0_LTR_CAP_MAX_SNOOP_LAT(PF0_LTR_CAP_MAX_SNOOP_LAT)
+   ,.PF0_LTR_CAP_MAX_NOSNOOP_LAT(PF0_LTR_CAP_MAX_NOSNOOP_LAT)
+   ,.LTR_TX_MESSAGE_ON_LTR_ENABLE(LTR_TX_MESSAGE_ON_LTR_ENABLE)
+   ,.LTR_TX_MESSAGE_ON_FUNC_POWER_STATE_CHANGE(LTR_TX_MESSAGE_ON_FUNC_POWER_STATE_CHANGE)
+   ,.LTR_TX_MESSAGE_MINIMUM_INTERVAL(LTR_TX_MESSAGE_MINIMUM_INTERVAL)
+   ,.SRIOV_CAP_ENABLE(SRIOV_CAP_ENABLE)
+   ,.PF0_SRIOV_CAP_NEXTPTR(PF0_SRIOV_CAP_NEXTPTR)
+   ,.PF1_SRIOV_CAP_NEXTPTR(PF1_SRIOV_CAP_NEXTPTR)
+   ,.PF2_SRIOV_CAP_NEXTPTR(PF2_SRIOV_CAP_NEXTPTR)
+   ,.PF3_SRIOV_CAP_NEXTPTR(PF3_SRIOV_CAP_NEXTPTR)
+   ,.PF0_SRIOV_CAP_VER(PF0_SRIOV_CAP_VER)
+   ,.PF1_SRIOV_CAP_VER(PF1_SRIOV_CAP_VER)
+   ,.PF2_SRIOV_CAP_VER(PF2_SRIOV_CAP_VER)
+   ,.PF3_SRIOV_CAP_VER(PF3_SRIOV_CAP_VER)
+   ,.PF0_SRIOV_ARI_CAPBL_HIER_PRESERVED(PF0_SRIOV_ARI_CAPBL_HIER_PRESERVED)
+   ,.PF1_SRIOV_ARI_CAPBL_HIER_PRESERVED(PF1_SRIOV_ARI_CAPBL_HIER_PRESERVED)
+   ,.PF2_SRIOV_ARI_CAPBL_HIER_PRESERVED(PF2_SRIOV_ARI_CAPBL_HIER_PRESERVED)
+   ,.PF3_SRIOV_ARI_CAPBL_HIER_PRESERVED(PF3_SRIOV_ARI_CAPBL_HIER_PRESERVED)
+   ,.PF0_SRIOV_CAP_INITIAL_VF(PF0_SRIOV_CAP_INITIAL_VF)
+   ,.PF1_SRIOV_CAP_INITIAL_VF(PF1_SRIOV_CAP_INITIAL_VF)
+   ,.PF2_SRIOV_CAP_INITIAL_VF(PF2_SRIOV_CAP_INITIAL_VF)
+   ,.PF3_SRIOV_CAP_INITIAL_VF(PF3_SRIOV_CAP_INITIAL_VF)
+   ,.PF0_SRIOV_CAP_TOTAL_VF(PF0_SRIOV_CAP_TOTAL_VF)
+   ,.PF1_SRIOV_CAP_TOTAL_VF(PF1_SRIOV_CAP_TOTAL_VF)
+   ,.PF2_SRIOV_CAP_TOTAL_VF(PF2_SRIOV_CAP_TOTAL_VF)
+   ,.PF3_SRIOV_CAP_TOTAL_VF(PF3_SRIOV_CAP_TOTAL_VF)
+   ,.PF0_SRIOV_FUNC_DEP_LINK(PF0_SRIOV_FUNC_DEP_LINK)
+   ,.PF1_SRIOV_FUNC_DEP_LINK(PF1_SRIOV_FUNC_DEP_LINK)
+   ,.PF2_SRIOV_FUNC_DEP_LINK(PF2_SRIOV_FUNC_DEP_LINK)
+   ,.PF3_SRIOV_FUNC_DEP_LINK(PF3_SRIOV_FUNC_DEP_LINK)
+   ,.PF0_SRIOV_FIRST_VF_OFFSET(PF0_SRIOV_FIRST_VF_OFFSET)
+   ,.PF1_SRIOV_FIRST_VF_OFFSET(PF1_SRIOV_FIRST_VF_OFFSET)
+   ,.PF2_SRIOV_FIRST_VF_OFFSET(PF2_SRIOV_FIRST_VF_OFFSET)
+   ,.PF3_SRIOV_FIRST_VF_OFFSET(PF3_SRIOV_FIRST_VF_OFFSET)
+   ,.PF0_SRIOV_VF_DEVICE_ID(PF0_SRIOV_VF_DEVICE_ID)
+   ,.PF1_SRIOV_VF_DEVICE_ID(PF1_SRIOV_VF_DEVICE_ID)
+   ,.PF2_SRIOV_VF_DEVICE_ID(PF2_SRIOV_VF_DEVICE_ID)
+   ,.PF3_SRIOV_VF_DEVICE_ID(PF3_SRIOV_VF_DEVICE_ID)
+   ,.PF0_SRIOV_SUPPORTED_PAGE_SIZE(PF0_SRIOV_SUPPORTED_PAGE_SIZE)
+   ,.PF1_SRIOV_SUPPORTED_PAGE_SIZE(PF1_SRIOV_SUPPORTED_PAGE_SIZE)
+   ,.PF2_SRIOV_SUPPORTED_PAGE_SIZE(PF2_SRIOV_SUPPORTED_PAGE_SIZE)
+   ,.PF3_SRIOV_SUPPORTED_PAGE_SIZE(PF3_SRIOV_SUPPORTED_PAGE_SIZE)
+   ,.PF0_SRIOV_BAR0_CONTROL(PF0_SRIOV_BAR0_CONTROL)
+   ,.PF1_SRIOV_BAR0_CONTROL(PF1_SRIOV_BAR0_CONTROL)
+   ,.PF2_SRIOV_BAR0_CONTROL(PF2_SRIOV_BAR0_CONTROL)
+   ,.PF3_SRIOV_BAR0_CONTROL(PF3_SRIOV_BAR0_CONTROL)
+   ,.PF0_SRIOV_BAR0_APERTURE_SIZE(PF0_SRIOV_BAR0_APERTURE_SIZE)
+   ,.PF1_SRIOV_BAR0_APERTURE_SIZE(PF1_SRIOV_BAR0_APERTURE_SIZE)
+   ,.PF2_SRIOV_BAR0_APERTURE_SIZE(PF2_SRIOV_BAR0_APERTURE_SIZE)
+   ,.PF3_SRIOV_BAR0_APERTURE_SIZE(PF3_SRIOV_BAR0_APERTURE_SIZE)
+   ,.PF0_SRIOV_BAR1_CONTROL(PF0_SRIOV_BAR1_CONTROL)
+   ,.PF1_SRIOV_BAR1_CONTROL(PF1_SRIOV_BAR1_CONTROL)
+   ,.PF2_SRIOV_BAR1_CONTROL(PF2_SRIOV_BAR1_CONTROL)
+   ,.PF3_SRIOV_BAR1_CONTROL(PF3_SRIOV_BAR1_CONTROL)
+   ,.PF0_SRIOV_BAR1_APERTURE_SIZE(PF0_SRIOV_BAR1_APERTURE_SIZE)
+   ,.PF1_SRIOV_BAR1_APERTURE_SIZE(PF1_SRIOV_BAR1_APERTURE_SIZE)
+   ,.PF2_SRIOV_BAR1_APERTURE_SIZE(PF2_SRIOV_BAR1_APERTURE_SIZE)
+   ,.PF3_SRIOV_BAR1_APERTURE_SIZE(PF3_SRIOV_BAR1_APERTURE_SIZE)
+   ,.PF0_SRIOV_BAR2_CONTROL(PF0_SRIOV_BAR2_CONTROL)
+   ,.PF1_SRIOV_BAR2_CONTROL(PF1_SRIOV_BAR2_CONTROL)
+   ,.PF2_SRIOV_BAR2_CONTROL(PF2_SRIOV_BAR2_CONTROL)
+   ,.PF3_SRIOV_BAR2_CONTROL(PF3_SRIOV_BAR2_CONTROL)
+   ,.PF0_SRIOV_BAR2_APERTURE_SIZE(PF0_SRIOV_BAR2_APERTURE_SIZE)
+   ,.PF1_SRIOV_BAR2_APERTURE_SIZE(PF1_SRIOV_BAR2_APERTURE_SIZE)
+   ,.PF2_SRIOV_BAR2_APERTURE_SIZE(PF2_SRIOV_BAR2_APERTURE_SIZE)
+   ,.PF3_SRIOV_BAR2_APERTURE_SIZE(PF3_SRIOV_BAR2_APERTURE_SIZE)
+   ,.PF0_SRIOV_BAR3_CONTROL(PF0_SRIOV_BAR3_CONTROL)
+   ,.PF1_SRIOV_BAR3_CONTROL(PF1_SRIOV_BAR3_CONTROL)
+   ,.PF2_SRIOV_BAR3_CONTROL(PF2_SRIOV_BAR3_CONTROL)
+   ,.PF3_SRIOV_BAR3_CONTROL(PF3_SRIOV_BAR3_CONTROL)
+   ,.PF0_SRIOV_BAR3_APERTURE_SIZE(PF0_SRIOV_BAR3_APERTURE_SIZE)
+   ,.PF1_SRIOV_BAR3_APERTURE_SIZE(PF1_SRIOV_BAR3_APERTURE_SIZE)
+   ,.PF2_SRIOV_BAR3_APERTURE_SIZE(PF2_SRIOV_BAR3_APERTURE_SIZE)
+   ,.PF3_SRIOV_BAR3_APERTURE_SIZE(PF3_SRIOV_BAR3_APERTURE_SIZE)
+   ,.PF0_SRIOV_BAR4_CONTROL(PF0_SRIOV_BAR4_CONTROL)
+   ,.PF1_SRIOV_BAR4_CONTROL(PF1_SRIOV_BAR4_CONTROL)
+   ,.PF2_SRIOV_BAR4_CONTROL(PF2_SRIOV_BAR4_CONTROL)
+   ,.PF3_SRIOV_BAR4_CONTROL(PF3_SRIOV_BAR4_CONTROL)
+   ,.PF0_SRIOV_BAR4_APERTURE_SIZE(PF0_SRIOV_BAR4_APERTURE_SIZE)
+   ,.PF1_SRIOV_BAR4_APERTURE_SIZE(PF1_SRIOV_BAR4_APERTURE_SIZE)
+   ,.PF2_SRIOV_BAR4_APERTURE_SIZE(PF2_SRIOV_BAR4_APERTURE_SIZE)
+   ,.PF3_SRIOV_BAR4_APERTURE_SIZE(PF3_SRIOV_BAR4_APERTURE_SIZE)
+   ,.PF0_SRIOV_BAR5_CONTROL(PF0_SRIOV_BAR5_CONTROL)
+   ,.PF1_SRIOV_BAR5_CONTROL(PF1_SRIOV_BAR5_CONTROL)
+   ,.PF2_SRIOV_BAR5_CONTROL(PF2_SRIOV_BAR5_CONTROL)
+   ,.PF3_SRIOV_BAR5_CONTROL(PF3_SRIOV_BAR5_CONTROL)
+   ,.PF0_SRIOV_BAR5_APERTURE_SIZE(PF0_SRIOV_BAR5_APERTURE_SIZE)
+   ,.PF1_SRIOV_BAR5_APERTURE_SIZE(PF1_SRIOV_BAR5_APERTURE_SIZE)
+   ,.PF2_SRIOV_BAR5_APERTURE_SIZE(PF2_SRIOV_BAR5_APERTURE_SIZE)
+   ,.PF3_SRIOV_BAR5_APERTURE_SIZE(PF3_SRIOV_BAR5_APERTURE_SIZE)
+   ,.PF0_TPHR_CAP_NEXTPTR(PF0_TPHR_CAP_NEXTPTR)
+   ,.PF1_TPHR_CAP_NEXTPTR(PF1_TPHR_CAP_NEXTPTR)
+   ,.PF2_TPHR_CAP_NEXTPTR(PF2_TPHR_CAP_NEXTPTR)
+   ,.PF3_TPHR_CAP_NEXTPTR(PF3_TPHR_CAP_NEXTPTR)
+   ,.VFG0_TPHR_CAP_NEXTPTR(VFG0_TPHR_CAP_NEXTPTR)
+   ,.VFG1_TPHR_CAP_NEXTPTR(VFG1_TPHR_CAP_NEXTPTR)
+   ,.VFG2_TPHR_CAP_NEXTPTR(VFG2_TPHR_CAP_NEXTPTR)
+   ,.VFG3_TPHR_CAP_NEXTPTR(VFG3_TPHR_CAP_NEXTPTR)
+   ,.PF0_TPHR_CAP_VER(PF0_TPHR_CAP_VER)
+   ,.PF0_TPHR_CAP_INT_VEC_MODE(PF0_TPHR_CAP_INT_VEC_MODE)
+   ,.PF0_TPHR_CAP_DEV_SPECIFIC_MODE(PF0_TPHR_CAP_DEV_SPECIFIC_MODE)
+   ,.PF0_TPHR_CAP_ST_TABLE_LOC(PF0_TPHR_CAP_ST_TABLE_LOC)
+   ,.PF0_TPHR_CAP_ST_TABLE_SIZE(PF0_TPHR_CAP_ST_TABLE_SIZE)
+   ,.PF0_TPHR_CAP_ST_MODE_SEL(PF0_TPHR_CAP_ST_MODE_SEL)
+   ,.PF1_TPHR_CAP_ST_MODE_SEL(PF1_TPHR_CAP_ST_MODE_SEL)
+   ,.PF2_TPHR_CAP_ST_MODE_SEL(PF2_TPHR_CAP_ST_MODE_SEL)
+   ,.PF3_TPHR_CAP_ST_MODE_SEL(PF3_TPHR_CAP_ST_MODE_SEL)
+   ,.VFG0_TPHR_CAP_ST_MODE_SEL(VFG0_TPHR_CAP_ST_MODE_SEL)
+   ,.VFG1_TPHR_CAP_ST_MODE_SEL(VFG1_TPHR_CAP_ST_MODE_SEL)
+   ,.VFG2_TPHR_CAP_ST_MODE_SEL(VFG2_TPHR_CAP_ST_MODE_SEL)
+   ,.VFG3_TPHR_CAP_ST_MODE_SEL(VFG3_TPHR_CAP_ST_MODE_SEL)
+   ,.PF0_TPHR_CAP_ENABLE(PF0_TPHR_CAP_ENABLE)
+   ,.TPH_TO_RAM_PIPELINE(TPH_TO_RAM_PIPELINE)
+   ,.TPH_FROM_RAM_PIPELINE(TPH_FROM_RAM_PIPELINE)
+   ,.MCAP_ENABLE(MCAP_ENABLE)
+   ,.MCAP_CONFIGURE_OVERRIDE(MCAP_CONFIGURE_OVERRIDE)
+   ,.MCAP_CAP_NEXTPTR(MCAP_CAP_NEXTPTR)
+   ,.MCAP_VSEC_ID(MCAP_VSEC_ID)
+   ,.MCAP_VSEC_REV(MCAP_VSEC_REV)
+   ,.MCAP_VSEC_LEN(MCAP_VSEC_LEN)
+   ,.MCAP_FPGA_BITSTREAM_VERSION(MCAP_FPGA_BITSTREAM_VERSION)
+   ,.MCAP_INTERRUPT_ON_MCAP_EOS(MCAP_INTERRUPT_ON_MCAP_EOS)
+   ,.MCAP_INTERRUPT_ON_MCAP_ERROR(MCAP_INTERRUPT_ON_MCAP_ERROR)
+   ,.MCAP_INPUT_GATE_DESIGN_SWITCH(MCAP_INPUT_GATE_DESIGN_SWITCH)
+   ,.MCAP_EOS_DESIGN_SWITCH(MCAP_EOS_DESIGN_SWITCH)
+   ,.MCAP_GATE_MEM_ENABLE_DESIGN_SWITCH(MCAP_GATE_MEM_ENABLE_DESIGN_SWITCH)
+   ,.MCAP_GATE_IO_ENABLE_DESIGN_SWITCH(MCAP_GATE_IO_ENABLE_DESIGN_SWITCH)
+   ,.SIM_JTAG_IDCODE(SIM_JTAG_IDCODE)
+   ,.DEBUG_AXIST_DISABLE_FEATURE_BIT(DEBUG_AXIST_DISABLE_FEATURE_BIT)
+   ,.DEBUG_TL_DISABLE_RX_TLP_ORDER_CHECKS(DEBUG_TL_DISABLE_RX_TLP_ORDER_CHECKS)
+   ,.DEBUG_TL_DISABLE_FC_TIMEOUT(DEBUG_TL_DISABLE_FC_TIMEOUT)
+   ,.DEBUG_PL_DISABLE_SCRAMBLING(DEBUG_PL_DISABLE_SCRAMBLING)
+   ,.DEBUG_PL_DISABLE_REC_ENTRY_ON_DYNAMIC_DSKEW_FAIL (DEBUG_PL_DISABLE_REC_ENTRY_ON_DYNAMIC_DSKEW_FAIL )
+   ,.DEBUG_PL_DISABLE_REC_ENTRY_ON_RX_BUFFER_UNDER_OVER_FLOW (DEBUG_PL_DISABLE_REC_ENTRY_ON_RX_BUFFER_UNDER_OVER_FLOW )
+   ,.DEBUG_PL_DISABLE_LES_UPDATE_ON_SKP_ERROR(DEBUG_PL_DISABLE_LES_UPDATE_ON_SKP_ERROR)
+   ,.DEBUG_PL_DISABLE_LES_UPDATE_ON_SKP_PARITY_ERROR(DEBUG_PL_DISABLE_LES_UPDATE_ON_SKP_PARITY_ERROR)
+   ,.DEBUG_PL_DISABLE_LES_UPDATE_ON_DEFRAMER_ERROR(DEBUG_PL_DISABLE_LES_UPDATE_ON_DEFRAMER_ERROR)
+   ,.DEBUG_PL_SIM_RESET_LFSR(DEBUG_PL_SIM_RESET_LFSR)
+   ,.DEBUG_PL_SPARE(DEBUG_PL_SPARE)
+   ,.DEBUG_LL_SPARE(DEBUG_LL_SPARE)
+   ,.DEBUG_TL_SPARE(DEBUG_TL_SPARE)
+   ,.DEBUG_AXI4ST_SPARE(DEBUG_AXI4ST_SPARE)
+   ,.DEBUG_CFG_SPARE(DEBUG_CFG_SPARE)
+   ,.DEBUG_CAR_SPARE(DEBUG_CAR_SPARE)
+   ,.TEST_MODE_PIN_CHAR(TEST_MODE_PIN_CHAR)
+   ,.SPARE_BIT0(SPARE_BIT0)
+   ,.SPARE_BIT1(SPARE_BIT1)
+   ,.SPARE_BIT2(SPARE_BIT2)
+   ,.SPARE_BIT3(SPARE_BIT3)
+   ,.SPARE_BIT4(SPARE_BIT4)
+   ,.SPARE_BIT5(SPARE_BIT5)
+   ,.SPARE_BIT6(SPARE_BIT6)
+   ,.SPARE_BIT7(SPARE_BIT7)
+   ,.SPARE_BIT8(SPARE_BIT8)
+   ,.SPARE_BYTE0(SPARE_BYTE0)
+   ,.SPARE_BYTE1(SPARE_BYTE1)
+   ,.SPARE_BYTE2(SPARE_BYTE2)
+   ,.SPARE_BYTE3(SPARE_BYTE3)
+   ,.SPARE_WORD0(SPARE_WORD0)
+   ,.SPARE_WORD1(SPARE_WORD1)
+   ,.SPARE_WORD2(SPARE_WORD2)
+   ,.SPARE_WORD3(SPARE_WORD3)
+   ,.AXISTEN_IF_CCIX_RX_CREDIT_LIMIT(AXISTEN_IF_CCIX_RX_CREDIT_LIMIT)
+   ,.AXISTEN_IF_CCIX_TX_CREDIT_LIMIT(AXISTEN_IF_CCIX_TX_CREDIT_LIMIT)
+   ,.AXISTEN_IF_CCIX_TX_REGISTERED_TREADY(AXISTEN_IF_CCIX_TX_REGISTERED_TREADY)
+   ,.CCIX_DIRECT_ATTACH_MODE(CCIX_DIRECT_ATTACH_MODE)
+   ,.CCIX_ENABLE(CCIX_ENABLE)
+   ,.CCIX_VENDOR_ID(CCIX_VENDOR_ID)
+   ,.PF0_ATS_CAP_INV_QUEUE_DEPTH(PF0_ATS_CAP_INV_QUEUE_DEPTH)
+   ,.PF0_ATS_CAP_NEXTPTR(PF0_ATS_CAP_NEXTPTR)
+   ,.PF0_ATS_CAP_ON(PF0_ATS_CAP_ON)
+   ,.PF0_PRI_CAP_NEXTPTR(PF0_PRI_CAP_NEXTPTR)
+   ,.PF0_PRI_CAP_ON(PF0_PRI_CAP_ON)
+   ,.PF0_PRI_OST_PR_CAPACITY(PF0_PRI_OST_PR_CAPACITY)
+   ,.PF0_VC_ARB_CAPABILITY(PF0_VC_ARB_CAPABILITY)
+   ,.PF0_VC_ARB_TBL_OFFSET(PF0_VC_ARB_TBL_OFFSET)
+   ,.PF0_VC_EXTENDED_COUNT(PF0_VC_EXTENDED_COUNT)
+   ,.PF0_VC_LOW_PRIORITY_EXTENDED_COUNT(PF0_VC_LOW_PRIORITY_EXTENDED_COUNT)
+   ,.PF1_ATS_CAP_INV_QUEUE_DEPTH(PF1_ATS_CAP_INV_QUEUE_DEPTH)
+   ,.PF1_ATS_CAP_NEXTPTR(PF1_ATS_CAP_NEXTPTR)
+   ,.PF1_ATS_CAP_ON(PF1_ATS_CAP_ON)
+   ,.PF1_PRI_CAP_NEXTPTR(PF1_PRI_CAP_NEXTPTR)
+   ,.PF1_PRI_CAP_ON(PF1_PRI_CAP_ON)
+   ,.PF1_PRI_OST_PR_CAPACITY(PF1_PRI_OST_PR_CAPACITY)
+   ,.PF2_ATS_CAP_INV_QUEUE_DEPTH(PF2_ATS_CAP_INV_QUEUE_DEPTH)
+   ,.PF2_ATS_CAP_NEXTPTR(PF2_ATS_CAP_NEXTPTR)
+   ,.PF2_ATS_CAP_ON(PF2_ATS_CAP_ON)
+   ,.PF2_PRI_CAP_NEXTPTR(PF2_PRI_CAP_NEXTPTR)
+   ,.PF2_PRI_CAP_ON(PF2_PRI_CAP_ON)
+   ,.PF2_PRI_OST_PR_CAPACITY(PF2_PRI_OST_PR_CAPACITY)
+   ,.PF3_ATS_CAP_INV_QUEUE_DEPTH(PF3_ATS_CAP_INV_QUEUE_DEPTH)
+   ,.PF3_ATS_CAP_NEXTPTR(PF3_ATS_CAP_NEXTPTR)
+   ,.PF3_ATS_CAP_ON(PF3_ATS_CAP_ON)
+   ,.PF3_PRI_CAP_NEXTPTR(PF3_PRI_CAP_NEXTPTR)
+   ,.PF3_PRI_CAP_ON(PF3_PRI_CAP_ON)
+   ,.PF3_PRI_OST_PR_CAPACITY(PF3_PRI_OST_PR_CAPACITY)
+   ,.PL_CTRL_SKP_GEN_ENABLE(PL_CTRL_SKP_GEN_ENABLE)
+   ,.PL_CTRL_SKP_PARITY_AND_CRC_CHECK_DISABLE(PL_CTRL_SKP_PARITY_AND_CRC_CHECK_DISABLE)
+   ,.PL_USER_SPARE2(PL_USER_SPARE2)
+   ,.TL_CREDITS_CD_VC1(TL_CREDITS_CD_VC1)
+   ,.TL_CREDITS_CH_VC1(TL_CREDITS_CH_VC1)
+   ,.TL_CREDITS_NPD_VC1(TL_CREDITS_NPD_VC1)
+   ,.TL_CREDITS_NPH_VC1(TL_CREDITS_NPH_VC1)
+   ,.TL_CREDITS_PD_VC1(TL_CREDITS_PD_VC1)
+   ,.TL_CREDITS_PH_VC1(TL_CREDITS_PH_VC1)
+   ,.TL_FC_UPDATE_MIN_INTERVAL_TIME_VC1(TL_FC_UPDATE_MIN_INTERVAL_TIME_VC1)
+   ,.TL_FC_UPDATE_MIN_INTERVAL_TLP_COUNT_VC1(TL_FC_UPDATE_MIN_INTERVAL_TLP_COUNT_VC1)
+   ,.TL_FEATURE_ENABLE_FC_SCALING(TL_FEATURE_ENABLE_FC_SCALING)
+   ,.VFG0_ATS_CAP_INV_QUEUE_DEPTH(VFG0_ATS_CAP_INV_QUEUE_DEPTH)
+   ,.VFG0_ATS_CAP_NEXTPTR(VFG0_ATS_CAP_NEXTPTR)
+   ,.VFG0_ATS_CAP_ON(VFG0_ATS_CAP_ON)
+   ,.VFG1_ATS_CAP_INV_QUEUE_DEPTH(VFG1_ATS_CAP_INV_QUEUE_DEPTH)
+   ,.VFG1_ATS_CAP_NEXTPTR(VFG1_ATS_CAP_NEXTPTR)
+   ,.VFG1_ATS_CAP_ON(VFG1_ATS_CAP_ON)
+   ,.VFG2_ATS_CAP_INV_QUEUE_DEPTH(VFG2_ATS_CAP_INV_QUEUE_DEPTH)
+   ,.VFG2_ATS_CAP_NEXTPTR(VFG2_ATS_CAP_NEXTPTR)
+   ,.VFG2_ATS_CAP_ON(VFG2_ATS_CAP_ON)
+   ,.VFG3_ATS_CAP_INV_QUEUE_DEPTH(VFG3_ATS_CAP_INV_QUEUE_DEPTH)
+   ,.VFG3_ATS_CAP_NEXTPTR(VFG3_ATS_CAP_NEXTPTR)
+   ,.VFG3_ATS_CAP_ON(VFG3_ATS_CAP_ON)
+
+  ) pcie_4_0_int_inst ( 
+
+    .common_commands_in ('h0), 
+    .pipe_rx_0_sigs     ('h0),
+    .pipe_rx_1_sigs     ('h0),
+    .pipe_rx_2_sigs     ('h0),
+    .pipe_rx_3_sigs     ('h0),
+    .pipe_rx_4_sigs     ('h0),
+    .pipe_rx_5_sigs     ('h0),
+    .pipe_rx_6_sigs     ('h0),
+    .pipe_rx_7_sigs     ('h0),
+    .pipe_rx_8_sigs     ('h0),
+    .pipe_rx_9_sigs     ('h0),
+    .pipe_rx_10_sigs    ('h0),
+    .pipe_rx_11_sigs    ('h0),
+    .pipe_rx_12_sigs    ('h0),
+    .pipe_rx_13_sigs    ('h0),
+    .pipe_rx_14_sigs    ('h0),
+    .pipe_rx_15_sigs    ('h0),
+
+    .common_commands_out( ),  
+    .pipe_tx_0_sigs     ( ),
+    .pipe_tx_1_sigs     ( ),
+    .pipe_tx_2_sigs     ( ),
+    .pipe_tx_3_sigs     ( ),
+    .pipe_tx_4_sigs     ( ),
+    .pipe_tx_5_sigs     ( ),
+    .pipe_tx_6_sigs     ( ),
+    .pipe_tx_7_sigs     ( ),
+    .pipe_tx_8_sigs     ( ),
+    .pipe_tx_9_sigs     ( ),
+    .pipe_tx_10_sigs    ( ),
+    .pipe_tx_11_sigs    ( ),
+    .pipe_tx_12_sigs    ( ),
+    .pipe_tx_13_sigs    ( ),
+    .pipe_tx_14_sigs    ( ),
+    .pipe_tx_15_sigs    ( ),
+
+    .pl_eq_in_progress(pl_eq_in_progress)
+   ,.pl_eq_phase(pl_eq_phase[1:0])
+   ,.pl_eq_reset_eieos_count(pl_eq_reset_eieos_count)
+   ,.pl_gen2_upstream_prefer_deemph(pl_gen2_upstream_prefer_deemph)
+   ,.pl_redo_eq(pl_redo_eq)
+   ,.pl_redo_eq_speed(pl_redo_eq_speed)
+   ,.pl_eq_mismatch(pl_eq_mismatch)
+   ,.pl_redo_eq_pending(pl_redo_eq_pending)
+
+   ,.m_axis_cq_tdata(m_axis_cq_tdata)
+   ,.s_axis_cc_tdata(s_axis_cc_tdata)
+   ,.s_axis_rq_tdata(s_axis_rq_tdata)
+   ,.m_axis_rc_tdata(m_axis_rc_tdata)
+   ,.m_axis_cq_tuser(m_axis_cq_tuser)
+   ,.s_axis_cc_tuser(s_axis_cc_tuser)
+   ,.m_axis_cq_tlast(m_axis_cq_tlast)
+   ,.s_axis_rq_tlast(s_axis_rq_tlast)
+   ,.m_axis_rc_tlast(m_axis_rc_tlast)
+   ,.s_axis_cc_tlast(s_axis_cc_tlast)
+   ,.pcie_cq_np_req(pcie_cq_np_req[1:0])
+   ,.pcie_cq_np_req_count(pcie_cq_np_req_count[5:0])
+   ,.s_axis_rq_tuser(s_axis_rq_tuser)
+   ,.m_axis_rc_tuser(m_axis_rc_tuser)
+   ,.m_axis_cq_tkeep(m_axis_cq_tkeep)
+   ,.s_axis_cc_tkeep(s_axis_cc_tkeep)
+   ,.s_axis_rq_tkeep(s_axis_rq_tkeep)
+   ,.m_axis_rc_tkeep(m_axis_rc_tkeep)
+   ,.m_axis_cq_tvalid(m_axis_cq_tvalid)
+   ,.s_axis_cc_tvalid(s_axis_cc_tvalid)
+   ,.s_axis_rq_tvalid(s_axis_rq_tvalid)
+   ,.m_axis_rc_tvalid(m_axis_rc_tvalid)
+   ,.m_axis_cq_tready(m_axis_cq_tready)
+   ,.s_axis_cc_tready(s_axis_cc_tready)
+   ,.s_axis_rq_tready(s_axis_rq_tready)
+   ,.m_axis_rc_tready(m_axis_rc_tready)
+   ,.pcie_rq_seq_num0(pcie_rq_seq_num0[5:0])
+   ,.pcie_rq_seq_num_vld0(pcie_rq_seq_num_vld0)
+   ,.pcie_rq_seq_num1(pcie_rq_seq_num1[5:0])
+   ,.pcie_rq_seq_num_vld1(pcie_rq_seq_num_vld1)
+   ,.pcie_rq_tag0(pcie_rq_tag0[7:0])
+   ,.pcie_rq_tag_vld0(pcie_rq_tag_vld0)
+   ,.pcie_rq_tag1(pcie_rq_tag1[7:0])
+   ,.pcie_rq_tag_vld1(pcie_rq_tag_vld1)
+   ,.pcie_tfc_nph_av(pcie_tfc_nph_av[3:0])
+   ,.pcie_tfc_npd_av(pcie_tfc_npd_av[3:0])
+   ,.pcie_rq_tag_av(pcie_rq_tag_av[3:0])
+   ,.cfg_mgmt_addr(cfg_mgmt_addr[9:0])
+   ,.cfg_mgmt_function_number(cfg_mgmt_function_number[7:0])
+   ,.cfg_mgmt_write(cfg_mgmt_write)
+   ,.cfg_mgmt_write_data(cfg_mgmt_write_data[31:0])
+   ,.cfg_mgmt_byte_enable(cfg_mgmt_byte_enable[3:0])
+   ,.cfg_mgmt_read(cfg_mgmt_read)
+   ,.cfg_mgmt_read_data(cfg_mgmt_read_data[31:0])
+   ,.cfg_mgmt_read_write_done(cfg_mgmt_read_write_done)
+   ,.cfg_mgmt_debug_access(cfg_mgmt_debug_access)
+   ,.cfg_phy_link_down(cfg_phy_link_down)
+   ,.cfg_phy_link_status(cfg_phy_link_status[1:0])
+   ,.cfg_negotiated_width(cfg_negotiated_width[2:0])
+   ,.cfg_current_speed(cfg_current_speed[1:0])
+   ,.cfg_max_payload(cfg_max_payload[1:0])
+   ,.cfg_max_read_req(cfg_max_read_req[2:0])
+   ,.cfg_function_status(cfg_function_status[15:0])
+   ,.cfg_function_power_state(cfg_function_power_state[11:0])
+   ,.cfg_link_power_state(cfg_link_power_state[1:0])
+   ,.cfg_err_cor_out(cfg_err_cor_out)
+   ,.cfg_err_nonfatal_out(cfg_err_nonfatal_out)
+   ,.cfg_err_fatal_out(cfg_err_fatal_out)
+   ,.cfg_local_error_valid(cfg_local_error_valid)
+   ,.cfg_local_error_out(cfg_local_error_out[4:0])
+   ,.cfg_ltr_enable(cfg_ltr_enable)
+   ,.cfg_ltssm_state(cfg_ltssm_state[5:0])
+   ,.cfg_rx_pm_state(cfg_rx_pm_state[1:0])
+   ,.cfg_tx_pm_state(cfg_tx_pm_state[1:0])
+   ,.cfg_vc1_enable (cfg_vc1_enable)
+   ,.cfg_vc1_negotiation_pending (cfg_vc1_negotiation_pending)
+   ,.cfg_rcb_status(cfg_rcb_status[3:0])
+   ,.cfg_obff_enable(cfg_obff_enable[1:0])
+   ,.cfg_pl_status_change(cfg_pl_status_change)
+   ,.cfg_tph_requester_enable(cfg_tph_requester_enable[3:0])
+   ,.cfg_tph_st_mode(cfg_tph_st_mode[11:0])
+   ,.cfg_msg_received(cfg_msg_received)
+   ,.cfg_msg_received_data(cfg_msg_received_data[7:0])
+   ,.cfg_msg_received_type(cfg_msg_received_type[4:0])
+   ,.cfg_msg_transmit(cfg_msg_transmit)
+   ,.cfg_msg_transmit_type(cfg_msg_transmit_type[2:0])
+   ,.cfg_msg_transmit_data(cfg_msg_transmit_data[31:0])
+   ,.cfg_msg_transmit_done(cfg_msg_transmit_done)
+   ,.cfg_fc_ph(cfg_fc_ph[7:0])
+   ,.cfg_fc_pd(cfg_fc_pd[11:0])
+   ,.cfg_fc_nph(cfg_fc_nph[7:0])
+   ,.cfg_fc_npd(cfg_fc_npd[11:0])
+   ,.cfg_fc_cplh(cfg_fc_cplh[7:0])
+   ,.cfg_fc_cpld(cfg_fc_cpld[11:0])
+   ,.cfg_fc_sel(cfg_fc_sel[2:0])
+   ,.cfg_fc_vc_sel(cfg_fc_vc_sel)
+   ,.cfg_hot_reset_in(cfg_hot_reset_in)
+   ,.cfg_hot_reset_out(cfg_hot_reset_out)
+   ,.cfg_config_space_enable(cfg_config_space_enable)
+   ,.cfg_dsn(cfg_dsn[63:0])
+   ,.cfg_dev_id_pf0(cfg_dev_id_pf0[15:0])
+   ,.cfg_dev_id_pf1(cfg_dev_id_pf1[15:0])
+   ,.cfg_dev_id_pf2(cfg_dev_id_pf2[15:0])
+   ,.cfg_dev_id_pf3(cfg_dev_id_pf3[15:0])
+   ,.cfg_vend_id(cfg_vend_id[15:0])
+   ,.cfg_rev_id_pf0(cfg_rev_id_pf0[7:0])
+   ,.cfg_rev_id_pf1(cfg_rev_id_pf1[7:0])
+   ,.cfg_rev_id_pf2(cfg_rev_id_pf2[7:0])
+   ,.cfg_rev_id_pf3(cfg_rev_id_pf3[7:0])
+   ,.cfg_subsys_id_pf0(cfg_subsys_id_pf0[15:0])
+   ,.cfg_subsys_id_pf1(cfg_subsys_id_pf1[15:0])
+   ,.cfg_subsys_id_pf2(cfg_subsys_id_pf2[15:0])
+   ,.cfg_subsys_id_pf3(cfg_subsys_id_pf3[15:0])
+   ,.cfg_subsys_vend_id(cfg_subsys_vend_id[15:0])
+   ,.cfg_ds_port_number(cfg_ds_port_number[7:0])
+   ,.cfg_ds_bus_number(cfg_ds_bus_number[7:0])
+   ,.cfg_ds_device_number(cfg_ds_device_number[4:0])
+   ,.cfg_bus_number(cfg_bus_number[7:0])
+   ,.cfg_power_state_change_ack(cfg_power_state_change_ack)
+   ,.cfg_power_state_change_interrupt(cfg_power_state_change_interrupt)
+   ,.cfg_err_cor_in(cfg_err_cor_in)
+   ,.cfg_err_uncor_in(cfg_err_uncor_in)
+   ,.cfg_flr_done(cfg_flr_done[3:0])
+   ,.cfg_vf_flr_in_process(cfg_vf_flr_in_process[251:0])
+   ,.cfg_vf_flr_func_num(cfg_vf_flr_func_num[7:0])
+   ,.cfg_vf_flr_done(cfg_vf_flr_done)
+   ,.cfg_vf_status(cfg_vf_status[503:0])
+   ,.cfg_vf_power_state(cfg_vf_power_state[755:0])
+   ,.cfg_vf_tph_requester_enable( cfg_vf_tph_requester_enable[251:0])
+   ,.cfg_vf_tph_st_mode(cfg_vf_tph_st_mode[755:0])
+   ,.cfg_interrupt_msix_vf_enable(cfg_interrupt_msix_vf_enable[251:0])
+   ,.cfg_interrupt_msix_vf_mask(cfg_interrupt_msix_vf_mask[251:0])
+   ,.cfg_flr_in_process(cfg_flr_in_process[3:0])
+   ,.cfg_req_pm_transition_l23_ready(cfg_req_pm_transition_l23_ready)
+   ,.cfg_link_training_enable(cfg_link_training_enable)
+   ,.cfg_interrupt_int(cfg_interrupt_int[3:0])
+   ,.cfg_interrupt_sent(cfg_interrupt_sent)
+   ,.cfg_interrupt_pending(cfg_interrupt_pending[3:0])
+   ,.cfg_interrupt_msi_enable(cfg_interrupt_msi_enable[3:0])
+   ,.cfg_interrupt_msi_int(cfg_interrupt_msi_int[31:0])
+   ,.cfg_interrupt_msi_sent(cfg_interrupt_msi_sent)
+   ,.cfg_interrupt_msi_fail(cfg_interrupt_msi_fail)
+   ,.cfg_interrupt_msi_mmenable(cfg_interrupt_msi_mmenable[11:0])
+   ,.cfg_interrupt_msi_pending_status(cfg_interrupt_msi_pending_status[31:0])
+   ,.cfg_interrupt_msi_pending_status_function_num(cfg_interrupt_msi_pending_status_function_num[1:0])
+   ,.cfg_interrupt_msi_pending_status_data_enable(cfg_interrupt_msi_pending_status_data_enable)
+   ,.cfg_interrupt_msi_mask_update(cfg_interrupt_msi_mask_update)
+   ,.cfg_interrupt_msi_select(cfg_interrupt_msi_select[1:0])
+   ,.cfg_interrupt_msi_data(cfg_interrupt_msi_data[31:0])
+   ,.cfg_interrupt_msix_enable(cfg_interrupt_msix_enable[3:0])
+   ,.cfg_interrupt_msix_mask(cfg_interrupt_msix_mask[3:0])
+   ,.cfg_interrupt_msix_address(cfg_interrupt_msix_address[63:0])
+   ,.cfg_interrupt_msix_data(cfg_interrupt_msix_data[31:0])
+   ,.cfg_interrupt_msix_int(cfg_interrupt_msix_int)
+   ,.cfg_interrupt_msix_vec_pending(cfg_interrupt_msix_vec_pending[1:0])
+   ,.cfg_interrupt_msix_vec_pending_status(cfg_interrupt_msix_vec_pending_status)
+   ,.cfg_interrupt_msi_attr(cfg_interrupt_msi_attr[2:0])
+   ,.cfg_interrupt_msi_tph_present(cfg_interrupt_msi_tph_present)
+   ,.cfg_interrupt_msi_tph_type(cfg_interrupt_msi_tph_type[1:0])
+   ,.cfg_interrupt_msi_tph_st_tag(cfg_interrupt_msi_tph_st_tag[7:0])
+   ,.cfg_interrupt_msi_function_number(cfg_interrupt_msi_function_number[7:0])
+   ,.cfg_ext_read_received(cfg_ext_read_received)
+   ,.cfg_ext_write_received(cfg_ext_write_received)
+   ,.cfg_ext_register_number(cfg_ext_register_number[9:0])
+   ,.cfg_ext_function_number(cfg_ext_function_number[7:0])
+   ,.cfg_ext_write_data(cfg_ext_write_data[31:0])
+   ,.cfg_ext_write_byte_enable(cfg_ext_write_byte_enable[3:0])
+   ,.cfg_ext_read_data(cfg_ext_read_data[31:0])
+   ,.cfg_ext_read_data_valid(cfg_ext_read_data_valid)
+   ,.cfg_pm_aspm_l1_entry_reject(cfg_pm_aspm_l1_entry_reject)
+   ,.cfg_pm_aspm_tx_l0s_entry_disable(cfg_pm_aspm_tx_l0s_entry_disable)
+   ,.conf_req_type(conf_req_type[1:0])
+   ,.conf_req_reg_num(conf_req_reg_num[3:0])
+   ,.conf_req_data(conf_req_data[31:0])
+   ,.conf_req_valid(conf_req_valid)
+   ,.conf_req_ready(conf_req_ready)
+   ,.conf_resp_rdata(conf_resp_rdata[31:0])
+   ,.conf_resp_valid(conf_resp_valid)
+/*
+   ,.conf_mcap_design_switch(conf_mcap_design_switch)
+   ,.conf_mcap_eos(conf_mcap_eos)
+   ,.conf_mcap_in_use_by_pcie(conf_mcap_in_use_by_pcie)
+   ,.conf_mcap_request_by_conf(conf_mcap_request_by_conf)
+
+   ,.dbg_data0_out(dbg_data0_out)
+   ,.dbg_ctrl0_out(dbg_ctrl0_out)
+   ,.dbg_sel0(dbg_sel0)
+   ,.dbg_data1_out(dbg_data1_out)
+   ,.dbg_ctrl1_out(dbg_ctrl1_out)
+   ,.dbg_sel1(dbg_sel1)
+
+   ,.scanmode_n(scanmode_n)
+   ,.scanenable_n(scanenable_n)
+   ,.scanin(scanin[149:0])
+   ,.scanout(scanout[149:0])
+   ,.pcie_perst0_b(pcie_perst0_b)
+   ,.pcie_perst1_b(pcie_perst1_b)
+   ,.pmv_enable_n(pmv_enable_n)
+   ,.pmv_select(pmv_select [2:0])
+   ,.pmv_divide(pmv_divide[1:0])
+   ,.pmv_out(pmv_out)
+   ,.user_spare_in(user_spare_in[31:0])
+   ,.user_spare_out(user_spare_out[31:0])
+   ,.drp_clk(drp_clk)
+   ,.drp_en(drp_en)
+   ,.drp_we(drp_we)
+   ,.drp_addr(drp_addr[9:0])
+   ,.drp_di(drp_di[15:0])
+   ,.drp_rdy(drp_rdy)
+   ,.drp_do(drp_do[15:0])
+*/
+
+   ,.user_clk(user_clk)
+   ,.core_clk(core_clk)
+   ,.user_reset(user_reset)
+   ,.user_lnk_up(user_lnk_up)
+   ,.sys_clk(sys_clk)
+   ,.sys_clk_gt(sys_clk_gt)
+   ,.sys_reset(sys_reset)
+   ,.pci_exp_rxp(pci_exp_rxp)
+   ,.pci_exp_rxn(pci_exp_rxn)
+   ,.pci_exp_txp(pci_exp_txp)
+   ,.pci_exp_txn(pci_exp_txn)
+   //-------------------------------------------
+   // CCIX Transmit TLP Interface		       
+   //-------------------------------------------
+   ,.s_axis_ccix_tx_tdata(s_axis_ccix_tx_tdata)
+   ,.s_axis_ccix_tx_tvalid(s_axis_ccix_tx_tvalid)
+   ,.s_axis_ccix_tx_tuser(s_axis_ccix_tx_tuser)
+   ,.ccix_tx_credit(ccix_tx_credit)
+   //-----------------------------------------------------------------------
+   // CCIX Receive TLP Interface
+   // Data to CCIX protocol processing block
+   //-----------------------------------------------------------------------
+   ,.m_axis_ccix_rx_tdata(m_axis_ccix_rx_tdata) // 256-bit data
+   ,.m_axis_ccix_rx_tvalid(m_axis_ccix_rx_tvalid)
+   ,.m_axis_ccix_rx_tuser(m_axis_ccix_rx_tuser) // tuser bus
+   ,.ccix_rx_credit(ccix_rx_credit)
+   ,.ccix_rx_credit_av(ccix_rx_credit_av)
+   ,.ccix_optimized_tlp_tx_and_rx_enable(ccix_optimized_tlp_tx_and_rx_enable)
+);
+
+endmodule
+
diff --git a/sim/tb/RP_model/sys_clk_gen.v b/sim/tb/RP_model/sys_clk_gen.v
new file mode 100644
index 0000000..7e63a8d
--- /dev/null
+++ b/sim/tb/RP_model/sys_clk_gen.v
@@ -0,0 +1,78 @@
+
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2025 Advanced Micro Devices, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : PCI Express DMA 
+// File       : sys_clk_gen.v
+// Version    : 5.0
+//-----------------------------------------------------------------------------
+//--
+//--------------------------------------------------------------------------------
+`timescale 1ps/1ps
+
+module sys_clk_gen (sys_clk);
+
+output	sys_clk;
+
+reg		sys_clk;
+
+parameter        offset = 0;
+parameter        halfcycle = 5000;
+
+initial begin
+
+	sys_clk = 0;
+	#(offset);
+
+	forever #(halfcycle) sys_clk = ~sys_clk;
+
+end
+
+endmodule // sys_clk_gen
diff --git a/sim/tb/RP_model/sys_clk_gen_ds.v b/sim/tb/RP_model/sys_clk_gen_ds.v
new file mode 100644
index 0000000..34d3abf
--- /dev/null
+++ b/sim/tb/RP_model/sys_clk_gen_ds.v
@@ -0,0 +1,84 @@
+
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2025 Advanced Micro Devices, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : PCI Express DMA 
+// File       : sys_clk_gen_ds.v
+// Version    : 5.0
+//-----------------------------------------------------------------------------
+//--
+//--------------------------------------------------------------------------------
+
+`timescale 1ps/1ps
+
+module sys_clk_gen_ds (sys_clk_p, sys_clk_n);
+
+output	         sys_clk_p;
+output	         sys_clk_n;
+
+parameter        offset = 0;
+parameter        halfcycle = 500;
+
+
+sys_clk_gen 	#(
+
+                 .offset( offset ),
+                 .halfcycle( halfcycle )
+
+)
+clk_gen (
+
+                 .sys_clk(sys_clk_p)
+
+);
+
+assign sys_clk_n = !sys_clk_p;
+
+endmodule // sys_clk_gen_ds
diff --git a/sim/tb/RP_model/xilinx_pcie_uscale_rp.v b/sim/tb/RP_model/xilinx_pcie_uscale_rp.v
new file mode 100644
index 0000000..197d972
--- /dev/null
+++ b/sim/tb/RP_model/xilinx_pcie_uscale_rp.v
@@ -0,0 +1,733 @@
+
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2025 Advanced Micro Devices, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : PCI Express DMA 
+// File       : xilinx_pcie_uscale_rp.v
+// Version    : 5.0
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+//--
+//-- Description:  PCI Express DSPORT Model Top for Endpoint example FPGA design
+//--
+//------------------------------------------------------------------------------
+
+`timescale 1ps / 1ps
+
+module xilinx_pcie4_uscale_rp # (
+  parameter        C_DATA_WIDTH                   = 512,    // RX/TX interface data width
+  parameter        EXT_PIPE_SIM                   = "FALSE",  // This Parameter has effect on selecting Enable External PIPE Interface in GUI.
+
+  parameter        PL_LINK_CAP_MAX_LINK_SPEED     = 4,   // 1- GEN1, 2 - GEN2, 4 - GEN3, 8 - GEN4
+  parameter  [4:0] PL_LINK_CAP_MAX_LINK_WIDTH     = 16,  // 1- X1, 2 - X2, 4 - X4, 8 - X8, 16 - X16
+
+  parameter  [2:0] PF0_DEV_CAP_MAX_PAYLOAD_SIZE   = 3'h0,
+  parameter        PL_DISABLE_EI_INFER_IN_L0      = "TRUE",
+  parameter        PL_DISABLE_UPCONFIG_CAPABLE    = "FALSE",
+
+  parameter        REF_CLK_FREQ                   = 0,                 // 0 - 100 MHz, 1 - 125 MHz,  2 - 250 MHz
+  parameter        AXISTEN_IF_RQ_ALIGNMENT_MODE   = "FALSE",
+  parameter        AXISTEN_IF_CC_ALIGNMENT_MODE   = "FALSE",
+  parameter        AXISTEN_IF_CQ_ALIGNMENT_MODE   = "FALSE",
+  parameter        AXISTEN_IF_RC_ALIGNMENT_MODE   = "FALSE",
+  parameter        AXI4_CQ_TUSER_WIDTH = 183,
+  parameter        AXI4_CC_TUSER_WIDTH = 81,
+  parameter        AXI4_RQ_TUSER_WIDTH = 137,
+  parameter        AXI4_RC_TUSER_WIDTH = 161,
+  parameter        AXISTEN_IF_ENABLE_CLIENT_TAG   = "TRUE",
+  parameter        AXISTEN_IF_RQ_PARITY_CHECK     = 0,
+  parameter        AXISTEN_IF_CC_PARITY_CHECK     = 0,
+  parameter        AXISTEN_IF_RC_PARITY_CHECK     = 0,
+  parameter        AXISTEN_IF_CQ_PARITY_CHECK     = 0,
+  parameter        AXISTEN_IF_MC_RX_STRADDLE      = "FALSE",
+  parameter        AXISTEN_IF_ENABLE_RX_MSG_INTFC = "FALSE",
+  parameter [17:0] AXISTEN_IF_ENABLE_MSG_ROUTE    = 18'h2FFFF,
+  parameter KEEP_WIDTH                            = C_DATA_WIDTH / 32
+)
+(
+  output  [(PL_LINK_CAP_MAX_LINK_WIDTH - 1) : 0]  pci_exp_txp,
+  output  [(PL_LINK_CAP_MAX_LINK_WIDTH - 1) : 0]  pci_exp_txn,
+  input   [(PL_LINK_CAP_MAX_LINK_WIDTH - 1) : 0]  pci_exp_rxp,
+  input   [(PL_LINK_CAP_MAX_LINK_WIDTH - 1) : 0]  pci_exp_rxn,
+  input                                           sys_clk_p,
+  input                                           sys_clk_n,
+  input                                           sys_rst_n
+);
+
+  localparam         TCQ = 1;
+  localparam         EP_DEV_ID = 16'h903F;
+
+  //----------------------------------------------------------------------------------------------------------------//
+  // 3. AXI Interface                                                                                               //
+  //----------------------------------------------------------------------------------------------------------------//
+
+  wire                                       user_clk;
+  wire                                       user_reset;
+  wire                                       user_lnk_up;
+
+  wire                                       s_axis_rq_tlast;
+  wire                 [C_DATA_WIDTH-1:0]    s_axis_rq_tdata;
+  wire             [AXI4_RQ_TUSER_WIDTH-1:0] s_axis_rq_tuser;
+  wire                   [KEEP_WIDTH-1:0]    s_axis_rq_tkeep;
+  wire                                       s_axis_rq_tready;
+  wire                                       s_axis_rq_tvalid;
+
+  wire                 [C_DATA_WIDTH-1:0]    m_axis_rc_tdata;
+  wire             [AXI4_RC_TUSER_WIDTH-1:0] m_axis_rc_tuser;
+  wire                                       m_axis_rc_tlast;
+  wire                   [KEEP_WIDTH-1:0]    m_axis_rc_tkeep;
+  wire                                       m_axis_rc_tvalid;
+  wire                                       m_axis_rc_tready;
+
+  wire                 [C_DATA_WIDTH-1:0]    m_axis_cq_tdata;
+  wire             [AXI4_CQ_TUSER_WIDTH-1:0] m_axis_cq_tuser;
+  wire                                       m_axis_cq_tlast;
+  wire                   [KEEP_WIDTH-1:0]    m_axis_cq_tkeep;
+  wire                                       m_axis_cq_tvalid;
+  wire                                       m_axis_cq_tready;
+
+  wire                 [C_DATA_WIDTH-1:0]    s_axis_cc_tdata;
+  wire             [AXI4_CC_TUSER_WIDTH-1:0] s_axis_cc_tuser;
+  wire                                       s_axis_cc_tlast;
+  wire                   [KEEP_WIDTH-1:0]    s_axis_cc_tkeep;
+  wire                                       s_axis_cc_tvalid;
+  wire                                       s_axis_cc_tready;
+
+  wire                              [3:0]    pcie_tfc_nph_av;
+  wire                              [3:0]    pcie_tfc_npd_av;
+  wire                              [3:0]    pcie_rq_seq_num;
+  wire                                       pcie_rq_seq_num_vld;
+  wire                              [5:0]    pcie_rq_tag;
+  wire                                       pcie_rq_tag_vld;
+  wire                              [1:0]    pcie_rq_tag_av;
+
+  wire                                       pcie_cq_np_req;
+  wire                              [5:0]    pcie_cq_np_req_count;
+
+  //----------------------------------------------------------------------------------------------------------------//
+  // 4. Configuration (CFG) Interface                                                                               //
+  //----------------------------------------------------------------------------------------------------------------//
+
+  //----------------------------------------------------------------------------------------------------------------//
+  // EP and RP                                                                                                      //
+  //----------------------------------------------------------------------------------------------------------------//
+
+  wire                                       cfg_phy_link_down;
+  wire                              [1:0]    cfg_phy_link_status;
+  wire                              [2:0]    cfg_negotiated_width;
+  wire                              [1:0]    cfg_current_speed;
+  wire                              [1:0]    cfg_max_payload;
+  wire                              [2:0]    cfg_max_read_req;
+  wire                             [15:0]    cfg_function_status;
+  wire                             [11:0]    cfg_function_power_state;
+  wire                             [503:0]    cfg_vf_status;
+  wire                             [755:0]    cfg_vf_power_state;
+  wire                              [1:0]    cfg_link_power_state;
+
+  // Management Interface
+  wire                             [9:0]    cfg_mgmt_addr;
+  wire                                       cfg_mgmt_write;
+  wire                             [31:0]    cfg_mgmt_write_data;
+  wire                              [3:0]    cfg_mgmt_byte_enable;
+  wire                                       cfg_mgmt_read;
+  wire                             [31:0]    cfg_mgmt_read_data;
+  wire                                       cfg_mgmt_read_write_done;
+  wire                                       cfg_mgmt_type1_cfg_reg_access;
+
+  // Error Reporting Interface
+  wire                                       cfg_err_cor_out;
+  wire                                       cfg_err_nonfatal_out;
+  wire                                       cfg_err_fatal_out;
+  wire                                       cfg_local_error;
+
+  wire                              [5:0]    cfg_ltssm_state;
+  wire                              [3:0]    cfg_rcb_status;
+  wire                              [3:0]    cfg_dpa_substate_change;
+  wire                              [1:0]    cfg_obff_enable;
+  wire                                       cfg_pl_status_change;
+
+  wire                              [3:0]    cfg_tph_requester_enable;
+  wire                             [11:0]    cfg_tph_st_mode;
+  wire                              [251:0]    cfg_vf_tph_requester_enable;
+  wire                             [755:0]    cfg_vf_tph_st_mode;
+
+  wire                                       cfg_msg_received;
+  wire                              [7:0]    cfg_msg_received_data;
+  wire                              [4:0]    cfg_msg_received_type;
+
+  wire                                       cfg_msg_transmit;
+  wire                              [2:0]    cfg_msg_transmit_type;
+  wire                             [31:0]    cfg_msg_transmit_data;
+  wire                                       cfg_msg_transmit_done;
+
+  wire                              [7:0]    cfg_fc_ph;
+  wire                             [11:0]    cfg_fc_pd;
+  wire                              [7:0]    cfg_fc_nph;
+  wire                             [11:0]    cfg_fc_npd;
+  wire                              [7:0]    cfg_fc_cplh;
+  wire                             [11:0]    cfg_fc_cpld;
+  wire                              [2:0]    cfg_fc_sel;
+
+  wire                              [2:0]    cfg_per_func_status_control;
+  wire                             [15:0]    cfg_per_func_status_data;
+  wire                              [2:0]    cfg_per_function_number;
+  wire                                       cfg_per_function_output_request;
+  wire                                       cfg_per_function_update_done;
+
+  wire                             [63:0]    cfg_dsn;
+  wire                                       cfg_power_state_change_ack;
+  wire                                       cfg_power_state_change_interrupt;
+  wire                                       cfg_err_cor_in;
+  wire                                       cfg_err_uncor_in;
+
+  wire                              [3:0]    cfg_flr_in_process;
+  wire                              [1:0]    cfg_flr_done;
+  wire                              [251:0]    cfg_vf_flr_in_process;
+  wire                                  cfg_vf_flr_done;
+
+  wire                                       cfg_link_training_enable;
+  wire                              [7:0]    cfg_ds_port_number;
+
+
+
+  //----------------------------------------------------------------------------------------------------------------//
+  // EP Only                                                                                                        //
+  //----------------------------------------------------------------------------------------------------------------//
+
+  // Interrupt Interface Signals
+  wire                              [3:0]    cfg_interrupt_int;
+  wire                              [1:0]    cfg_interrupt_pending;
+  wire                                       cfg_interrupt_sent;
+
+  wire                              [1:0]    cfg_interrupt_msix_enable;
+  wire                              [1:0]    cfg_interrupt_msix_mask;
+  wire                              [5:0]    cfg_interrupt_msix_vf_enable;
+  wire                              [5:0]    cfg_interrupt_msix_vf_mask;
+  wire                             [31:0]    cfg_interrupt_msix_data;
+  wire                             [63:0]    cfg_interrupt_msix_address;
+  wire                                       cfg_interrupt_msix_int;
+  wire                                       cfg_interrupt_msix_sent;
+  wire                                       cfg_interrupt_msix_fail;
+
+
+// EP only
+  wire                                       cfg_hot_reset_out;
+  wire                                       cfg_config_space_enable;
+  wire                                       cfg_req_pm_transition_l23_ready;
+
+// RP only
+  wire                                       cfg_hot_reset_in;
+
+  wire                              [7:0]    cfg_ds_bus_number;
+  wire                              [4:0]    cfg_ds_device_number;
+
+  //----------------------------------------------------------------------------------------------------------------//
+  // 8. System(SYS) Interface                                                                                       //
+  //----------------------------------------------------------------------------------------------------------------//
+
+  wire                                       sys_clk;
+  wire                                       sys_clk_gt;
+  wire                                       sys_rst_n_c;
+
+  //-----------------------------------------------------------------------------------------------------------------------
+
+  IBUF   sys_reset_n_ibuf (.O(sys_rst_n_c), .I(sys_rst_n));
+
+  IBUFDS_GTE4 refclk_ibuf (.O(sys_clk_gt), .ODIV2(sys_clk), .I(sys_clk_p), .CEB(1'b0), .IB(sys_clk_n));
+
+
+  wire [15:0]  cfg_vend_id        = 16'h10EE;
+
+  wire [15:0]  cfg_dev_id         = 16'h903F;
+  wire [15:0]  cfg_subsys_id      = 16'h0007;
+  wire [7:0]   cfg_rev_id         = 8'h00;
+  wire [15:0]  cfg_subsys_vend_id = 16'h10EE;
+
+  wire  [63:0] cfg_interrupt_msi_pending_status;
+  wire  [3:0]  cfg_interrupt_msi_select;
+  wire  [31:0] cfg_interrupt_msi_int;
+  wire  [2:0]  cfg_interrupt_msi_attr;
+  wire         cfg_interrupt_msi_tph_present;
+  wire  [1:0]  cfg_interrupt_msi_tph_type;
+  wire  [7:0]  cfg_interrupt_msi_tph_st_tag;
+  wire  [2:0]  cfg_interrupt_msi_function_number;
+
+  //--------------------------------------------------------------------------------------------------------------------//
+  // Instantiate Root Port wrapper
+  //--------------------------------------------------------------------------------------------------------------------//
+  // Core Top Level Wrapper
+ pcie_4_c_rp pcie_4_0_rport (
+    //---------------------------------------------------------------------------------------//
+    //  PCI Express (pci_exp) Interface                                                      //
+    //---------------------------------------------------------------------------------------//
+    .cfg_vend_id                                    (cfg_vend_id),
+    .cfg_dev_id_pf0                                 (cfg_dev_id),
+    .cfg_dev_id_pf1                                 (cfg_dev_id),
+    .cfg_dev_id_pf2                                 (cfg_dev_id),
+    .cfg_dev_id_pf3                                 (cfg_dev_id),
+    .cfg_rev_id_pf0                                 (cfg_rev_id),
+    .cfg_rev_id_pf1                                 (cfg_rev_id),
+    .cfg_rev_id_pf2                                 (cfg_rev_id),
+    .cfg_rev_id_pf3                                 (cfg_rev_id),
+    .cfg_subsys_id_pf0                              (cfg_subsys_id),
+    .cfg_subsys_id_pf1                              (cfg_subsys_id),
+    .cfg_subsys_id_pf2                              (cfg_subsys_id),
+    .cfg_subsys_id_pf3                              (cfg_subsys_id),
+    .cfg_subsys_vend_id                             (cfg_subsys_vend_id),
+
+    .cfg_mgmt_debug_access                          (1'b0),
+    .cfg_mgmt_function_number                       (8'b0),
+
+    .cfg_vf_flr_func_num                            (8'b0),
+    .conf_req_type                                  (2'b0),
+    .conf_req_reg_num                               (4'b0),
+    .conf_req_data                                  (32'b0),
+    .conf_req_valid                                 (1'b0),
+
+    .pl_gen2_upstream_prefer_deemph                 (1'b0),
+    .pl_redo_eq                                     (1'b0),
+    .pl_redo_eq_speed                               (1'b0),
+
+    //---------------------------------------------------------------------------------------//
+    //  PCI Express (pci_exp) Interface                                                      //
+    //---------------------------------------------------------------------------------------//
+
+    // Tx
+    .pci_exp_txn                                    ( pci_exp_txn ),
+    .pci_exp_txp                                    ( pci_exp_txp ),
+
+    // Rx
+    .pci_exp_rxn                                    ( pci_exp_rxn ),
+    .pci_exp_rxp                                    ( pci_exp_rxp ),
+
+
+   //---------------------------------------------------------------------------------------//
+    //  AXI Interface                                                                        //
+    //---------------------------------------------------------------------------------------//
+
+    .user_clk                                       ( user_clk ),
+    .user_reset                                     ( user_reset ),
+    .user_lnk_up                                    ( user_lnk_up ),
+
+    .s_axis_rq_tlast                                ( s_axis_rq_tlast ),
+    .s_axis_rq_tdata                                ( s_axis_rq_tdata ),
+    .s_axis_rq_tuser                                ( s_axis_rq_tuser ),
+    .s_axis_rq_tkeep                                ( s_axis_rq_tkeep ),
+    .s_axis_rq_tready                               ( s_axis_rq_tready ),
+    .s_axis_rq_tvalid                               ( s_axis_rq_tvalid ),
+
+    .m_axis_rc_tdata                                ( m_axis_rc_tdata ),
+    .m_axis_rc_tuser                                ( m_axis_rc_tuser ),
+    .m_axis_rc_tlast                                ( m_axis_rc_tlast ),
+    .m_axis_rc_tkeep                                ( m_axis_rc_tkeep ),
+    .m_axis_rc_tvalid                               ( m_axis_rc_tvalid ),
+    .m_axis_rc_tready                               ( {22{m_axis_rc_tready}} ),
+
+
+    .m_axis_cq_tdata                                ( m_axis_cq_tdata ),
+    .m_axis_cq_tuser                                ( m_axis_cq_tuser ),
+    .m_axis_cq_tlast                                ( m_axis_cq_tlast ),
+    .m_axis_cq_tkeep                                ( m_axis_cq_tkeep ),
+    .m_axis_cq_tvalid                               ( m_axis_cq_tvalid ),
+    .m_axis_cq_tready                               ( {22{m_axis_cq_tready}} ),
+
+    .s_axis_cc_tdata                                ( s_axis_cc_tdata ),
+    .s_axis_cc_tuser                                ( s_axis_cc_tuser ),
+    .s_axis_cc_tlast                                ( s_axis_cc_tlast ),
+    .s_axis_cc_tkeep                                ( s_axis_cc_tkeep ),
+    .s_axis_cc_tvalid                               ( s_axis_cc_tvalid ),
+    .s_axis_cc_tready                               ( s_axis_cc_tready ),
+
+    //---------------------------------------------------------------------------------------//
+    //  Configuration (CFG) Interface                                                        //
+    //---------------------------------------------------------------------------------------//
+
+    .pcie_cq_np_req                                 ( {1'b0,pcie_cq_np_req} ),
+    .pcie_cq_np_req_count                           ( pcie_cq_np_req_count ),
+    .cfg_phy_link_down                              ( cfg_phy_link_down ),
+    .cfg_phy_link_status                            ( ),
+    .cfg_negotiated_width                           ( cfg_negotiated_width ),
+    .cfg_current_speed                              ( cfg_current_speed ),
+    .cfg_max_payload                                ( cfg_max_payload ),
+    .cfg_max_read_req                               ( cfg_max_read_req ),
+    .cfg_function_status                            ( cfg_function_status ),
+    .cfg_function_power_state                       ( cfg_function_power_state ),
+    .cfg_vf_status                                  ( cfg_vf_status ),
+    .cfg_vf_power_state                             ( cfg_vf_power_state ),
+    .cfg_link_power_state                           ( cfg_link_power_state ),
+    // Error Reporting Interface
+    .cfg_err_cor_out                                ( cfg_err_cor_out ),
+    .cfg_err_nonfatal_out                           ( cfg_err_nonfatal_out ),
+    .cfg_err_fatal_out                              ( cfg_err_fatal_out ),
+
+    .cfg_local_error_out                                ( ),
+
+    .cfg_ltssm_state                                ( cfg_ltssm_state ),
+    .cfg_rcb_status                                 ( cfg_rcb_status ),
+
+    .cfg_obff_enable                                ( cfg_obff_enable ),
+    .cfg_pl_status_change                           ( cfg_pl_status_change ),
+
+    .cfg_tph_requester_enable                       ( cfg_tph_requester_enable ),
+    .cfg_tph_st_mode                                ( cfg_tph_st_mode ),
+    .cfg_vf_tph_requester_enable                    ( cfg_vf_tph_requester_enable ),
+    .cfg_vf_tph_st_mode                             ( cfg_vf_tph_st_mode ),
+
+
+    // Management Interface
+    .cfg_mgmt_addr                                  ( cfg_mgmt_addr ),
+    .cfg_mgmt_write                                 ( cfg_mgmt_write ),
+    .cfg_mgmt_write_data                            ( cfg_mgmt_write_data ),
+    .cfg_mgmt_byte_enable                           ( cfg_mgmt_byte_enable ),
+    .cfg_mgmt_read                                  ( cfg_mgmt_read ),
+    .cfg_mgmt_read_data                             ( cfg_mgmt_read_data ),
+    .cfg_mgmt_read_write_done                       ( cfg_mgmt_read_write_done ),
+    //.cfg_mgmt_type1_cfg_reg_access                  ( cfg_mgmt_type1_cfg_reg_access ),//Additional
+    .pcie_tfc_nph_av                                ( pcie_tfc_nph_av ),
+    .pcie_tfc_npd_av                                ( pcie_tfc_npd_av ),
+    .cfg_msg_received                               ( cfg_msg_received ),
+    .cfg_msg_received_data                          ( cfg_msg_received_data ),
+    .cfg_msg_received_type                          ( cfg_msg_received_type ),
+
+    .cfg_msg_transmit                               ( cfg_msg_transmit ),
+    .cfg_msg_transmit_type                          ( cfg_msg_transmit_type ),
+    .cfg_msg_transmit_data                          ( cfg_msg_transmit_data ),
+    .cfg_msg_transmit_done                          ( cfg_msg_transmit_done ),
+
+    .cfg_fc_ph                                      ( cfg_fc_ph ),
+    .cfg_fc_pd                                      ( cfg_fc_pd ),
+    .cfg_fc_nph                                     ( cfg_fc_nph ),
+    .cfg_fc_npd                                     ( cfg_fc_npd ),
+    .cfg_fc_cplh                                    ( cfg_fc_cplh ),
+    .cfg_fc_cpld                                    ( cfg_fc_cpld ),
+    .cfg_fc_sel                                     ( cfg_fc_sel ),
+
+  //-------------------------------------------------------------------------------//
+    // EP and RP                                                                     //
+    //-------------------------------------------------------------------------------//
+
+    .cfg_bus_number                                 ( ),
+    .cfg_dsn                                        ( cfg_dsn ),
+    .cfg_power_state_change_ack                     ( cfg_power_state_change_ack ),
+    .cfg_power_state_change_interrupt               ( cfg_power_state_change_interrupt ),
+    .cfg_err_cor_in                                 ( cfg_err_cor_in ),
+    .cfg_err_uncor_in                               ( cfg_err_uncor_in ),
+
+    .cfg_flr_in_process                             ( cfg_flr_in_process ),
+    .cfg_flr_done                                   ( {2'b0,cfg_flr_done} ),
+    .cfg_vf_flr_in_process                          ( cfg_vf_flr_in_process ),
+    .cfg_vf_flr_done                                ( cfg_vf_flr_done ),
+    .cfg_link_training_enable                       ( cfg_link_training_enable ),
+  // EP only
+    .cfg_hot_reset_out                              ( cfg_hot_reset_out ),
+    .cfg_config_space_enable                        ( cfg_config_space_enable ),
+    .cfg_req_pm_transition_l23_ready                ( cfg_req_pm_transition_l23_ready ),
+
+  // RP only
+    .cfg_hot_reset_in                               ( cfg_hot_reset_in ),
+
+    .cfg_ds_bus_number                              ( cfg_ds_bus_number ),
+    .cfg_ds_device_number                           ( cfg_ds_device_number ),
+    .cfg_ds_port_number                             ( cfg_ds_port_number ),
+    .cfg_ext_read_received                          ( cfg_ext_read_received ),
+    .cfg_ext_write_received                         ( cfg_ext_write_received ),
+    .cfg_ext_register_number                        ( cfg_ext_register_number ),
+    .cfg_ext_function_number                        ( cfg_ext_function_number ),
+    .cfg_ext_write_data                             ( cfg_ext_write_data ),
+    .cfg_ext_write_byte_enable                      ( cfg_ext_write_byte_enable ),
+    .cfg_ext_read_data                              ( cfg_ext_read_data ),
+    .cfg_ext_read_data_valid                        ( cfg_ext_read_data_valid ),
+
+
+    //-------------------------------------------------------------------------------//
+    // EP Only                                                                       //
+    //-------------------------------------------------------------------------------//
+
+    // Interrupt Interface Signals
+    .cfg_interrupt_int                              ( cfg_interrupt_int ),
+    .cfg_interrupt_pending                          ( {2'b0,cfg_interrupt_pending} ),
+    .cfg_interrupt_sent                             ( cfg_interrupt_sent ),
+
+    .cfg_interrupt_msi_enable                       ( cfg_interrupt_msi_enable ),
+    .cfg_interrupt_msi_mmenable                     ( cfg_interrupt_msi_mmenable ),
+    .cfg_interrupt_msi_mask_update                  ( cfg_interrupt_msi_mask_update ),
+    .cfg_interrupt_msi_data                         ( cfg_interrupt_msi_data ),
+    .cfg_interrupt_msi_select                       ( cfg_interrupt_msi_select ),
+    .cfg_interrupt_msi_int                          ( cfg_interrupt_msi_int ),
+    .cfg_interrupt_msi_pending_status               ( cfg_interrupt_msi_pending_status[31:0]),
+    .cfg_interrupt_msi_sent                         ( cfg_interrupt_msi_sent ),
+    .cfg_interrupt_msi_fail                         ( cfg_interrupt_msi_fail ),
+    .cfg_interrupt_msi_attr                         ( cfg_interrupt_msi_attr ),
+    .cfg_interrupt_msi_tph_present                  ( cfg_interrupt_msi_tph_present ),
+    .cfg_interrupt_msi_tph_type                     ( cfg_interrupt_msi_tph_type ),
+    .cfg_interrupt_msi_tph_st_tag                   ( cfg_interrupt_msi_tph_st_tag ),
+    .cfg_interrupt_msi_function_number              (8'b0 ),
+    .cfg_interrupt_msi_pending_status_function_num  (4'b0),
+    .cfg_interrupt_msi_pending_status_data_enable   (1'b0),
+
+    .cfg_pm_aspm_l1_entry_reject                    (1'b0),
+    .cfg_pm_aspm_tx_l0s_entry_disable               (1'b1),
+
+    //--------------------------------------------------------------------------------------//
+    //  System(SYS) Interface                                                               //
+    //--------------------------------------------------------------------------------------//
+
+    .sys_clk                                        ( sys_clk ),
+    .sys_clk_gt                                     ( sys_clk_gt ),
+    .sys_reset                                      ( sys_rst_n_c )
+
+
+  );
+
+  pci_exp_usrapp_rx # (
+    .AXISTEN_IF_CC_ALIGNMENT_MODE     ( AXISTEN_IF_CC_ALIGNMENT_MODE ),
+    .AXISTEN_IF_CQ_ALIGNMENT_MODE     ( AXISTEN_IF_CQ_ALIGNMENT_MODE ),
+    .AXISTEN_IF_RC_ALIGNMENT_MODE     ( AXISTEN_IF_RC_ALIGNMENT_MODE ),
+    .AXISTEN_IF_RQ_ALIGNMENT_MODE     ( AXISTEN_IF_RQ_ALIGNMENT_MODE ),
+    .AXISTEN_IF_RC_PARITY_CHECK       ( AXISTEN_IF_RC_PARITY_CHECK   ),
+    .AXISTEN_IF_CQ_PARITY_CHECK       ( AXISTEN_IF_CQ_PARITY_CHECK   ),
+    .C_DATA_WIDTH                     ( C_DATA_WIDTH                 )
+  ) rx_usrapp (
+    .m_axis_cq_tdata(m_axis_cq_tdata),
+    .m_axis_cq_tlast(m_axis_cq_tlast),
+    .m_axis_cq_tvalid(m_axis_cq_tvalid),
+    .m_axis_cq_tuser(m_axis_cq_tuser),
+    .m_axis_cq_tkeep(m_axis_cq_tkeep),
+    .pcie_cq_np_req_count(pcie_cq_np_req_count),
+    .m_axis_cq_tready(m_axis_cq_tready),
+    .m_axis_rc_tdata(m_axis_rc_tdata),
+    .m_axis_rc_tlast(m_axis_rc_tlast),
+    .m_axis_rc_tvalid(m_axis_rc_tvalid),
+    .m_axis_rc_tuser(m_axis_rc_tuser),
+    .m_axis_rc_tkeep(m_axis_rc_tkeep),
+    .m_axis_rc_tready(m_axis_rc_tready),
+    .pcie_cq_np_req(pcie_cq_np_req),
+    .user_clk(user_clk),
+    .user_reset(user_reset),
+    .user_lnk_up(user_lnk_up)
+
+  );
+
+  // Tx User Application Interface
+  pci_exp_usrapp_tx # (
+    .C_DATA_WIDTH                     ( C_DATA_WIDTH),
+    .DEV_CAP_MAX_PAYLOAD_SUPPORTED    ( PF0_DEV_CAP_MAX_PAYLOAD_SIZE ),
+    .AXISTEN_IF_CC_ALIGNMENT_MODE     ( AXISTEN_IF_CC_ALIGNMENT_MODE ),
+    .AXISTEN_IF_CQ_ALIGNMENT_MODE     ( AXISTEN_IF_CQ_ALIGNMENT_MODE ),
+    .AXISTEN_IF_RC_ALIGNMENT_MODE     ( AXISTEN_IF_RC_ALIGNMENT_MODE ),
+    .AXISTEN_IF_RQ_ALIGNMENT_MODE     ( AXISTEN_IF_RQ_ALIGNMENT_MODE ),
+    .AXISTEN_IF_RQ_PARITY_CHECK       ( AXISTEN_IF_RQ_PARITY_CHECK   ),
+    .AXISTEN_IF_CC_PARITY_CHECK       ( AXISTEN_IF_CC_PARITY_CHECK   ),
+    .EP_DEV_ID                        ( EP_DEV_ID                    )
+  ) tx_usrapp (
+  .s_axis_rq_tlast    (s_axis_rq_tlast),
+  .s_axis_rq_tdata    (s_axis_rq_tdata),
+  .s_axis_rq_tuser    (s_axis_rq_tuser),
+  .s_axis_rq_tkeep    (s_axis_rq_tkeep),
+  .s_axis_rq_tready   (s_axis_rq_tready),
+  .s_axis_rq_tvalid   (s_axis_rq_tvalid),
+  .s_axis_cc_tdata    (s_axis_cc_tdata),
+  .s_axis_cc_tuser    (s_axis_cc_tuser),
+  .s_axis_cc_tlast    (s_axis_cc_tlast),
+  .s_axis_cc_tkeep    (s_axis_cc_tkeep),
+  .s_axis_cc_tvalid   (s_axis_cc_tvalid),
+  .s_axis_cc_tready   (s_axis_cc_tready),
+  .pcie_rq_seq_num    (pcie_rq_seq_num),
+  .pcie_rq_seq_num_vld(pcie_rq_seq_num_vld),
+  .pcie_rq_tag        (pcie_rq_tag),
+  .pcie_rq_tag_vld    (pcie_rq_tag_vld),
+  .pcie_tfc_nph_av    (pcie_tfc_nph_av),
+  .pcie_tfc_npd_av    (pcie_tfc_npd_av),
+  .speed_change_done_n(),
+  .user_clk           (user_clk),
+  .reset            (user_reset),
+  .user_lnk_up      (user_lnk_up)
+
+
+  );
+
+  // Cfg UsrApp
+
+  pci_exp_usrapp_cfg cfg_usrapp (
+
+ .user_clk                                  (user_clk),
+ .user_reset                                (user_reset),
+  //-------------------------------------------------------------------------------------------//
+  // 4. Configuration (CFG) Interface                                                          //
+  //-------------------------------------------------------------------------------------------//
+  // EP and RP                                                                                 //
+  //-------------------------------------------------------------------------------------------//
+
+ .cfg_phy_link_down                         (cfg_phy_link_down),
+ .cfg_phy_link_status                       (cfg_phy_link_status),
+ .cfg_negotiated_width                      (cfg_negotiated_width),
+ .cfg_current_speed                         (cfg_current_speed),
+ .cfg_max_payload                           (cfg_max_payload),
+ .cfg_max_read_req                          (cfg_max_read_req),
+ .cfg_function_status                       (cfg_function_status),
+ .cfg_function_power_state                  (cfg_function_power_state),
+ .cfg_vf_status                             (cfg_vf_status),
+ .cfg_vf_power_state                        (cfg_vf_power_state),
+ .cfg_link_power_state                      (cfg_link_power_state),
+
+
+  // Error Reporting Interface
+ .cfg_err_cor_out                           (cfg_err_cor_out),
+ .cfg_err_nonfatal_out                      (cfg_err_nonfatal_out),
+ .cfg_err_fatal_out                         (cfg_err_fatal_out),
+
+ .cfg_ltr_enable                            (1'b0),
+ .cfg_ltssm_state                           (cfg_ltssm_state),
+ .cfg_rcb_status                            (cfg_rcb_status),
+ .cfg_dpa_substate_change                   (cfg_dpa_substate_change),
+ .cfg_obff_enable                           (cfg_obff_enable),
+ .cfg_pl_status_change                      (cfg_pl_status_change),
+
+ .cfg_tph_requester_enable                  (cfg_tph_requester_enable),
+ .cfg_tph_st_mode                           (cfg_tph_st_mode),
+ .cfg_vf_tph_requester_enable               (cfg_vf_tph_requester_enable),
+ .cfg_vf_tph_st_mode                        (cfg_vf_tph_st_mode),
+  // Management Interface
+ .cfg_mgmt_addr                             (cfg_mgmt_addr),
+ .cfg_mgmt_write                            (cfg_mgmt_write),
+ .cfg_mgmt_write_data                       (cfg_mgmt_write_data),
+ .cfg_mgmt_byte_enable                      (cfg_mgmt_byte_enable),
+
+ .cfg_mgmt_read                             (cfg_mgmt_read),
+ .cfg_mgmt_read_data                        (cfg_mgmt_read_data),
+ .cfg_mgmt_read_write_done                  (cfg_mgmt_read_write_done),
+ .cfg_mgmt_type1_cfg_reg_access             (cfg_mgmt_type1_cfg_reg_access),
+ .cfg_msg_received                          (cfg_msg_received),
+ .cfg_msg_received_data                     (cfg_msg_received_data),
+ .cfg_msg_received_type                     (cfg_msg_received_type),
+ .cfg_msg_transmit                          (cfg_msg_transmit),
+ .cfg_msg_transmit_type                     (cfg_msg_transmit_type),
+ .cfg_msg_transmit_data                     (cfg_msg_transmit_data),
+ .cfg_msg_transmit_done                     (cfg_msg_transmit_done),
+ .cfg_fc_ph                                 (cfg_fc_ph),
+ .cfg_fc_pd                                 (cfg_fc_pd),
+ .cfg_fc_nph                                (cfg_fc_nph),
+ .cfg_fc_npd                                (cfg_fc_npd),
+ .cfg_fc_cplh                               (cfg_fc_cplh),
+ .cfg_fc_cpld                               (cfg_fc_cpld),
+ .cfg_fc_sel                                (cfg_fc_sel),
+
+ .cfg_per_func_status_control               (cfg_per_func_status_control),
+ .cfg_per_func_status_data                  (cfg_per_func_status_data),
+ .cfg_per_function_number                   (cfg_per_function_number),
+ .cfg_per_function_output_request           (cfg_per_function_output_request),
+ .cfg_per_function_update_done              (cfg_per_function_update_done),
+
+ .cfg_dsn                                   (cfg_dsn),
+ .cfg_power_state_change_ack                (cfg_power_state_change_ack),
+ .cfg_power_state_change_interrupt          (cfg_power_state_change_interrupt),
+ .cfg_err_cor_in                            (cfg_err_cor_in),
+ .cfg_err_uncor_in                          (cfg_err_uncor_in),
+
+ .cfg_flr_in_process                        (cfg_flr_in_process),
+ .cfg_flr_done                              (cfg_flr_done),
+ .cfg_vf_flr_in_process                     (cfg_vf_flr_in_process),
+ .cfg_vf_flr_done                           (cfg_vf_flr_done),
+
+ .cfg_link_training_enable                  (cfg_link_training_enable),
+ .cfg_ds_port_number                        (cfg_ds_port_number),
+
+
+ .cfg_interrupt_msix_enable                 (cfg_interrupt_msix_enable),
+ .cfg_interrupt_msix_mask                   (cfg_interrupt_msix_mask),
+ .cfg_interrupt_msix_vf_enable              (cfg_interrupt_msix_vf_enable),
+ .cfg_interrupt_msix_vf_mask                (cfg_interrupt_msix_vf_mask),
+ .cfg_interrupt_msix_data                   (cfg_interrupt_msix_data),
+ .cfg_interrupt_msix_address                (cfg_interrupt_msix_address),
+ .cfg_interrupt_msix_int                    (cfg_interrupt_msix_int),
+ .cfg_interrupt_msix_sent                   (cfg_interrupt_msix_sent),
+ .cfg_interrupt_msix_fail                   (cfg_interrupt_msix_fail),
+
+ .cfg_hot_reset_out                         (cfg_hot_reset_out),
+ .cfg_config_space_enable                   (cfg_config_space_enable),
+ .cfg_req_pm_transition_l23_ready           (cfg_req_pm_transition_l23_ready),
+  //------------------------------------------------------------------------------------------//
+  // RP Only                                                                                  //
+  //------------------------------------------------------------------------------------------//
+ .cfg_hot_reset_in                          (cfg_hot_reset_in),
+
+ .cfg_ds_bus_number                         (cfg_ds_bus_number),
+ .cfg_ds_device_number                      (cfg_ds_device_number),
+ .cfg_ds_function_number                    (),
+
+  // Interrupt Interface Signals
+ .cfg_interrupt_int                         (cfg_interrupt_int),
+ .cfg_interrupt_pending                     (cfg_interrupt_pending),
+ .cfg_interrupt_sent                        (cfg_interrupt_sent)
+
+  );
+
+
+assign  cfg_interrupt_msi_pending_status = 64'b0;
+assign  cfg_interrupt_msi_select = 4'b0;
+assign  cfg_interrupt_msi_int = 32'b0;
+assign  cfg_interrupt_msi_attr = 3'b0;
+assign  cfg_interrupt_msi_tph_present = 1'b0;
+assign  cfg_interrupt_msi_tph_type = 2'b0;
+assign  cfg_interrupt_msi_tph_st_tag = 8'h00;
+assign  cfg_interrupt_msi_function_number = 3'b0;
+
+
+  // Common UsrApp
+
+  pci_exp_usrapp_com com_usrapp   ();
+
+
+
+
+
+
+endmodule
diff --git a/sim/tb/RP_model/xp4c_usp_smsw_model_core_top.v b/sim/tb/RP_model/xp4c_usp_smsw_model_core_top.v
new file mode 100644
index 0000000..43fefd9
--- /dev/null
+++ b/sim/tb/RP_model/xp4c_usp_smsw_model_core_top.v
@@ -0,0 +1,32912 @@
+
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2025 Advanced Micro Devices, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : PCI Express DMA 
+// File       : xp4c_usp_smsw_model_core_top.v
+// Version    : 5.0
+//-----------------------------------------------------------------------------
+//-----------------------------------------------------------------------------
+// 
+//      PCIe4 Model - Core Top
+//
+//-----------------------------------------------------------------------------
+ // Gen4 EIEOS Mode
+`timescale 1ps/1ps
+
+//-----------------------------------------------------------------------------
+`define PHYREG(clk, reset, q, d, rstval)  \
+   always @(posedge clk) begin \
+      if (reset) \
+         q  <= #(TCQ)   rstval;  \
+      else  \
+         q  <= #(TCQ)   d; \
+   end
+
+`define AS_PHYREG(clk, reset, q, d, rstval)  \
+   always @(posedge clk or posedge reset) begin \
+      if (reset) \
+         q  <= #(TCQ)   rstval;  \
+      else  \
+         q  <= #(TCQ)   d; \
+   end
+
+`define PHYREG_EN(clk, reset, q, d, rstval, en) \
+   always @(posedge clk) begin \
+      if (reset) \
+         q  <= #(TCQ)   rstval;  \
+      else  \
+         q  <= #(TCQ)   en ? d : q; \
+   end
+
+// Fast2Slow
+`define FAST2SLOW_MODEL(bit_width, rst_val, mod_name, fast_input, fast_clk, enable_input, mask_input, slow_reset, fast_reset, slow_clk, slow_output1, slow_output2)   \
+   xp4_usp_smsw_gen4_fast2slow #(.WIDTH(bit_width), .ASYNC("FALSE"), .RST_1(rst_val), .TCQ(TCQ)) mod_name (.fast_bits(fast_input),  \
+                                                                                              .fast_clk_i(fast_clk),   \
+                                                                                              .enable_i(enable_input), \
+                                                                                              .mask_bits(mask_input),  \
+                                                                                              .mgmt_reset_fast_i(fast_reset),  \
+                                                                                              .mgmt_reset_slow_i(slow_reset),  \
+                                                                                              .slow_clk_i(slow_clk),   \
+                                                                                              .slow_bits_ns(slow_output1),   \
+                                                                                              .slow_bits_r(slow_output2));
+
+`define AS_FAST2SLOW_MODEL(bit_width, rst_val, mod_name, fast_input, fast_clk, enable_input, mask_input, slow_reset, fast_reset, slow_clk, slow_output1, slow_output2)   \
+   xp4_usp_smsw_gen4_fast2slow #(.WIDTH(bit_width), .ASYNC("TRUE"), .RST_1(rst_val), .TCQ(TCQ)) mod_name (.fast_bits(fast_input),  \
+                                                                                             .fast_clk_i(fast_clk),   \
+                                                                                             .enable_i(enable_input), \
+                                                                                             .mask_bits(mask_input),  \
+                                                                                             .mgmt_reset_fast_i(fast_reset),  \
+                                                                                             .mgmt_reset_slow_i(slow_reset),  \
+                                                                                             .slow_clk_i(slow_clk),   \
+                                                                                             .slow_bits_ns(slow_output1),   \
+                                                                                             .slow_bits_r(slow_output2));
+
+// FF Chain
+`define FF_CHAIN_MODEL(chain_length, chain_width, rst_value, mod_name, clk_i, rst_i, ff_out, ff_in)   \
+   xp4_usp_smsw_phy_ff_chain #(.PIPELINE_STAGES(chain_length), .ASYNC("FALSE"), .FF_WIDTH(chain_width), .RST_VAL(rst_value), .TCQ(TCQ))   \
+      mod_name (.clock_i(clk_i), \
+                .reset_i(rst_i),   \
+                .ff_i(ff_in), \
+                .ff_o(ff_out));
+
+`define AS_FF_CHAIN_MODEL(chain_length, chain_width, rst_value, mod_name, clk_i, rst_i, ff_out, ff_in)   \
+   xp4_usp_smsw_phy_ff_chain #(.PIPELINE_STAGES(chain_length), .ASYNC("TRUE"), .FF_WIDTH(chain_width), .RST_VAL(rst_value), .TCQ(TCQ))   \
+      mod_name (.clock_i(clk_i), \
+                .reset_i(rst_i),   \
+                .ff_i(ff_in), \
+                .ff_o(ff_out));
+
+
+`timescale 1ps/1ps
+//-----------------------------------------------------------------------------
+
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4c_usp_smsw_model_core_top 
+#(
+     parameter           TCQ = 100
+   , parameter           KESTREL_512_HLF = "FALSE"
+   , parameter           IMPL_TARGET = "HARD"
+   , parameter           AXISTEN_IF_EXT_512_INTFC_RAM_STYLE = "BRAM"
+   , parameter           FPGA_FAMILY = "USM"
+   , parameter           FPGA_XCVR = "Y"
+   , parameter integer   PIPE_PIPELINE_STAGES = 1
+   , parameter integer   PHY_REFCLK_FREQ  = 0
+   , parameter           CRM_CORE_CLK_FREQ_500="TRUE"
+   , parameter [1:0]     CRM_USER_CLK_FREQ=2'b11
+   , parameter           CRM_MCAP_CLK_FREQ=1'b0
+   , parameter           AXI4_DATA_WIDTH = 512
+   , parameter           AXI4_TKEEP_WIDTH = 16
+   , parameter [1:0]     AXISTEN_IF_WIDTH = (AXI4_DATA_WIDTH == 64) ? 2'b00 : (AXI4_DATA_WIDTH == 128) ? 2'b01 : 2'b10
+   , parameter           AXISTEN_IF_EXT_512= (AXI4_DATA_WIDTH == 512) ? "TRUE" : "FALSE"
+   , parameter           AXISTEN_IF_EXT_512_CQ_STRADDLE="FALSE"
+   , parameter           AXISTEN_IF_EXT_512_CC_STRADDLE="FALSE"
+   , parameter           AXISTEN_IF_EXT_512_RQ_STRADDLE="FALSE"
+   , parameter           AXISTEN_IF_EXT_512_RC_STRADDLE="FALSE"
+   , parameter           AXISTEN_IF_EXT_512_RC_4TLP_STRADDLE="TRUE"
+   , parameter [1:0]     AXISTEN_IF_CQ_ALIGNMENT_MODE=2'b00
+   , parameter [1:0]     AXISTEN_IF_CC_ALIGNMENT_MODE=2'b00
+   , parameter [1:0]     AXISTEN_IF_RQ_ALIGNMENT_MODE=2'b00
+   , parameter [1:0]     AXISTEN_IF_RC_ALIGNMENT_MODE=2'b00
+   , parameter           AXISTEN_IF_RC_STRADDLE="FALSE"
+
+   , parameter           AXI4_CQ_TUSER_WIDTH = 183
+   , parameter           AXI4_CQ_TREADY_WIDTH = 22
+   , parameter           AXI4_CC_TUSER_WIDTH = 81
+   , parameter           AXI4_CC_TREADY_WIDTH = 4
+   , parameter           AXI4_RQ_TUSER_WIDTH = 137
+   , parameter           AXI4_RQ_TREADY_WIDTH = 4
+   , parameter           AXI4_RC_TUSER_WIDTH = 161
+   , parameter           AXI4_RC_TREADY_WIDTH = 22
+
+   , parameter           AXISTEN_IF_ENABLE_RX_MSG_INTFC="FALSE"
+   , parameter [17:0]    AXISTEN_IF_ENABLE_MSG_ROUTE=18'h0
+   , parameter           AXISTEN_IF_RX_PARITY_EN="FALSE"
+   , parameter           AXISTEN_IF_TX_PARITY_EN="FALSE"
+   , parameter           AXISTEN_IF_ENABLE_CLIENT_TAG="FALSE"
+   , parameter           AXISTEN_IF_ENABLE_256_TAGS="TRUE"
+   , parameter [23:0]    AXISTEN_IF_COMPL_TIMEOUT_REG0=24'hBEBC20
+   , parameter [27:0]    AXISTEN_IF_COMPL_TIMEOUT_REG1=28'h2FAF080
+   , parameter           AXISTEN_IF_LEGACY_MODE_ENABLE="FALSE"
+   , parameter           AXISTEN_IF_ENABLE_MESSAGE_RID_CHECK="TRUE"
+   , parameter           AXISTEN_IF_MSIX_TO_RAM_PIPELINE="TRUE"
+   , parameter           AXISTEN_IF_MSIX_FROM_RAM_PIPELINE="TRUE"
+   , parameter           AXISTEN_IF_MSIX_RX_PARITY_EN="TRUE"
+   , parameter           AXISTEN_IF_ENABLE_INTERNAL_MSIX_TABLE="FALSE"
+   , parameter           AXISTEN_IF_SIM_SHORT_CPL_TIMEOUT="FALSE"
+   , parameter           AXISTEN_IF_CQ_EN_POISONED_MEM_WR="FALSE"
+   , parameter           AXISTEN_IF_RQ_CC_REGISTERED_TREADY="TRUE"
+   , parameter [15:0]    PM_ASPML0S_TIMEOUT=16'h1500
+   , parameter [31:0]    PM_L1_REENTRY_DELAY= (CRM_CORE_CLK_FREQ_500 == "TRUE") ? 32'hC350 :  32'h61A8
+   , parameter [19:0]    PM_ASPML1_ENTRY_DELAY=20'h3E8
+   , parameter           PM_ENABLE_SLOT_POWER_CAPTURE="TRUE"
+   , parameter [19:0]    PM_PME_SERVICE_TIMEOUT_DELAY=20'h0
+   , parameter [15:0]    PM_PME_TURNOFF_ACK_DELAY=16'h100
+   , parameter           PL_UPSTREAM_FACING="TRUE"
+   , parameter [4:0]     PL_LINK_CAP_MAX_LINK_WIDTH=5'b01000
+   , parameter [3:0]     PL_LINK_CAP_MAX_LINK_SPEED=4'b0100
+   , parameter           PL_DISABLE_DC_BALANCE="FALSE"
+   , parameter           PL_DISABLE_EI_INFER_IN_L0="FALSE"
+   , parameter integer   PL_N_FTS=255
+   , parameter           PL_DISABLE_UPCONFIG_CAPABLE="FALSE"
+   , parameter           PL_DISABLE_RETRAIN_ON_FRAMING_ERROR="FALSE"
+   , parameter           PL_DISABLE_RETRAIN_ON_EB_ERROR="FALSE"
+   , parameter [15:0]    PL_DISABLE_RETRAIN_ON_SPECIFIC_FRAMING_ERROR=16'b0000000000000000
+   , parameter [7:0]     PL_REPORT_ALL_PHY_ERRORS=8'b00000000
+   , parameter [1:0]     PL_DISABLE_LFSR_UPDATE_ON_SKP=2'b00
+   , parameter [31:0]    PL_LANE0_EQ_CONTROL = PL_UPSTREAM_FACING == "TRUE" ? 32'h3F00 : 32'h3505  
+   , parameter [31:0]    PL_LANE1_EQ_CONTROL = PL_UPSTREAM_FACING == "TRUE" ? 32'h3F00 : 32'h3505
+   , parameter [31:0]    PL_LANE2_EQ_CONTROL = PL_UPSTREAM_FACING == "TRUE" ? 32'h3F00 : 32'h3505
+   , parameter [31:0]    PL_LANE3_EQ_CONTROL = PL_UPSTREAM_FACING == "TRUE" ? 32'h3F00 : 32'h3505
+   , parameter [31:0]    PL_LANE4_EQ_CONTROL = PL_UPSTREAM_FACING == "TRUE" ? 32'h3F00 : 32'h3505
+   , parameter [31:0]    PL_LANE5_EQ_CONTROL = PL_UPSTREAM_FACING == "TRUE" ? 32'h3F00 : 32'h3505
+   , parameter [31:0]    PL_LANE6_EQ_CONTROL = PL_UPSTREAM_FACING == "TRUE" ? 32'h3F00 : 32'h3505
+   , parameter [31:0]    PL_LANE7_EQ_CONTROL = PL_UPSTREAM_FACING == "TRUE" ? 32'h3F00 : 32'h3505
+   , parameter [31:0]    PL_LANE8_EQ_CONTROL = PL_UPSTREAM_FACING == "TRUE" ? 32'h3F00 : 32'h3505
+   , parameter [31:0]    PL_LANE9_EQ_CONTROL = PL_UPSTREAM_FACING == "TRUE" ? 32'h3F00 : 32'h3505
+   , parameter [31:0]    PL_LANE10_EQ_CONTROL= PL_UPSTREAM_FACING == "TRUE" ? 32'h3F00 : 32'h3505
+   , parameter [31:0]    PL_LANE11_EQ_CONTROL= PL_UPSTREAM_FACING == "TRUE" ? 32'h3F00 : 32'h3505
+   , parameter [31:0]    PL_LANE12_EQ_CONTROL= PL_UPSTREAM_FACING == "TRUE" ? 32'h3F00 : 32'h3505
+   , parameter [31:0]    PL_LANE13_EQ_CONTROL= PL_UPSTREAM_FACING == "TRUE" ? 32'h3F00 : 32'h3505
+   , parameter [31:0]    PL_LANE14_EQ_CONTROL= PL_UPSTREAM_FACING == "TRUE" ? 32'h3F00 : 32'h3505
+   , parameter [31:0]    PL_LANE15_EQ_CONTROL= PL_UPSTREAM_FACING == "TRUE" ? 32'h3F00 : 32'h3505
+   , parameter [1:0]     PL_EQ_BYPASS_PHASE23=2'b00
+   , parameter [4:0]     PL_EQ_ADAPT_ITER_COUNT=5'h2
+   , parameter [1:0]     PL_EQ_ADAPT_REJECT_RETRY_COUNT=2'h1
+   , parameter           PL_EQ_SHORT_ADAPT_PHASE="FALSE"
+   , parameter [1:0]     PL_EQ_ADAPT_DISABLE_COEFF_CHECK=2'b0
+   , parameter [1:0]     PL_EQ_ADAPT_DISABLE_PRESET_CHECK=2'b0
+   , parameter [7:0]     PL_EQ_DEFAULT_TX_PRESET=8'h44
+   , parameter [5:0]     PL_EQ_DEFAULT_RX_PRESET_HINT=6'h33
+   , parameter [1:0]     PL_EQ_RX_ADAPT_EQ_PHASE0=2'b00
+   , parameter [1:0]     PL_EQ_RX_ADAPT_EQ_PHASE1=2'b00
+   , parameter           PL_EQ_DISABLE_MISMATCH_CHECK ="TRUE"
+   , parameter [1:0]     PL_RX_L0S_EXIT_TO_RECOVERY=2'b00
+   , parameter           PL_EQ_TX_8G_EQ_TS2_ENABLE="FALSE"
+   , parameter           PL_DISABLE_AUTO_EQ_SPEED_CHANGE_TO_GEN4="FALSE"
+   , parameter           PL_DISABLE_AUTO_EQ_SPEED_CHANGE_TO_GEN3="FALSE"
+   , parameter           PL_DISABLE_AUTO_SPEED_CHANGE_TO_GEN2="FALSE"
+   , parameter           PL_DESKEW_ON_SKIP_IN_GEN12="FALSE"
+   , parameter           PL_INFER_EI_DISABLE_REC_RC="FALSE"
+   , parameter           PL_INFER_EI_DISABLE_REC_SPD="FALSE"
+   , parameter           PL_INFER_EI_DISABLE_LPBK_ACTIVE="FALSE"
+   , parameter [3:0]     PL_RX_ADAPT_TIMER_RRL_GEN3=4'h6
+   , parameter [1:0]     PL_RX_ADAPT_TIMER_RRL_CLOBBER_TX_TS=2'b00
+   , parameter [3:0]     PL_RX_ADAPT_TIMER_RRL_GEN4=4'h0
+   , parameter [3:0]     PL_RX_ADAPT_TIMER_CLWS_GEN3=4'h0
+   , parameter [1:0]     PL_RX_ADAPT_TIMER_CLWS_CLOBBER_TX_TS=2'b00
+   , parameter [3:0]     PL_RX_ADAPT_TIMER_CLWS_GEN4=4'h0
+   , parameter           PL_DISABLE_LANE_REVERSAL="FALSE"
+   , parameter           PL_CFG_STATE_ROBUSTNESS_ENABLE="TRUE"
+   , parameter           PL_REDO_EQ_SOURCE_SELECT="TRUE"
+   , parameter           PL_DEEMPH_SOURCE_SELECT="FALSE"
+   , parameter           PL_EXIT_LOOPBACK_ON_EI_ENTRY="TRUE"
+   , parameter           PL_QUIESCE_GUARANTEE_DISABLE="FALSE"
+   , parameter           PL_SRIS_ENABLE="FALSE"
+   , parameter [6:0]     PL_SRIS_SKPOS_GEN_SPD_VEC=7'h0
+   , parameter [6:0]     PL_SRIS_SKPOS_REC_SPD_VEC=7'h0
+   , parameter [1:0]     PL_SIM_FAST_LINK_TRAINING=2'h0
+   , parameter [15:0]    PL_USER_SPARE=16'h3
+   , parameter           LL_ACK_TIMEOUT_EN="FALSE"
+   , parameter [8:0]     LL_ACK_TIMEOUT=9'h0
+   , parameter integer   LL_ACK_TIMEOUT_FUNC=0
+   , parameter           LL_REPLAY_TIMEOUT_EN="FALSE"
+   , parameter [8:0]     LL_REPLAY_TIMEOUT=9'h0
+   , parameter integer   LL_REPLAY_TIMEOUT_FUNC=0
+   , parameter           LL_REPLAY_TO_RAM_PIPELINE="TRUE"
+   , parameter           LL_REPLAY_FROM_RAM_PIPELINE="TRUE"
+   , parameter           LL_DISABLE_SCHED_TX_NAK="FALSE"
+   , parameter           LL_TX_TLP_PARITY_CHK="FALSE"
+   , parameter           LL_RX_TLP_PARITY_GEN="FALSE"
+   , parameter [15:0]    LL_USER_SPARE=16'h0
+   , parameter           IS_SWITCH_PORT="FALSE"
+   , parameter           CFG_BYPASS_MODE_ENABLE="FALSE"
+   , parameter [1:0]     TL_PF_ENABLE_REG=2'h0
+   , parameter [11:0]    TL_CREDITS_CD=12'h1C0
+   , parameter [7:0]     TL_CREDITS_CH=8'h20
+   , parameter [1:0]     TL_COMPLETION_RAM_SIZE=2'b10
+   , parameter [1:0]     TL_COMPLETION_RAM_NUM_TLPS=2'b10
+   , parameter [11:0]    TL_CREDITS_NPD=12'h4
+   , parameter [7:0]     TL_CREDITS_NPH=8'h20
+   , parameter [11:0]    TL_CREDITS_PD=12'h3e0
+   , parameter [7:0]     TL_CREDITS_PH=8'h20
+   , parameter           TL_RX_COMPLETION_TO_RAM_WRITE_PIPELINE="TRUE"
+   , parameter           TL_RX_COMPLETION_TO_RAM_READ_PIPELINE="TRUE"
+   , parameter           TL_RX_COMPLETION_FROM_RAM_READ_PIPELINE="TRUE"
+   , parameter           TL_POSTED_RAM_SIZE=1'b1
+   , parameter           TL_RX_POSTED_TO_RAM_WRITE_PIPELINE="TRUE"
+   , parameter           TL_RX_POSTED_TO_RAM_READ_PIPELINE="TRUE"
+   , parameter           TL_RX_POSTED_FROM_RAM_READ_PIPELINE="TRUE"
+   , parameter           TL_TX_MUX_STRICT_PRIORITY="TRUE"
+   , parameter           TL_TX_TLP_STRADDLE_ENABLE="FALSE"
+   , parameter           TL_TX_TLP_TERMINATE_PARITY="FALSE"
+   , parameter [4:0]     TL_FC_UPDATE_MIN_INTERVAL_TLP_COUNT=5'h8
+   , parameter [4:0]     TL_FC_UPDATE_MIN_INTERVAL_TIME=5'h2
+   , parameter [15:0]    TL_USER_SPARE=16'h0
+   , parameter [23:0]    PF0_CLASS_CODE=24'h000000
+   , parameter [23:0]    PF1_CLASS_CODE=24'h000000
+   , parameter [23:0]    PF2_CLASS_CODE=24'h000000
+   , parameter [23:0]    PF3_CLASS_CODE=24'h000000
+   , parameter [2:0]     PF0_INTERRUPT_PIN=3'h1
+   , parameter [2:0]     PF1_INTERRUPT_PIN=3'h1
+   , parameter [2:0]     PF2_INTERRUPT_PIN=3'h1
+   , parameter [2:0]     PF3_INTERRUPT_PIN=3'h1
+   , parameter [7:0]     PF0_CAPABILITY_POINTER=8'h80
+   , parameter [7:0]     PF1_CAPABILITY_POINTER=8'h80
+   , parameter [7:0]     PF2_CAPABILITY_POINTER=8'h80
+   , parameter [7:0]     PF3_CAPABILITY_POINTER=8'h80
+   , parameter [7:0]     VF0_CAPABILITY_POINTER=8'h80
+   , parameter           LEGACY_CFG_EXTEND_INTERFACE_ENABLE="FALSE"
+   , parameter           EXTENDED_CFG_EXTEND_INTERFACE_ENABLE="FALSE"
+   , parameter           TL2CFG_IF_PARITY_CHK="FALSE"
+   , parameter           HEADER_TYPE_OVERRIDE="FALSE"
+   , parameter [2:0]     PF0_BAR0_CONTROL=3'b100
+   , parameter [2:0]     PF1_BAR0_CONTROL=3'b100
+   , parameter [2:0]     PF2_BAR0_CONTROL=3'b100
+   , parameter [2:0]     PF3_BAR0_CONTROL=3'b100
+   , parameter [5:0]     PF0_BAR0_APERTURE_SIZE=6'b000011
+   , parameter [5:0]     PF1_BAR0_APERTURE_SIZE=6'b000011
+   , parameter [5:0]     PF2_BAR0_APERTURE_SIZE=6'b000011
+   , parameter [5:0]     PF3_BAR0_APERTURE_SIZE=6'b000011
+   , parameter [2:0]     PF0_BAR1_CONTROL=3'h4
+   , parameter [2:0]     PF1_BAR1_CONTROL=3'b0
+   , parameter [2:0]     PF2_BAR1_CONTROL=3'b0
+   , parameter [2:0]     PF3_BAR1_CONTROL=3'b0
+   , parameter [4:0]     PF0_BAR1_APERTURE_SIZE=5'b0
+   , parameter [4:0]     PF1_BAR1_APERTURE_SIZE=5'b0
+   , parameter [4:0]     PF2_BAR1_APERTURE_SIZE=5'b0
+   , parameter [4:0]     PF3_BAR1_APERTURE_SIZE=5'b0
+   , parameter [2:0]     PF0_BAR2_CONTROL=3'b100
+   , parameter [2:0]     PF1_BAR2_CONTROL=3'b100
+   , parameter [2:0]     PF2_BAR2_CONTROL=3'b100
+   , parameter [2:0]     PF3_BAR2_CONTROL=3'b100
+   , parameter [5:0]     PF0_BAR2_APERTURE_SIZE=6'b00011
+   , parameter [5:0]     PF1_BAR2_APERTURE_SIZE=6'b00011
+   , parameter [5:0]     PF2_BAR2_APERTURE_SIZE=6'b00011
+   , parameter [5:0]     PF3_BAR2_APERTURE_SIZE=6'b00011
+   , parameter [2:0]     PF0_BAR3_CONTROL=3'b0
+   , parameter [2:0]     PF1_BAR3_CONTROL=3'b0
+   , parameter [2:0]     PF2_BAR3_CONTROL=3'b0
+   , parameter [2:0]     PF3_BAR3_CONTROL=3'b0
+   , parameter [4:0]     PF0_BAR3_APERTURE_SIZE=5'b00011
+   , parameter [4:0]     PF1_BAR3_APERTURE_SIZE=5'b00011
+   , parameter [4:0]     PF2_BAR3_APERTURE_SIZE=5'b00011
+   , parameter [4:0]     PF3_BAR3_APERTURE_SIZE=5'b00011
+   , parameter [2:0]     PF0_BAR4_CONTROL=3'b100
+   , parameter [2:0]     PF1_BAR4_CONTROL=3'b100
+   , parameter [2:0]     PF2_BAR4_CONTROL=3'b100
+   , parameter [2:0]     PF3_BAR4_CONTROL=3'b100
+   , parameter [5:0]     PF0_BAR4_APERTURE_SIZE=6'b00011
+   , parameter [5:0]     PF1_BAR4_APERTURE_SIZE=6'b00011
+   , parameter [5:0]     PF2_BAR4_APERTURE_SIZE=6'b00011
+   , parameter [5:0]     PF3_BAR4_APERTURE_SIZE=6'b00011
+   , parameter [2:0]     PF0_BAR5_CONTROL=3'b0
+   , parameter [2:0]     PF1_BAR5_CONTROL=3'b0
+   , parameter [2:0]     PF2_BAR5_CONTROL=3'b0
+   , parameter [2:0]     PF3_BAR5_CONTROL=3'b0
+   , parameter [4:0]     PF0_BAR5_APERTURE_SIZE=5'b00011
+   , parameter [4:0]     PF1_BAR5_APERTURE_SIZE=5'b00011
+   , parameter [4:0]     PF2_BAR5_APERTURE_SIZE=5'b00011
+   , parameter [4:0]     PF3_BAR5_APERTURE_SIZE=5'b00011
+   , parameter           PF0_EXPANSION_ROM_ENABLE="FALSE"
+   , parameter           PF1_EXPANSION_ROM_ENABLE="FALSE"
+   , parameter           PF2_EXPANSION_ROM_ENABLE="FALSE"
+   , parameter           PF3_EXPANSION_ROM_ENABLE="FALSE"
+   , parameter [4:0]     PF0_EXPANSION_ROM_APERTURE_SIZE=5'b00011
+   , parameter [4:0]     PF1_EXPANSION_ROM_APERTURE_SIZE=5'b00011
+   , parameter [4:0]     PF2_EXPANSION_ROM_APERTURE_SIZE=5'b00011
+   , parameter [4:0]     PF3_EXPANSION_ROM_APERTURE_SIZE=5'b00011
+   , parameter [7:0]     PF0_PCIE_CAP_NEXTPTR=8'h0
+   , parameter [7:0]     PF1_PCIE_CAP_NEXTPTR=8'h0
+   , parameter [7:0]     PF2_PCIE_CAP_NEXTPTR=8'h0
+   , parameter [7:0]     PF3_PCIE_CAP_NEXTPTR=8'h0
+   , parameter [7:0]     VFG0_PCIE_CAP_NEXTPTR=8'h0
+   , parameter [7:0]     VFG1_PCIE_CAP_NEXTPTR=8'h0
+   , parameter [7:0]     VFG2_PCIE_CAP_NEXTPTR=8'h0
+   , parameter [7:0]     VFG3_PCIE_CAP_NEXTPTR=8'h0
+   , parameter [2:0]     PF0_DEV_CAP_MAX_PAYLOAD_SIZE=3'b011
+   , parameter [2:0]     PF1_DEV_CAP_MAX_PAYLOAD_SIZE=3'b011
+   , parameter [2:0]     PF2_DEV_CAP_MAX_PAYLOAD_SIZE=3'b011
+   , parameter [2:0]     PF3_DEV_CAP_MAX_PAYLOAD_SIZE=3'b011
+   , parameter           PF0_DEV_CAP_EXT_TAG_SUPPORTED="TRUE"
+   , parameter integer   PF0_DEV_CAP_ENDPOINT_L0S_LATENCY=0
+   , parameter integer   PF0_DEV_CAP_ENDPOINT_L1_LATENCY=0
+   , parameter           PF0_DEV_CAP_FUNCTION_LEVEL_RESET_CAPABLE="TRUE"
+   , parameter integer   PF0_LINK_CAP_ASPM_SUPPORT=0
+   , parameter [0:0]     PF0_LINK_CONTROL_RCB=1'b0
+   , parameter           PF0_LINK_STATUS_SLOT_CLOCK_CONFIG="TRUE"
+   , parameter integer   PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN1=7
+   , parameter integer   PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN2=7
+   , parameter integer   PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN3=7
+   , parameter integer   PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN4=7
+   , parameter integer   PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN1=7
+   , parameter integer   PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN2=7
+   , parameter integer   PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN3=7
+   , parameter integer   PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN4=7
+   , parameter integer   PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN1=7
+   , parameter integer   PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN2=7
+   , parameter integer   PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN3=7
+   , parameter integer   PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN4=7
+   , parameter integer   PF0_LINK_CAP_L1_EXIT_LATENCY_GEN1=7
+   , parameter integer   PF0_LINK_CAP_L1_EXIT_LATENCY_GEN2=7
+   , parameter integer   PF0_LINK_CAP_L1_EXIT_LATENCY_GEN3=7
+   , parameter integer   PF0_LINK_CAP_L1_EXIT_LATENCY_GEN4=7
+   , parameter           PF0_DEV_CAP2_CPL_TIMEOUT_DISABLE="TRUE"
+   , parameter           PF0_DEV_CAP2_32B_ATOMIC_COMPLETER_SUPPORT="TRUE"
+   , parameter           PF0_DEV_CAP2_64B_ATOMIC_COMPLETER_SUPPORT="TRUE"
+   , parameter           PF0_DEV_CAP2_128B_CAS_ATOMIC_COMPLETER_SUPPORT="TRUE"
+   , parameter           PF0_DEV_CAP2_LTR_SUPPORT="FALSE"
+   , parameter           PF0_DEV_CAP2_TPH_COMPLETER_SUPPORT="FALSE"
+   , parameter [1:0]     PF0_DEV_CAP2_OBFF_SUPPORT=2'b00
+   , parameter           PF0_DEV_CAP2_ARI_FORWARD_ENABLE="FALSE"
+   , parameter [7:0]     PF0_MSI_CAP_NEXTPTR=8'h0
+   , parameter [7:0]     PF1_MSI_CAP_NEXTPTR=8'h0
+   , parameter [7:0]     PF2_MSI_CAP_NEXTPTR=8'h0
+   , parameter [7:0]     PF3_MSI_CAP_NEXTPTR=8'h0
+   , parameter           PF0_MSI_CAP_PERVECMASKCAP="FALSE"
+   , parameter           PF1_MSI_CAP_PERVECMASKCAP="FALSE"
+   , parameter           PF2_MSI_CAP_PERVECMASKCAP="FALSE"
+   , parameter           PF3_MSI_CAP_PERVECMASKCAP="FALSE"
+   , parameter integer   PF0_MSI_CAP_MULTIMSGCAP=0
+   , parameter integer   PF1_MSI_CAP_MULTIMSGCAP=0
+   , parameter integer   PF2_MSI_CAP_MULTIMSGCAP=0
+   , parameter integer   PF3_MSI_CAP_MULTIMSGCAP=0
+   , parameter [7:0]     PF0_MSIX_CAP_NEXTPTR=8'h0
+   , parameter [7:0]     PF1_MSIX_CAP_NEXTPTR=8'h0
+   , parameter [7:0]     PF2_MSIX_CAP_NEXTPTR=8'h0
+   , parameter [7:0]     PF3_MSIX_CAP_NEXTPTR=8'h0
+   , parameter [7:0]     VFG0_MSIX_CAP_NEXTPTR=PF0_MSIX_CAP_NEXTPTR
+   , parameter [7:0]     VFG1_MSIX_CAP_NEXTPTR=PF1_MSIX_CAP_NEXTPTR
+   , parameter [7:0]     VFG2_MSIX_CAP_NEXTPTR=PF2_MSIX_CAP_NEXTPTR
+   , parameter [7:0]     VFG3_MSIX_CAP_NEXTPTR=PF3_MSIX_CAP_NEXTPTR
+   , parameter integer   PF0_MSIX_CAP_PBA_BIR=0
+   , parameter integer   PF1_MSIX_CAP_PBA_BIR=0
+   , parameter integer   PF2_MSIX_CAP_PBA_BIR=0
+   , parameter integer   PF3_MSIX_CAP_PBA_BIR=0
+   , parameter integer   VFG0_MSIX_CAP_PBA_BIR=PF0_MSIX_CAP_PBA_BIR
+   , parameter integer   VFG1_MSIX_CAP_PBA_BIR=PF1_MSIX_CAP_PBA_BIR
+   , parameter integer   VFG2_MSIX_CAP_PBA_BIR=PF2_MSIX_CAP_PBA_BIR
+   , parameter integer   VFG3_MSIX_CAP_PBA_BIR=PF3_MSIX_CAP_PBA_BIR
+   , parameter [28:0]    PF0_MSIX_CAP_PBA_OFFSET=29'h50
+   , parameter [28:0]    PF1_MSIX_CAP_PBA_OFFSET=29'h50
+   , parameter [28:0]    PF2_MSIX_CAP_PBA_OFFSET=29'h50
+   , parameter [28:0]    PF3_MSIX_CAP_PBA_OFFSET=29'h50
+   , parameter [28:0]    VFG0_MSIX_CAP_PBA_OFFSET=PF0_MSIX_CAP_PBA_OFFSET
+   , parameter [28:0]    VFG1_MSIX_CAP_PBA_OFFSET=PF1_MSIX_CAP_PBA_OFFSET
+   , parameter [28:0]    VFG2_MSIX_CAP_PBA_OFFSET=PF2_MSIX_CAP_PBA_OFFSET
+   , parameter [28:0]    VFG3_MSIX_CAP_PBA_OFFSET=PF3_MSIX_CAP_PBA_OFFSET
+   , parameter integer   PF0_MSIX_CAP_TABLE_BIR=0
+   , parameter integer   PF1_MSIX_CAP_TABLE_BIR=0
+   , parameter integer   PF2_MSIX_CAP_TABLE_BIR=0
+   , parameter integer   PF3_MSIX_CAP_TABLE_BIR=0
+   , parameter integer   VFG0_MSIX_CAP_TABLE_BIR=PF0_MSIX_CAP_TABLE_BIR
+   , parameter integer   VFG1_MSIX_CAP_TABLE_BIR=PF1_MSIX_CAP_TABLE_BIR
+   , parameter integer   VFG2_MSIX_CAP_TABLE_BIR=PF2_MSIX_CAP_TABLE_BIR
+   , parameter integer   VFG3_MSIX_CAP_TABLE_BIR=PF3_MSIX_CAP_TABLE_BIR
+   , parameter [28:0]    PF0_MSIX_CAP_TABLE_OFFSET=29'h40
+   , parameter [28:0]    PF1_MSIX_CAP_TABLE_OFFSET=29'h40
+   , parameter [28:0]    PF2_MSIX_CAP_TABLE_OFFSET=29'h40
+   , parameter [28:0]    PF3_MSIX_CAP_TABLE_OFFSET=29'h40
+   , parameter [28:0]    VFG0_MSIX_CAP_TABLE_OFFSET=PF0_MSIX_CAP_TABLE_OFFSET
+   , parameter [28:0]    VFG1_MSIX_CAP_TABLE_OFFSET=PF1_MSIX_CAP_TABLE_OFFSET
+   , parameter [28:0]    VFG2_MSIX_CAP_TABLE_OFFSET=PF2_MSIX_CAP_TABLE_OFFSET
+   , parameter [28:0]    VFG3_MSIX_CAP_TABLE_OFFSET=PF3_MSIX_CAP_TABLE_OFFSET
+   , parameter [10:0]    PF0_MSIX_CAP_TABLE_SIZE=11'h0
+   , parameter [10:0]    PF1_MSIX_CAP_TABLE_SIZE=11'h0
+   , parameter [10:0]    PF2_MSIX_CAP_TABLE_SIZE=11'h0
+   , parameter [10:0]    PF3_MSIX_CAP_TABLE_SIZE=11'h0
+   , parameter [10:0]    VFG0_MSIX_CAP_TABLE_SIZE=PF0_MSIX_CAP_TABLE_SIZE
+   , parameter [10:0]    VFG1_MSIX_CAP_TABLE_SIZE=PF1_MSIX_CAP_TABLE_SIZE
+   , parameter [10:0]    VFG2_MSIX_CAP_TABLE_SIZE=PF2_MSIX_CAP_TABLE_SIZE
+   , parameter [10:0]    VFG3_MSIX_CAP_TABLE_SIZE=PF3_MSIX_CAP_TABLE_SIZE
+   , parameter [5:0]     PF0_MSIX_VECTOR_COUNT=6'h4
+   , parameter [7:0]     PF0_PM_CAP_ID=8'h1
+   , parameter [7:0]     PF0_PM_CAP_NEXTPTR=8'h0
+   , parameter [7:0]     PF1_PM_CAP_NEXTPTR=8'h0
+   , parameter [7:0]     PF2_PM_CAP_NEXTPTR=8'h0
+   , parameter [7:0]     PF3_PM_CAP_NEXTPTR=8'h0
+   , parameter           PF0_PM_CAP_PMESUPPORT_D3HOT="TRUE"
+   , parameter           PF0_PM_CAP_PMESUPPORT_D1="TRUE"
+   , parameter           PF0_PM_CAP_PMESUPPORT_D0="TRUE"
+   , parameter           PF0_PM_CAP_SUPP_D1_STATE="TRUE"
+   , parameter [2:0]     PF0_PM_CAP_VER_ID=3'h3
+   , parameter           PF0_PM_CSR_NOSOFTRESET="TRUE"
+   , parameter           PM_ENABLE_L23_ENTRY="TRUE"
+   , parameter [7:0]     DNSTREAM_LINK_NUM=8'h0
+   , parameter           AUTO_FLR_RESPONSE="FALSE"
+   , parameter [11:0]    PF0_DSN_CAP_NEXTPTR=12'h10C
+   , parameter [11:0]    PF1_DSN_CAP_NEXTPTR=12'h10C
+   , parameter [11:0]    PF2_DSN_CAP_NEXTPTR=12'h10C
+   , parameter [11:0]    PF3_DSN_CAP_NEXTPTR=12'h10C
+   , parameter           DSN_CAP_ENABLE="FALSE"
+   , parameter [3:0]     PF0_VC_CAP_VER=4'h1
+   , parameter [11:0]    PF0_VC_CAP_NEXTPTR=12'h0
+   , parameter           PF0_VC_CAP_ENABLE="FALSE"
+   , parameter [11:0]    PF0_SECONDARY_PCIE_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    PF0_AER_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    PF1_AER_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    PF2_AER_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    PF3_AER_CAP_NEXTPTR=12'h0
+   , parameter           PF0_AER_CAP_ECRC_GEN_AND_CHECK_CAPABLE="FALSE"
+   , parameter           ARI_CAP_ENABLE="FALSE"
+   , parameter [11:0]    PF0_ARI_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    PF1_ARI_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    PF2_ARI_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    PF3_ARI_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    VFG0_ARI_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    VFG1_ARI_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    VFG2_ARI_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    VFG3_ARI_CAP_NEXTPTR=12'h0
+   , parameter [3:0]     PF0_ARI_CAP_VER=4'h1
+   , parameter [7:0]     PF0_ARI_CAP_NEXT_FUNC=8'h0
+   , parameter [7:0]     PF1_ARI_CAP_NEXT_FUNC=8'h0
+   , parameter [7:0]     PF2_ARI_CAP_NEXT_FUNC=8'h0
+   , parameter [7:0]     PF3_ARI_CAP_NEXT_FUNC=8'h0
+   , parameter [11:0]    PF0_LTR_CAP_NEXTPTR=12'h0
+   , parameter [3:0]     PF0_LTR_CAP_VER=4'h1
+   , parameter [9:0]     PF0_LTR_CAP_MAX_SNOOP_LAT=10'h0
+   , parameter [9:0]     PF0_LTR_CAP_MAX_NOSNOOP_LAT=10'h0
+   , parameter           LTR_TX_MESSAGE_ON_LTR_ENABLE="FALSE"
+   , parameter           LTR_TX_MESSAGE_ON_FUNC_POWER_STATE_CHANGE="FALSE"
+   , parameter [9:0]     LTR_TX_MESSAGE_MINIMUM_INTERVAL=10'h250
+   , parameter [3:0]     SRIOV_CAP_ENABLE=4'h0
+   , parameter [11:0]    PF0_SRIOV_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    PF1_SRIOV_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    PF2_SRIOV_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    PF3_SRIOV_CAP_NEXTPTR=12'h0
+   , parameter [3:0]     PF0_SRIOV_CAP_VER=4'h1
+   , parameter [3:0]     PF1_SRIOV_CAP_VER=4'h1
+   , parameter [3:0]     PF2_SRIOV_CAP_VER=4'h1
+   , parameter [3:0]     PF3_SRIOV_CAP_VER=4'h1
+   , parameter           PF0_SRIOV_ARI_CAPBL_HIER_PRESERVED="FALSE"
+   , parameter           PF1_SRIOV_ARI_CAPBL_HIER_PRESERVED="FALSE"
+   , parameter           PF2_SRIOV_ARI_CAPBL_HIER_PRESERVED="FALSE"
+   , parameter           PF3_SRIOV_ARI_CAPBL_HIER_PRESERVED="FALSE"
+   , parameter [15:0]    PF0_SRIOV_CAP_INITIAL_VF=16'h0
+   , parameter [15:0]    PF1_SRIOV_CAP_INITIAL_VF=16'h0
+   , parameter [15:0]    PF2_SRIOV_CAP_INITIAL_VF=16'h0
+   , parameter [15:0]    PF3_SRIOV_CAP_INITIAL_VF=16'h0
+   , parameter [15:0]    PF0_SRIOV_CAP_TOTAL_VF=16'h0
+   , parameter [15:0]    PF1_SRIOV_CAP_TOTAL_VF=16'h0
+   , parameter [15:0]    PF2_SRIOV_CAP_TOTAL_VF=16'h0
+   , parameter [15:0]    PF3_SRIOV_CAP_TOTAL_VF=16'h0
+   , parameter [15:0]    PF0_SRIOV_FUNC_DEP_LINK=16'h0
+   , parameter [15:0]    PF1_SRIOV_FUNC_DEP_LINK=16'h0
+   , parameter [15:0]    PF2_SRIOV_FUNC_DEP_LINK=16'h0
+   , parameter [15:0]    PF3_SRIOV_FUNC_DEP_LINK=16'h0
+   , parameter [15:0]    PF0_SRIOV_FIRST_VF_OFFSET=16'h0
+   , parameter [15:0]    PF1_SRIOV_FIRST_VF_OFFSET=16'h0
+   , parameter [15:0]    PF2_SRIOV_FIRST_VF_OFFSET=16'h0
+   , parameter [15:0]    PF3_SRIOV_FIRST_VF_OFFSET=16'h0
+   , parameter [15:0]    PF0_SRIOV_VF_DEVICE_ID=16'h0
+   , parameter [15:0]    PF1_SRIOV_VF_DEVICE_ID=16'h0
+   , parameter [15:0]    PF2_SRIOV_VF_DEVICE_ID=16'h0
+   , parameter [15:0]    PF3_SRIOV_VF_DEVICE_ID=16'h0
+   , parameter [31:0]    PF0_SRIOV_SUPPORTED_PAGE_SIZE=32'h0
+   , parameter [31:0]    PF1_SRIOV_SUPPORTED_PAGE_SIZE=32'h0
+   , parameter [31:0]    PF2_SRIOV_SUPPORTED_PAGE_SIZE=32'h0
+   , parameter [31:0]    PF3_SRIOV_SUPPORTED_PAGE_SIZE=32'h0
+   , parameter [2:0]     PF0_SRIOV_BAR0_CONTROL=3'b100
+   , parameter [2:0]     PF1_SRIOV_BAR0_CONTROL=3'b100
+   , parameter [2:0]     PF2_SRIOV_BAR0_CONTROL=3'b100
+   , parameter [2:0]     PF3_SRIOV_BAR0_CONTROL=3'b100
+   , parameter [5:0]     PF0_SRIOV_BAR0_APERTURE_SIZE=6'b000011
+   , parameter [5:0]     PF1_SRIOV_BAR0_APERTURE_SIZE=6'b000011
+   , parameter [5:0]     PF2_SRIOV_BAR0_APERTURE_SIZE=6'b000011
+   , parameter [5:0]     PF3_SRIOV_BAR0_APERTURE_SIZE=6'b000011
+   , parameter [2:0]     PF0_SRIOV_BAR1_CONTROL=3'b0
+   , parameter [2:0]     PF1_SRIOV_BAR1_CONTROL=3'b0
+   , parameter [2:0]     PF2_SRIOV_BAR1_CONTROL=3'b0
+   , parameter [2:0]     PF3_SRIOV_BAR1_CONTROL=3'b0
+   , parameter [4:0]     PF0_SRIOV_BAR1_APERTURE_SIZE=5'b0
+   , parameter [4:0]     PF1_SRIOV_BAR1_APERTURE_SIZE=5'b0
+   , parameter [4:0]     PF2_SRIOV_BAR1_APERTURE_SIZE=5'b0
+   , parameter [4:0]     PF3_SRIOV_BAR1_APERTURE_SIZE=5'b0
+   , parameter [2:0]     PF0_SRIOV_BAR2_CONTROL=3'b100
+   , parameter [2:0]     PF1_SRIOV_BAR2_CONTROL=3'b100
+   , parameter [2:0]     PF2_SRIOV_BAR2_CONTROL=3'b100
+   , parameter [2:0]     PF3_SRIOV_BAR2_CONTROL=3'b100
+   , parameter [5:0]     PF0_SRIOV_BAR2_APERTURE_SIZE=6'b000011
+   , parameter [5:0]     PF1_SRIOV_BAR2_APERTURE_SIZE=6'b000011
+   , parameter [5:0]     PF2_SRIOV_BAR2_APERTURE_SIZE=6'b000011
+   , parameter [5:0]     PF3_SRIOV_BAR2_APERTURE_SIZE=6'b000011
+   , parameter [2:0]     PF0_SRIOV_BAR3_CONTROL=3'b0
+   , parameter [2:0]     PF1_SRIOV_BAR3_CONTROL=3'b0
+   , parameter [2:0]     PF2_SRIOV_BAR3_CONTROL=3'b0
+   , parameter [2:0]     PF3_SRIOV_BAR3_CONTROL=3'b0
+   , parameter [4:0]     PF0_SRIOV_BAR3_APERTURE_SIZE=5'b00011
+   , parameter [4:0]     PF1_SRIOV_BAR3_APERTURE_SIZE=5'b00011
+   , parameter [4:0]     PF2_SRIOV_BAR3_APERTURE_SIZE=5'b00011
+   , parameter [4:0]     PF3_SRIOV_BAR3_APERTURE_SIZE=5'b00011
+   , parameter [2:0]     PF0_SRIOV_BAR4_CONTROL=3'b100
+   , parameter [2:0]     PF1_SRIOV_BAR4_CONTROL=3'b100
+   , parameter [2:0]     PF2_SRIOV_BAR4_CONTROL=3'b100
+   , parameter [2:0]     PF3_SRIOV_BAR4_CONTROL=3'b100
+   , parameter [5:0]     PF0_SRIOV_BAR4_APERTURE_SIZE=6'b000011
+   , parameter [5:0]     PF1_SRIOV_BAR4_APERTURE_SIZE=6'b000011
+   , parameter [5:0]     PF2_SRIOV_BAR4_APERTURE_SIZE=6'b000011
+   , parameter [5:0]     PF3_SRIOV_BAR4_APERTURE_SIZE=6'b000011
+   , parameter [2:0]     PF0_SRIOV_BAR5_CONTROL=3'b0
+   , parameter [2:0]     PF1_SRIOV_BAR5_CONTROL=3'b0
+   , parameter [2:0]     PF2_SRIOV_BAR5_CONTROL=3'b0
+   , parameter [2:0]     PF3_SRIOV_BAR5_CONTROL=3'b0
+   , parameter [4:0]     PF0_SRIOV_BAR5_APERTURE_SIZE=5'b00011
+   , parameter [4:0]     PF1_SRIOV_BAR5_APERTURE_SIZE=5'b00011
+   , parameter [4:0]     PF2_SRIOV_BAR5_APERTURE_SIZE=5'b00011
+   , parameter [4:0]     PF3_SRIOV_BAR5_APERTURE_SIZE=5'b00011
+   , parameter [11:0]    PF0_TPHR_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    PF1_TPHR_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    PF2_TPHR_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    PF3_TPHR_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    VFG0_TPHR_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    VFG1_TPHR_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    VFG2_TPHR_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    VFG3_TPHR_CAP_NEXTPTR=12'h0
+   , parameter [3:0]     PF0_TPHR_CAP_VER=4'h1
+   , parameter           PF0_TPHR_CAP_INT_VEC_MODE="TRUE"
+   , parameter           PF0_TPHR_CAP_DEV_SPECIFIC_MODE="TRUE"
+   , parameter [1:0]     PF0_TPHR_CAP_ST_TABLE_LOC=2'h0
+   , parameter [10:0]    PF0_TPHR_CAP_ST_TABLE_SIZE=11'h0
+   , parameter [2:0]     PF0_TPHR_CAP_ST_MODE_SEL=3'h0
+   , parameter [2:0]     PF1_TPHR_CAP_ST_MODE_SEL=3'h0
+   , parameter [2:0]     PF2_TPHR_CAP_ST_MODE_SEL=3'h0
+   , parameter [2:0]     PF3_TPHR_CAP_ST_MODE_SEL=3'h0
+   , parameter [2:0]     VFG0_TPHR_CAP_ST_MODE_SEL=3'h0
+   , parameter [2:0]     VFG1_TPHR_CAP_ST_MODE_SEL=3'h0
+   , parameter [2:0]     VFG2_TPHR_CAP_ST_MODE_SEL=3'h0
+   , parameter [2:0]     VFG3_TPHR_CAP_ST_MODE_SEL=3'h0
+   , parameter           PF0_TPHR_CAP_ENABLE="FALSE"
+   , parameter           TPH_TO_RAM_PIPELINE="TRUE"
+   , parameter           TPH_FROM_RAM_PIPELINE="TRUE"
+   , parameter           MCAP_ENABLE="FALSE"
+   , parameter           MCAP_CONFIGURE_OVERRIDE="FALSE"
+   , parameter [11:0]    MCAP_CAP_NEXTPTR=12'h0
+   , parameter [15:0]    MCAP_VSEC_ID=16'h0
+   , parameter [3:0]     MCAP_VSEC_REV=4'h0
+   , parameter [11:0]    MCAP_VSEC_LEN=12'h2C
+   , parameter [31:0]    MCAP_FPGA_BITSTREAM_VERSION=32'h0
+   , parameter           MCAP_INTERRUPT_ON_MCAP_EOS="FALSE"
+   , parameter           MCAP_INTERRUPT_ON_MCAP_ERROR="FALSE"
+   , parameter           MCAP_INPUT_GATE_DESIGN_SWITCH="FALSE"
+   , parameter           MCAP_EOS_DESIGN_SWITCH="FALSE"
+   , parameter           MCAP_GATE_MEM_ENABLE_DESIGN_SWITCH="FALSE"
+   , parameter           MCAP_GATE_IO_ENABLE_DESIGN_SWITCH="FALSE"
+   , parameter [31:0]    SIM_JTAG_IDCODE=32'h0
+   , parameter [7:0]     DEBUG_AXIST_DISABLE_FEATURE_BIT=8'h0
+   , parameter           DEBUG_TL_DISABLE_RX_TLP_ORDER_CHECKS="FALSE"
+   , parameter           DEBUG_TL_DISABLE_FC_TIMEOUT="FALSE"
+   , parameter           DEBUG_PL_DISABLE_SCRAMBLING="FALSE"
+   , parameter           DEBUG_PL_DISABLE_REC_ENTRY_ON_DYNAMIC_DSKEW_FAIL ="FALSE"
+   , parameter           DEBUG_PL_DISABLE_REC_ENTRY_ON_RX_BUFFER_UNDER_OVER_FLOW ="FALSE"
+   , parameter           DEBUG_PL_DISABLE_LES_UPDATE_ON_SKP_ERROR="FALSE"
+   , parameter           DEBUG_PL_DISABLE_LES_UPDATE_ON_SKP_PARITY_ERROR="FALSE"
+   , parameter           DEBUG_PL_DISABLE_LES_UPDATE_ON_DEFRAMER_ERROR="FALSE"
+   , parameter           DEBUG_PL_SIM_RESET_LFSR="FALSE"
+   , parameter [15:0]    DEBUG_PL_SPARE=16'h0
+   , parameter [15:0]    DEBUG_LL_SPARE=16'h0
+   , parameter [15:0]    DEBUG_TL_SPARE=16'h0
+   , parameter [15:0]    DEBUG_AXI4ST_SPARE=16'h0
+   , parameter [15:0]    DEBUG_CFG_SPARE=16'h0
+   , parameter [3:0]     DEBUG_CAR_SPARE=4'h0
+   , parameter           TEST_MODE_PIN_CHAR="FALSE"
+   , parameter           SPARE_BIT0="FALSE"
+   , parameter           SPARE_BIT1=1'b0
+   , parameter           SPARE_BIT2=1'b0
+   , parameter           SPARE_BIT3="FALSE"
+   , parameter           SPARE_BIT4=1'b0
+   , parameter           SPARE_BIT5=1'b0
+   , parameter           SPARE_BIT6=1'b0
+   , parameter           SPARE_BIT7=1'b0
+   , parameter           SPARE_BIT8=1'b0
+   , parameter [7:0]     SPARE_BYTE0=8'h0
+   , parameter [7:0]     SPARE_BYTE1=8'h0
+   , parameter [7:0]     SPARE_BYTE2=8'h0
+   , parameter [7:0]     SPARE_BYTE3=8'h0
+   , parameter [31:0]    SPARE_WORD0=32'h0
+   , parameter [31:0]    SPARE_WORD1=32'h0
+   , parameter [31:0]    SPARE_WORD2=32'h0
+   , parameter [31:0]    SPARE_WORD3=32'h0
+   , parameter [7:0]     AXISTEN_IF_CCIX_RX_CREDIT_LIMIT	= 8'h08
+   , parameter [7:0]     AXISTEN_IF_CCIX_TX_CREDIT_LIMIT	= 8'h08
+   , parameter           AXISTEN_IF_CCIX_TX_REGISTERED_TREADY	= "FALSE"
+   , parameter           CCIX_DIRECT_ATTACH_MODE	= "FALSE"
+   , parameter           CCIX_ENABLE	= "FALSE"
+   , parameter [15:0]    CCIX_VENDOR_ID	= 16'h0000
+   , parameter [4:0]     PF0_ATS_CAP_INV_QUEUE_DEPTH	= 5'h00
+   , parameter [11:0]    PF0_ATS_CAP_NEXTPTR	= 12'h000
+   , parameter           PF0_ATS_CAP_ON	= "FALSE"
+   , parameter [11:0]    PF0_PRI_CAP_NEXTPTR	= 12'h000
+   , parameter           PF0_PRI_CAP_ON	= "FALSE"
+   , parameter [31:0]    PF0_PRI_OST_PR_CAPACITY	= 32'h00000000
+   , parameter [3:0]     PF0_VC_ARB_CAPABILITY	= 4'h0
+   , parameter [7:0]     PF0_VC_ARB_TBL_OFFSET	= 8'h00
+   , parameter           PF0_VC_EXTENDED_COUNT	= "FALSE"
+   , parameter           PF0_VC_LOW_PRIORITY_EXTENDED_COUNT	= "FALSE"
+   , parameter [4:0]     PF1_ATS_CAP_INV_QUEUE_DEPTH	= 5'h00
+   , parameter [11:0]    PF1_ATS_CAP_NEXTPTR	= 12'h000
+   , parameter           PF1_ATS_CAP_ON	= "FALSE"
+   , parameter [11:0]    PF1_PRI_CAP_NEXTPTR	= 12'h000
+   , parameter           PF1_PRI_CAP_ON	= "FALSE"
+   , parameter [31:0]    PF1_PRI_OST_PR_CAPACITY	= 32'h00000000
+   , parameter [4:0]     PF2_ATS_CAP_INV_QUEUE_DEPTH	= 5'h00
+   , parameter [11:0]    PF2_ATS_CAP_NEXTPTR	= 12'h000
+   , parameter           PF2_ATS_CAP_ON	= "FALSE"
+   , parameter [11:0]    PF2_PRI_CAP_NEXTPTR	= 12'h000
+   , parameter           PF2_PRI_CAP_ON	= "FALSE"
+   , parameter [31:0]    PF2_PRI_OST_PR_CAPACITY	= 32'h00000000
+   , parameter [4:0]     PF3_ATS_CAP_INV_QUEUE_DEPTH	= 5'h00
+   , parameter [11:0]    PF3_ATS_CAP_NEXTPTR	= 12'h000
+   , parameter           PF3_ATS_CAP_ON	= "FALSE"
+   , parameter [11:0]    PF3_PRI_CAP_NEXTPTR	= 12'h000
+   , parameter           PF3_PRI_CAP_ON	= "FALSE"
+   , parameter [31:0]    PF3_PRI_OST_PR_CAPACITY	= 32'h00000000
+   , parameter           PL_CTRL_SKP_GEN_ENABLE	= "FALSE"
+   , parameter           PL_CTRL_SKP_PARITY_AND_CRC_CHECK_DISABLE	= "TRUE"
+   , parameter [15:0]    PL_USER_SPARE2	= 16'h0000
+   , parameter [11:0]    TL_CREDITS_CD_VC1	= 12'h000
+   , parameter [7:0]     TL_CREDITS_CH_VC1	= 8'h00
+   , parameter [11:0]    TL_CREDITS_NPD_VC1	= 12'h000
+   , parameter [7:0]     TL_CREDITS_NPH_VC1	= 8'h01
+   , parameter [11:0]    TL_CREDITS_PD_VC1	= 12'h3e0
+   , parameter [7:0]     TL_CREDITS_PH_VC1	= 8'h20
+   , parameter [4:0]     TL_FC_UPDATE_MIN_INTERVAL_TIME_VC1	= 5'h02
+   , parameter [4:0]     TL_FC_UPDATE_MIN_INTERVAL_TLP_COUNT_VC1	= 5'h08
+   , parameter           TL_FEATURE_ENABLE_FC_SCALING	= "FALSE"
+   , parameter [4:0]     VFG0_ATS_CAP_INV_QUEUE_DEPTH	= 5'h00
+   , parameter [11:0]    VFG0_ATS_CAP_NEXTPTR	= 12'h000
+   , parameter           VFG0_ATS_CAP_ON	= "FALSE"
+   , parameter [4:0]     VFG1_ATS_CAP_INV_QUEUE_DEPTH	= 5'h00
+   , parameter [11:0]    VFG1_ATS_CAP_NEXTPTR	= 12'h000
+   , parameter           VFG1_ATS_CAP_ON	= "FALSE"
+   , parameter [4:0]     VFG2_ATS_CAP_INV_QUEUE_DEPTH	= 5'h00
+   , parameter [11:0]    VFG2_ATS_CAP_NEXTPTR	= 12'h000
+   , parameter           VFG2_ATS_CAP_ON	= "FALSE"
+   , parameter [4:0]     VFG3_ATS_CAP_INV_QUEUE_DEPTH	= 5'h00
+   , parameter [11:0]    VFG3_ATS_CAP_NEXTPTR	= 12'h000
+   , parameter           VFG3_ATS_CAP_ON	= "FALSE"
+   , parameter EXT_PIPE_SIM = "FALSE"
+
+   , parameter PF0_VENDOR_ID='H10EE
+   , parameter PF0_SUBSYSTEM_VENDOR_ID='H10EE
+   , parameter PF0_DEVICE_ID='H903F
+   , parameter PF1_DEVICE_ID='H903F
+   , parameter PF2_DEVICE_ID='H903F
+   , parameter PF3_DEVICE_ID='H903F
+   , parameter PF0_REVISION_ID='H00
+   , parameter PF1_REVISION_ID='H00
+   , parameter PF2_REVISION_ID='H00
+   , parameter PF3_REVISION_ID='H00
+   , parameter PF0_SUBSYSTEM_ID='H0007
+   , parameter PF1_SUBSYSTEM_ID='H0007
+   , parameter PF2_SUBSYSTEM_ID='H0007
+   , parameter PF3_SUBSYSTEM_ID='H0007
+
+/// ----------------------------------------------
+  , parameter TL_LEGACY_MODE_ENABLE="FALSE",
+    parameter DEDICATE_PERST="TRUE",
+    parameter SYS_RESET_POLARITY=0,
+    parameter DIS_GT_WIZARD="TRUE",
+    parameter BMD_PIO_MODE="FALSE",
+    parameter COMPLETER_MODEL="FALSE",
+    parameter SRIOV_EXD_MODE="FALSE",
+    parameter TWO_PORT_SWITCH="FALSE",
+    parameter TWO_PORT_CONFIG="X8G3",
+    parameter silicon_revision="ES1",
+    parameter DEV_PORT_TYPE= 0,
+    parameter pcie_blk_locn=0,
+    parameter gen_x0y0_xdc=0,
+    parameter gen_x0y1_xdc=0,
+    parameter gen_x0y2_xdc=0,
+    parameter gen_x0y3_xdc=0,
+    parameter gen_x0y4_xdc=0,
+    parameter gen_x0y5_xdc=0,
+    parameter gen_x1y0_xdc=1,
+    parameter gen_x1y1_xdc=0,
+    parameter gen_x1y2_xdc=0,
+    parameter gen_x1y3_xdc=0,
+    parameter gen_x1y4_xdc=0,
+    parameter gen_x1y5_xdc=0,
+    parameter xlnx_ref_board=0,
+    parameter PIPE_SIM="FALSE",
+    parameter PCIE_FAST_CONFIG="NONE",
+    parameter EXT_STARTUP_PRIMITIVE="FALSE",
+    parameter PL_INTERFACE="FALSE",
+    parameter PCIE_CONFIGURATION="FALSE",
+    parameter CFG_STATUS_IF="TRUE",
+    parameter TX_FC_IF="TRUE",
+    parameter CFG_EXT_IF="TRUE",
+    parameter CFG_FC_IF="TRUE",
+    parameter PER_FUNC_STATUS_IF="TRUE",
+    parameter CFG_MGMT_IF="TRUE",
+    parameter CFG_PM_IF="TRUE",
+    parameter RCV_MSG_IF="TRUE",
+    parameter CFG_TX_MSG_IF="TRUE",
+    parameter CFG_CTL_IF="TRUE",
+    parameter PCIE_ID_IF="FALSE",
+    parameter MSI_EN="TRUE",
+    parameter MSIX_EN="FALSE",
+    parameter PCIE3_DRP="FALSE",
+    parameter TRANSCEIVER_CTRL_STATUS_PORTS="FALSE",
+    parameter SHARED_LOGIC=1,
+    parameter MCAP_ENABLEMENT="NONE",
+    parameter EXT_CH_GT_DRP="FALSE",
+    parameter EN_GT_SELECTION="FALSE",
+    parameter PLL_TYPE = 0,
+    parameter EN_PARITY = "FALSE",
+    parameter INS_LOSS_PROFILE = "TRUE",
+    parameter MSI_X_OPTIONS="MSI-X_Ext",
+    parameter SELECT_QUAD="GTY_Quad_124"
+/// ----------------------------------------------
+
+   ) (
+
+    input  wire           pl_gen2_upstream_prefer_deemph
+   ,output wire           pl_eq_in_progress
+   ,output wire [1:0]     pl_eq_phase
+   ,input  wire           pl_redo_eq
+   ,input  wire           pl_redo_eq_speed
+   ,output wire           pl_eq_mismatch
+   ,output wire           pl_redo_eq_pending
+
+   ,output wire [AXI4_DATA_WIDTH-1:0] m_axis_cq_tdata
+   ,input  wire [AXI4_DATA_WIDTH-1:0] s_axis_cc_tdata
+   ,input  wire [AXI4_DATA_WIDTH-1:0] s_axis_rq_tdata
+   ,output wire [AXI4_DATA_WIDTH-1:0] m_axis_rc_tdata
+   ,output wire [AXI4_CQ_TUSER_WIDTH-1:0] m_axis_cq_tuser
+   ,input  wire [AXI4_CC_TUSER_WIDTH-1:0] s_axis_cc_tuser
+   ,output wire           m_axis_cq_tlast
+   ,input  wire           s_axis_rq_tlast
+   ,output wire           m_axis_rc_tlast
+   ,input  wire           s_axis_cc_tlast
+   ,input  wire [1:0]     pcie_cq_np_req
+   ,output wire [5:0]     pcie_cq_np_req_count
+   ,input  wire [AXI4_RQ_TUSER_WIDTH-1:0] s_axis_rq_tuser
+   ,output wire [AXI4_RC_TUSER_WIDTH-1:0] m_axis_rc_tuser
+   ,output wire [AXI4_TKEEP_WIDTH-1:0] m_axis_cq_tkeep
+   ,input  wire [AXI4_TKEEP_WIDTH-1:0] s_axis_cc_tkeep
+   ,input  wire [AXI4_TKEEP_WIDTH-1:0] s_axis_rq_tkeep
+   ,output wire [AXI4_TKEEP_WIDTH-1:0] m_axis_rc_tkeep
+   ,output wire           m_axis_cq_tvalid
+   ,input  wire           s_axis_cc_tvalid
+   ,input  wire           s_axis_rq_tvalid
+   ,output wire           m_axis_rc_tvalid
+   ,input  wire           m_axis_cq_tready
+   ,output wire [AXI4_CC_TREADY_WIDTH-1:0] s_axis_cc_tready
+   ,output wire [AXI4_RQ_TREADY_WIDTH-1:0] s_axis_rq_tready
+   ,input  wire           m_axis_rc_tready
+   ,output wire [5:0]     pcie_rq_seq_num0
+   ,output wire           pcie_rq_seq_num_vld0
+   ,output wire [5:0]     pcie_rq_seq_num1
+   ,output wire           pcie_rq_seq_num_vld1
+   ,output wire [7:0]     pcie_rq_tag0
+   ,output wire           pcie_rq_tag_vld0
+   ,output wire [7:0]     pcie_rq_tag1
+   ,output wire           pcie_rq_tag_vld1
+   ,output wire [3:0]     pcie_tfc_nph_av
+   ,output wire [3:0]     pcie_tfc_npd_av
+   ,output wire [3:0]     pcie_rq_tag_av
+   ,input  wire [9:0]     cfg_mgmt_addr
+   ,input  wire [7:0]     cfg_mgmt_function_number
+   ,input  wire           cfg_mgmt_write
+   ,input  wire [31:0]    cfg_mgmt_write_data
+   ,input  wire [3:0]     cfg_mgmt_byte_enable
+   ,input  wire           cfg_mgmt_read
+   ,output wire [31:0]    cfg_mgmt_read_data
+   ,output wire           cfg_mgmt_read_write_done
+   ,input  wire           cfg_mgmt_debug_access
+   ,output wire           cfg_phy_link_down
+   ,output wire [1:0]     cfg_phy_link_status
+   ,output wire [2:0]     cfg_negotiated_width
+   ,output wire [1:0]     cfg_current_speed
+   ,output wire [1:0]     cfg_max_payload
+   ,output wire [2:0]     cfg_max_read_req
+   ,output wire [15:0]    cfg_function_status
+   ,output wire [11:0]    cfg_function_power_state
+   ,output wire [1:0]     cfg_link_power_state
+   ,output wire           cfg_err_cor_out
+   ,output wire           cfg_err_nonfatal_out
+   ,output wire           cfg_err_fatal_out
+   ,output wire           cfg_local_error_valid
+   ,output wire [4:0]     cfg_local_error_out
+   ,output wire [5:0]     cfg_ltssm_state
+   ,output wire [1:0]     cfg_rx_pm_state
+   ,output wire [1:0]     cfg_tx_pm_state
+   ,output wire [3:0]     cfg_rcb_status
+   ,output wire [1:0]     cfg_obff_enable
+   ,output wire           cfg_pl_status_change
+   ,output wire [3:0]     cfg_tph_requester_enable
+   ,output wire [11:0]    cfg_tph_st_mode
+   ,output wire           cfg_msg_received
+   ,output wire [7:0]     cfg_msg_received_data
+   ,output wire [4:0]     cfg_msg_received_type
+   ,input  wire           cfg_msg_transmit
+   ,input  wire [2:0]     cfg_msg_transmit_type
+   ,input  wire [31:0]    cfg_msg_transmit_data
+   ,output wire           cfg_msg_transmit_done
+   ,output wire [7:0]     cfg_fc_ph
+   ,output wire [11:0]    cfg_fc_pd
+   ,output wire [7:0]     cfg_fc_nph
+   ,output wire [11:0]    cfg_fc_npd
+   ,output wire [7:0]     cfg_fc_cplh
+   ,output wire [11:0]    cfg_fc_cpld
+   ,input  wire [2:0]     cfg_fc_sel
+   ,input  wire           cfg_hot_reset_in
+   ,output wire           cfg_hot_reset_out
+   ,input  wire           cfg_config_space_enable
+   ,input  wire [63:0]    cfg_dsn
+   ,input  wire [15:0]    cfg_dev_id_pf0
+   ,input  wire [15:0]    cfg_dev_id_pf1
+   ,input  wire [15:0]    cfg_dev_id_pf2
+   ,input  wire [15:0]    cfg_dev_id_pf3
+   ,input  wire [15:0]    cfg_vend_id
+   ,input  wire [7:0]     cfg_rev_id_pf0
+   ,input  wire [7:0]     cfg_rev_id_pf1
+   ,input  wire [7:0]     cfg_rev_id_pf2
+   ,input  wire [7:0]     cfg_rev_id_pf3
+   ,input  wire [15:0]    cfg_subsys_id_pf0
+   ,input  wire [15:0]    cfg_subsys_id_pf1
+   ,input  wire [15:0]    cfg_subsys_id_pf2
+   ,input  wire [15:0]    cfg_subsys_id_pf3
+   ,input  wire [15:0]    cfg_subsys_vend_id
+   ,output wire           cfg_ltr_enable
+   ,input  wire [7:0]     cfg_ds_port_number
+   ,input  wire [7:0]     cfg_ds_bus_number
+   ,input  wire [4:0]     cfg_ds_device_number
+   ,output wire [7:0]     cfg_bus_number
+   ,input  wire           cfg_power_state_change_ack
+   ,output wire           cfg_power_state_change_interrupt
+   ,input  wire           cfg_err_cor_in
+   ,input  wire           cfg_err_uncor_in
+   ,input  wire [3:0]     cfg_flr_done
+   ,output wire [3:0]     cfg_flr_in_process
+   ,input  wire           cfg_req_pm_transition_l23_ready
+   ,input  wire           cfg_link_training_enable
+   ,input  wire [3:0]     cfg_interrupt_int
+   ,output wire           cfg_interrupt_sent
+   ,input  wire [3:0]     cfg_interrupt_pending
+   ,output wire [3:0]     cfg_interrupt_msi_enable
+   ,input  wire [31:0]    cfg_interrupt_msi_int
+   ,output wire           cfg_interrupt_msi_sent
+   ,output wire           cfg_interrupt_msi_fail
+   ,output wire [11:0]    cfg_interrupt_msi_mmenable
+   ,input  wire [31:0]    cfg_interrupt_msi_pending_status
+   ,input  wire [1:0]     cfg_interrupt_msi_pending_status_function_num
+   ,input  wire           cfg_interrupt_msi_pending_status_data_enable
+   ,output wire           cfg_interrupt_msi_mask_update
+   ,input  wire [1:0]     cfg_interrupt_msi_select
+   ,output wire [31:0]    cfg_interrupt_msi_data
+   ,output wire [3:0]     cfg_interrupt_msix_enable
+   ,output wire [3:0]     cfg_interrupt_msix_mask
+   ,input  wire [63:0]    cfg_interrupt_msix_address
+   ,input  wire [31:0]    cfg_interrupt_msix_data
+   ,input  wire           cfg_interrupt_msix_int
+   ,input  wire [1:0]     cfg_interrupt_msix_vec_pending
+   ,output wire           cfg_interrupt_msix_vec_pending_status
+   ,input  wire [2:0]     cfg_interrupt_msi_attr
+   ,input  wire           cfg_interrupt_msi_tph_present
+   ,input  wire [1:0]     cfg_interrupt_msi_tph_type
+   ,input  wire [7:0]     cfg_interrupt_msi_tph_st_tag
+   ,input  wire [7:0]     cfg_interrupt_msi_function_number
+   ,output wire           cfg_ext_read_received
+   ,output wire           cfg_ext_write_received
+   ,output wire [9:0]     cfg_ext_register_number
+   ,output wire [7:0]     cfg_ext_function_number
+   ,output wire [31:0]    cfg_ext_write_data
+   ,output wire [3:0]     cfg_ext_write_byte_enable
+   ,input  wire [31:0]    cfg_ext_read_data
+   ,input  wire           cfg_ext_read_data_valid
+   ,output wire [251:0]   cfg_vf_flr_in_process 
+   ,input  wire [7:0]     cfg_vf_flr_func_num
+   ,input  wire           cfg_vf_flr_done
+   ,output wire [503:0]   cfg_vf_status
+   ,output wire [755:0]   cfg_vf_power_state
+   ,output wire [251:0]   cfg_vf_tph_requester_enable
+   ,output wire [755:0]   cfg_vf_tph_st_mode
+   ,output wire [251:0]   cfg_interrupt_msix_vf_enable
+   ,output wire [251:0]   cfg_interrupt_msix_vf_mask
+   ,input  wire           cfg_pm_aspm_l1_entry_reject
+   ,input  wire           cfg_pm_aspm_tx_l0s_entry_disable
+   ,input  wire [1:0]     conf_req_type
+   ,input  wire [3:0]     conf_req_reg_num
+   ,input  wire [31:0]    conf_req_data
+   ,input  wire           conf_req_valid
+   ,output wire           conf_req_ready
+   ,output wire [31:0]    conf_resp_rdata
+   ,output wire           conf_resp_valid
+   ,output wire           conf_mcap_design_switch
+   ,output wire           conf_mcap_eos
+   ,output wire           conf_mcap_in_use_by_pcie
+   ,input  wire           conf_mcap_request_by_conf
+   ,output wire           user_clk
+   ,output wire           user_reset
+   ,output wire           user_lnk_up
+   ,input  wire           sys_clk
+   ,input  wire           sys_clk_gt
+   ,input  wire           sys_reset
+   ,input  wire [PL_LINK_CAP_MAX_LINK_WIDTH-1:0]     pci_exp_rxp
+   ,input  wire [PL_LINK_CAP_MAX_LINK_WIDTH-1:0]     pci_exp_rxn
+   ,output wire [PL_LINK_CAP_MAX_LINK_WIDTH-1:0]     pci_exp_txp
+   ,output wire [PL_LINK_CAP_MAX_LINK_WIDTH-1:0]     pci_exp_txn
+  // PIPE INTERFACE
+   ,input  wire  [25:0] common_commands_in
+   ,input  wire [83:0]  pipe_rx_0_sigs
+   ,input  wire [83:0]  pipe_rx_1_sigs
+   ,input  wire [83:0]  pipe_rx_2_sigs
+   ,input  wire [83:0]  pipe_rx_3_sigs
+   ,input  wire [83:0]  pipe_rx_4_sigs
+   ,input  wire [83:0]  pipe_rx_5_sigs
+   ,input  wire [83:0]  pipe_rx_6_sigs
+   ,input  wire [83:0]  pipe_rx_7_sigs
+   ,input  wire [83:0]  pipe_rx_8_sigs
+   ,input  wire [83:0]  pipe_rx_9_sigs
+   ,input  wire [83:0]  pipe_rx_10_sigs
+   ,input  wire [83:0]  pipe_rx_11_sigs
+   ,input  wire [83:0]  pipe_rx_12_sigs
+   ,input  wire [83:0]  pipe_rx_13_sigs
+   ,input  wire [83:0]  pipe_rx_14_sigs
+   ,input  wire [83:0]  pipe_rx_15_sigs
+                      
+   ,output wire [16:0]  common_commands_out
+   ,output wire [69:0]  pipe_tx_0_sigs
+   ,output wire [69:0]  pipe_tx_1_sigs
+   ,output wire [69:0]  pipe_tx_2_sigs
+   ,output wire [69:0]  pipe_tx_3_sigs
+   ,output wire [69:0]  pipe_tx_4_sigs
+   ,output wire [69:0]  pipe_tx_5_sigs
+   ,output wire [69:0]  pipe_tx_6_sigs
+   ,output wire [69:0]  pipe_tx_7_sigs
+   ,output  wire [69:0]  pipe_tx_8_sigs
+   ,output  wire [69:0]  pipe_tx_9_sigs
+   ,output  wire [69:0]  pipe_tx_10_sigs
+   ,output  wire [69:0]  pipe_tx_11_sigs
+   ,output  wire [69:0]  pipe_tx_12_sigs
+   ,output  wire [69:0]  pipe_tx_13_sigs
+   ,output  wire [69:0]  pipe_tx_14_sigs
+   ,output  wire [69:0]  pipe_tx_15_sigs
+   ,output wire           core_clk
+   ,input  wire           pl_eq_reset_eieos_count
+   ,input  wire           cfg_fc_vc_sel
+   ,output wire           cfg_vc1_enable
+   ,output wire           cfg_vc1_negotiation_pending
+     //-----------------------------------------------------------------------
+     // CCIX TX Interface
+     // Data from CCIX protocol processing block
+     //-----------------------------------------------------------------------
+   ,input wire [255:0]   s_axis_ccix_tx_tdata // 256-bit data
+   ,input wire           s_axis_ccix_tx_tvalid // Valid
+   ,input wire [45:0]    s_axis_ccix_tx_tuser // tuser bus
+                         // [0] = is_sop0, [1] = is_sop0_ptr,
+                         // [2] = is_sop1, [3] = is_sop1_ptr,
+                         // [4] = is_eop0, [7:5] = is_eop0_ptr,
+                         // [8] = is_eop1, [11:9] = is_eop1_ptr,
+                         // [13:12] = discontinue, [45:14] = odd parity
+   ,output wire          ccix_tx_credit // Flow control credits to CCIX protocol processing block
+     //-----------------------------------------------------------------------
+     // CCIX RX Interface
+     // Data to downstream CCIX protocol processing block
+     //-----------------------------------------------------------------------
+   ,output wire [255:0]  m_axis_ccix_rx_tdata // 256-bit data
+   ,output wire          m_axis_ccix_rx_tvalid // Valid
+   ,output wire [45:0]   m_axis_ccix_rx_tuser // tuser bus
+                         // [0] = is_sop0, [1] = is_sop0_ptr,
+                         // [2] = is_sop1, [3] = is_sop1_ptr,
+                         // [4] = is_eop0, [7:5] = is_eop0_ptr,
+                         // [8] = is_eop1, [11:9] = is_eop1_ptr,
+                         // [13:12] = discontinue, [45:14] = odd parity
+   ,input wire           ccix_rx_credit // Flow control credits from CCIX protocol processing block
+   ,output wire [7:0]    ccix_rx_credit_av // Current value of available credit maintained by the bridge
+   ,input wire           ccix_optimized_tlp_tx_and_rx_enable
+  );
+
+   wire           pcie_perst0_b;
+   wire           pcie_perst1_b;
+   wire           sys_clk_bufg;
+   wire           phy_rdy ;
+   wire           phy_rdy_phystatus;
+   wire [1:0]     pipe_rx00_char_is_k;
+   wire [1:0]     pipe_rx01_char_is_k;
+   wire [1:0]     pipe_rx02_char_is_k;
+   wire [1:0]     pipe_rx03_char_is_k;
+   wire [1:0]     pipe_rx04_char_is_k;
+   wire [1:0]     pipe_rx05_char_is_k;
+   wire [1:0]     pipe_rx06_char_is_k;
+   wire [1:0]     pipe_rx07_char_is_k;
+   wire [1:0]     pipe_rx08_char_is_k;
+   wire [1:0]     pipe_rx09_char_is_k;
+   wire [1:0]     pipe_rx10_char_is_k;
+   wire [1:0]     pipe_rx11_char_is_k;
+   wire [1:0]     pipe_rx12_char_is_k;
+   wire [1:0]     pipe_rx13_char_is_k;
+   wire [1:0]     pipe_rx14_char_is_k;
+   wire [1:0]     pipe_rx15_char_is_k;
+   wire           pipe_rx00_valid;
+   wire           pipe_rx01_valid;
+   wire           pipe_rx02_valid;
+   wire           pipe_rx03_valid;
+   wire           pipe_rx04_valid;
+   wire           pipe_rx05_valid;
+   wire           pipe_rx06_valid;
+   wire           pipe_rx07_valid;
+   wire           pipe_rx08_valid;
+   wire           pipe_rx09_valid;
+   wire           pipe_rx10_valid;
+   wire           pipe_rx11_valid;
+   wire           pipe_rx12_valid;
+   wire           pipe_rx13_valid;
+   wire           pipe_rx14_valid;
+   wire           pipe_rx15_valid;
+   wire [63:0]    pipe_rx00_data;
+   wire [63:0]    pipe_rx01_data;
+   wire [63:0]    pipe_rx02_data;
+   wire [63:0]    pipe_rx03_data;
+   wire [63:0]    pipe_rx04_data;
+   wire [63:0]    pipe_rx05_data;
+   wire [63:0]    pipe_rx06_data;
+   wire [63:0]    pipe_rx07_data;
+   wire [63:0]    pipe_rx08_data;
+   wire [63:0]    pipe_rx09_data;
+   wire [63:0]    pipe_rx10_data;
+   wire [63:0]    pipe_rx11_data;
+   wire [63:0]    pipe_rx12_data;
+   wire [63:0]    pipe_rx13_data;
+   wire [63:0]    pipe_rx14_data;
+   wire [63:0]    pipe_rx15_data;
+   wire           pipe_rx00_polarity;
+   wire           pipe_rx01_polarity;
+   wire           pipe_rx02_polarity;
+   wire           pipe_rx03_polarity;
+   wire           pipe_rx04_polarity;
+   wire           pipe_rx05_polarity;
+   wire           pipe_rx06_polarity;
+   wire           pipe_rx07_polarity;
+   wire           pipe_rx08_polarity;
+   wire           pipe_rx09_polarity;
+   wire           pipe_rx10_polarity;
+   wire           pipe_rx11_polarity;
+   wire           pipe_rx12_polarity;
+   wire           pipe_rx13_polarity;
+   wire           pipe_rx14_polarity;
+   wire           pipe_rx15_polarity;
+   wire [2:0]     pipe_rx00_status;
+   wire [2:0]     pipe_rx01_status;
+   wire [2:0]     pipe_rx02_status;
+   wire [2:0]     pipe_rx03_status;
+   wire [2:0]     pipe_rx04_status;
+   wire [2:0]     pipe_rx05_status;
+   wire [2:0]     pipe_rx06_status;
+   wire [2:0]     pipe_rx07_status;
+   wire [2:0]     pipe_rx08_status;
+   wire [2:0]     pipe_rx09_status;
+   wire [2:0]     pipe_rx10_status;
+   wire [2:0]     pipe_rx11_status;
+   wire [2:0]     pipe_rx12_status;
+   wire [2:0]     pipe_rx13_status;
+   wire [2:0]     pipe_rx14_status;
+   wire [2:0]     pipe_rx15_status;
+   wire           pipe_rx00_phy_status;
+   wire           pipe_rx01_phy_status;
+   wire           pipe_rx02_phy_status;
+   wire           pipe_rx03_phy_status;
+   wire           pipe_rx04_phy_status;
+   wire           pipe_rx05_phy_status;
+   wire           pipe_rx06_phy_status;
+   wire           pipe_rx07_phy_status;
+   wire           pipe_rx08_phy_status;
+   wire           pipe_rx09_phy_status;
+   wire           pipe_rx10_phy_status;
+   wire           pipe_rx11_phy_status;
+   wire           pipe_rx12_phy_status;
+   wire           pipe_rx13_phy_status;
+   wire           pipe_rx14_phy_status;
+   wire           pipe_rx15_phy_status;
+   wire           pipe_rx00_elec_idle;
+   wire           pipe_rx01_elec_idle;
+   wire           pipe_rx02_elec_idle;
+   wire           pipe_rx03_elec_idle;
+   wire           pipe_rx04_elec_idle;
+   wire           pipe_rx05_elec_idle;
+   wire           pipe_rx06_elec_idle;
+   wire           pipe_rx07_elec_idle;
+   wire           pipe_rx08_elec_idle;
+   wire           pipe_rx09_elec_idle;
+   wire           pipe_rx10_elec_idle;
+   wire           pipe_rx11_elec_idle;
+   wire           pipe_rx12_elec_idle;
+   wire           pipe_rx13_elec_idle;
+   wire           pipe_rx14_elec_idle;
+   wire           pipe_rx15_elec_idle;
+   wire           pipe_rx00_data_valid;
+   wire           pipe_rx01_data_valid;
+   wire           pipe_rx02_data_valid;
+   wire           pipe_rx03_data_valid;
+   wire           pipe_rx04_data_valid;
+   wire           pipe_rx05_data_valid;
+   wire           pipe_rx06_data_valid;
+   wire           pipe_rx07_data_valid;
+   wire           pipe_rx08_data_valid;
+   wire           pipe_rx09_data_valid;
+   wire           pipe_rx10_data_valid;
+   wire           pipe_rx11_data_valid;
+   wire           pipe_rx12_data_valid;
+   wire           pipe_rx13_data_valid;
+   wire           pipe_rx14_data_valid;
+   wire           pipe_rx15_data_valid;
+   wire [1:0]     pipe_rx00_start_block;
+   wire [1:0]     pipe_rx01_start_block;
+   wire [1:0]     pipe_rx02_start_block;
+   wire [1:0]     pipe_rx03_start_block;
+   wire [1:0]     pipe_rx04_start_block;
+   wire [1:0]     pipe_rx05_start_block;
+   wire [1:0]     pipe_rx06_start_block;
+   wire [1:0]     pipe_rx07_start_block;
+   wire [1:0]     pipe_rx08_start_block;
+   wire [1:0]     pipe_rx09_start_block;
+   wire [1:0]     pipe_rx10_start_block;
+   wire [1:0]     pipe_rx11_start_block;
+   wire [1:0]     pipe_rx12_start_block;
+   wire [1:0]     pipe_rx13_start_block;
+   wire [1:0]     pipe_rx14_start_block;
+   wire [1:0]     pipe_rx15_start_block;
+   wire [1:0]     pipe_rx00_sync_header;
+   wire [1:0]     pipe_rx01_sync_header;
+   wire [1:0]     pipe_rx02_sync_header;
+   wire [1:0]     pipe_rx03_sync_header;
+   wire [1:0]     pipe_rx04_sync_header;
+   wire [1:0]     pipe_rx05_sync_header;
+   wire [1:0]     pipe_rx06_sync_header;
+   wire [1:0]     pipe_rx07_sync_header;
+   wire [1:0]     pipe_rx08_sync_header;
+   wire [1:0]     pipe_rx09_sync_header;
+   wire [1:0]     pipe_rx10_sync_header;
+   wire [1:0]     pipe_rx11_sync_header;
+   wire [1:0]     pipe_rx12_sync_header;
+   wire [1:0]     pipe_rx13_sync_header;
+   wire [1:0]     pipe_rx14_sync_header;
+   wire [1:0]     pipe_rx15_sync_header;
+   wire           pipe_tx00_compliance;
+   wire           pipe_tx01_compliance;
+   wire           pipe_tx02_compliance;
+   wire           pipe_tx03_compliance;
+   wire           pipe_tx04_compliance;
+   wire           pipe_tx05_compliance;
+   wire           pipe_tx06_compliance;
+   wire           pipe_tx07_compliance;
+   wire           pipe_tx08_compliance;
+   wire           pipe_tx09_compliance;
+   wire           pipe_tx10_compliance;
+   wire           pipe_tx11_compliance;
+   wire           pipe_tx12_compliance;
+   wire           pipe_tx13_compliance;
+   wire           pipe_tx14_compliance;
+   wire           pipe_tx15_compliance;
+   wire [1:0]     pipe_tx00_char_is_k;
+   wire [1:0]     pipe_tx01_char_is_k;
+   wire [1:0]     pipe_tx02_char_is_k;
+   wire [1:0]     pipe_tx03_char_is_k;
+   wire [1:0]     pipe_tx04_char_is_k;
+   wire [1:0]     pipe_tx05_char_is_k;
+   wire [1:0]     pipe_tx06_char_is_k;
+   wire [1:0]     pipe_tx07_char_is_k;
+   wire [1:0]     pipe_tx08_char_is_k;
+   wire [1:0]     pipe_tx09_char_is_k;
+   wire [1:0]     pipe_tx10_char_is_k;
+   wire [1:0]     pipe_tx11_char_is_k;
+   wire [1:0]     pipe_tx12_char_is_k;
+   wire [1:0]     pipe_tx13_char_is_k;
+   wire [1:0]     pipe_tx14_char_is_k;
+   wire [1:0]     pipe_tx15_char_is_k;
+   wire [31:0]    pipe_tx00_data;
+   wire [31:0]    pipe_tx01_data;
+   wire [31:0]    pipe_tx02_data;
+   wire [31:0]    pipe_tx03_data;
+   wire [31:0]    pipe_tx04_data;
+   wire [31:0]    pipe_tx05_data;
+   wire [31:0]    pipe_tx06_data;
+   wire [31:0]    pipe_tx07_data;
+   wire [31:0]    pipe_tx08_data;
+   wire [31:0]    pipe_tx09_data;
+   wire [31:0]    pipe_tx10_data;
+   wire [31:0]    pipe_tx11_data;
+   wire [31:0]    pipe_tx12_data;
+   wire [31:0]    pipe_tx13_data;
+   wire [31:0]    pipe_tx14_data;
+   wire [31:0]    pipe_tx15_data;
+   wire           pipe_tx00_elec_idle;
+   wire           pipe_tx01_elec_idle;
+   wire           pipe_tx02_elec_idle;
+   wire           pipe_tx03_elec_idle;
+   wire           pipe_tx04_elec_idle;
+   wire           pipe_tx05_elec_idle;
+   wire           pipe_tx06_elec_idle;
+   wire           pipe_tx07_elec_idle;
+   wire           pipe_tx08_elec_idle;
+   wire           pipe_tx09_elec_idle;
+   wire           pipe_tx10_elec_idle;
+   wire           pipe_tx11_elec_idle;
+   wire           pipe_tx12_elec_idle;
+   wire           pipe_tx13_elec_idle;
+   wire           pipe_tx14_elec_idle;
+   wire           pipe_tx15_elec_idle;
+   wire [1:0]     pipe_tx00_powerdown;
+   wire [1:0]     pipe_tx01_powerdown;
+   wire [1:0]     pipe_tx02_powerdown;
+   wire [1:0]     pipe_tx03_powerdown;
+   wire [1:0]     pipe_tx04_powerdown;
+   wire [1:0]     pipe_tx05_powerdown;
+   wire [1:0]     pipe_tx06_powerdown;
+   wire [1:0]     pipe_tx07_powerdown;
+   wire [1:0]     pipe_tx08_powerdown;
+   wire [1:0]     pipe_tx09_powerdown;
+   wire [1:0]     pipe_tx10_powerdown;
+   wire [1:0]     pipe_tx11_powerdown;
+   wire [1:0]     pipe_tx12_powerdown;
+   wire [1:0]     pipe_tx13_powerdown;
+   wire [1:0]     pipe_tx14_powerdown;
+   wire [1:0]     pipe_tx15_powerdown;
+   wire           pipe_tx00_data_valid;
+   wire           pipe_tx01_data_valid;
+   wire           pipe_tx02_data_valid;
+   wire           pipe_tx03_data_valid;
+   wire           pipe_tx04_data_valid;
+   wire           pipe_tx05_data_valid;
+   wire           pipe_tx06_data_valid;
+   wire           pipe_tx07_data_valid;
+   wire           pipe_tx08_data_valid;
+   wire           pipe_tx09_data_valid;
+   wire           pipe_tx10_data_valid;
+   wire           pipe_tx11_data_valid;
+   wire           pipe_tx12_data_valid;
+   wire           pipe_tx13_data_valid;
+   wire           pipe_tx14_data_valid;
+   wire           pipe_tx15_data_valid;
+   wire           pipe_tx00_start_block;
+   wire           pipe_tx01_start_block;
+   wire           pipe_tx02_start_block;
+   wire           pipe_tx03_start_block;
+   wire           pipe_tx04_start_block;
+   wire           pipe_tx05_start_block;
+   wire           pipe_tx06_start_block;
+   wire           pipe_tx07_start_block;
+   wire           pipe_tx08_start_block;
+   wire           pipe_tx09_start_block;
+   wire           pipe_tx10_start_block;
+   wire           pipe_tx11_start_block;
+   wire           pipe_tx12_start_block;
+   wire           pipe_tx13_start_block;
+   wire           pipe_tx14_start_block;
+   wire           pipe_tx15_start_block;
+   wire [1:0]     pipe_tx00_sync_header;
+   wire [1:0]     pipe_tx01_sync_header;
+   wire [1:0]     pipe_tx02_sync_header;
+   wire [1:0]     pipe_tx03_sync_header;
+   wire [1:0]     pipe_tx04_sync_header;
+   wire [1:0]     pipe_tx05_sync_header;
+   wire [1:0]     pipe_tx06_sync_header;
+   wire [1:0]     pipe_tx07_sync_header;
+   wire [1:0]     pipe_tx08_sync_header;
+   wire [1:0]     pipe_tx09_sync_header;
+   wire [1:0]     pipe_tx10_sync_header;
+   wire [1:0]     pipe_tx11_sync_header;
+   wire [1:0]     pipe_tx12_sync_header;
+   wire [1:0]     pipe_tx13_sync_header;
+   wire [1:0]     pipe_tx14_sync_header;
+   wire [1:0]     pipe_tx15_sync_header;
+   wire [1:0]     pipe_rx00_eq_control;
+   wire [1:0]     pipe_rx01_eq_control;
+   wire [1:0]     pipe_rx02_eq_control;
+   wire [1:0]     pipe_rx03_eq_control;
+   wire [1:0]     pipe_rx04_eq_control;
+   wire [1:0]     pipe_rx05_eq_control;
+   wire [1:0]     pipe_rx06_eq_control;
+   wire [1:0]     pipe_rx07_eq_control;
+   wire [1:0]     pipe_rx08_eq_control;
+   wire [1:0]     pipe_rx09_eq_control;
+   wire [1:0]     pipe_rx10_eq_control;
+   wire [1:0]     pipe_rx11_eq_control;
+   wire [1:0]     pipe_rx12_eq_control;
+   wire [1:0]     pipe_rx13_eq_control;
+   wire [1:0]     pipe_rx14_eq_control;
+   wire [1:0]     pipe_rx15_eq_control;
+   wire           pipe_rx00_eq_lp_lf_fs_sel;
+   wire           pipe_rx01_eq_lp_lf_fs_sel;
+   wire           pipe_rx02_eq_lp_lf_fs_sel;
+   wire           pipe_rx03_eq_lp_lf_fs_sel;
+   wire           pipe_rx04_eq_lp_lf_fs_sel;
+   wire           pipe_rx05_eq_lp_lf_fs_sel;
+   wire           pipe_rx06_eq_lp_lf_fs_sel;
+   wire           pipe_rx07_eq_lp_lf_fs_sel;
+   wire           pipe_rx08_eq_lp_lf_fs_sel;
+   wire           pipe_rx09_eq_lp_lf_fs_sel;
+   wire           pipe_rx10_eq_lp_lf_fs_sel;
+   wire           pipe_rx11_eq_lp_lf_fs_sel;
+   wire           pipe_rx12_eq_lp_lf_fs_sel;
+   wire           pipe_rx13_eq_lp_lf_fs_sel;
+   wire           pipe_rx14_eq_lp_lf_fs_sel;
+   wire           pipe_rx15_eq_lp_lf_fs_sel;
+   wire [17:0]    pipe_rx00_eq_lp_new_tx_coeff_or_preset;
+   wire [17:0]    pipe_rx01_eq_lp_new_tx_coeff_or_preset;
+   wire [17:0]    pipe_rx02_eq_lp_new_tx_coeff_or_preset;
+   wire [17:0]    pipe_rx03_eq_lp_new_tx_coeff_or_preset;
+   wire [17:0]    pipe_rx04_eq_lp_new_tx_coeff_or_preset;
+   wire [17:0]    pipe_rx05_eq_lp_new_tx_coeff_or_preset;
+   wire [17:0]    pipe_rx06_eq_lp_new_tx_coeff_or_preset;
+   wire [17:0]    pipe_rx07_eq_lp_new_tx_coeff_or_preset;
+   wire [17:0]    pipe_rx08_eq_lp_new_tx_coeff_or_preset;
+   wire [17:0]    pipe_rx09_eq_lp_new_tx_coeff_or_preset;
+   wire [17:0]    pipe_rx10_eq_lp_new_tx_coeff_or_preset;
+   wire [17:0]    pipe_rx11_eq_lp_new_tx_coeff_or_preset;
+   wire [17:0]    pipe_rx12_eq_lp_new_tx_coeff_or_preset;
+   wire [17:0]    pipe_rx13_eq_lp_new_tx_coeff_or_preset;
+   wire [17:0]    pipe_rx14_eq_lp_new_tx_coeff_or_preset;
+   wire [17:0]    pipe_rx15_eq_lp_new_tx_coeff_or_preset;
+   wire           pipe_rx00_eq_lp_adapt_done;
+   wire           pipe_rx01_eq_lp_adapt_done;
+   wire           pipe_rx02_eq_lp_adapt_done;
+   wire           pipe_rx03_eq_lp_adapt_done;
+   wire           pipe_rx04_eq_lp_adapt_done;
+   wire           pipe_rx05_eq_lp_adapt_done;
+   wire           pipe_rx06_eq_lp_adapt_done;
+   wire           pipe_rx07_eq_lp_adapt_done;
+   wire           pipe_rx08_eq_lp_adapt_done;
+   wire           pipe_rx09_eq_lp_adapt_done;
+   wire           pipe_rx10_eq_lp_adapt_done;
+   wire           pipe_rx11_eq_lp_adapt_done;
+   wire           pipe_rx12_eq_lp_adapt_done;
+   wire           pipe_rx13_eq_lp_adapt_done;
+   wire           pipe_rx14_eq_lp_adapt_done;
+   wire           pipe_rx15_eq_lp_adapt_done;
+   wire           pipe_rx00_eq_done;
+   wire           pipe_rx01_eq_done;
+   wire           pipe_rx02_eq_done;
+   wire           pipe_rx03_eq_done;
+   wire           pipe_rx04_eq_done;
+   wire           pipe_rx05_eq_done;
+   wire           pipe_rx06_eq_done;
+   wire           pipe_rx07_eq_done;
+   wire           pipe_rx08_eq_done;
+   wire           pipe_rx09_eq_done;
+   wire           pipe_rx10_eq_done;
+   wire           pipe_rx11_eq_done;
+   wire           pipe_rx12_eq_done;
+   wire           pipe_rx13_eq_done;
+   wire           pipe_rx14_eq_done;
+   wire           pipe_rx15_eq_done;
+   wire [1:0]     pipe_tx00_eq_control;
+   wire [1:0]     pipe_tx01_eq_control;
+   wire [1:0]     pipe_tx02_eq_control;
+   wire [1:0]     pipe_tx03_eq_control;
+   wire [1:0]     pipe_tx04_eq_control;
+   wire [1:0]     pipe_tx05_eq_control;
+   wire [1:0]     pipe_tx06_eq_control;
+   wire [1:0]     pipe_tx07_eq_control;
+   wire [1:0]     pipe_tx08_eq_control;
+   wire [1:0]     pipe_tx09_eq_control;
+   wire [1:0]     pipe_tx10_eq_control;
+   wire [1:0]     pipe_tx11_eq_control;
+   wire [1:0]     pipe_tx12_eq_control;
+   wire [1:0]     pipe_tx13_eq_control;
+   wire [1:0]     pipe_tx14_eq_control;
+   wire [1:0]     pipe_tx15_eq_control;
+   wire [5:0]     pipe_tx00_eq_deemph;
+   wire [5:0]     pipe_tx01_eq_deemph;
+   wire [5:0]     pipe_tx02_eq_deemph;
+   wire [5:0]     pipe_tx03_eq_deemph;
+   wire [5:0]     pipe_tx04_eq_deemph;
+   wire [5:0]     pipe_tx05_eq_deemph;
+   wire [5:0]     pipe_tx06_eq_deemph;
+   wire [5:0]     pipe_tx07_eq_deemph;
+   wire [5:0]     pipe_tx08_eq_deemph;
+   wire [5:0]     pipe_tx09_eq_deemph;
+   wire [5:0]     pipe_tx10_eq_deemph;
+   wire [5:0]     pipe_tx11_eq_deemph;
+   wire [5:0]     pipe_tx12_eq_deemph;
+   wire [5:0]     pipe_tx13_eq_deemph;
+   wire [5:0]     pipe_tx14_eq_deemph;
+   wire [5:0]     pipe_tx15_eq_deemph;
+   wire [17:0]    pipe_tx00_eq_coeff;
+   wire [17:0]    pipe_tx01_eq_coeff;
+   wire [17:0]    pipe_tx02_eq_coeff;
+   wire [17:0]    pipe_tx03_eq_coeff;
+   wire [17:0]    pipe_tx04_eq_coeff;
+   wire [17:0]    pipe_tx05_eq_coeff;
+   wire [17:0]    pipe_tx06_eq_coeff;
+   wire [17:0]    pipe_tx07_eq_coeff;
+   wire [17:0]    pipe_tx08_eq_coeff;
+   wire [17:0]    pipe_tx09_eq_coeff;
+   wire [17:0]    pipe_tx10_eq_coeff;
+   wire [17:0]    pipe_tx11_eq_coeff;
+   wire [17:0]    pipe_tx12_eq_coeff;
+   wire [17:0]    pipe_tx13_eq_coeff;
+   wire [17:0]    pipe_tx14_eq_coeff;
+   wire [17:0]    pipe_tx15_eq_coeff;
+   wire           pipe_tx00_eq_done;
+   wire           pipe_tx01_eq_done;
+   wire           pipe_tx02_eq_done;
+   wire           pipe_tx03_eq_done;
+   wire           pipe_tx04_eq_done;
+   wire           pipe_tx05_eq_done;
+   wire           pipe_tx06_eq_done;
+   wire           pipe_tx07_eq_done;
+   wire           pipe_tx08_eq_done;
+   wire           pipe_tx09_eq_done;
+   wire           pipe_tx10_eq_done;
+   wire           pipe_tx11_eq_done;
+   wire           pipe_tx12_eq_done;
+   wire           pipe_tx13_eq_done;
+   wire           pipe_tx14_eq_done;
+   wire           pipe_tx15_eq_done;
+
+   wire [3:0]     pipe_rx_eq_lp_tx_preset;
+   wire [5:0]     pipe_rx_eq_lp_lf_fs;
+   wire           pipe_tx_rcvr_det;
+   wire [1:0]     pipe_tx_rate;
+   reg  [1:0]     pipe_tx_rate_ff;
+   reg            speed_change_in_progress;
+   wire           pipe_tx_deemph;
+   wire [2:0]     pipe_tx_margin;
+   wire           pipe_tx_swing;
+   wire           pipe_tx_reset;
+   wire [5:0]     pipe_eq_fs;
+   wire [5:0]     pipe_eq_lf;
+
+   wire [2:0]     pipe_rx_eq_preset = 3'b0;
+
+   wire           user_clk_en;
+   wire           sys_rst_n;
+   wire           sys_or_hot_rst;
+   wire           user_lnk_up_int;
+   wire           user_clk2 = (AXISTEN_IF_EXT_512 == "TRUE") ? core_clk : user_clk;
+   wire           mcap_clk;
+   wire		        pipe_clk;   
+
+
+
+   wire [(PL_LINK_CAP_MAX_LINK_WIDTH*64)-1:0]     PHY_RXDATA;
+   wire [(PL_LINK_CAP_MAX_LINK_WIDTH* 2)-1:0]     PHY_RXDATAK;
+   wire [PL_LINK_CAP_MAX_LINK_WIDTH-1:0]          PHY_RXDATA_VALID;
+   wire [(PL_LINK_CAP_MAX_LINK_WIDTH* 2)-1:0]     PHY_RXSTART_BLOCK;
+   reg [(PL_LINK_CAP_MAX_LINK_WIDTH* 2)-1:0]     PHY_RXSYNC_HEADER;
+
+   wire [PL_LINK_CAP_MAX_LINK_WIDTH-1:0]          PHY_RXVALID;
+   wire [PL_LINK_CAP_MAX_LINK_WIDTH-1:0]          PHY_PHYSTATUS;
+   wire [PL_LINK_CAP_MAX_LINK_WIDTH-1:0]          phy_status_fix;
+   wire [PL_LINK_CAP_MAX_LINK_WIDTH-1:0]          PHY_RXELECIDLE;
+   wire [(PL_LINK_CAP_MAX_LINK_WIDTH*3)-1:0]      PHY_RXSTATUS;
+
+   wire [(PL_LINK_CAP_MAX_LINK_WIDTH*18)-1:0]     PHY_TXEQ_NEW_COEFF;
+   wire [PL_LINK_CAP_MAX_LINK_WIDTH-1:0]          PHY_TXEQ_DONE;
+
+   wire [PL_LINK_CAP_MAX_LINK_WIDTH-1:0]          PHY_RXEQ_LFFS_SEL;
+   wire [(PL_LINK_CAP_MAX_LINK_WIDTH*18)-1:0]     PHY_RXEQ_NEW_TXCOEFF;
+   wire [PL_LINK_CAP_MAX_LINK_WIDTH-1:0]          PHY_RXEQ_ADAPT_DONE;
+   wire [PL_LINK_CAP_MAX_LINK_WIDTH-1:0]          PHY_RXEQ_DONE;
+
+   wire [PL_LINK_CAP_MAX_LINK_WIDTH*64-1:0]       PHY_TXDATA;
+   wire [PL_LINK_CAP_MAX_LINK_WIDTH*2-1:0]        PHY_TXDATAK;
+   wire [PL_LINK_CAP_MAX_LINK_WIDTH-1:0]          PHY_TXDATA_VALID;
+   wire [PL_LINK_CAP_MAX_LINK_WIDTH-1:0]          PHY_TXSTART_BLOCK;
+   wire [PL_LINK_CAP_MAX_LINK_WIDTH*2-1:0]        PHY_TXSYNC_HEADER;
+   wire [PL_LINK_CAP_MAX_LINK_WIDTH-1:0]          PHY_TXELECIDLE;
+   wire [PL_LINK_CAP_MAX_LINK_WIDTH-1:0]          PHY_TXCOMPLIANCE;
+   wire [PL_LINK_CAP_MAX_LINK_WIDTH-1:0]          PHY_RXPOLARITY;
+   wire [PL_LINK_CAP_MAX_LINK_WIDTH*2-1:0]        PHY_TXEQ_CTRL;
+   wire [PL_LINK_CAP_MAX_LINK_WIDTH*4-1:0]        PHY_TXEQ_PRESET;
+   wire [PL_LINK_CAP_MAX_LINK_WIDTH*6-1:0]        PHY_TXEQ_COEFF;
+   wire [PL_LINK_CAP_MAX_LINK_WIDTH*2-1:0]        PHY_RXEQ_CTRL;
+
+(* keep = "true", max_fanout = 800 *) reg   reg_user_lnk_up;
+(* keep = "true", max_fanout = 800 *) reg   user_reset_int;
+(* keep = "true", max_fanout = 800 *) reg   reg_user_reset;
+
+   reg   as_cdr_hold_req_user;
+   reg   as_cdr_hold_req_ff;
+   reg   as_cdr_hold_req_ff1;
+   reg   as_mac_in_detect_user;
+   reg   as_mac_in_detect_ff;
+   reg   as_mac_in_detect_ff1;
+
+// Gate rxsync_header with rxstart_block
+wire [(PL_LINK_CAP_MAX_LINK_WIDTH* 2)-1:0]     rxsync_header_nogate;
+integer ii;
+always @*
+  for (ii=0;ii<(PL_LINK_CAP_MAX_LINK_WIDTH*2);ii=ii+2)
+    PHY_RXSYNC_HEADER[ii+:2] = rxsync_header_nogate[ii+:2] & {2{^PHY_RXSTART_BLOCK[ii+:2]}};
+
+
+// Workaround for the double-triggering on cfg_msg_transmit
+wire cfg_msg_transmit_int = cfg_msg_transmit & ~cfg_msg_transmit_done;
+
+generate if (EXT_PIPE_SIM == "TRUE") 
+begin
+  /////////////// phy_rdy, rcvr det , seepd_change & gt_powerdown /////////////////////////////
+  
+  reg [31:0] phy_rdy_reg = 32'b0;
+  reg [31:0] rcvr_det_reg     = 32'b0;
+  reg  [7:0] pipe_rate_reg    = 8'b0;
+  reg  [7:0] gt_powerdown_reg = {4{2'b10}};
+  
+  wire      rcvr_det;
+  wire      speed_change;
+  wire      gt_powerdown;
+
+  wire      pipe_tx0_rcvr_det;
+
+    
+  always @ (posedge pipe_clk)
+  begin
+   phy_rdy_reg      <= {phy_rdy_reg[30:0], sys_rst_n};
+   rcvr_det_reg     <= {rcvr_det_reg[30:0], pipe_tx0_rcvr_det};
+   pipe_rate_reg    <= {pipe_rate_reg[5:0], common_commands_out[2:1]};
+   gt_powerdown_reg <= {gt_powerdown_reg[5:0],pipe_tx_0_sigs[41:40]};
+  end 
+  
+  assign phy_rdy      =  phy_rdy_reg[31];
+  assign rcvr_det     = ~rcvr_det_reg[30] && rcvr_det_reg[29];
+  assign speed_change = (pipe_rate_reg[7:6] != pipe_rate_reg[5:4])? 1'b1 : 1'b0;
+  assign gt_powerdown = (gt_powerdown_reg[7:6] == 2'b10 && gt_powerdown_reg[5:4] == 2'b0)? 1'b1 : 1'b0;
+  
+  
+  
+  //////// generate Rx status and Phy status ////////////// 
+  
+  wire [2:0] rx_status;
+  wire       phy_status;
+  
+  assign  rx_status  = (pipe_tx0_rcvr_det && rcvr_det) ? 3'b011 : 3'b0;
+  assign  phy_status = (pipe_tx0_rcvr_det && rcvr_det) || speed_change || gt_powerdown ;
+
+   
+  //////// generate clocks for pipe mode //////////////
+ 
+  wire clk_500;
+  wire clk_250;
+  wire clk_125;
+  wire clk_62_5;
+ 
+  xp4_usp_smsw_sys_clk_gen_ps 	#(.offset(7000),.halfcycle(1000)) clk_gen_500  (.sys_clk(clk_500));
+  xp4_usp_smsw_sys_clk_gen_ps 	#(.offset(6000),.halfcycle(2000)) clk_gen_250  (.sys_clk(clk_250));
+  xp4_usp_smsw_sys_clk_gen_ps 	#(.offset(4000),.halfcycle(4000)) clk_gen_125  (.sys_clk(clk_125));
+  xp4_usp_smsw_sys_clk_gen_ps 	#(.offset(0000),.halfcycle(8000)) clk_gen_62_5 (.sys_clk(clk_62_5));
+ 
+  assign mcap_clk = (CRM_USER_CLK_FREQ == 2'b10 || CRM_USER_CLK_FREQ == 2'b11) ? clk_125 : user_clk;
+  assign pipe_clk = (common_commands_out[2:1] == 2'b0)? clk_125 : clk_250;
+  assign core_clk = (CRM_CORE_CLK_FREQ_500 == "TRUE") ? clk_500 : clk_250 ;
+  assign user_clk = (CRM_USER_CLK_FREQ == 2'b10 || CRM_USER_CLK_FREQ == 2'b11) ? clk_250: ((CRM_USER_CLK_FREQ == 01) ? clk_125 : clk_62_5);
+
+  // PCIE_4_0 Instance
+  xp4_usp_smsw_model_pipe 
+  #(
+
+    .TCQ(TCQ)
+   ,.IMPL_TARGET(IMPL_TARGET)
+   ,.AXISTEN_IF_EXT_512_INTFC_RAM_STYLE(AXISTEN_IF_EXT_512_INTFC_RAM_STYLE)
+   ,.CRM_CORE_CLK_FREQ_500(CRM_CORE_CLK_FREQ_500)
+   ,.CRM_USER_CLK_FREQ(CRM_USER_CLK_FREQ)
+   ,.AXISTEN_IF_WIDTH(AXISTEN_IF_WIDTH)
+   ,.AXISTEN_IF_EXT_512_CQ_STRADDLE(AXISTEN_IF_EXT_512_CQ_STRADDLE)
+   ,.AXISTEN_IF_EXT_512_CC_STRADDLE(AXISTEN_IF_EXT_512_CC_STRADDLE)
+   ,.AXISTEN_IF_EXT_512_RQ_STRADDLE(AXISTEN_IF_EXT_512_RQ_STRADDLE)
+   ,.AXISTEN_IF_EXT_512_RC_STRADDLE(AXISTEN_IF_EXT_512_RC_STRADDLE)
+   ,.AXISTEN_IF_EXT_512_RC_4TLP_STRADDLE(AXISTEN_IF_EXT_512_RC_4TLP_STRADDLE)
+   ,.AXISTEN_IF_EXT_512(AXISTEN_IF_EXT_512)
+   ,.AXISTEN_IF_CQ_ALIGNMENT_MODE(AXISTEN_IF_CQ_ALIGNMENT_MODE)
+   ,.AXISTEN_IF_CC_ALIGNMENT_MODE(AXISTEN_IF_CC_ALIGNMENT_MODE)
+   ,.AXISTEN_IF_RQ_ALIGNMENT_MODE(AXISTEN_IF_RQ_ALIGNMENT_MODE)
+   ,.AXISTEN_IF_RC_ALIGNMENT_MODE(AXISTEN_IF_RC_ALIGNMENT_MODE)
+   ,.AXISTEN_IF_RC_STRADDLE(AXISTEN_IF_RC_STRADDLE)
+   ,.AXI4_DATA_WIDTH(AXI4_DATA_WIDTH)
+   ,.AXI4_TKEEP_WIDTH(AXI4_TKEEP_WIDTH)
+   ,.AXI4_CQ_TUSER_WIDTH(AXI4_CQ_TUSER_WIDTH)
+   ,.AXI4_CC_TUSER_WIDTH(AXI4_CC_TUSER_WIDTH)
+   ,.AXI4_RQ_TUSER_WIDTH(AXI4_RQ_TUSER_WIDTH)
+   ,.AXI4_RC_TUSER_WIDTH(AXI4_RC_TUSER_WIDTH)
+   ,.AXI4_CQ_TREADY_WIDTH(AXI4_CQ_TREADY_WIDTH)
+   ,.AXI4_CC_TREADY_WIDTH(AXI4_CC_TREADY_WIDTH)
+   ,.AXI4_RQ_TREADY_WIDTH(AXI4_RQ_TREADY_WIDTH)
+   ,.AXI4_RC_TREADY_WIDTH(AXI4_RC_TREADY_WIDTH)
+   ,.AXISTEN_IF_ENABLE_RX_MSG_INTFC(AXISTEN_IF_ENABLE_RX_MSG_INTFC)
+   ,.AXISTEN_IF_ENABLE_MSG_ROUTE(AXISTEN_IF_ENABLE_MSG_ROUTE)
+   ,.AXISTEN_IF_RX_PARITY_EN(AXISTEN_IF_RX_PARITY_EN)
+   ,.AXISTEN_IF_TX_PARITY_EN(AXISTEN_IF_TX_PARITY_EN)
+   ,.AXISTEN_IF_ENABLE_CLIENT_TAG(AXISTEN_IF_ENABLE_CLIENT_TAG)
+   ,.AXISTEN_IF_ENABLE_256_TAGS(AXISTEN_IF_ENABLE_256_TAGS)
+   ,.AXISTEN_IF_COMPL_TIMEOUT_REG0(AXISTEN_IF_COMPL_TIMEOUT_REG0)
+   ,.AXISTEN_IF_COMPL_TIMEOUT_REG1(AXISTEN_IF_COMPL_TIMEOUT_REG1)
+   ,.AXISTEN_IF_LEGACY_MODE_ENABLE(AXISTEN_IF_LEGACY_MODE_ENABLE)
+   ,.AXISTEN_IF_ENABLE_MESSAGE_RID_CHECK(AXISTEN_IF_ENABLE_MESSAGE_RID_CHECK)
+   ,.AXISTEN_IF_MSIX_TO_RAM_PIPELINE(AXISTEN_IF_MSIX_TO_RAM_PIPELINE)
+   ,.AXISTEN_IF_MSIX_FROM_RAM_PIPELINE(AXISTEN_IF_MSIX_FROM_RAM_PIPELINE)
+   ,.AXISTEN_IF_MSIX_RX_PARITY_EN(AXISTEN_IF_MSIX_RX_PARITY_EN)
+   ,.AXISTEN_IF_ENABLE_INTERNAL_MSIX_TABLE(AXISTEN_IF_ENABLE_INTERNAL_MSIX_TABLE)
+   ,.AXISTEN_IF_SIM_SHORT_CPL_TIMEOUT(AXISTEN_IF_SIM_SHORT_CPL_TIMEOUT)
+   ,.AXISTEN_IF_CQ_EN_POISONED_MEM_WR(AXISTEN_IF_CQ_EN_POISONED_MEM_WR)
+   ,.AXISTEN_IF_RQ_CC_REGISTERED_TREADY(AXISTEN_IF_RQ_CC_REGISTERED_TREADY)
+   ,.PM_ASPML0S_TIMEOUT(PM_ASPML0S_TIMEOUT)
+   ,.PM_L1_REENTRY_DELAY(PM_L1_REENTRY_DELAY)
+   ,.PM_ASPML1_ENTRY_DELAY(PM_ASPML1_ENTRY_DELAY)
+   ,.PM_ENABLE_SLOT_POWER_CAPTURE(PM_ENABLE_SLOT_POWER_CAPTURE)
+   ,.PM_PME_SERVICE_TIMEOUT_DELAY(PM_PME_SERVICE_TIMEOUT_DELAY)
+   ,.PM_PME_TURNOFF_ACK_DELAY(PM_PME_TURNOFF_ACK_DELAY)
+   ,.PL_UPSTREAM_FACING(PL_UPSTREAM_FACING)
+   ,.PL_LINK_CAP_MAX_LINK_WIDTH(PL_LINK_CAP_MAX_LINK_WIDTH)
+   ,.PL_LINK_CAP_MAX_LINK_SPEED(PL_LINK_CAP_MAX_LINK_SPEED)
+   ,.PL_DISABLE_DC_BALANCE(PL_DISABLE_DC_BALANCE)
+   ,.PL_DISABLE_EI_INFER_IN_L0(PL_DISABLE_EI_INFER_IN_L0)
+   ,.PL_N_FTS(PL_N_FTS)
+   ,.PL_DISABLE_UPCONFIG_CAPABLE(PL_DISABLE_UPCONFIG_CAPABLE)
+   ,.PL_DISABLE_RETRAIN_ON_FRAMING_ERROR(PL_DISABLE_RETRAIN_ON_FRAMING_ERROR)
+   ,.PL_DISABLE_RETRAIN_ON_EB_ERROR(PL_DISABLE_RETRAIN_ON_EB_ERROR)
+   ,.PL_DISABLE_RETRAIN_ON_SPECIFIC_FRAMING_ERROR(PL_DISABLE_RETRAIN_ON_SPECIFIC_FRAMING_ERROR)
+   ,.PL_REPORT_ALL_PHY_ERRORS(PL_REPORT_ALL_PHY_ERRORS)
+   ,.PL_DISABLE_LFSR_UPDATE_ON_SKP(PL_DISABLE_LFSR_UPDATE_ON_SKP)
+   ,.PL_LANE0_EQ_CONTROL(PL_LANE0_EQ_CONTROL)
+   ,.PL_LANE1_EQ_CONTROL(PL_LANE1_EQ_CONTROL)
+   ,.PL_LANE2_EQ_CONTROL(PL_LANE2_EQ_CONTROL)
+   ,.PL_LANE3_EQ_CONTROL(PL_LANE3_EQ_CONTROL)
+   ,.PL_LANE4_EQ_CONTROL(PL_LANE4_EQ_CONTROL)
+   ,.PL_LANE5_EQ_CONTROL(PL_LANE5_EQ_CONTROL)
+   ,.PL_LANE6_EQ_CONTROL(PL_LANE6_EQ_CONTROL)
+   ,.PL_LANE7_EQ_CONTROL(PL_LANE7_EQ_CONTROL)
+   ,.PL_LANE8_EQ_CONTROL(PL_LANE8_EQ_CONTROL)
+   ,.PL_LANE9_EQ_CONTROL(PL_LANE9_EQ_CONTROL)
+   ,.PL_LANE10_EQ_CONTROL(PL_LANE10_EQ_CONTROL)
+   ,.PL_LANE11_EQ_CONTROL(PL_LANE11_EQ_CONTROL)
+   ,.PL_LANE12_EQ_CONTROL(PL_LANE12_EQ_CONTROL)
+   ,.PL_LANE13_EQ_CONTROL(PL_LANE13_EQ_CONTROL)
+   ,.PL_LANE14_EQ_CONTROL(PL_LANE14_EQ_CONTROL)
+   ,.PL_LANE15_EQ_CONTROL(PL_LANE15_EQ_CONTROL)
+   ,.PL_EQ_BYPASS_PHASE23(PL_EQ_BYPASS_PHASE23)
+   ,.PL_EQ_ADAPT_ITER_COUNT(PL_EQ_ADAPT_ITER_COUNT)
+   ,.PL_EQ_ADAPT_REJECT_RETRY_COUNT(PL_EQ_ADAPT_REJECT_RETRY_COUNT)
+   ,.PL_EQ_SHORT_ADAPT_PHASE(PL_EQ_SHORT_ADAPT_PHASE)
+   ,.PL_EQ_ADAPT_DISABLE_COEFF_CHECK(PL_EQ_ADAPT_DISABLE_COEFF_CHECK)
+   ,.PL_EQ_ADAPT_DISABLE_PRESET_CHECK(PL_EQ_ADAPT_DISABLE_PRESET_CHECK)
+   ,.PL_EQ_DEFAULT_TX_PRESET(PL_EQ_DEFAULT_TX_PRESET)
+   ,.PL_EQ_DEFAULT_RX_PRESET_HINT(PL_EQ_DEFAULT_RX_PRESET_HINT)
+   ,.PL_EQ_RX_ADAPT_EQ_PHASE0(PL_EQ_RX_ADAPT_EQ_PHASE0)
+   ,.PL_EQ_RX_ADAPT_EQ_PHASE1(PL_EQ_RX_ADAPT_EQ_PHASE1)
+   ,.PL_EQ_DISABLE_MISMATCH_CHECK(PL_EQ_DISABLE_MISMATCH_CHECK)
+   ,.PL_RX_L0S_EXIT_TO_RECOVERY(PL_RX_L0S_EXIT_TO_RECOVERY)
+   ,.PL_EQ_TX_8G_EQ_TS2_ENABLE(PL_EQ_TX_8G_EQ_TS2_ENABLE)
+   ,.PL_DISABLE_AUTO_EQ_SPEED_CHANGE_TO_GEN4(PL_DISABLE_AUTO_EQ_SPEED_CHANGE_TO_GEN4)
+   ,.PL_DISABLE_AUTO_EQ_SPEED_CHANGE_TO_GEN3(PL_DISABLE_AUTO_EQ_SPEED_CHANGE_TO_GEN3)
+   ,.PL_DISABLE_AUTO_SPEED_CHANGE_TO_GEN2(PL_DISABLE_AUTO_SPEED_CHANGE_TO_GEN2)
+   ,.PL_DESKEW_ON_SKIP_IN_GEN12(PL_DESKEW_ON_SKIP_IN_GEN12)
+   ,.PL_INFER_EI_DISABLE_REC_RC(PL_INFER_EI_DISABLE_REC_RC)
+   ,.PL_INFER_EI_DISABLE_REC_SPD(PL_INFER_EI_DISABLE_REC_SPD)
+   ,.PL_INFER_EI_DISABLE_LPBK_ACTIVE(PL_INFER_EI_DISABLE_LPBK_ACTIVE)
+   ,.PL_RX_ADAPT_TIMER_RRL_GEN3(PL_RX_ADAPT_TIMER_RRL_GEN3)
+   ,.PL_RX_ADAPT_TIMER_RRL_CLOBBER_TX_TS(PL_RX_ADAPT_TIMER_RRL_CLOBBER_TX_TS)
+   ,.PL_RX_ADAPT_TIMER_RRL_GEN4(PL_RX_ADAPT_TIMER_RRL_GEN4)
+   ,.PL_RX_ADAPT_TIMER_CLWS_GEN3(PL_RX_ADAPT_TIMER_CLWS_GEN3)
+   ,.PL_RX_ADAPT_TIMER_CLWS_CLOBBER_TX_TS(PL_RX_ADAPT_TIMER_CLWS_CLOBBER_TX_TS)
+   ,.PL_RX_ADAPT_TIMER_CLWS_GEN4(PL_RX_ADAPT_TIMER_CLWS_GEN4)
+   ,.PL_DISABLE_LANE_REVERSAL(PL_DISABLE_LANE_REVERSAL)
+   ,.PL_CFG_STATE_ROBUSTNESS_ENABLE(PL_CFG_STATE_ROBUSTNESS_ENABLE)
+   ,.PL_REDO_EQ_SOURCE_SELECT(PL_REDO_EQ_SOURCE_SELECT)
+   ,.PL_DEEMPH_SOURCE_SELECT(PL_DEEMPH_SOURCE_SELECT)
+   ,.PL_EXIT_LOOPBACK_ON_EI_ENTRY(PL_EXIT_LOOPBACK_ON_EI_ENTRY)
+   ,.PL_QUIESCE_GUARANTEE_DISABLE(PL_QUIESCE_GUARANTEE_DISABLE)
+   ,.PL_SRIS_ENABLE(PL_SRIS_ENABLE)
+   ,.PL_SRIS_SKPOS_GEN_SPD_VEC(PL_SRIS_SKPOS_GEN_SPD_VEC)
+   ,.PL_SRIS_SKPOS_REC_SPD_VEC(PL_SRIS_SKPOS_REC_SPD_VEC)
+   ,.PL_SIM_FAST_LINK_TRAINING(PL_SIM_FAST_LINK_TRAINING)
+   ,.PL_USER_SPARE(PL_USER_SPARE)
+   ,.LL_ACK_TIMEOUT_EN(LL_ACK_TIMEOUT_EN)
+   ,.LL_ACK_TIMEOUT(LL_ACK_TIMEOUT)
+   ,.LL_ACK_TIMEOUT_FUNC(LL_ACK_TIMEOUT_FUNC)
+   ,.LL_REPLAY_TIMEOUT_EN(LL_REPLAY_TIMEOUT_EN)
+   ,.LL_REPLAY_TIMEOUT(LL_REPLAY_TIMEOUT)
+   ,.LL_REPLAY_TIMEOUT_FUNC(LL_REPLAY_TIMEOUT_FUNC)
+   ,.LL_REPLAY_TO_RAM_PIPELINE(LL_REPLAY_TO_RAM_PIPELINE)
+   ,.LL_REPLAY_FROM_RAM_PIPELINE(LL_REPLAY_FROM_RAM_PIPELINE)
+   ,.LL_DISABLE_SCHED_TX_NAK(LL_DISABLE_SCHED_TX_NAK)
+   ,.LL_TX_TLP_PARITY_CHK(LL_TX_TLP_PARITY_CHK)
+   ,.LL_RX_TLP_PARITY_GEN(LL_RX_TLP_PARITY_GEN)
+   ,.LL_USER_SPARE(LL_USER_SPARE)
+   ,.IS_SWITCH_PORT(IS_SWITCH_PORT)
+   ,.CFG_BYPASS_MODE_ENABLE(CFG_BYPASS_MODE_ENABLE)
+   ,.TL_PF_ENABLE_REG(TL_PF_ENABLE_REG)
+   ,.TL_CREDITS_CD(TL_CREDITS_CD)
+   ,.TL_CREDITS_CH(TL_CREDITS_CH)
+   ,.TL_COMPLETION_RAM_SIZE(TL_COMPLETION_RAM_SIZE)
+   ,.TL_COMPLETION_RAM_NUM_TLPS(TL_COMPLETION_RAM_NUM_TLPS)
+   ,.TL_CREDITS_NPD(TL_CREDITS_NPD)
+   ,.TL_CREDITS_NPH(TL_CREDITS_NPH)
+   ,.TL_CREDITS_PD(TL_CREDITS_PD)
+   ,.TL_CREDITS_PH(TL_CREDITS_PH)
+   ,.TL_RX_COMPLETION_TO_RAM_WRITE_PIPELINE(TL_RX_COMPLETION_TO_RAM_WRITE_PIPELINE)
+   ,.TL_RX_COMPLETION_TO_RAM_READ_PIPELINE(TL_RX_COMPLETION_TO_RAM_READ_PIPELINE)
+   ,.TL_RX_COMPLETION_FROM_RAM_READ_PIPELINE(TL_RX_COMPLETION_FROM_RAM_READ_PIPELINE)
+   ,.TL_POSTED_RAM_SIZE(TL_POSTED_RAM_SIZE)
+   ,.TL_RX_POSTED_TO_RAM_WRITE_PIPELINE(TL_RX_POSTED_TO_RAM_WRITE_PIPELINE)
+   ,.TL_RX_POSTED_TO_RAM_READ_PIPELINE(TL_RX_POSTED_TO_RAM_READ_PIPELINE)
+   ,.TL_RX_POSTED_FROM_RAM_READ_PIPELINE(TL_RX_POSTED_FROM_RAM_READ_PIPELINE)
+   ,.TL_TX_MUX_STRICT_PRIORITY(TL_TX_MUX_STRICT_PRIORITY)
+   ,.TL_TX_TLP_STRADDLE_ENABLE(TL_TX_TLP_STRADDLE_ENABLE)
+   ,.TL_TX_TLP_TERMINATE_PARITY(TL_TX_TLP_TERMINATE_PARITY)
+   ,.TL_FC_UPDATE_MIN_INTERVAL_TLP_COUNT(TL_FC_UPDATE_MIN_INTERVAL_TLP_COUNT)
+   ,.TL_FC_UPDATE_MIN_INTERVAL_TIME(TL_FC_UPDATE_MIN_INTERVAL_TIME)
+   ,.TL_USER_SPARE(TL_USER_SPARE)
+   ,.PF0_CLASS_CODE(PF0_CLASS_CODE)
+   ,.PF1_CLASS_CODE(PF1_CLASS_CODE)
+   ,.PF2_CLASS_CODE(PF2_CLASS_CODE)
+   ,.PF3_CLASS_CODE(PF3_CLASS_CODE)
+   ,.PF0_INTERRUPT_PIN(PF0_INTERRUPT_PIN)
+   ,.PF1_INTERRUPT_PIN(PF1_INTERRUPT_PIN)
+   ,.PF2_INTERRUPT_PIN(PF2_INTERRUPT_PIN)
+   ,.PF3_INTERRUPT_PIN(PF3_INTERRUPT_PIN)
+   ,.PF0_CAPABILITY_POINTER(PF0_CAPABILITY_POINTER)
+   ,.PF1_CAPABILITY_POINTER(PF1_CAPABILITY_POINTER)
+   ,.PF2_CAPABILITY_POINTER(PF2_CAPABILITY_POINTER)
+   ,.PF3_CAPABILITY_POINTER(PF3_CAPABILITY_POINTER)
+   ,.VF0_CAPABILITY_POINTER(VF0_CAPABILITY_POINTER)
+   ,.LEGACY_CFG_EXTEND_INTERFACE_ENABLE(LEGACY_CFG_EXTEND_INTERFACE_ENABLE)
+   ,.EXTENDED_CFG_EXTEND_INTERFACE_ENABLE(EXTENDED_CFG_EXTEND_INTERFACE_ENABLE)
+   ,.TL2CFG_IF_PARITY_CHK(TL2CFG_IF_PARITY_CHK)
+   ,.HEADER_TYPE_OVERRIDE(HEADER_TYPE_OVERRIDE)
+   ,.PF0_BAR0_CONTROL(PF0_BAR0_CONTROL)
+   ,.PF1_BAR0_CONTROL(PF1_BAR0_CONTROL)
+   ,.PF2_BAR0_CONTROL(PF2_BAR0_CONTROL)
+   ,.PF3_BAR0_CONTROL(PF3_BAR0_CONTROL)
+   ,.PF0_BAR0_APERTURE_SIZE(PF0_BAR0_APERTURE_SIZE)
+   ,.PF1_BAR0_APERTURE_SIZE(PF1_BAR0_APERTURE_SIZE)
+   ,.PF2_BAR0_APERTURE_SIZE(PF2_BAR0_APERTURE_SIZE)
+   ,.PF3_BAR0_APERTURE_SIZE(PF3_BAR0_APERTURE_SIZE)
+   ,.PF0_BAR1_CONTROL(PF0_BAR1_CONTROL)
+   ,.PF1_BAR1_CONTROL(PF1_BAR1_CONTROL)
+   ,.PF2_BAR1_CONTROL(PF2_BAR1_CONTROL)
+   ,.PF3_BAR1_CONTROL(PF3_BAR1_CONTROL)
+   ,.PF0_BAR1_APERTURE_SIZE(PF0_BAR1_APERTURE_SIZE)
+   ,.PF1_BAR1_APERTURE_SIZE(PF1_BAR1_APERTURE_SIZE)
+   ,.PF2_BAR1_APERTURE_SIZE(PF2_BAR1_APERTURE_SIZE)
+   ,.PF3_BAR1_APERTURE_SIZE(PF3_BAR1_APERTURE_SIZE)
+   ,.PF0_BAR2_CONTROL(PF0_BAR2_CONTROL)
+   ,.PF1_BAR2_CONTROL(PF1_BAR2_CONTROL)
+   ,.PF2_BAR2_CONTROL(PF2_BAR2_CONTROL)
+   ,.PF3_BAR2_CONTROL(PF3_BAR2_CONTROL)
+   ,.PF0_BAR2_APERTURE_SIZE(PF0_BAR2_APERTURE_SIZE)
+   ,.PF1_BAR2_APERTURE_SIZE(PF1_BAR2_APERTURE_SIZE)
+   ,.PF2_BAR2_APERTURE_SIZE(PF2_BAR2_APERTURE_SIZE)
+   ,.PF3_BAR2_APERTURE_SIZE(PF3_BAR2_APERTURE_SIZE)
+   ,.PF0_BAR3_CONTROL(PF0_BAR3_CONTROL)
+   ,.PF1_BAR3_CONTROL(PF1_BAR3_CONTROL)
+   ,.PF2_BAR3_CONTROL(PF2_BAR3_CONTROL)
+   ,.PF3_BAR3_CONTROL(PF3_BAR3_CONTROL)
+   ,.PF0_BAR3_APERTURE_SIZE(PF0_BAR3_APERTURE_SIZE)
+   ,.PF1_BAR3_APERTURE_SIZE(PF1_BAR3_APERTURE_SIZE)
+   ,.PF2_BAR3_APERTURE_SIZE(PF2_BAR3_APERTURE_SIZE)
+   ,.PF3_BAR3_APERTURE_SIZE(PF3_BAR3_APERTURE_SIZE)
+   ,.PF0_BAR4_CONTROL(PF0_BAR4_CONTROL)
+   ,.PF1_BAR4_CONTROL(PF1_BAR4_CONTROL)
+   ,.PF2_BAR4_CONTROL(PF2_BAR4_CONTROL)
+   ,.PF3_BAR4_CONTROL(PF3_BAR4_CONTROL)
+   ,.PF0_BAR4_APERTURE_SIZE(PF0_BAR4_APERTURE_SIZE)
+   ,.PF1_BAR4_APERTURE_SIZE(PF1_BAR4_APERTURE_SIZE)
+   ,.PF2_BAR4_APERTURE_SIZE(PF2_BAR4_APERTURE_SIZE)
+   ,.PF3_BAR4_APERTURE_SIZE(PF3_BAR4_APERTURE_SIZE)
+   ,.PF0_BAR5_CONTROL(PF0_BAR5_CONTROL)
+   ,.PF1_BAR5_CONTROL(PF1_BAR5_CONTROL)
+   ,.PF2_BAR5_CONTROL(PF2_BAR5_CONTROL)
+   ,.PF3_BAR5_CONTROL(PF3_BAR5_CONTROL)
+   ,.PF0_BAR5_APERTURE_SIZE(PF0_BAR5_APERTURE_SIZE)
+   ,.PF1_BAR5_APERTURE_SIZE(PF1_BAR5_APERTURE_SIZE)
+   ,.PF2_BAR5_APERTURE_SIZE(PF2_BAR5_APERTURE_SIZE)
+   ,.PF3_BAR5_APERTURE_SIZE(PF3_BAR5_APERTURE_SIZE)
+   ,.PF0_EXPANSION_ROM_ENABLE(PF0_EXPANSION_ROM_ENABLE)
+   ,.PF1_EXPANSION_ROM_ENABLE(PF1_EXPANSION_ROM_ENABLE)
+   ,.PF2_EXPANSION_ROM_ENABLE(PF2_EXPANSION_ROM_ENABLE)
+   ,.PF3_EXPANSION_ROM_ENABLE(PF3_EXPANSION_ROM_ENABLE)
+   ,.PF0_EXPANSION_ROM_APERTURE_SIZE(PF0_EXPANSION_ROM_APERTURE_SIZE)
+   ,.PF1_EXPANSION_ROM_APERTURE_SIZE(PF1_EXPANSION_ROM_APERTURE_SIZE)
+   ,.PF2_EXPANSION_ROM_APERTURE_SIZE(PF2_EXPANSION_ROM_APERTURE_SIZE)
+   ,.PF3_EXPANSION_ROM_APERTURE_SIZE(PF3_EXPANSION_ROM_APERTURE_SIZE)
+   ,.PF0_PCIE_CAP_NEXTPTR(PF0_PCIE_CAP_NEXTPTR)
+   ,.PF1_PCIE_CAP_NEXTPTR(PF1_PCIE_CAP_NEXTPTR)
+   ,.PF2_PCIE_CAP_NEXTPTR(PF2_PCIE_CAP_NEXTPTR)
+   ,.PF3_PCIE_CAP_NEXTPTR(PF3_PCIE_CAP_NEXTPTR)
+   ,.VFG0_PCIE_CAP_NEXTPTR(VFG0_PCIE_CAP_NEXTPTR)
+   ,.VFG1_PCIE_CAP_NEXTPTR(VFG1_PCIE_CAP_NEXTPTR)
+   ,.VFG2_PCIE_CAP_NEXTPTR(VFG2_PCIE_CAP_NEXTPTR)
+   ,.VFG3_PCIE_CAP_NEXTPTR(VFG3_PCIE_CAP_NEXTPTR)
+   ,.PF0_DEV_CAP_MAX_PAYLOAD_SIZE(PF0_DEV_CAP_MAX_PAYLOAD_SIZE)
+   ,.PF1_DEV_CAP_MAX_PAYLOAD_SIZE(PF1_DEV_CAP_MAX_PAYLOAD_SIZE)
+   ,.PF2_DEV_CAP_MAX_PAYLOAD_SIZE(PF2_DEV_CAP_MAX_PAYLOAD_SIZE)
+   ,.PF3_DEV_CAP_MAX_PAYLOAD_SIZE(PF3_DEV_CAP_MAX_PAYLOAD_SIZE)
+   ,.PF0_DEV_CAP_EXT_TAG_SUPPORTED(PF0_DEV_CAP_EXT_TAG_SUPPORTED)
+   ,.PF0_DEV_CAP_ENDPOINT_L0S_LATENCY(PF0_DEV_CAP_ENDPOINT_L0S_LATENCY)
+   ,.PF0_DEV_CAP_ENDPOINT_L1_LATENCY(PF0_DEV_CAP_ENDPOINT_L1_LATENCY)
+   ,.PF0_DEV_CAP_FUNCTION_LEVEL_RESET_CAPABLE(PF0_DEV_CAP_FUNCTION_LEVEL_RESET_CAPABLE)
+   ,.PF0_LINK_CAP_ASPM_SUPPORT(PF0_LINK_CAP_ASPM_SUPPORT)
+   ,.PF0_LINK_CONTROL_RCB(PF0_LINK_CONTROL_RCB)
+   ,.PF0_LINK_STATUS_SLOT_CLOCK_CONFIG(PF0_LINK_STATUS_SLOT_CLOCK_CONFIG)
+   ,.PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN1(PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN1)
+   ,.PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN2(PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN2)
+   ,.PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN3(PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN3)
+   ,.PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN4(PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN4)
+   ,.PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN1(PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN1)
+   ,.PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN2(PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN2)
+   ,.PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN3(PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN3)
+   ,.PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN4(PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN4)
+   ,.PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN1(PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN1)
+   ,.PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN2(PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN2)
+   ,.PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN3(PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN3)
+   ,.PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN4(PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN4)
+   ,.PF0_LINK_CAP_L1_EXIT_LATENCY_GEN1(PF0_LINK_CAP_L1_EXIT_LATENCY_GEN1)
+   ,.PF0_LINK_CAP_L1_EXIT_LATENCY_GEN2(PF0_LINK_CAP_L1_EXIT_LATENCY_GEN2)
+   ,.PF0_LINK_CAP_L1_EXIT_LATENCY_GEN3(PF0_LINK_CAP_L1_EXIT_LATENCY_GEN3)
+   ,.PF0_LINK_CAP_L1_EXIT_LATENCY_GEN4(PF0_LINK_CAP_L1_EXIT_LATENCY_GEN4)
+   ,.PF0_DEV_CAP2_CPL_TIMEOUT_DISABLE(PF0_DEV_CAP2_CPL_TIMEOUT_DISABLE)
+   ,.PF0_DEV_CAP2_32B_ATOMIC_COMPLETER_SUPPORT(PF0_DEV_CAP2_32B_ATOMIC_COMPLETER_SUPPORT)
+   ,.PF0_DEV_CAP2_64B_ATOMIC_COMPLETER_SUPPORT(PF0_DEV_CAP2_64B_ATOMIC_COMPLETER_SUPPORT)
+   ,.PF0_DEV_CAP2_128B_CAS_ATOMIC_COMPLETER_SUPPORT(PF0_DEV_CAP2_128B_CAS_ATOMIC_COMPLETER_SUPPORT)
+   ,.PF0_DEV_CAP2_LTR_SUPPORT(PF0_DEV_CAP2_LTR_SUPPORT)
+   ,.PF0_DEV_CAP2_TPH_COMPLETER_SUPPORT(PF0_DEV_CAP2_TPH_COMPLETER_SUPPORT)
+   ,.PF0_DEV_CAP2_OBFF_SUPPORT(PF0_DEV_CAP2_OBFF_SUPPORT)
+   ,.PF0_DEV_CAP2_ARI_FORWARD_ENABLE(PF0_DEV_CAP2_ARI_FORWARD_ENABLE)
+   ,.PF0_MSI_CAP_NEXTPTR(PF0_MSI_CAP_NEXTPTR)
+   ,.PF1_MSI_CAP_NEXTPTR(PF1_MSI_CAP_NEXTPTR)
+   ,.PF2_MSI_CAP_NEXTPTR(PF2_MSI_CAP_NEXTPTR)
+   ,.PF3_MSI_CAP_NEXTPTR(PF3_MSI_CAP_NEXTPTR)
+   ,.PF0_MSI_CAP_PERVECMASKCAP(PF0_MSI_CAP_PERVECMASKCAP)
+   ,.PF1_MSI_CAP_PERVECMASKCAP(PF1_MSI_CAP_PERVECMASKCAP)
+   ,.PF2_MSI_CAP_PERVECMASKCAP(PF2_MSI_CAP_PERVECMASKCAP)
+   ,.PF3_MSI_CAP_PERVECMASKCAP(PF3_MSI_CAP_PERVECMASKCAP)
+   ,.PF0_MSI_CAP_MULTIMSGCAP(PF0_MSI_CAP_MULTIMSGCAP)
+   ,.PF1_MSI_CAP_MULTIMSGCAP(PF1_MSI_CAP_MULTIMSGCAP)
+   ,.PF2_MSI_CAP_MULTIMSGCAP(PF2_MSI_CAP_MULTIMSGCAP)
+   ,.PF3_MSI_CAP_MULTIMSGCAP(PF3_MSI_CAP_MULTIMSGCAP)
+   ,.PF0_MSIX_CAP_NEXTPTR(PF0_MSIX_CAP_NEXTPTR)
+   ,.PF1_MSIX_CAP_NEXTPTR(PF1_MSIX_CAP_NEXTPTR)
+   ,.PF2_MSIX_CAP_NEXTPTR(PF2_MSIX_CAP_NEXTPTR)
+   ,.PF3_MSIX_CAP_NEXTPTR(PF3_MSIX_CAP_NEXTPTR)
+   ,.VFG0_MSIX_CAP_NEXTPTR(VFG0_MSIX_CAP_NEXTPTR)
+   ,.VFG1_MSIX_CAP_NEXTPTR(VFG1_MSIX_CAP_NEXTPTR)
+   ,.VFG2_MSIX_CAP_NEXTPTR(VFG2_MSIX_CAP_NEXTPTR)
+   ,.VFG3_MSIX_CAP_NEXTPTR(VFG3_MSIX_CAP_NEXTPTR)
+   ,.PF0_MSIX_CAP_PBA_BIR(PF0_MSIX_CAP_PBA_BIR)
+   ,.PF1_MSIX_CAP_PBA_BIR(PF1_MSIX_CAP_PBA_BIR)
+   ,.PF2_MSIX_CAP_PBA_BIR(PF2_MSIX_CAP_PBA_BIR)
+   ,.PF3_MSIX_CAP_PBA_BIR(PF3_MSIX_CAP_PBA_BIR)
+   ,.VFG0_MSIX_CAP_PBA_BIR(VFG0_MSIX_CAP_PBA_BIR)
+   ,.VFG1_MSIX_CAP_PBA_BIR(VFG1_MSIX_CAP_PBA_BIR)
+   ,.VFG2_MSIX_CAP_PBA_BIR(VFG2_MSIX_CAP_PBA_BIR)
+   ,.VFG3_MSIX_CAP_PBA_BIR(VFG3_MSIX_CAP_PBA_BIR)
+   ,.PF0_MSIX_CAP_PBA_OFFSET(PF0_MSIX_CAP_PBA_OFFSET)
+   ,.PF1_MSIX_CAP_PBA_OFFSET(PF1_MSIX_CAP_PBA_OFFSET)
+   ,.PF2_MSIX_CAP_PBA_OFFSET(PF2_MSIX_CAP_PBA_OFFSET)
+   ,.PF3_MSIX_CAP_PBA_OFFSET(PF3_MSIX_CAP_PBA_OFFSET)
+   ,.VFG0_MSIX_CAP_PBA_OFFSET(VFG0_MSIX_CAP_PBA_OFFSET)
+   ,.VFG1_MSIX_CAP_PBA_OFFSET(VFG1_MSIX_CAP_PBA_OFFSET)
+   ,.VFG2_MSIX_CAP_PBA_OFFSET(VFG2_MSIX_CAP_PBA_OFFSET)
+   ,.VFG3_MSIX_CAP_PBA_OFFSET(VFG3_MSIX_CAP_PBA_OFFSET)
+   ,.PF0_MSIX_CAP_TABLE_BIR(PF0_MSIX_CAP_TABLE_BIR)
+   ,.PF1_MSIX_CAP_TABLE_BIR(PF1_MSIX_CAP_TABLE_BIR)
+   ,.PF2_MSIX_CAP_TABLE_BIR(PF2_MSIX_CAP_TABLE_BIR)
+   ,.PF3_MSIX_CAP_TABLE_BIR(PF3_MSIX_CAP_TABLE_BIR)
+   ,.VFG0_MSIX_CAP_TABLE_BIR(VFG0_MSIX_CAP_TABLE_BIR)
+   ,.VFG1_MSIX_CAP_TABLE_BIR(VFG1_MSIX_CAP_TABLE_BIR)
+   ,.VFG2_MSIX_CAP_TABLE_BIR(VFG2_MSIX_CAP_TABLE_BIR)
+   ,.VFG3_MSIX_CAP_TABLE_BIR(VFG3_MSIX_CAP_TABLE_BIR)
+   ,.PF0_MSIX_CAP_TABLE_OFFSET(PF0_MSIX_CAP_TABLE_OFFSET)
+   ,.PF1_MSIX_CAP_TABLE_OFFSET(PF1_MSIX_CAP_TABLE_OFFSET)
+   ,.PF2_MSIX_CAP_TABLE_OFFSET(PF2_MSIX_CAP_TABLE_OFFSET)
+   ,.PF3_MSIX_CAP_TABLE_OFFSET(PF3_MSIX_CAP_TABLE_OFFSET)
+   ,.VFG0_MSIX_CAP_TABLE_OFFSET(VFG0_MSIX_CAP_TABLE_OFFSET)
+   ,.VFG1_MSIX_CAP_TABLE_OFFSET(VFG1_MSIX_CAP_TABLE_OFFSET)
+   ,.VFG2_MSIX_CAP_TABLE_OFFSET(VFG2_MSIX_CAP_TABLE_OFFSET)
+   ,.VFG3_MSIX_CAP_TABLE_OFFSET(VFG3_MSIX_CAP_TABLE_OFFSET)
+   ,.PF0_MSIX_CAP_TABLE_SIZE(PF0_MSIX_CAP_TABLE_SIZE)
+   ,.PF1_MSIX_CAP_TABLE_SIZE(PF1_MSIX_CAP_TABLE_SIZE)
+   ,.PF2_MSIX_CAP_TABLE_SIZE(PF2_MSIX_CAP_TABLE_SIZE)
+   ,.PF3_MSIX_CAP_TABLE_SIZE(PF3_MSIX_CAP_TABLE_SIZE)
+   ,.VFG0_MSIX_CAP_TABLE_SIZE(VFG0_MSIX_CAP_TABLE_SIZE)
+   ,.VFG1_MSIX_CAP_TABLE_SIZE(VFG1_MSIX_CAP_TABLE_SIZE)
+   ,.VFG2_MSIX_CAP_TABLE_SIZE(VFG2_MSIX_CAP_TABLE_SIZE)
+   ,.VFG3_MSIX_CAP_TABLE_SIZE(VFG3_MSIX_CAP_TABLE_SIZE)
+   ,.PF0_MSIX_VECTOR_COUNT(PF0_MSIX_VECTOR_COUNT)
+   ,.PF0_PM_CAP_ID(PF0_PM_CAP_ID)
+   ,.PF0_PM_CAP_NEXTPTR(PF0_PM_CAP_NEXTPTR)
+   ,.PF1_PM_CAP_NEXTPTR(PF1_PM_CAP_NEXTPTR)
+   ,.PF2_PM_CAP_NEXTPTR(PF2_PM_CAP_NEXTPTR)
+   ,.PF3_PM_CAP_NEXTPTR(PF3_PM_CAP_NEXTPTR)
+   ,.PF0_PM_CAP_PMESUPPORT_D3HOT(PF0_PM_CAP_PMESUPPORT_D3HOT)
+   ,.PF0_PM_CAP_PMESUPPORT_D1(PF0_PM_CAP_PMESUPPORT_D1)
+   ,.PF0_PM_CAP_PMESUPPORT_D0(PF0_PM_CAP_PMESUPPORT_D0)
+   ,.PF0_PM_CAP_SUPP_D1_STATE(PF0_PM_CAP_SUPP_D1_STATE)
+   ,.PF0_PM_CAP_VER_ID(PF0_PM_CAP_VER_ID)
+   ,.PF0_PM_CSR_NOSOFTRESET(PF0_PM_CSR_NOSOFTRESET)
+   ,.PM_ENABLE_L23_ENTRY(PM_ENABLE_L23_ENTRY)
+   ,.DNSTREAM_LINK_NUM(DNSTREAM_LINK_NUM)
+   ,.AUTO_FLR_RESPONSE(AUTO_FLR_RESPONSE)
+   ,.PF0_DSN_CAP_NEXTPTR(PF0_DSN_CAP_NEXTPTR)
+   ,.PF1_DSN_CAP_NEXTPTR(PF1_DSN_CAP_NEXTPTR)
+   ,.PF2_DSN_CAP_NEXTPTR(PF2_DSN_CAP_NEXTPTR)
+   ,.PF3_DSN_CAP_NEXTPTR(PF3_DSN_CAP_NEXTPTR)
+   ,.DSN_CAP_ENABLE(DSN_CAP_ENABLE)
+   ,.PF0_VC_CAP_VER(PF0_VC_CAP_VER)
+   ,.PF0_VC_CAP_NEXTPTR(PF0_VC_CAP_NEXTPTR)
+   ,.PF0_VC_CAP_ENABLE(PF0_VC_CAP_ENABLE)
+   ,.PF0_SECONDARY_PCIE_CAP_NEXTPTR(PF0_SECONDARY_PCIE_CAP_NEXTPTR)
+   ,.PF0_AER_CAP_NEXTPTR(PF0_AER_CAP_NEXTPTR)
+   ,.PF1_AER_CAP_NEXTPTR(PF1_AER_CAP_NEXTPTR)
+   ,.PF2_AER_CAP_NEXTPTR(PF2_AER_CAP_NEXTPTR)
+   ,.PF3_AER_CAP_NEXTPTR(PF3_AER_CAP_NEXTPTR)
+   ,.PF0_AER_CAP_ECRC_GEN_AND_CHECK_CAPABLE(PF0_AER_CAP_ECRC_GEN_AND_CHECK_CAPABLE)
+   ,.ARI_CAP_ENABLE(ARI_CAP_ENABLE)
+   ,.PF0_ARI_CAP_NEXTPTR(PF0_ARI_CAP_NEXTPTR)
+   ,.PF1_ARI_CAP_NEXTPTR(PF1_ARI_CAP_NEXTPTR)
+   ,.PF2_ARI_CAP_NEXTPTR(PF2_ARI_CAP_NEXTPTR)
+   ,.PF3_ARI_CAP_NEXTPTR(PF3_ARI_CAP_NEXTPTR)
+   ,.VFG0_ARI_CAP_NEXTPTR(VFG0_ARI_CAP_NEXTPTR)
+   ,.VFG1_ARI_CAP_NEXTPTR(VFG1_ARI_CAP_NEXTPTR)
+   ,.VFG2_ARI_CAP_NEXTPTR(VFG2_ARI_CAP_NEXTPTR)
+   ,.VFG3_ARI_CAP_NEXTPTR(VFG3_ARI_CAP_NEXTPTR)
+   ,.PF0_ARI_CAP_VER(PF0_ARI_CAP_VER)
+   ,.PF0_ARI_CAP_NEXT_FUNC(PF0_ARI_CAP_NEXT_FUNC)
+   ,.PF1_ARI_CAP_NEXT_FUNC(PF1_ARI_CAP_NEXT_FUNC)
+   ,.PF2_ARI_CAP_NEXT_FUNC(PF2_ARI_CAP_NEXT_FUNC)
+   ,.PF3_ARI_CAP_NEXT_FUNC(PF3_ARI_CAP_NEXT_FUNC)
+   ,.PF0_LTR_CAP_NEXTPTR(PF0_LTR_CAP_NEXTPTR)
+   ,.PF0_LTR_CAP_VER(PF0_LTR_CAP_VER)
+   ,.PF0_LTR_CAP_MAX_SNOOP_LAT(PF0_LTR_CAP_MAX_SNOOP_LAT)
+   ,.PF0_LTR_CAP_MAX_NOSNOOP_LAT(PF0_LTR_CAP_MAX_NOSNOOP_LAT)
+   ,.LTR_TX_MESSAGE_ON_LTR_ENABLE(LTR_TX_MESSAGE_ON_LTR_ENABLE)
+   ,.LTR_TX_MESSAGE_ON_FUNC_POWER_STATE_CHANGE(LTR_TX_MESSAGE_ON_FUNC_POWER_STATE_CHANGE)
+   ,.LTR_TX_MESSAGE_MINIMUM_INTERVAL(LTR_TX_MESSAGE_MINIMUM_INTERVAL)
+   ,.SRIOV_CAP_ENABLE(SRIOV_CAP_ENABLE)
+   ,.PF0_SRIOV_CAP_NEXTPTR(PF0_SRIOV_CAP_NEXTPTR)
+   ,.PF1_SRIOV_CAP_NEXTPTR(PF1_SRIOV_CAP_NEXTPTR)
+   ,.PF2_SRIOV_CAP_NEXTPTR(PF2_SRIOV_CAP_NEXTPTR)
+   ,.PF3_SRIOV_CAP_NEXTPTR(PF3_SRIOV_CAP_NEXTPTR)
+   ,.PF0_SRIOV_CAP_VER(PF0_SRIOV_CAP_VER)
+   ,.PF1_SRIOV_CAP_VER(PF1_SRIOV_CAP_VER)
+   ,.PF2_SRIOV_CAP_VER(PF2_SRIOV_CAP_VER)
+   ,.PF3_SRIOV_CAP_VER(PF3_SRIOV_CAP_VER)
+   ,.PF0_SRIOV_ARI_CAPBL_HIER_PRESERVED(PF0_SRIOV_ARI_CAPBL_HIER_PRESERVED)
+   ,.PF1_SRIOV_ARI_CAPBL_HIER_PRESERVED(PF1_SRIOV_ARI_CAPBL_HIER_PRESERVED)
+   ,.PF2_SRIOV_ARI_CAPBL_HIER_PRESERVED(PF2_SRIOV_ARI_CAPBL_HIER_PRESERVED)
+   ,.PF3_SRIOV_ARI_CAPBL_HIER_PRESERVED(PF3_SRIOV_ARI_CAPBL_HIER_PRESERVED)
+   ,.PF0_SRIOV_CAP_INITIAL_VF(PF0_SRIOV_CAP_INITIAL_VF)
+   ,.PF1_SRIOV_CAP_INITIAL_VF(PF1_SRIOV_CAP_INITIAL_VF)
+   ,.PF2_SRIOV_CAP_INITIAL_VF(PF2_SRIOV_CAP_INITIAL_VF)
+   ,.PF3_SRIOV_CAP_INITIAL_VF(PF3_SRIOV_CAP_INITIAL_VF)
+   ,.PF0_SRIOV_CAP_TOTAL_VF(PF0_SRIOV_CAP_TOTAL_VF)
+   ,.PF1_SRIOV_CAP_TOTAL_VF(PF1_SRIOV_CAP_TOTAL_VF)
+   ,.PF2_SRIOV_CAP_TOTAL_VF(PF2_SRIOV_CAP_TOTAL_VF)
+   ,.PF3_SRIOV_CAP_TOTAL_VF(PF3_SRIOV_CAP_TOTAL_VF)
+   ,.PF0_SRIOV_FUNC_DEP_LINK(PF0_SRIOV_FUNC_DEP_LINK)
+   ,.PF1_SRIOV_FUNC_DEP_LINK(PF1_SRIOV_FUNC_DEP_LINK)
+   ,.PF2_SRIOV_FUNC_DEP_LINK(PF2_SRIOV_FUNC_DEP_LINK)
+   ,.PF3_SRIOV_FUNC_DEP_LINK(PF3_SRIOV_FUNC_DEP_LINK)
+   ,.PF0_SRIOV_FIRST_VF_OFFSET(PF0_SRIOV_FIRST_VF_OFFSET)
+   ,.PF1_SRIOV_FIRST_VF_OFFSET(PF1_SRIOV_FIRST_VF_OFFSET)
+   ,.PF2_SRIOV_FIRST_VF_OFFSET(PF2_SRIOV_FIRST_VF_OFFSET)
+   ,.PF3_SRIOV_FIRST_VF_OFFSET(PF3_SRIOV_FIRST_VF_OFFSET)
+   ,.PF0_SRIOV_VF_DEVICE_ID(PF0_SRIOV_VF_DEVICE_ID)
+   ,.PF1_SRIOV_VF_DEVICE_ID(PF1_SRIOV_VF_DEVICE_ID)
+   ,.PF2_SRIOV_VF_DEVICE_ID(PF2_SRIOV_VF_DEVICE_ID)
+   ,.PF3_SRIOV_VF_DEVICE_ID(PF3_SRIOV_VF_DEVICE_ID)
+   ,.PF0_SRIOV_SUPPORTED_PAGE_SIZE(PF0_SRIOV_SUPPORTED_PAGE_SIZE)
+   ,.PF1_SRIOV_SUPPORTED_PAGE_SIZE(PF1_SRIOV_SUPPORTED_PAGE_SIZE)
+   ,.PF2_SRIOV_SUPPORTED_PAGE_SIZE(PF2_SRIOV_SUPPORTED_PAGE_SIZE)
+   ,.PF3_SRIOV_SUPPORTED_PAGE_SIZE(PF3_SRIOV_SUPPORTED_PAGE_SIZE)
+   ,.PF0_SRIOV_BAR0_CONTROL(PF0_SRIOV_BAR0_CONTROL)
+   ,.PF1_SRIOV_BAR0_CONTROL(PF1_SRIOV_BAR0_CONTROL)
+   ,.PF2_SRIOV_BAR0_CONTROL(PF2_SRIOV_BAR0_CONTROL)
+   ,.PF3_SRIOV_BAR0_CONTROL(PF3_SRIOV_BAR0_CONTROL)
+   ,.PF0_SRIOV_BAR0_APERTURE_SIZE(PF0_SRIOV_BAR0_APERTURE_SIZE)
+   ,.PF1_SRIOV_BAR0_APERTURE_SIZE(PF1_SRIOV_BAR0_APERTURE_SIZE)
+   ,.PF2_SRIOV_BAR0_APERTURE_SIZE(PF2_SRIOV_BAR0_APERTURE_SIZE)
+   ,.PF3_SRIOV_BAR0_APERTURE_SIZE(PF3_SRIOV_BAR0_APERTURE_SIZE)
+   ,.PF0_SRIOV_BAR1_CONTROL(PF0_SRIOV_BAR1_CONTROL)
+   ,.PF1_SRIOV_BAR1_CONTROL(PF1_SRIOV_BAR1_CONTROL)
+   ,.PF2_SRIOV_BAR1_CONTROL(PF2_SRIOV_BAR1_CONTROL)
+   ,.PF3_SRIOV_BAR1_CONTROL(PF3_SRIOV_BAR1_CONTROL)
+   ,.PF0_SRIOV_BAR1_APERTURE_SIZE(PF0_SRIOV_BAR1_APERTURE_SIZE)
+   ,.PF1_SRIOV_BAR1_APERTURE_SIZE(PF1_SRIOV_BAR1_APERTURE_SIZE)
+   ,.PF2_SRIOV_BAR1_APERTURE_SIZE(PF2_SRIOV_BAR1_APERTURE_SIZE)
+   ,.PF3_SRIOV_BAR1_APERTURE_SIZE(PF3_SRIOV_BAR1_APERTURE_SIZE)
+   ,.PF0_SRIOV_BAR2_CONTROL(PF0_SRIOV_BAR2_CONTROL)
+   ,.PF1_SRIOV_BAR2_CONTROL(PF1_SRIOV_BAR2_CONTROL)
+   ,.PF2_SRIOV_BAR2_CONTROL(PF2_SRIOV_BAR2_CONTROL)
+   ,.PF3_SRIOV_BAR2_CONTROL(PF3_SRIOV_BAR2_CONTROL)
+   ,.PF0_SRIOV_BAR2_APERTURE_SIZE(PF0_SRIOV_BAR2_APERTURE_SIZE)
+   ,.PF1_SRIOV_BAR2_APERTURE_SIZE(PF1_SRIOV_BAR2_APERTURE_SIZE)
+   ,.PF2_SRIOV_BAR2_APERTURE_SIZE(PF2_SRIOV_BAR2_APERTURE_SIZE)
+   ,.PF3_SRIOV_BAR2_APERTURE_SIZE(PF3_SRIOV_BAR2_APERTURE_SIZE)
+   ,.PF0_SRIOV_BAR3_CONTROL(PF0_SRIOV_BAR3_CONTROL)
+   ,.PF1_SRIOV_BAR3_CONTROL(PF1_SRIOV_BAR3_CONTROL)
+   ,.PF2_SRIOV_BAR3_CONTROL(PF2_SRIOV_BAR3_CONTROL)
+   ,.PF3_SRIOV_BAR3_CONTROL(PF3_SRIOV_BAR3_CONTROL)
+   ,.PF0_SRIOV_BAR3_APERTURE_SIZE(PF0_SRIOV_BAR3_APERTURE_SIZE)
+   ,.PF1_SRIOV_BAR3_APERTURE_SIZE(PF1_SRIOV_BAR3_APERTURE_SIZE)
+   ,.PF2_SRIOV_BAR3_APERTURE_SIZE(PF2_SRIOV_BAR3_APERTURE_SIZE)
+   ,.PF3_SRIOV_BAR3_APERTURE_SIZE(PF3_SRIOV_BAR3_APERTURE_SIZE)
+   ,.PF0_SRIOV_BAR4_CONTROL(PF0_SRIOV_BAR4_CONTROL)
+   ,.PF1_SRIOV_BAR4_CONTROL(PF1_SRIOV_BAR4_CONTROL)
+   ,.PF2_SRIOV_BAR4_CONTROL(PF2_SRIOV_BAR4_CONTROL)
+   ,.PF3_SRIOV_BAR4_CONTROL(PF3_SRIOV_BAR4_CONTROL)
+   ,.PF0_SRIOV_BAR4_APERTURE_SIZE(PF0_SRIOV_BAR4_APERTURE_SIZE)
+   ,.PF1_SRIOV_BAR4_APERTURE_SIZE(PF1_SRIOV_BAR4_APERTURE_SIZE)
+   ,.PF2_SRIOV_BAR4_APERTURE_SIZE(PF2_SRIOV_BAR4_APERTURE_SIZE)
+   ,.PF3_SRIOV_BAR4_APERTURE_SIZE(PF3_SRIOV_BAR4_APERTURE_SIZE)
+   ,.PF0_SRIOV_BAR5_CONTROL(PF0_SRIOV_BAR5_CONTROL)
+   ,.PF1_SRIOV_BAR5_CONTROL(PF1_SRIOV_BAR5_CONTROL)
+   ,.PF2_SRIOV_BAR5_CONTROL(PF2_SRIOV_BAR5_CONTROL)
+   ,.PF3_SRIOV_BAR5_CONTROL(PF3_SRIOV_BAR5_CONTROL)
+   ,.PF0_SRIOV_BAR5_APERTURE_SIZE(PF0_SRIOV_BAR5_APERTURE_SIZE)
+   ,.PF1_SRIOV_BAR5_APERTURE_SIZE(PF1_SRIOV_BAR5_APERTURE_SIZE)
+   ,.PF2_SRIOV_BAR5_APERTURE_SIZE(PF2_SRIOV_BAR5_APERTURE_SIZE)
+   ,.PF3_SRIOV_BAR5_APERTURE_SIZE(PF3_SRIOV_BAR5_APERTURE_SIZE)
+   ,.PF0_TPHR_CAP_NEXTPTR(PF0_TPHR_CAP_NEXTPTR)
+   ,.PF1_TPHR_CAP_NEXTPTR(PF1_TPHR_CAP_NEXTPTR)
+   ,.PF2_TPHR_CAP_NEXTPTR(PF2_TPHR_CAP_NEXTPTR)
+   ,.PF3_TPHR_CAP_NEXTPTR(PF3_TPHR_CAP_NEXTPTR)
+   ,.VFG0_TPHR_CAP_NEXTPTR(VFG0_TPHR_CAP_NEXTPTR)
+   ,.VFG1_TPHR_CAP_NEXTPTR(VFG1_TPHR_CAP_NEXTPTR)
+   ,.VFG2_TPHR_CAP_NEXTPTR(VFG2_TPHR_CAP_NEXTPTR)
+   ,.VFG3_TPHR_CAP_NEXTPTR(VFG3_TPHR_CAP_NEXTPTR)
+   ,.PF0_TPHR_CAP_VER(PF0_TPHR_CAP_VER)
+   ,.PF0_TPHR_CAP_INT_VEC_MODE(PF0_TPHR_CAP_INT_VEC_MODE)
+   ,.PF0_TPHR_CAP_DEV_SPECIFIC_MODE(PF0_TPHR_CAP_DEV_SPECIFIC_MODE)
+   ,.PF0_TPHR_CAP_ST_TABLE_LOC(PF0_TPHR_CAP_ST_TABLE_LOC)
+   ,.PF0_TPHR_CAP_ST_TABLE_SIZE(PF0_TPHR_CAP_ST_TABLE_SIZE)
+   ,.PF0_TPHR_CAP_ST_MODE_SEL(PF0_TPHR_CAP_ST_MODE_SEL)
+   ,.PF1_TPHR_CAP_ST_MODE_SEL(PF1_TPHR_CAP_ST_MODE_SEL)
+   ,.PF2_TPHR_CAP_ST_MODE_SEL(PF2_TPHR_CAP_ST_MODE_SEL)
+   ,.PF3_TPHR_CAP_ST_MODE_SEL(PF3_TPHR_CAP_ST_MODE_SEL)
+   ,.VFG0_TPHR_CAP_ST_MODE_SEL(VFG0_TPHR_CAP_ST_MODE_SEL)
+   ,.VFG1_TPHR_CAP_ST_MODE_SEL(VFG1_TPHR_CAP_ST_MODE_SEL)
+   ,.VFG2_TPHR_CAP_ST_MODE_SEL(VFG2_TPHR_CAP_ST_MODE_SEL)
+   ,.VFG3_TPHR_CAP_ST_MODE_SEL(VFG3_TPHR_CAP_ST_MODE_SEL)
+   ,.PF0_TPHR_CAP_ENABLE(PF0_TPHR_CAP_ENABLE)
+   ,.TPH_TO_RAM_PIPELINE(TPH_TO_RAM_PIPELINE)
+   ,.TPH_FROM_RAM_PIPELINE(TPH_FROM_RAM_PIPELINE)
+   ,.MCAP_ENABLE(MCAP_ENABLE)
+   ,.MCAP_CONFIGURE_OVERRIDE(MCAP_CONFIGURE_OVERRIDE)
+   ,.MCAP_CAP_NEXTPTR(MCAP_CAP_NEXTPTR)
+   ,.MCAP_VSEC_ID(MCAP_VSEC_ID)
+   ,.MCAP_VSEC_REV(MCAP_VSEC_REV)
+   ,.MCAP_VSEC_LEN(MCAP_VSEC_LEN)
+   ,.MCAP_FPGA_BITSTREAM_VERSION(MCAP_FPGA_BITSTREAM_VERSION)
+   ,.MCAP_INTERRUPT_ON_MCAP_EOS(MCAP_INTERRUPT_ON_MCAP_EOS)
+   ,.MCAP_INTERRUPT_ON_MCAP_ERROR(MCAP_INTERRUPT_ON_MCAP_ERROR)
+   ,.MCAP_INPUT_GATE_DESIGN_SWITCH(MCAP_INPUT_GATE_DESIGN_SWITCH)
+   ,.MCAP_EOS_DESIGN_SWITCH(MCAP_EOS_DESIGN_SWITCH)
+   ,.MCAP_GATE_MEM_ENABLE_DESIGN_SWITCH(MCAP_GATE_MEM_ENABLE_DESIGN_SWITCH)
+   ,.MCAP_GATE_IO_ENABLE_DESIGN_SWITCH(MCAP_GATE_IO_ENABLE_DESIGN_SWITCH)
+   ,.SIM_JTAG_IDCODE(SIM_JTAG_IDCODE)
+   ,.DEBUG_AXIST_DISABLE_FEATURE_BIT(DEBUG_AXIST_DISABLE_FEATURE_BIT)
+   ,.DEBUG_TL_DISABLE_RX_TLP_ORDER_CHECKS(DEBUG_TL_DISABLE_RX_TLP_ORDER_CHECKS)
+   ,.DEBUG_TL_DISABLE_FC_TIMEOUT(DEBUG_TL_DISABLE_FC_TIMEOUT)
+   ,.DEBUG_PL_DISABLE_SCRAMBLING(DEBUG_PL_DISABLE_SCRAMBLING)
+   ,.DEBUG_PL_DISABLE_REC_ENTRY_ON_DYNAMIC_DSKEW_FAIL (DEBUG_PL_DISABLE_REC_ENTRY_ON_DYNAMIC_DSKEW_FAIL )
+   ,.DEBUG_PL_DISABLE_REC_ENTRY_ON_RX_BUFFER_UNDER_OVER_FLOW (DEBUG_PL_DISABLE_REC_ENTRY_ON_RX_BUFFER_UNDER_OVER_FLOW )
+   ,.DEBUG_PL_DISABLE_LES_UPDATE_ON_SKP_ERROR(DEBUG_PL_DISABLE_LES_UPDATE_ON_SKP_ERROR)
+   ,.DEBUG_PL_DISABLE_LES_UPDATE_ON_SKP_PARITY_ERROR(DEBUG_PL_DISABLE_LES_UPDATE_ON_SKP_PARITY_ERROR)
+   ,.DEBUG_PL_DISABLE_LES_UPDATE_ON_DEFRAMER_ERROR(DEBUG_PL_DISABLE_LES_UPDATE_ON_DEFRAMER_ERROR)
+   ,.DEBUG_PL_SIM_RESET_LFSR(DEBUG_PL_SIM_RESET_LFSR)
+   ,.DEBUG_PL_SPARE(DEBUG_PL_SPARE)
+   ,.DEBUG_LL_SPARE(DEBUG_LL_SPARE)
+   ,.DEBUG_TL_SPARE(DEBUG_TL_SPARE)
+   ,.DEBUG_AXI4ST_SPARE(DEBUG_AXI4ST_SPARE)
+   ,.DEBUG_CFG_SPARE(DEBUG_CFG_SPARE)
+   ,.DEBUG_CAR_SPARE(DEBUG_CAR_SPARE)
+   ,.TEST_MODE_PIN_CHAR(TEST_MODE_PIN_CHAR)
+   ,.SPARE_BIT0(SPARE_BIT0)
+   ,.SPARE_BIT1(SPARE_BIT1)
+   ,.SPARE_BIT2(SPARE_BIT2)
+   ,.SPARE_BIT3(SPARE_BIT3)
+   ,.SPARE_BIT4(SPARE_BIT4)
+   ,.SPARE_BIT5(SPARE_BIT5)
+   ,.SPARE_BIT6(SPARE_BIT6)
+   ,.SPARE_BIT7(SPARE_BIT7)
+   ,.SPARE_BIT8(SPARE_BIT8)
+   ,.SPARE_BYTE0(SPARE_BYTE0)
+   ,.SPARE_BYTE1(SPARE_BYTE1)
+   ,.SPARE_BYTE2(SPARE_BYTE2)
+   ,.SPARE_BYTE3(SPARE_BYTE3)
+   ,.SPARE_WORD0(SPARE_WORD0)
+   ,.SPARE_WORD1(SPARE_WORD1)
+   ,.SPARE_WORD2(SPARE_WORD2)
+   ,.SPARE_WORD3(SPARE_WORD3)
+   ,.AXISTEN_IF_CCIX_RX_CREDIT_LIMIT(AXISTEN_IF_CCIX_RX_CREDIT_LIMIT)
+   ,.AXISTEN_IF_CCIX_TX_CREDIT_LIMIT(AXISTEN_IF_CCIX_TX_CREDIT_LIMIT)
+   ,.AXISTEN_IF_CCIX_TX_REGISTERED_TREADY(AXISTEN_IF_CCIX_TX_REGISTERED_TREADY)
+   ,.CCIX_DIRECT_ATTACH_MODE(CCIX_DIRECT_ATTACH_MODE)
+   ,.CCIX_ENABLE(CCIX_ENABLE)
+   ,.CCIX_VENDOR_ID(CCIX_VENDOR_ID)
+   ,.PF0_ATS_CAP_INV_QUEUE_DEPTH(PF0_ATS_CAP_INV_QUEUE_DEPTH)
+   ,.PF0_ATS_CAP_NEXTPTR(PF0_ATS_CAP_NEXTPTR)
+   ,.PF0_ATS_CAP_ON(PF0_ATS_CAP_ON)
+   ,.PF0_PRI_CAP_NEXTPTR(PF0_PRI_CAP_NEXTPTR)
+   ,.PF0_PRI_CAP_ON(PF0_PRI_CAP_ON)
+   ,.PF0_PRI_OST_PR_CAPACITY(PF0_PRI_OST_PR_CAPACITY)
+   ,.PF0_VC_ARB_CAPABILITY(PF0_VC_ARB_CAPABILITY)
+   ,.PF0_VC_ARB_TBL_OFFSET(PF0_VC_ARB_TBL_OFFSET)
+   ,.PF0_VC_EXTENDED_COUNT(PF0_VC_EXTENDED_COUNT)
+   ,.PF0_VC_LOW_PRIORITY_EXTENDED_COUNT(PF0_VC_LOW_PRIORITY_EXTENDED_COUNT)
+   ,.PF1_ATS_CAP_INV_QUEUE_DEPTH(PF1_ATS_CAP_INV_QUEUE_DEPTH)
+   ,.PF1_ATS_CAP_NEXTPTR(PF1_ATS_CAP_NEXTPTR)
+   ,.PF1_ATS_CAP_ON(PF1_ATS_CAP_ON)
+   ,.PF1_PRI_CAP_NEXTPTR(PF1_PRI_CAP_NEXTPTR)
+   ,.PF1_PRI_CAP_ON(PF1_PRI_CAP_ON)
+   ,.PF1_PRI_OST_PR_CAPACITY(PF1_PRI_OST_PR_CAPACITY)
+   ,.PF2_ATS_CAP_INV_QUEUE_DEPTH(PF2_ATS_CAP_INV_QUEUE_DEPTH)
+   ,.PF2_ATS_CAP_NEXTPTR(PF2_ATS_CAP_NEXTPTR)
+   ,.PF2_ATS_CAP_ON(PF2_ATS_CAP_ON)
+   ,.PF2_PRI_CAP_NEXTPTR(PF2_PRI_CAP_NEXTPTR)
+   ,.PF2_PRI_CAP_ON(PF2_PRI_CAP_ON)
+   ,.PF2_PRI_OST_PR_CAPACITY(PF2_PRI_OST_PR_CAPACITY)
+   ,.PF3_ATS_CAP_INV_QUEUE_DEPTH(PF3_ATS_CAP_INV_QUEUE_DEPTH)
+   ,.PF3_ATS_CAP_NEXTPTR(PF3_ATS_CAP_NEXTPTR)
+   ,.PF3_ATS_CAP_ON(PF3_ATS_CAP_ON)
+   ,.PF3_PRI_CAP_NEXTPTR(PF3_PRI_CAP_NEXTPTR)
+   ,.PF3_PRI_CAP_ON(PF3_PRI_CAP_ON)
+   ,.PF3_PRI_OST_PR_CAPACITY(PF3_PRI_OST_PR_CAPACITY)
+   ,.PL_CTRL_SKP_GEN_ENABLE(PL_CTRL_SKP_GEN_ENABLE)
+   ,.PL_CTRL_SKP_PARITY_AND_CRC_CHECK_DISABLE(PL_CTRL_SKP_PARITY_AND_CRC_CHECK_DISABLE)
+   ,.PL_USER_SPARE2(PL_USER_SPARE2)
+   ,.TL_CREDITS_CD_VC1(TL_CREDITS_CD_VC1)
+   ,.TL_CREDITS_CH_VC1(TL_CREDITS_CH_VC1)
+   ,.TL_CREDITS_NPD_VC1(TL_CREDITS_NPD_VC1)
+   ,.TL_CREDITS_NPH_VC1(TL_CREDITS_NPH_VC1)
+   ,.TL_CREDITS_PD_VC1(TL_CREDITS_PD_VC1)
+   ,.TL_CREDITS_PH_VC1(TL_CREDITS_PH_VC1)
+   ,.TL_FC_UPDATE_MIN_INTERVAL_TIME_VC1(TL_FC_UPDATE_MIN_INTERVAL_TIME_VC1)
+   ,.TL_FC_UPDATE_MIN_INTERVAL_TLP_COUNT_VC1(TL_FC_UPDATE_MIN_INTERVAL_TLP_COUNT_VC1)
+   ,.TL_FEATURE_ENABLE_FC_SCALING(TL_FEATURE_ENABLE_FC_SCALING)
+   ,.VFG0_ATS_CAP_INV_QUEUE_DEPTH(VFG0_ATS_CAP_INV_QUEUE_DEPTH)
+   ,.VFG0_ATS_CAP_NEXTPTR(VFG0_ATS_CAP_NEXTPTR)
+   ,.VFG0_ATS_CAP_ON(VFG0_ATS_CAP_ON)
+   ,.VFG1_ATS_CAP_INV_QUEUE_DEPTH(VFG1_ATS_CAP_INV_QUEUE_DEPTH)
+   ,.VFG1_ATS_CAP_NEXTPTR(VFG1_ATS_CAP_NEXTPTR)
+   ,.VFG1_ATS_CAP_ON(VFG1_ATS_CAP_ON)
+   ,.VFG2_ATS_CAP_INV_QUEUE_DEPTH(VFG2_ATS_CAP_INV_QUEUE_DEPTH)
+   ,.VFG2_ATS_CAP_NEXTPTR(VFG2_ATS_CAP_NEXTPTR)
+   ,.VFG2_ATS_CAP_ON(VFG2_ATS_CAP_ON)
+   ,.VFG3_ATS_CAP_INV_QUEUE_DEPTH(VFG3_ATS_CAP_INV_QUEUE_DEPTH)
+   ,.VFG3_ATS_CAP_NEXTPTR(VFG3_ATS_CAP_NEXTPTR)
+   ,.VFG3_ATS_CAP_ON(VFG3_ATS_CAP_ON)
+  ) pcie_4_0_pipe_smsw_inst ( 
+
+////////   PIPE Controls ////////////
+   .pipe_tx_rcvr_det                   ( pipe_tx0_rcvr_det     ),//(pipe_tx_rcvr_det)
+   .pipe_tx_rate                       ( common_commands_out[2:1]   ),//(pipe_tx_rate[1:0])
+   .pipe_tx_deemph                     ( common_commands_out[9]     ),//(pipe_tx_deemph)
+   .pipe_tx_margin                     ( common_commands_out[6:4]   ),//(pipe_tx_margin[2:0])
+   .pipe_tx_swing                      ( common_commands_out[7]     ),//(pipe_tx_swing)
+   .pipe_tx_reset                      ( common_commands_out[8]     ),//(pipe_tx_reset)
+   .pipe_eq_fs                         ( 6'd40 ),//(pipe_eq_fs[5:0])
+   .pipe_eq_lf                         ( 6'd12 ),//(pipe_eq_lf[5:0])
+
+   .pipe_rx_eq_lp_tx_preset (pipe_rx_eq_lp_tx_preset[3:0]),
+   .pipe_rx_eq_lp_lf_fs     (pipe_rx_eq_lp_lf_fs[5:0]),
+  //-----------------------------
+  // PIPE TX BUS Signals[69:0]
+  //-----------------------------
+  // pipe_tx_0_sigs[69:0]
+   .pipe_tx00_data                       ( pipe_tx_0_sigs[31: 0] ),//(pipe_tx00_data[31:0])
+   .pipe_tx00_char_is_k                  ( pipe_tx_0_sigs[33:32] ),//(pipe_tx00_char_is_k[1:0])
+   .pipe_tx00_elec_idle                  ( pipe_tx_0_sigs[34]    ),//(pipe_tx00_elec_idle)
+   .pipe_tx00_data_valid                 ( pipe_tx_0_sigs[35]    ),//(pipe_tx00_data_valid)
+   .pipe_tx00_start_block                ( pipe_tx_0_sigs[36]    ),//(pipe_tx00_start_block)
+   .pipe_tx00_sync_header                ( pipe_tx_0_sigs[38:37] ),//(pipe_tx00_sync_header[1:0])
+   .pipe_rx00_polarity                   ( pipe_tx_0_sigs[39]    ),//(pipe_rx00_polarity)
+   .pipe_tx00_powerdown                  ( pipe_tx_0_sigs[41:40] ),//(pipe_tx00_powerdown[1:0])
+   .pipe_tx00_eq_control                 ( pipe_tx00_eq_control ),//(pipe_tx00_eq_control[1:0])
+                                       //( pipe_tx_0_sigs[47:44] ),//
+   .pipe_tx00_eq_deemph                  ( ),//(pipe_tx00_eq_deemph[5:0])
+   .pipe_rx00_eq_control                 ( pipe_rx00_eq_control ),//(pipe_rx00_eq_control[1:0])
+                                       //( pipe_tx_0_sigs[58:56] ),//
+                                       //( pipe_tx_0_sigs[64:59] ),//
+                                       //( pipe_tx_0_sigs[68:65] ),//
+   .pipe_tx00_compliance                 ( ),//(pipe_tx00_compliance)
+  //-----------------------------
+  // pipe_tx_1_sigs[69:0]
+   .pipe_tx01_data                       ( pipe_tx_1_sigs[31: 0] ),//(pipe_tx00_data[31:0])
+   .pipe_tx01_char_is_k                  ( pipe_tx_1_sigs[33:32] ),//(pipe_tx00_char_is_k[1:0])
+   .pipe_tx01_elec_idle                  ( pipe_tx_1_sigs[34]    ),//(pipe_tx00_elec_idle)
+   .pipe_tx01_data_valid                 ( pipe_tx_1_sigs[35]    ),//(pipe_tx00_data_valid)
+   .pipe_tx01_start_block                ( pipe_tx_1_sigs[36]    ),//(pipe_tx00_start_block)
+   .pipe_tx01_sync_header                ( pipe_tx_1_sigs[38:37] ),//(pipe_tx00_sync_header[1:0])
+   .pipe_rx01_polarity                   ( pipe_tx_1_sigs[39]    ),//(pipe_rx00_polarity)
+   .pipe_tx01_powerdown                  ( pipe_tx_1_sigs[41:40] ),//(pipe_tx00_powerdown[1:0])
+   .pipe_tx01_eq_control                 ( pipe_tx01_eq_control ),//(pipe_tx00_eq_control[1:0])
+                                       //( pipe_tx_1_sigs[47:44] ),//
+   .pipe_tx01_eq_deemph                  (  ),//(pipe_tx00_eq_deemph[5:0])
+   .pipe_rx01_eq_control                 ( pipe_rx01_eq_control ),//(pipe_rx00_eq_control[1:0])
+                                       //( pipe_tx_1_sigs[58:56] ),//
+                                       //( pipe_tx_1_sigs[64:59] ),//
+                                       //( pipe_tx_1_sigs[68:65] ),//
+   .pipe_tx01_compliance                 ( ),//(pipe_tx00_compliance)
+  //-----------------------------
+  // pipe_tx_2_sigs[69:0]
+   .pipe_tx02_data                       ( pipe_tx_2_sigs[31: 0] ),//(pipe_tx00_data[31:0])
+   .pipe_tx02_char_is_k                  ( pipe_tx_2_sigs[33:32] ),//(pipe_tx00_char_is_k[1:0])
+   .pipe_tx02_elec_idle                  ( pipe_tx_2_sigs[34]    ),//(pipe_tx00_elec_idle)
+   .pipe_tx02_data_valid                 ( pipe_tx_2_sigs[35]    ),//(pipe_tx00_data_valid)
+   .pipe_tx02_start_block                ( pipe_tx_2_sigs[36]    ),//(pipe_tx00_start_block)
+   .pipe_tx02_sync_header                ( pipe_tx_2_sigs[38:37] ),//(pipe_tx00_sync_header[1:0])
+   .pipe_rx02_polarity                   ( pipe_tx_2_sigs[39]    ),//(pipe_rx00_polarity)
+   .pipe_tx02_powerdown                  ( pipe_tx_2_sigs[41:40] ),//(pipe_tx00_powerdown[1:0])
+   .pipe_tx02_eq_control                 ( pipe_tx02_eq_control ),//(pipe_tx00_eq_control[1:0])
+                                       //( pipe_tx_2_sigs[47:44] ),//
+   .pipe_tx02_eq_deemph                  ( ),//(pipe_tx00_eq_deemph[5:0])
+   .pipe_rx02_eq_control                 ( pipe_rx02_eq_control ),//(pipe_rx00_eq_control[1:0])
+                                       //( pipe_tx_2_sigs[58:56] ),//
+                                       //( pipe_tx_2_sigs[64:59] ),//
+                                       //( pipe_tx_2_sigs[68:65] ),//
+   .pipe_tx02_compliance                 ( ),//(pipe_tx00_compliance)
+  //-----------------------------
+  // pipe_tx_3_sigs[69:0]
+   .pipe_tx03_data                       ( pipe_tx_3_sigs[31: 0] ),//(pipe_tx00_data[31:0])
+   .pipe_tx03_char_is_k                  ( pipe_tx_3_sigs[33:32] ),//(pipe_tx00_char_is_k[1:0])
+   .pipe_tx03_elec_idle                  ( pipe_tx_3_sigs[34]    ),//(pipe_tx00_elec_idle)
+   .pipe_tx03_data_valid                 ( pipe_tx_3_sigs[35]    ),//(pipe_tx00_data_valid)
+   .pipe_tx03_start_block                ( pipe_tx_3_sigs[36]    ),//(pipe_tx00_start_block)
+   .pipe_tx03_sync_header                ( pipe_tx_3_sigs[38:37] ),//(pipe_tx00_sync_header[1:0])
+   .pipe_rx03_polarity                   ( pipe_tx_3_sigs[39]    ),//(pipe_rx00_polarity)
+   .pipe_tx03_powerdown                  ( pipe_tx_3_sigs[41:40] ),//(pipe_tx00_powerdown[1:0])
+   .pipe_tx03_eq_control                 ( pipe_tx03_eq_control ),//(pipe_tx00_eq_control[1:0])
+                                       //( pipe_tx_3_sigs[47:44] ),//
+   .pipe_tx03_eq_deemph                  ( ),//(pipe_tx00_eq_deemph[5:0])
+   .pipe_rx03_eq_control                 ( pipe_rx03_eq_control ),//(pipe_rx00_eq_control[1:0])
+                                       //( pipe_tx_3_sigs[58:56] ),//
+                                       //( pipe_tx_3_sigs[64:59] ),//
+                                       //( pipe_tx_3_sigs[68:65] ),//
+   .pipe_tx03_compliance                 ( ),//(pipe_tx00_compliance)
+  //-----------------------------
+  // pipe_tx_4_sigs[69:0]
+   .pipe_tx04_data                       ( pipe_tx_4_sigs[31: 0] ),//(pipe_tx00_data[31:0])
+   .pipe_tx04_char_is_k                  ( pipe_tx_4_sigs[33:32] ),//(pipe_tx00_char_is_k[1:0])
+   .pipe_tx04_elec_idle                  ( pipe_tx_4_sigs[34]    ),//(pipe_tx00_elec_idle)
+   .pipe_tx04_data_valid                 ( pipe_tx_4_sigs[35]    ),//(pipe_tx00_data_valid)
+   .pipe_tx04_start_block                ( pipe_tx_4_sigs[36]    ),//(pipe_tx00_start_block)
+   .pipe_tx04_sync_header                ( pipe_tx_4_sigs[38:37] ),//(pipe_tx00_sync_header[1:0])
+   .pipe_rx04_polarity                   ( pipe_tx_4_sigs[39]    ),//(pipe_rx00_polarity)
+   .pipe_tx04_powerdown                  ( pipe_tx_4_sigs[41:40] ),//(pipe_tx00_powerdown[1:0])
+   .pipe_tx04_eq_control                 ( pipe_tx04_eq_control ),//(pipe_tx00_eq_control[1:0])
+                                       //( pipe_tx_4_sigs[47:44] ),//
+   .pipe_tx04_eq_deemph                  ( ),//(pipe_tx00_eq_deemph[5:0])
+   .pipe_rx04_eq_control                 ( pipe_rx04_eq_control ),//(pipe_rx00_eq_control[1:0])
+                                       //( pipe_tx_4_sigs[58:56] ),//
+                                       //( pipe_tx_4_sigs[64:59] ),//
+                                       //( pipe_tx_4_sigs[68:65] ),//
+   .pipe_tx04_compliance                 ( ),//(pipe_tx00_compliance)
+  //-----------------------------
+  // pipe_tx_5_sigs[69:0]
+   .pipe_tx05_data                       ( pipe_tx_5_sigs[31: 0] ),//(pipe_tx00_data[31:0])
+   .pipe_tx05_char_is_k                  ( pipe_tx_5_sigs[33:32] ),//(pipe_tx00_char_is_k[1:0])
+   .pipe_tx05_elec_idle                  ( pipe_tx_5_sigs[34]    ),//(pipe_tx00_elec_idle)
+   .pipe_tx05_data_valid                 ( pipe_tx_5_sigs[35]    ),//(pipe_tx00_data_valid)
+   .pipe_tx05_start_block                ( pipe_tx_5_sigs[36]    ),//(pipe_tx00_start_block)
+   .pipe_tx05_sync_header                ( pipe_tx_5_sigs[38:37] ),//(pipe_tx00_sync_header[1:0])
+   .pipe_rx05_polarity                   ( pipe_tx_5_sigs[39]    ),//(pipe_rx00_polarity)
+   .pipe_tx05_powerdown                  ( pipe_tx_5_sigs[41:40] ),//(pipe_tx00_powerdown[1:0])
+   .pipe_tx05_eq_control                 ( pipe_tx05_eq_control ),//(pipe_tx00_eq_control[1:0])
+                                       //( pipe_tx_5_sigs[47:44] ),//
+   .pipe_tx05_eq_deemph                  ( ),//(pipe_tx00_eq_deemph[5:0])
+   .pipe_rx05_eq_control                 ( pipe_rx05_eq_control ),//(pipe_rx00_eq_control[1:0])
+                                       //( pipe_tx_5_sigs[58:56] ),//
+                                       //( pipe_tx_5_sigs[64:59] ),//
+                                       //( pipe_tx_5_sigs[68:65] ),//
+   .pipe_tx05_compliance                 ( ),//(pipe_tx00_compliance)
+  //-----------------------------
+  // pipe_tx_6_sigs[69:0]
+   .pipe_tx06_data                       ( pipe_tx_6_sigs[31: 0] ),//(pipe_tx00_data[31:0])
+   .pipe_tx06_char_is_k                  ( pipe_tx_6_sigs[33:32] ),//(pipe_tx00_char_is_k[1:0])
+   .pipe_tx06_elec_idle                  ( pipe_tx_6_sigs[34]    ),//(pipe_tx00_elec_idle)
+   .pipe_tx06_data_valid                 ( pipe_tx_6_sigs[35]    ),//(pipe_tx00_data_valid)
+   .pipe_tx06_start_block                ( pipe_tx_6_sigs[36]    ),//(pipe_tx00_start_block)
+   .pipe_tx06_sync_header                ( pipe_tx_6_sigs[38:37] ),//(pipe_tx00_sync_header[1:0])
+   .pipe_rx06_polarity                   ( pipe_tx_6_sigs[39]    ),//(pipe_rx00_polarity)
+   .pipe_tx06_powerdown                  ( pipe_tx_6_sigs[41:40] ),//(pipe_tx00_powerdown[1:0])
+   .pipe_tx06_eq_control                 ( pipe_tx06_eq_control ),//(pipe_tx00_eq_control[1:0])
+                                       //( pipe_tx_6_sigs[47:44] ),//
+   .pipe_tx06_eq_deemph                  ( ),//(pipe_tx00_eq_deemph[5:0])
+   .pipe_rx06_eq_control                 ( pipe_rx06_eq_control ),//(pipe_rx00_eq_control[1:0])
+                                       //( pipe_tx_6_sigs[58:56] ),//
+                                       //( pipe_tx_6_sigs[64:59] ),//
+                                       //( pipe_tx_6_sigs[68:65] ),//
+   .pipe_tx06_compliance                 ( ),//(pipe_tx00_compliance)
+  //-----------------------------
+  // pipe_tx_7_sigs[69:0]
+   .pipe_tx07_data                       ( pipe_tx_7_sigs[31: 0] ),//(pipe_tx00_data[31:0])
+   .pipe_tx07_char_is_k                  ( pipe_tx_7_sigs[33:32] ),//(pipe_tx00_char_is_k[1:0])
+   .pipe_tx07_elec_idle                  ( pipe_tx_7_sigs[34]    ),//(pipe_tx00_elec_idle)
+   .pipe_tx07_data_valid                 ( pipe_tx_7_sigs[35]    ),//(pipe_tx00_data_valid)
+   .pipe_tx07_start_block                ( pipe_tx_7_sigs[36]    ),//(pipe_tx00_start_block)
+   .pipe_tx07_sync_header                ( pipe_tx_7_sigs[38:37] ),//(pipe_tx00_sync_header[1:0])
+   .pipe_rx07_polarity                   ( pipe_tx_7_sigs[39]    ),//(pipe_rx00_polarity)
+   .pipe_tx07_powerdown                  ( pipe_tx_7_sigs[41:40] ),//(pipe_tx00_powerdown[1:0])
+   .pipe_tx07_eq_control                 ( pipe_tx07_eq_control ),//(pipe_tx00_eq_control[1:0])
+                                       //( pipe_tx_7_sigs[47:44] ),//
+   .pipe_tx07_eq_deemph                  ( ),//(pipe_tx00_eq_deemph[5:0])
+   .pipe_rx07_eq_control                 ( pipe_rx07_eq_control ),//(pipe_rx00_eq_control[1:0])
+                                       //( pipe_tx_7_sigs[58:56] ),//
+                                       //( pipe_tx_7_sigs[64:59] ),//
+                                       //( pipe_tx_7_sigs[68:65] ),//
+   .pipe_tx07_compliance                 ( ),//(pipe_tx00_compliance)
+  //-----------------------------
+  // pipe_tx_8_sigs[69:0]
+   .pipe_tx08_data                       ( pipe_tx_8_sigs[31: 0] ),//(pipe_tx00_data[31:0])
+   .pipe_tx08_char_is_k                  ( pipe_tx_8_sigs[33:32] ),//(pipe_tx00_char_is_k[1:0])
+   .pipe_tx08_elec_idle                  ( pipe_tx_8_sigs[34]    ),//(pipe_tx00_elec_idle)
+   .pipe_tx08_data_valid                 ( pipe_tx_8_sigs[35]    ),//(pipe_tx00_data_valid)
+   .pipe_tx08_start_block                ( pipe_tx_8_sigs[36]    ),//(pipe_tx00_start_block)
+   .pipe_tx08_sync_header                ( pipe_tx_8_sigs[38:37] ),//(pipe_tx00_sync_header[1:0])
+   .pipe_rx08_polarity                   ( pipe_tx_8_sigs[39]    ),//(pipe_rx00_polarity)
+   .pipe_tx08_powerdown                  ( pipe_tx_8_sigs[41:40] ),//(pipe_tx00_powerdown[1:0])
+   .pipe_tx08_eq_control                 ( pipe_tx08_eq_control ),//(pipe_tx00_eq_control[1:0])
+                                       //( pipe_tx_8_sigs[47:44] ),//
+   .pipe_tx08_eq_deemph                  ( ),//(pipe_tx00_eq_deemph[5:0])
+   .pipe_rx08_eq_control                 ( pipe_rx08_eq_control ),//(pipe_rx00_eq_control[1:0])
+                                       //( pipe_tx_8_sigs[58:56] ),//
+                                       //( pipe_tx_8_sigs[64:59] ),//
+                                       //( pipe_tx_8_sigs[68:65] ),//
+   .pipe_tx08_compliance                 (  ),//(pipe_tx00_compliance)
+  //-----------------------------
+  // pipe_tx_9_sigs[69:0]
+   .pipe_tx09_data                       ( pipe_tx_9_sigs[31: 0] ),//(pipe_tx00_data[31:0])
+   .pipe_tx09_char_is_k                  ( pipe_tx_9_sigs[33:32] ),//(pipe_tx00_char_is_k[1:0])
+   .pipe_tx09_elec_idle                  ( pipe_tx_9_sigs[34]    ),//(pipe_tx00_elec_idle)
+   .pipe_tx09_data_valid                 ( pipe_tx_9_sigs[35]    ),//(pipe_tx00_data_valid)
+   .pipe_tx09_start_block                ( pipe_tx_9_sigs[36]    ),//(pipe_tx00_start_block)
+   .pipe_tx09_sync_header                ( pipe_tx_9_sigs[38:37] ),//(pipe_tx00_sync_header[1:0])
+   .pipe_rx09_polarity                   ( pipe_tx_9_sigs[39]    ),//(pipe_rx00_polarity)
+   .pipe_tx09_powerdown                  ( pipe_tx_9_sigs[41:40] ),//(pipe_tx00_powerdown[1:0])
+   .pipe_tx09_eq_control                 ( pipe_tx09_eq_control ),//(pipe_tx00_eq_control[1:0])
+                                       //( pipe_tx_9_sigs[47:44] ),//
+   .pipe_tx09_eq_deemph                  ( ),//(pipe_tx00_eq_deemph[5:0])
+   .pipe_rx09_eq_control                 ( pipe_rx09_eq_control),//(pipe_rx00_eq_control[1:0])
+                                       //( pipe_tx_9_sigs[58:56] ),//
+                                       //( pipe_tx_9_sigs[64:59] ),//
+                                       //( pipe_tx_9_sigs[68:65] ),//
+   .pipe_tx09_compliance                 ( ),//(pipe_tx00_compliance)
+  //-----------------------------
+  // pipe_tx_10_sigs[69:0]
+   .pipe_tx10_data                       ( pipe_tx_10_sigs[31: 0] ),//(pipe_tx00_data[31:0])
+   .pipe_tx10_char_is_k                  ( pipe_tx_10_sigs[33:32] ),//(pipe_tx00_char_is_k[1:0])
+   .pipe_tx10_elec_idle                  ( pipe_tx_10_sigs[34]    ),//(pipe_tx00_elec_idle)
+   .pipe_tx10_data_valid                 ( pipe_tx_10_sigs[35]    ),//(pipe_tx00_data_valid)
+   .pipe_tx10_start_block                ( pipe_tx_10_sigs[36]    ),//(pipe_tx00_start_block)
+   .pipe_tx10_sync_header                ( pipe_tx_10_sigs[38:37] ),//(pipe_tx00_sync_header[1:0])
+   .pipe_rx10_polarity                   ( pipe_tx_10_sigs[39]    ),//(pipe_rx00_polarity)
+   .pipe_tx10_powerdown                  ( pipe_tx_10_sigs[41:40] ),//(pipe_tx00_powerdown[1:0])
+   .pipe_tx10_eq_control                 ( pipe_tx10_eq_control ),//(pipe_tx00_eq_control[1:0])
+                                       //( pipe_tx_10_sigs[47:44] ),//
+   .pipe_tx10_eq_deemph                  ( ),//(pipe_tx00_eq_deemph[5:0])
+   .pipe_rx10_eq_control                 ( pipe_rx10_eq_control ),//(pipe_rx00_eq_control[1:0])
+                                       //( pipe_tx_10_sigs[58:56] ),//
+                                       //( pipe_tx_10_sigs[64:59] ),//
+                                       //( pipe_tx_10_sigs[68:65] ),//
+   .pipe_tx10_compliance                 ( ),//(pipe_tx00_compliance)
+  //-----------------------------
+  // pipe_tx_11_sigs[69:0]
+   .pipe_tx11_data                       ( pipe_tx_11_sigs[31: 0] ),//(pipe_tx00_data[31:0])
+   .pipe_tx11_char_is_k                  ( pipe_tx_11_sigs[33:32] ),//(pipe_tx00_char_is_k[1:0])
+   .pipe_tx11_elec_idle                  ( pipe_tx_11_sigs[34]    ),//(pipe_tx00_elec_idle)
+   .pipe_tx11_data_valid                 ( pipe_tx_11_sigs[35]    ),//(pipe_tx00_data_valid)
+   .pipe_tx11_start_block                ( pipe_tx_11_sigs[36]    ),//(pipe_tx00_start_block)
+   .pipe_tx11_sync_header                ( pipe_tx_11_sigs[38:37] ),//(pipe_tx00_sync_header[1:0])
+   .pipe_rx11_polarity                   ( pipe_tx_11_sigs[39]    ),//(pipe_rx00_polarity)
+   .pipe_tx11_powerdown                  ( pipe_tx_11_sigs[41:40] ),//(pipe_tx00_powerdown[1:0])
+   .pipe_tx11_eq_control                 ( pipe_tx11_eq_control ),//(pipe_tx00_eq_control[1:0])
+                                       //( pipe_tx_11_sigs[47:44] ),//
+   .pipe_tx11_eq_deemph                  ( ),//(pipe_tx00_eq_deemph[5:0])
+   .pipe_rx11_eq_control                 ( pipe_rx11_eq_control ),//(pipe_rx00_eq_control[1:0])
+                                       //( pipe_tx_11_sigs[58:56] ),//
+                                       //( pipe_tx_11_sigs[64:59] ),//
+                                       //( pipe_tx_11_sigs[68:65] ),//
+   .pipe_tx11_compliance                 ( ),//(pipe_tx00_compliance)
+  //-----------------------------
+  // pipe_tx_12_sigs[69:0]
+   .pipe_tx12_data                       ( pipe_tx_12_sigs[31: 0] ),//(pipe_tx00_data[31:0])
+   .pipe_tx12_char_is_k                  ( pipe_tx_12_sigs[33:32] ),//(pipe_tx00_char_is_k[1:0])
+   .pipe_tx12_elec_idle                  ( pipe_tx_12_sigs[34]    ),//(pipe_tx00_elec_idle)
+   .pipe_tx12_data_valid                 ( pipe_tx_12_sigs[35]    ),//(pipe_tx00_data_valid)
+   .pipe_tx12_start_block                ( pipe_tx_12_sigs[36]    ),//(pipe_tx00_start_block)
+   .pipe_tx12_sync_header                ( pipe_tx_12_sigs[38:37] ),//(pipe_tx00_sync_header[1:0])
+   .pipe_rx12_polarity                   ( pipe_tx_12_sigs[39]    ),//(pipe_rx00_polarity)
+   .pipe_tx12_powerdown                  ( pipe_tx_12_sigs[41:40] ),//(pipe_tx00_powerdown[1:0])
+   .pipe_tx12_eq_control                 ( pipe_tx12_eq_control ),//(pipe_tx00_eq_control[1:0])
+                                       //( pipe_tx_12_sigs[47:44] ),//
+   .pipe_tx12_eq_deemph                  ( ),//(pipe_tx00_eq_deemph[5:0])
+   .pipe_rx12_eq_control                 ( pipe_rx12_eq_control ),//(pipe_rx00_eq_control[1:0])
+                                       //( pipe_tx_12_sigs[58:56] ),//
+                                       //( pipe_tx_12_sigs[64:59] ),//
+                                       //( pipe_tx_12_sigs[68:65] ),//
+   .pipe_tx12_compliance                 ( ),//(pipe_tx00_compliance)
+  //-----------------------------
+  // pipe_tx_13_sigs[69:0]
+   .pipe_tx13_data                       ( pipe_tx_13_sigs[31: 0] ),//(pipe_tx00_data[31:0])
+   .pipe_tx13_char_is_k                  ( pipe_tx_13_sigs[33:32] ),//(pipe_tx00_char_is_k[1:0])
+   .pipe_tx13_elec_idle                  ( pipe_tx_13_sigs[34]    ),//(pipe_tx00_elec_idle)
+   .pipe_tx13_data_valid                 ( pipe_tx_13_sigs[35]    ),//(pipe_tx00_data_valid)
+   .pipe_tx13_start_block                ( pipe_tx_13_sigs[36]    ),//(pipe_tx00_start_block)
+   .pipe_tx13_sync_header                ( pipe_tx_13_sigs[38:37] ),//(pipe_tx00_sync_header[1:0])
+   .pipe_rx13_polarity                   ( pipe_tx_13_sigs[39]    ),//(pipe_rx00_polarity)
+   .pipe_tx13_powerdown                  ( pipe_tx_13_sigs[41:40] ),//(pipe_tx00_powerdown[1:0])
+   .pipe_tx13_eq_control                 ( pipe_tx13_eq_control ),//(pipe_tx00_eq_control[1:0])
+                                       //( pipe_tx_13_sigs[47:44] ),//
+   .pipe_tx13_eq_deemph                  (  ),//(pipe_tx00_eq_deemph[5:0])
+   .pipe_rx13_eq_control                 ( pipe_rx13_eq_control ),//(pipe_rx00_eq_control[1:0])
+                                       //( pipe_tx_13_sigs[58:56] ),//
+                                       //( pipe_tx_13_sigs[64:59] ),//
+                                       //( pipe_tx_13_sigs[68:65] ),//
+   .pipe_tx13_compliance                 ( ),//(pipe_tx00_compliance)
+  //-----------------------------
+  // pipe_tx_14_sigs[69:0]
+   .pipe_tx14_data                       ( pipe_tx_14_sigs[31: 0] ),//(pipe_tx00_data[31:0])
+   .pipe_tx14_char_is_k                  ( pipe_tx_14_sigs[33:32] ),//(pipe_tx00_char_is_k[1:0])
+   .pipe_tx14_elec_idle                  ( pipe_tx_14_sigs[34]    ),//(pipe_tx00_elec_idle)
+   .pipe_tx14_data_valid                 ( pipe_tx_14_sigs[35]    ),//(pipe_tx00_data_valid)
+   .pipe_tx14_start_block                ( pipe_tx_14_sigs[36]    ),//(pipe_tx00_start_block)
+   .pipe_tx14_sync_header                ( pipe_tx_14_sigs[38:37] ),//(pipe_tx00_sync_header[1:0])
+   .pipe_rx14_polarity                   ( pipe_tx_14_sigs[39]    ),//(pipe_rx00_polarity)
+   .pipe_tx14_powerdown                  ( pipe_tx_14_sigs[41:40] ),//(pipe_tx00_powerdown[1:0])
+   .pipe_tx14_eq_control                 ( pipe_tx14_eq_control ),//(pipe_tx00_eq_control[1:0])
+                                       //( pipe_tx_14_sigs[47:44] ),//
+   .pipe_tx14_eq_deemph                  ( ),//(pipe_tx00_eq_deemph[5:0])
+   .pipe_rx14_eq_control                 ( pipe_rx14_eq_control ),//(pipe_rx00_eq_control[1:0])
+                                       //( pipe_tx_14_sigs[58:56] ),//
+                                       //( pipe_tx_14_sigs[64:59] ),//
+                                       //( pipe_tx_14_sigs[68:65] ),//
+   .pipe_tx14_compliance                 ( ),//(pipe_tx00_compliance)
+  //-----------------------------
+  // pipe_tx_15_sigs[69:0]
+   .pipe_tx15_data                       ( pipe_tx_15_sigs[31: 0] ),//(pipe_tx00_data[31:0])
+   .pipe_tx15_char_is_k                  ( pipe_tx_15_sigs[33:32] ),//(pipe_tx00_char_is_k[1:0])
+   .pipe_tx15_elec_idle                  ( pipe_tx_15_sigs[34]    ),//(pipe_tx00_elec_idle)
+   .pipe_tx15_data_valid                 ( pipe_tx_15_sigs[35]    ),//(pipe_tx00_data_valid)
+   .pipe_tx15_start_block                ( pipe_tx_15_sigs[36]    ),//(pipe_tx00_start_block)
+   .pipe_tx15_sync_header                ( pipe_tx_15_sigs[38:37] ),//(pipe_tx00_sync_header[1:0])
+   .pipe_rx15_polarity                   ( pipe_tx_15_sigs[39]    ),//(pipe_rx00_polarity)
+   .pipe_tx15_powerdown                  ( pipe_tx_15_sigs[41:40] ),//(pipe_tx00_powerdown[1:0])
+   .pipe_tx15_eq_control                 ( pipe_tx15_eq_control ),//(pipe_tx00_eq_control[1:0])
+                                       //( pipe_tx_15_sigs[47:44] ),//
+   .pipe_tx15_eq_deemph                  ( ),//(pipe_tx00_eq_deemph[5:0])
+   .pipe_rx15_eq_control                 ( pipe_rx15_eq_control ),//(pipe_rx00_eq_control[1:0])
+                                       //( pipe_tx_15_sigs[58:56] ),//
+                                       //( pipe_tx_15_sigs[64:59] ),//
+                                       //( pipe_tx_15_sigs[68:65] ),//
+   .pipe_tx15_compliance                 ( ),//(pipe_tx00_compliance)
+  //-----------------------------
+  // PIPE RX BUS Signals[83:0]
+  //-----------------------------
+  // pipe_rx00_sigs[83:0]
+   .pipe_rx00_data                         ( pipe_rx_0_sigs[31: 0] ),//(pipe_rx00_data[31:0])
+   .pipe_rx00_char_is_k                    ( pipe_rx_0_sigs[33:32] ),//(pipe_rx00_char_is_k[1:0])
+   .pipe_rx00_data_valid                   ( pipe_rx_0_sigs[35]    ),//(pipe_rx00_data_valid)
+   .pipe_rx00_elec_idle                    ( pipe_rx_0_sigs[34]    ),//(pipe_rx00_elec_idle)
+   .pipe_rx00_start_block                  ( {1'b0, pipe_rx_0_sigs[36]}    ),//(pipe_rx00_start_block[1:0])
+   .pipe_rx00_sync_header                  ( pipe_rx_0_sigs[38:37] ),//(pipe_rx00_sync_header[1:0])
+   .pipe_rx00_status                       ( rx_status ),//(pipe_rx00_status[2:0])
+   .pipe_rx00_valid                        ( ~pipe_rx_0_sigs[34]    ),//(pipe_rx00_valid)
+   .pipe_rx00_phy_status                   ( phy_status ),//(pipe_rx00_phy_status)
+   .pipe_tx00_eq_done                      ( pipe_tx00_eq_done   ),//(pipe_tx00_eq_done)
+   .pipe_tx00_eq_coeff                     ( 18'h00904 ),//(pipe_tx00_eq_coeff[17:0])
+   .pipe_rx00_eq_lp_new_tx_coeff_or_preset ( 18'h05 ),//(pipe_rx00_eq_lp_new_tx_coeff_or_preset[17:0])
+   .pipe_rx00_eq_lp_lf_fs_sel              ( 1'b0    ),//(pipe_rx00_eq_lp_lf_fs_sel)
+   .pipe_rx00_eq_lp_adapt_done             ( 1'b0   ),//(pipe_rx00_eq_lp_adapt_done)
+   .pipe_rx00_eq_done                      ( pipe_rx00_eq_done    ),//(pipe_rx00_eq_done)
+  //-----------------------------
+  // pipe_rx01_sigs[83:0]
+   .pipe_rx01_data                         ( pipe_rx_1_sigs[31: 0] ),//(pipe_rx00_data[31:0])
+   .pipe_rx01_char_is_k                    ( pipe_rx_1_sigs[33:32] ),//(pipe_rx00_char_is_k[1:0])
+   .pipe_rx01_data_valid                   ( pipe_rx_1_sigs[35]    ),//(pipe_rx00_data_valid)
+   .pipe_rx01_elec_idle                    ( pipe_rx_1_sigs[34]    ),//(pipe_rx00_elec_idle)
+   .pipe_rx01_start_block                  ( {1'b0, pipe_rx_1_sigs[36]}    ),//(pipe_rx00_start_block[1:0])
+   .pipe_rx01_sync_header                  ( pipe_rx_1_sigs[38:37] ),//(pipe_rx00_sync_header[1:0])
+   .pipe_rx01_status                       ( (PL_LINK_CAP_MAX_LINK_WIDTH >= 2 )? rx_status : 3'b0  ),//(pipe_rx00_status[2:0])
+   .pipe_rx01_valid                        ( ~pipe_rx_1_sigs[34]    ),//(pipe_rx00_valid)
+   .pipe_rx01_phy_status                   ( (PL_LINK_CAP_MAX_LINK_WIDTH >= 2 )? phy_status : 1'b0  ),//(pipe_rx00_phy_status)
+   .pipe_tx01_eq_done                      ( pipe_tx01_eq_done    ),//(pipe_tx00_eq_done)
+   .pipe_tx01_eq_coeff                     ( 18'h00904 ),//(pipe_tx00_eq_coeff[17:0])
+   .pipe_rx01_eq_lp_new_tx_coeff_or_preset ( 18'h05 ),//(pipe_rx00_eq_lp_new_tx_coeff_or_preset[17:0])
+   .pipe_rx01_eq_lp_lf_fs_sel              ( 1'b0    ),//(pipe_rx00_eq_lp_lf_fs_sel)
+   .pipe_rx01_eq_lp_adapt_done             ( 1'b0    ),//(pipe_rx00_eq_lp_adapt_done)
+   .pipe_rx01_eq_done                      ( pipe_rx01_eq_done    ),//(pipe_rx00_eq_done)
+  //-----------------------------
+  // pipe_rx02_sigs[83:0]
+   .pipe_rx02_data                         ( pipe_rx_2_sigs[31: 0] ),//(pipe_rx00_data[31:0])
+   .pipe_rx02_char_is_k                    ( pipe_rx_2_sigs[33:32] ),//(pipe_rx00_char_is_k[1:0])
+   .pipe_rx02_data_valid                   ( pipe_rx_2_sigs[35]    ),//(pipe_rx00_data_valid)
+   .pipe_rx02_elec_idle                    ( pipe_rx_2_sigs[34]    ),//(pipe_rx00_elec_idle)
+   .pipe_rx02_start_block                  ( {1'b0, pipe_rx_2_sigs[36]}    ),//(pipe_rx00_start_block[1:0])
+   .pipe_rx02_sync_header                  ( pipe_rx_2_sigs[38:37] ),//(pipe_rx00_sync_header[1:0])
+   .pipe_rx02_status                       ( (PL_LINK_CAP_MAX_LINK_WIDTH >= 2 )? rx_status : 3'b0  ),//(pipe_rx00_status[2:0])
+   .pipe_rx02_valid                        ( ~pipe_rx_2_sigs[34]    ),//(pipe_rx00_valid)
+   .pipe_rx02_phy_status                   ( (PL_LINK_CAP_MAX_LINK_WIDTH >= 4 )? phy_status : 1'b0 ),//(pipe_rx00_phy_status)
+   .pipe_tx02_eq_done                      ( pipe_tx02_eq_done    ),//(pipe_tx00_eq_done)
+   .pipe_tx02_eq_coeff                     ( 18'h00904 ),//(pipe_tx00_eq_coeff[17:0])
+   .pipe_rx02_eq_lp_new_tx_coeff_or_preset ( 18'h05 ),//(pipe_rx00_eq_lp_new_tx_coeff_or_preset[17:0])
+   .pipe_rx02_eq_lp_lf_fs_sel              ( 1'b0    ),//(pipe_rx00_eq_lp_lf_fs_sel)
+   .pipe_rx02_eq_lp_adapt_done             ( 1'b0    ),//(pipe_rx00_eq_lp_adapt_done)
+   .pipe_rx02_eq_done                      ( pipe_rx02_eq_done    ),//(pipe_rx00_eq_done)
+  //-----------------------------
+  // pipe_rx03_sigs[83:0]
+   .pipe_rx03_data                         ( pipe_rx_3_sigs[31: 0] ),//(pipe_rx00_data[31:0])
+   .pipe_rx03_char_is_k                    ( pipe_rx_3_sigs[33:32] ),//(pipe_rx00_char_is_k[1:0])
+   .pipe_rx03_data_valid                   ( pipe_rx_3_sigs[35]    ),//(pipe_rx00_data_valid)
+   .pipe_rx03_elec_idle                    ( pipe_rx_3_sigs[34]    ),//(pipe_rx00_elec_idle)
+   .pipe_rx03_start_block                  ( {1'b0, pipe_rx_3_sigs[36]}    ),//(pipe_rx00_start_block[1:0])
+   .pipe_rx03_sync_header                  ( pipe_rx_3_sigs[38:37] ),//(pipe_rx00_sync_header[1:0])
+   .pipe_rx03_status                       ( (PL_LINK_CAP_MAX_LINK_WIDTH >= 2 )? rx_status : 3'b0 ),//(pipe_rx00_status[2:0])
+   .pipe_rx03_valid                        ( ~pipe_rx_3_sigs[34]    ),//(pipe_rx00_valid)
+   .pipe_rx03_phy_status                   ( (PL_LINK_CAP_MAX_LINK_WIDTH >= 4 )? phy_status : 1'b0 ),//(pipe_rx00_phy_status)
+   .pipe_tx03_eq_done                      ( pipe_tx03_eq_done    ),//(pipe_tx00_eq_done)
+   .pipe_tx03_eq_coeff                     ( 18'h00904 ),//(pipe_tx00_eq_coeff[17:0])
+   .pipe_rx03_eq_lp_new_tx_coeff_or_preset ( 18'h05 ),//(pipe_rx00_eq_lp_new_tx_coeff_or_preset[17:0])
+   .pipe_rx03_eq_lp_lf_fs_sel              ( 1'b0    ),//(pipe_rx00_eq_lp_lf_fs_sel)
+   .pipe_rx03_eq_lp_adapt_done             ( 1'b0    ),//(pipe_rx00_eq_lp_adapt_done)
+   .pipe_rx03_eq_done                      ( pipe_rx03_eq_done    ),//(pipe_rx00_eq_done)
+  //-----------------------------
+  // pipe_rx04_sigs[83:0]
+   .pipe_rx04_data                         ( pipe_rx_4_sigs[31: 0] ),//(pipe_rx00_data[31:0])
+   .pipe_rx04_char_is_k                    ( pipe_rx_4_sigs[33:32] ),//(pipe_rx00_char_is_k[1:0])
+   .pipe_rx04_data_valid                   ( pipe_rx_4_sigs[35]    ),//(pipe_rx00_data_valid)
+   .pipe_rx04_elec_idle                    ( pipe_rx_4_sigs[34]    ),//(pipe_rx00_elec_idle)
+   .pipe_rx04_start_block                  ({1'b0,  pipe_rx_4_sigs[36]}    ),//(pipe_rx00_start_block[1:0])
+   .pipe_rx04_sync_header                  ( pipe_rx_4_sigs[38:37] ),//(pipe_rx00_sync_header[1:0])
+   .pipe_rx04_status                       ( (PL_LINK_CAP_MAX_LINK_WIDTH >= 2 )? rx_status : 3'b0 ),//(pipe_rx00_status[2:0])
+   .pipe_rx04_valid                        ( ~pipe_rx_4_sigs[34]    ),//(pipe_rx00_valid)
+   .pipe_rx04_phy_status                   ( (PL_LINK_CAP_MAX_LINK_WIDTH >= 4 )? phy_status : 1'b0    ),//(pipe_rx00_phy_status)
+   .pipe_tx04_eq_done                      ( pipe_tx04_eq_done    ),//(pipe_tx00_eq_done)
+   .pipe_tx04_eq_coeff                     ( 18'h00904 ),//(pipe_tx00_eq_coeff[17:0])
+   .pipe_rx04_eq_lp_new_tx_coeff_or_preset ( 18'h05 ),//(pipe_rx00_eq_lp_new_tx_coeff_or_preset[17:0])
+   .pipe_rx04_eq_lp_lf_fs_sel              ( 1'b0    ),//(pipe_rx00_eq_lp_lf_fs_sel)
+   .pipe_rx04_eq_lp_adapt_done             ( 1'b0    ),//(pipe_rx00_eq_lp_adapt_done)
+   .pipe_rx04_eq_done                      ( pipe_rx04_eq_done    ),//(pipe_rx00_eq_done)
+  //-----------------------------
+  // pipe_rx05_sigs[83:0]
+   .pipe_rx05_data                         ( pipe_rx_5_sigs[31: 0] ),//(pipe_rx00_data[31:0])
+   .pipe_rx05_char_is_k                    ( pipe_rx_5_sigs[33:32] ),//(pipe_rx00_char_is_k[1:0])
+   .pipe_rx05_data_valid                   ( pipe_rx_5_sigs[35]    ),//(pipe_rx00_data_valid)
+   .pipe_rx05_elec_idle                    ( pipe_rx_5_sigs[34]    ),//(pipe_rx00_elec_idle)
+   .pipe_rx05_start_block                  ( {1'b0, pipe_rx_5_sigs[36]}    ),//(pipe_rx00_start_block[1:0])
+   .pipe_rx05_sync_header                  ( pipe_rx_5_sigs[38:37] ),//(pipe_rx00_sync_header[1:0])
+   .pipe_rx05_status                       ( (PL_LINK_CAP_MAX_LINK_WIDTH >= 2 )? rx_status : 3'b0 ),//(pipe_rx00_status[2:0])
+   .pipe_rx05_valid                        ( ~pipe_rx_5_sigs[34]    ),//(pipe_rx00_valid)
+   .pipe_rx05_phy_status                   ( (PL_LINK_CAP_MAX_LINK_WIDTH >= 4 )? phy_status : 1'b0    ),//(pipe_rx00_phy_status)
+   .pipe_tx05_eq_done                      ( pipe_tx05_eq_done    ),//(pipe_tx00_eq_done)
+   .pipe_tx05_eq_coeff                     ( 18'h00904 ),//(pipe_tx00_eq_coeff[17:0])
+   .pipe_rx05_eq_lp_new_tx_coeff_or_preset ( 18'h05 ),//(pipe_rx00_eq_lp_new_tx_coeff_or_preset[17:0])
+   .pipe_rx05_eq_lp_lf_fs_sel              ( 1'b0    ),//(pipe_rx00_eq_lp_lf_fs_sel)
+   .pipe_rx05_eq_lp_adapt_done             ( 1'b0    ),//(pipe_rx00_eq_lp_adapt_done)
+   .pipe_rx05_eq_done                      ( pipe_rx05_eq_done    ),//(pipe_rx00_eq_done)
+  //-----------------------------
+  // pipe_rx06_sigs[83:0]
+   .pipe_rx06_data                         ( pipe_rx_6_sigs[31: 0] ),//(pipe_rx00_data[31:0])
+   .pipe_rx06_char_is_k                    ( pipe_rx_6_sigs[33:32] ),//(pipe_rx00_char_is_k[1:0])
+   .pipe_rx06_data_valid                   ( pipe_rx_6_sigs[35]    ),//(pipe_rx00_data_valid)
+   .pipe_rx06_elec_idle                    ( pipe_rx_6_sigs[34]    ),//(pipe_rx00_elec_idle)
+   .pipe_rx06_start_block                  ( {1'b0, pipe_rx_6_sigs[36]}    ),//(pipe_rx00_start_block[1:0])
+   .pipe_rx06_sync_header                  ( pipe_rx_6_sigs[38:37] ),//(pipe_rx00_sync_header[1:0])
+   .pipe_rx06_status                       ( (PL_LINK_CAP_MAX_LINK_WIDTH >= 2 )? rx_status : 3'b0 ),//(pipe_rx00_status[2:0])
+   .pipe_rx06_valid                        ( ~pipe_rx_6_sigs[34]    ),//(pipe_rx00_valid)
+   .pipe_rx06_phy_status                   ( (PL_LINK_CAP_MAX_LINK_WIDTH >= 4 )? phy_status : 1'b0    ),//(pipe_rx00_phy_status)
+   .pipe_tx06_eq_done                      ( pipe_tx06_eq_done    ),//(pipe_tx00_eq_done)
+   .pipe_tx06_eq_coeff                     ( 18'h00904 ),//(pipe_tx00_eq_coeff[17:0])
+   .pipe_rx06_eq_lp_new_tx_coeff_or_preset ( 18'h05 ),//(pipe_rx00_eq_lp_new_tx_coeff_or_preset[17:0])
+   .pipe_rx06_eq_lp_lf_fs_sel              ( 1'b1    ),//(pipe_rx00_eq_lp_lf_fs_sel)
+   .pipe_rx06_eq_lp_adapt_done             ( 1'b1    ),//(pipe_rx00_eq_lp_adapt_done)
+   .pipe_rx06_eq_done                      ( pipe_rx06_eq_done    ),//(pipe_rx00_eq_done)
+  //-----------------------------
+  // pipe_rx07_sigs[83:0]
+   .pipe_rx07_data                         ( pipe_rx_7_sigs[31: 0] ),//(pipe_rx00_data[31:0])
+   .pipe_rx07_char_is_k                    ( pipe_rx_7_sigs[33:32] ),//(pipe_rx00_char_is_k[1:0])
+   .pipe_rx07_data_valid                   ( pipe_rx_7_sigs[35]    ),//(pipe_rx00_data_valid)
+   .pipe_rx07_elec_idle                    ( pipe_rx_7_sigs[34]    ),//(pipe_rx00_elec_idle)
+   .pipe_rx07_start_block                  ( {1'b0, pipe_rx_7_sigs[36]}    ),//(pipe_rx00_start_block[1:0])
+   .pipe_rx07_sync_header                  ( pipe_rx_7_sigs[38:37] ),//(pipe_rx00_sync_header[1:0])
+   .pipe_rx07_status                       ( (PL_LINK_CAP_MAX_LINK_WIDTH >= 2 )? rx_status : 3'b0 ),//(pipe_rx00_status[2:0])
+   .pipe_rx07_valid                        ( ~pipe_rx_7_sigs[34]    ),//(pipe_rx00_valid)
+   .pipe_rx07_phy_status                   ( (PL_LINK_CAP_MAX_LINK_WIDTH >= 4 )? phy_status : 1'b0     ),//(pipe_rx00_phy_status)
+   .pipe_tx07_eq_done                      ( pipe_tx07_eq_done    ),//(pipe_tx00_eq_done)
+   .pipe_tx07_eq_coeff                     ( 18'h00904 ),//(pipe_tx00_eq_coeff[17:0])
+   .pipe_rx07_eq_lp_new_tx_coeff_or_preset ( 18'h05 ),//(pipe_rx00_eq_lp_new_tx_coeff_or_preset[17:0])
+   .pipe_rx07_eq_lp_lf_fs_sel              ( 1'b1   ),//(pipe_rx00_eq_lp_lf_fs_sel)
+   .pipe_rx07_eq_lp_adapt_done             ( 1'b1    ),//(pipe_rx00_eq_lp_adapt_done)
+   .pipe_rx07_eq_done                      ( pipe_rx07_eq_done    ),//(pipe_rx00_eq_done)
+  //-----------------------------
+  // pipe_rx08_sigs[83:0]
+   .pipe_rx08_data                         ( pipe_rx_8_sigs[31: 0] ),//(pipe_rx00_data[31:0])
+   .pipe_rx08_char_is_k                    ( pipe_rx_8_sigs[33:32] ),//(pipe_rx00_char_is_k[1:0])
+   .pipe_rx08_data_valid                   ( pipe_rx_8_sigs[35]    ),//(pipe_rx00_data_valid)
+   .pipe_rx08_elec_idle                    ( pipe_rx_8_sigs[34]    ),//(pipe_rx00_elec_idle)
+   .pipe_rx08_start_block                  ( {1'b0, pipe_rx_8_sigs[36]}    ),//(pipe_rx00_start_block[1:0])
+   .pipe_rx08_sync_header                  ( pipe_rx_8_sigs[38:37] ),//(pipe_rx00_sync_header[1:0])
+   .pipe_rx08_status                       ( (PL_LINK_CAP_MAX_LINK_WIDTH >= 2 )? rx_status : 3'b0 ),//(pipe_rx00_status[2:0])
+   .pipe_rx08_valid                        ( ~pipe_rx_8_sigs[34]    ),//(pipe_rx00_valid)
+   .pipe_rx08_phy_status                   ( (PL_LINK_CAP_MAX_LINK_WIDTH >= 8 )? phy_status : 1'b0  ),//(pipe_rx00_phy_status)
+   .pipe_tx08_eq_done                      ( pipe_tx08_eq_done    ),//(pipe_tx00_eq_done)
+   .pipe_tx08_eq_coeff                     ( 18'h00904 ),//(pipe_tx00_eq_coeff[17:0])
+   .pipe_rx08_eq_lp_new_tx_coeff_or_preset ( 18'h05 ),//(pipe_rx00_eq_lp_new_tx_coeff_or_preset[17:0])
+   .pipe_rx08_eq_lp_lf_fs_sel              ( 1'b1    ),//(pipe_rx00_eq_lp_lf_fs_sel)
+   .pipe_rx08_eq_lp_adapt_done             ( 1'b1    ),//(pipe_rx00_eq_lp_adapt_done)
+   .pipe_rx08_eq_done                      ( pipe_rx08_eq_done    ),//(pipe_rx00_eq_done)
+  //-----------------------------
+  // pipe_rx09_sigs[83:0]
+   .pipe_rx09_data                         ( pipe_rx_9_sigs[31: 0] ),//(pipe_rx00_data[31:0])
+   .pipe_rx09_char_is_k                    ( pipe_rx_9_sigs[33:32] ),//(pipe_rx00_char_is_k[1:0])
+   .pipe_rx09_data_valid                   ( pipe_rx_9_sigs[35]    ),//(pipe_rx00_data_valid)
+   .pipe_rx09_elec_idle                    ( pipe_rx_9_sigs[34]    ),//(pipe_rx00_elec_idle)
+   .pipe_rx09_start_block                  ( {1'b0, pipe_rx_9_sigs[36]}    ),//(pipe_rx00_start_block[1:0])
+   .pipe_rx09_sync_header                  ( pipe_rx_9_sigs[38:37] ),//(pipe_rx00_sync_header[1:0])
+   .pipe_rx09_status                       ( (PL_LINK_CAP_MAX_LINK_WIDTH >= 2 )? rx_status : 3'b0  ),//(pipe_rx00_status[2:0])
+   .pipe_rx09_valid                        ( ~pipe_rx_9_sigs[34]    ),//(pipe_rx00_valid)
+   .pipe_rx09_phy_status                   ( (PL_LINK_CAP_MAX_LINK_WIDTH >= 8 )? phy_status : 1'b0    ),//(pipe_rx00_phy_status)
+   .pipe_tx09_eq_done                      ( pipe_tx09_eq_done    ),//(pipe_tx00_eq_done)
+   .pipe_tx09_eq_coeff                     ( 18'h00904 ),//(pipe_tx00_eq_coeff[17:0])
+   .pipe_rx09_eq_lp_new_tx_coeff_or_preset ( 18'h05 ),//(pipe_rx00_eq_lp_new_tx_coeff_or_preset[17:0])
+   .pipe_rx09_eq_lp_lf_fs_sel              ( 1'b1    ),//(pipe_rx00_eq_lp_lf_fs_sel)
+   .pipe_rx09_eq_lp_adapt_done             ( 1'b1    ),//(pipe_rx00_eq_lp_adapt_done)
+   .pipe_rx09_eq_done                      ( pipe_rx09_eq_done    ),//(pipe_rx00_eq_done)
+  //-----------------------------
+  // pipe_rx10_sigs[83:0]
+   .pipe_rx10_data                         ( pipe_rx_10_sigs[31: 0] ),//(pipe_rx00_data[31:0])
+   .pipe_rx10_char_is_k                    ( pipe_rx_10_sigs[33:32] ),//(pipe_rx00_char_is_k[1:0])
+   .pipe_rx10_data_valid                   ( pipe_rx_10_sigs[35]    ),//(pipe_rx00_data_valid)
+   .pipe_rx10_elec_idle                    ( pipe_rx_10_sigs[34]    ),//(pipe_rx00_elec_idle)
+   .pipe_rx10_start_block                  ( {1'b0, pipe_rx_10_sigs[36]}    ),//(pipe_rx00_start_block[1:0])
+   .pipe_rx10_sync_header                  ( pipe_rx_10_sigs[38:37] ),//(pipe_rx00_sync_header[1:0])
+   .pipe_rx10_status                       ( (PL_LINK_CAP_MAX_LINK_WIDTH >= 2 )? rx_status : 3'b0 ),//(pipe_rx00_status[2:0])
+   .pipe_rx10_valid                        ( ~pipe_rx_10_sigs[34]    ),//(pipe_rx00_valid)
+   .pipe_rx10_phy_status                   ( (PL_LINK_CAP_MAX_LINK_WIDTH >= 8 )? phy_status : 1'b0   ),//(pipe_rx00_phy_status)
+   .pipe_tx10_eq_done                      ( pipe_tx10_eq_done    ),//(pipe_tx00_eq_done)
+   .pipe_tx10_eq_coeff                     ( 18'h00904 ),//(pipe_tx00_eq_coeff[17:0])
+   .pipe_rx10_eq_lp_new_tx_coeff_or_preset ( 18'h05 ),//(pipe_rx00_eq_lp_new_tx_coeff_or_preset[17:0])
+   .pipe_rx10_eq_lp_lf_fs_sel              ( 1'b1    ),//(pipe_rx00_eq_lp_lf_fs_sel)
+   .pipe_rx10_eq_lp_adapt_done             ( 1'b1    ),//(pipe_rx00_eq_lp_adapt_done)
+   .pipe_rx10_eq_done                      ( pipe_rx10_eq_done    ),//(pipe_rx00_eq_done)
+  //-----------------------------
+  // pipe_rx11_sigs[83:0]
+   .pipe_rx11_data                         ( pipe_rx_11_sigs[31: 0] ),//(pipe_rx00_data[31:0])
+   .pipe_rx11_char_is_k                    ( pipe_rx_11_sigs[33:32] ),//(pipe_rx00_char_is_k[1:0])
+   .pipe_rx11_data_valid                   ( pipe_rx_11_sigs[35]    ),//(pipe_rx00_data_valid)
+   .pipe_rx11_elec_idle                    ( pipe_rx_11_sigs[34]    ),//(pipe_rx00_elec_idle)
+   .pipe_rx11_start_block                  ( {1'b0, pipe_rx_11_sigs[36]}    ),//(pipe_rx00_start_block[1:0])
+   .pipe_rx11_sync_header                  ( pipe_rx_11_sigs[38:37] ),//(pipe_rx00_sync_header[1:0])
+   .pipe_rx11_status                       ( (PL_LINK_CAP_MAX_LINK_WIDTH >= 2 )? rx_status : 3'b0 ),//(pipe_rx00_status[2:0])
+   .pipe_rx11_valid                        ( ~pipe_rx_11_sigs[34]    ),//(pipe_rx00_valid)
+   .pipe_rx11_phy_status                   ( (PL_LINK_CAP_MAX_LINK_WIDTH >= 8 )? phy_status : 1'b0    ),//(pipe_rx00_phy_status)
+   .pipe_tx11_eq_done                      ( pipe_tx11_eq_done    ),//(pipe_tx00_eq_done)
+   .pipe_tx11_eq_coeff                     ( 18'h00904 ),//(pipe_tx00_eq_coeff[17:0])
+   .pipe_rx11_eq_lp_new_tx_coeff_or_preset ( 18'h05 ),//(pipe_rx00_eq_lp_new_tx_coeff_or_preset[17:0])
+   .pipe_rx11_eq_lp_lf_fs_sel              ( 1'b1    ),//(pipe_rx00_eq_lp_lf_fs_sel)
+   .pipe_rx11_eq_lp_adapt_done             ( 1'b1    ),//(pipe_rx00_eq_lp_adapt_done)
+   .pipe_rx11_eq_done                      ( pipe_rx11_eq_done    ),//(pipe_rx00_eq_done)
+  //-----------------------------
+  // pipe_rx12_sigs[83:0]
+   .pipe_rx12_data                         ( pipe_rx_12_sigs[31: 0] ),//(pipe_rx00_data[31:0])
+   .pipe_rx12_char_is_k                    ( pipe_rx_12_sigs[33:32] ),//(pipe_rx00_char_is_k[1:0])
+   .pipe_rx12_data_valid                   ( pipe_rx_12_sigs[35]    ),//(pipe_rx00_data_valid)
+   .pipe_rx12_elec_idle                    ( pipe_rx_12_sigs[34]    ),//(pipe_rx00_elec_idle)
+   .pipe_rx12_start_block                  ( {1'b0, pipe_rx_12_sigs[36]}    ),//(pipe_rx00_start_block[1:0])
+   .pipe_rx12_sync_header                  ( pipe_rx_12_sigs[38:37] ),//(pipe_rx00_sync_header[1:0])
+   .pipe_rx12_status                       ( (PL_LINK_CAP_MAX_LINK_WIDTH >= 2 )? rx_status : 3'b0 ),//(pipe_rx00_status[2:0])
+   .pipe_rx12_valid                        ( ~pipe_rx_12_sigs[34]    ),//(pipe_rx00_valid)
+   .pipe_rx12_phy_status                   ( (PL_LINK_CAP_MAX_LINK_WIDTH >= 8 )? phy_status : 1'b0    ),//(pipe_rx00_phy_status)
+   .pipe_tx12_eq_done                      ( pipe_tx12_eq_done    ),//(pipe_tx00_eq_done)
+   .pipe_tx12_eq_coeff                     ( 18'h00904 ),//(pipe_tx00_eq_coeff[17:0])
+   .pipe_rx12_eq_lp_new_tx_coeff_or_preset ( 18'h05 ),//(pipe_rx00_eq_lp_new_tx_coeff_or_preset[17:0])
+   .pipe_rx12_eq_lp_lf_fs_sel              ( 1'b1    ),//(pipe_rx00_eq_lp_lf_fs_sel)
+   .pipe_rx12_eq_lp_adapt_done             ( 1'b1    ),//(pipe_rx00_eq_lp_adapt_done)
+   .pipe_rx12_eq_done                      ( pipe_rx12_eq_done    ),//(pipe_rx00_eq_done)
+  //-----------------------------
+  // pipe_rx13_sigs[83:0]
+   .pipe_rx13_data                         ( pipe_rx_13_sigs[31: 0] ),//(pipe_rx00_data[31:0])
+   .pipe_rx13_char_is_k                    ( pipe_rx_13_sigs[33:32] ),//(pipe_rx00_char_is_k[1:0])
+   .pipe_rx13_data_valid                   ( pipe_rx_13_sigs[35]    ),//(pipe_rx00_data_valid)
+   .pipe_rx13_elec_idle                    ( pipe_rx_13_sigs[34]    ),//(pipe_rx00_elec_idle)
+   .pipe_rx13_start_block                  ( {1'b0, pipe_rx_13_sigs[36]}    ),//(pipe_rx00_start_block[1:0])
+   .pipe_rx13_sync_header                  ( pipe_rx_13_sigs[38:37] ),//(pipe_rx00_sync_header[1:0])
+   .pipe_rx13_status                       ( (PL_LINK_CAP_MAX_LINK_WIDTH >= 2 )? rx_status : 3'b0 ),//(pipe_rx00_status[2:0])
+   .pipe_rx13_valid                        ( ~pipe_rx_13_sigs[34]    ),//(pipe_rx00_valid)
+   .pipe_rx13_phy_status                   ( (PL_LINK_CAP_MAX_LINK_WIDTH >= 8 )? phy_status : 1'b0    ),//(pipe_rx00_phy_status)
+   .pipe_tx13_eq_done                      ( pipe_tx13_eq_done    ),//(pipe_tx00_eq_done)
+   .pipe_tx13_eq_coeff                     ( 18'h00904 ),//(pipe_tx00_eq_coeff[17:0])
+   .pipe_rx13_eq_lp_new_tx_coeff_or_preset ( 18'h05 ),//(pipe_rx00_eq_lp_new_tx_coeff_or_preset[17:0])
+   .pipe_rx13_eq_lp_lf_fs_sel              ( 1'b1    ),//(pipe_rx00_eq_lp_lf_fs_sel)
+   .pipe_rx13_eq_lp_adapt_done             ( 1'b1    ),//(pipe_rx00_eq_lp_adapt_done)
+   .pipe_rx13_eq_done                      ( pipe_rx13_eq_done    ),//(pipe_rx00_eq_done)
+  //-----------------------------
+  // pipe_rx14_sigs[83:0]
+   .pipe_rx14_data                         ( pipe_rx_14_sigs[31: 0] ),//(pipe_rx00_data[31:0])
+   .pipe_rx14_char_is_k                    ( pipe_rx_14_sigs[33:32] ),//(pipe_rx00_char_is_k[1:0])
+   .pipe_rx14_data_valid                   ( pipe_rx_14_sigs[35]    ),//(pipe_rx00_data_valid)
+   .pipe_rx14_elec_idle                    ( pipe_rx_14_sigs[34]    ),//(pipe_rx00_elec_idle)
+   .pipe_rx14_start_block                  ( {1'b0, pipe_rx_14_sigs[36] }   ),//(pipe_rx00_start_block[1:0])
+   .pipe_rx14_sync_header                  ( pipe_rx_14_sigs[38:37] ),//(pipe_rx00_sync_header[1:0])
+   .pipe_rx14_status                       ( (PL_LINK_CAP_MAX_LINK_WIDTH >= 2 )? rx_status : 3'b0 ),//(pipe_rx00_status[2:0])
+   .pipe_rx14_valid                        ( ~pipe_rx_14_sigs[34]    ),//(pipe_rx00_valid)
+   .pipe_rx14_phy_status                   ( (PL_LINK_CAP_MAX_LINK_WIDTH >= 8 )? phy_status : 1'b0     ),//(pipe_rx00_phy_status)
+   .pipe_tx14_eq_done                      ( pipe_tx14_eq_done    ),//(pipe_tx00_eq_done)
+   .pipe_tx14_eq_coeff                     ( 18'h00904 ),//(pipe_tx00_eq_coeff[17:0])
+   .pipe_rx14_eq_lp_new_tx_coeff_or_preset ( 18'h05 ),//(pipe_rx00_eq_lp_new_tx_coeff_or_preset[17:0])
+   .pipe_rx14_eq_lp_lf_fs_sel              ( 1'b1    ),//(pipe_rx00_eq_lp_lf_fs_sel)
+   .pipe_rx14_eq_lp_adapt_done             ( 1'b1    ),//(pipe_rx00_eq_lp_adapt_done)
+   .pipe_rx14_eq_done                      ( pipe_rx14_eq_done    ),//(pipe_rx00_eq_done)
+  //-----------------------------
+  // pipe_rx15_sigs[83:0]
+   .pipe_rx15_data                         ( pipe_rx_15_sigs[31: 0] ),//(pipe_rx00_data[31:0])
+   .pipe_rx15_char_is_k                    ( pipe_rx_15_sigs[33:32] ),//(pipe_rx00_char_is_k[1:0])
+   .pipe_rx15_data_valid                   ( pipe_rx_15_sigs[35]    ),//(pipe_rx00_data_valid)
+   .pipe_rx15_elec_idle                    ( pipe_rx_15_sigs[34]    ),//(pipe_rx00_elec_idle)
+   .pipe_rx15_start_block                  ( {1'b0, pipe_rx_15_sigs[36] }   ),//(pipe_rx00_start_block[1:0])
+   .pipe_rx15_sync_header                  ( pipe_rx_15_sigs[38:37] ),//(pipe_rx00_sync_header[1:0])
+   .pipe_rx15_status                       ( (PL_LINK_CAP_MAX_LINK_WIDTH >= 2 )? rx_status : 3'b0 ),//(pipe_rx00_status[2:0])
+   .pipe_rx15_valid                        ( ~pipe_rx_15_sigs[34]    ),//(pipe_rx00_valid)
+   .pipe_rx15_phy_status                   ( (PL_LINK_CAP_MAX_LINK_WIDTH >= 8 )? phy_status : 1'b0    ),//(pipe_rx00_phy_status)
+   .pipe_tx15_eq_done                      ( pipe_tx15_eq_done    ),//(pipe_tx00_eq_done)
+   .pipe_tx15_eq_coeff                     ( 18'h00904 ),//(pipe_tx00_eq_coeff[17:0])
+   .pipe_rx15_eq_lp_new_tx_coeff_or_preset ( 18'h05 ),//(pipe_rx00_eq_lp_new_tx_coeff_or_preset[17:0])
+   .pipe_rx15_eq_lp_lf_fs_sel              ( 1'b1    ),//(pipe_rx00_eq_lp_lf_fs_sel)
+   .pipe_rx15_eq_lp_adapt_done             ( 1'b1    ),//(pipe_rx00_eq_lp_adapt_done)
+   .pipe_rx15_eq_done                      ( pipe_rx15_eq_done    )//(pipe_rx00_eq_done)
+
+   //,.pipe_rx08_data( pipe_tx_rate==2'b11 ? pipe_rx00_data[63:32] : pipe_rx08_data[31:0] )
+   //,.pipe_rx09_data( pipe_tx_rate==2'b11 ? pipe_rx01_data[63:32] : pipe_rx09_data[31:0] )
+   //,.pipe_rx10_data( pipe_tx_rate==2'b11 ? pipe_rx02_data[63:32] : pipe_rx10_data[31:0] )
+   //,.pipe_rx11_data( pipe_tx_rate==2'b11 ? pipe_rx03_data[63:32] : pipe_rx11_data[31:0] )
+   //,.pipe_rx12_data( pipe_tx_rate==2'b11 ? pipe_rx04_data[63:32] : pipe_rx12_data[31:0] )
+   //,.pipe_rx13_data( pipe_tx_rate==2'b11 ? pipe_rx05_data[63:32] : pipe_rx13_data[31:0] )
+   //,.pipe_rx14_data( pipe_tx_rate==2'b11 ? pipe_rx06_data[63:32] : pipe_rx14_data[31:0] )
+   //,.pipe_rx15_data( pipe_tx_rate==2'b11 ? pipe_rx07_data[63:32] : pipe_rx15_data[31:0] )
+   // -------------------------------------------------------------------------------------
+   ,.pl_gen2_upstream_prefer_deemph(pl_gen2_upstream_prefer_deemph)
+   ,.pl_eq_in_progress(pl_eq_in_progress)
+   ,.pl_eq_phase(pl_eq_phase[1:0])
+   ,.pl_redo_eq(pl_redo_eq)
+   ,.pl_redo_eq_speed(pl_redo_eq_speed)
+   ,.pl_eq_mismatch(pl_eq_mismatch)
+   ,.pl_redo_eq_pending(pl_redo_eq_pending)
+   ,.m_axis_cq_tdata(m_axis_cq_tdata[AXI4_DATA_WIDTH-1:0])
+   ,.s_axis_cc_tdata(s_axis_cc_tdata[AXI4_DATA_WIDTH-1:0])
+   ,.s_axis_rq_tdata(s_axis_rq_tdata[AXI4_DATA_WIDTH-1:0])
+   ,.m_axis_rc_tdata(m_axis_rc_tdata[AXI4_DATA_WIDTH-1:0])
+   ,.m_axis_cq_tuser(m_axis_cq_tuser[AXI4_CQ_TUSER_WIDTH-1:0])
+   ,.s_axis_cc_tuser(s_axis_cc_tuser[AXI4_CC_TUSER_WIDTH-1:0])
+   ,.m_axis_cq_tlast(m_axis_cq_tlast)
+   ,.s_axis_rq_tlast(s_axis_rq_tlast)
+   ,.m_axis_rc_tlast(m_axis_rc_tlast)
+   ,.s_axis_cc_tlast(s_axis_cc_tlast)
+   ,.pcie_cq_np_req(pcie_cq_np_req[1:0])
+   ,.pcie_cq_np_req_count(pcie_cq_np_req_count[5:0])
+   ,.s_axis_rq_tuser(s_axis_rq_tuser[AXI4_RQ_TUSER_WIDTH-1:0])
+   ,.m_axis_rc_tuser(m_axis_rc_tuser[AXI4_RC_TUSER_WIDTH-1:0])
+   ,.m_axis_cq_tkeep(m_axis_cq_tkeep[AXI4_TKEEP_WIDTH-1:0])
+   ,.s_axis_cc_tkeep(s_axis_cc_tkeep[AXI4_TKEEP_WIDTH-1:0])
+   ,.s_axis_rq_tkeep(s_axis_rq_tkeep[AXI4_TKEEP_WIDTH-1:0])
+   ,.m_axis_rc_tkeep(m_axis_rc_tkeep[AXI4_TKEEP_WIDTH-1:0])
+   ,.m_axis_cq_tvalid(m_axis_cq_tvalid)
+   ,.s_axis_cc_tvalid(s_axis_cc_tvalid)
+   ,.s_axis_rq_tvalid(s_axis_rq_tvalid)
+   ,.m_axis_rc_tvalid(m_axis_rc_tvalid)
+   ,.m_axis_cq_tready({AXI4_CQ_TREADY_WIDTH{m_axis_cq_tready}})
+   ,.s_axis_cc_tready(s_axis_cc_tready)
+   ,.s_axis_rq_tready(s_axis_rq_tready)
+   ,.m_axis_rc_tready({AXI4_RC_TREADY_WIDTH{m_axis_rc_tready}})
+   ,.pcie_rq_seq_num0(pcie_rq_seq_num0[5:0])
+   ,.pcie_rq_seq_num_vld0(pcie_rq_seq_num_vld0)
+   ,.pcie_rq_seq_num1(pcie_rq_seq_num1[5:0])
+   ,.pcie_rq_seq_num_vld1(pcie_rq_seq_num_vld1)
+   ,.pcie_rq_tag0(pcie_rq_tag0[7:0])
+   ,.pcie_rq_tag_vld0(pcie_rq_tag_vld0)
+   ,.pcie_rq_tag1(pcie_rq_tag1[7:0])
+   ,.pcie_rq_tag_vld1(pcie_rq_tag_vld1)
+   ,.pcie_tfc_nph_av(pcie_tfc_nph_av[3:0])
+   ,.pcie_tfc_npd_av(pcie_tfc_npd_av[3:0])
+   ,.pcie_rq_tag_av(pcie_rq_tag_av[3:0])
+   ,.axi_user_out( )
+   ,.axi_user_in(8'h00)
+   ,.cfg_mgmt_addr(cfg_mgmt_addr[9:0])
+   ,.cfg_mgmt_function_number(cfg_mgmt_function_number[7:0])
+   ,.cfg_mgmt_write(cfg_mgmt_write)
+   ,.cfg_mgmt_write_data(cfg_mgmt_write_data[31:0])
+   ,.cfg_mgmt_byte_enable(cfg_mgmt_byte_enable[3:0])
+   ,.cfg_mgmt_read(cfg_mgmt_read)
+   ,.cfg_mgmt_read_data(cfg_mgmt_read_data[31:0])
+   ,.cfg_mgmt_read_write_done(cfg_mgmt_read_write_done)
+   ,.cfg_mgmt_debug_access(cfg_mgmt_debug_access)
+   ,.cfg_phy_link_down(cfg_phy_link_down)
+   ,.cfg_phy_link_status(cfg_phy_link_status[1:0])
+   ,.cfg_negotiated_width(cfg_negotiated_width[2:0])
+   ,.cfg_current_speed(cfg_current_speed[1:0])
+   ,.cfg_max_payload(cfg_max_payload[1:0])
+   ,.cfg_max_read_req(cfg_max_read_req[2:0])
+   ,.cfg_function_status(cfg_function_status[15:0])
+   ,.cfg_function_power_state(cfg_function_power_state[11:0])
+   ,.cfg_link_power_state(cfg_link_power_state[1:0])
+   ,.cfg_err_cor_out(cfg_err_cor_out)
+   ,.cfg_err_nonfatal_out(cfg_err_nonfatal_out)
+   ,.cfg_err_fatal_out(cfg_err_fatal_out)
+   ,.cfg_local_error_valid(cfg_local_error_valid)
+   ,.cfg_local_error_out(cfg_local_error_out[4:0])
+   ,.cfg_ltssm_state(cfg_ltssm_state[5:0])
+   ,.cfg_rx_pm_state(cfg_rx_pm_state[1:0])
+   ,.cfg_tx_pm_state(cfg_tx_pm_state[1:0])
+   ,.cfg_rcb_status(cfg_rcb_status[3:0])
+   ,.cfg_obff_enable(cfg_obff_enable[1:0])
+   ,.cfg_pl_status_change(cfg_pl_status_change)
+   ,.cfg_tph_requester_enable(cfg_tph_requester_enable[3:0])
+   ,.cfg_tph_st_mode(cfg_tph_st_mode[11:0])
+   ,.cfg_msg_received(cfg_msg_received)
+   ,.cfg_msg_received_data(cfg_msg_received_data[7:0])
+   ,.cfg_msg_received_type(cfg_msg_received_type[4:0])
+   ,.cfg_msg_transmit(cfg_msg_transmit_int)
+   ,.cfg_msg_transmit_type(cfg_msg_transmit_type[2:0])
+   ,.cfg_msg_transmit_data(cfg_msg_transmit_data[31:0])
+   ,.cfg_msg_transmit_done(cfg_msg_transmit_done)
+   ,.cfg_fc_ph(cfg_fc_ph[7:0])
+   ,.cfg_fc_pd(cfg_fc_pd[11:0])
+   ,.cfg_fc_nph(cfg_fc_nph[7:0])
+   ,.cfg_fc_npd(cfg_fc_npd[11:0])
+   ,.cfg_fc_cplh(cfg_fc_cplh[7:0])
+   ,.cfg_fc_cpld(cfg_fc_cpld[11:0])
+   ,.cfg_fc_sel(cfg_fc_sel[2:0])
+   ,.cfg_hot_reset_in(cfg_hot_reset_in)
+   ,.cfg_hot_reset_out(cfg_hot_reset_out)
+   ,.cfg_config_space_enable(cfg_config_space_enable)
+   ,.cfg_dsn(cfg_dsn[63:0])
+   ,.cfg_dev_id_pf0(cfg_dev_id_pf0[15:0])
+   ,.cfg_dev_id_pf1(cfg_dev_id_pf1[15:0])
+   ,.cfg_dev_id_pf2(cfg_dev_id_pf2[15:0])
+   ,.cfg_dev_id_pf3(cfg_dev_id_pf3[15:0])
+   ,.cfg_vend_id(cfg_vend_id[15:0])
+   ,.cfg_rev_id_pf0(cfg_rev_id_pf0[7:0])
+   ,.cfg_rev_id_pf1(cfg_rev_id_pf1[7:0])
+   ,.cfg_rev_id_pf2(cfg_rev_id_pf2[7:0])
+   ,.cfg_rev_id_pf3(cfg_rev_id_pf3[7:0])
+   ,.cfg_subsys_id_pf0(cfg_subsys_id_pf0[15:0])
+   ,.cfg_subsys_id_pf1(cfg_subsys_id_pf1[15:0])
+   ,.cfg_subsys_id_pf2(cfg_subsys_id_pf2[15:0])
+   ,.cfg_subsys_id_pf3(cfg_subsys_id_pf3[15:0])
+   ,.cfg_subsys_vend_id(cfg_subsys_vend_id[15:0])
+   ,.cfg_ds_port_number(cfg_ds_port_number[7:0])
+   ,.cfg_ds_bus_number(cfg_ds_bus_number[7:0])
+   ,.cfg_ds_device_number(cfg_ds_device_number[4:0])
+   ,.cfg_ds_function_number(3'b0)
+   ,.cfg_bus_number(cfg_bus_number[7:0])
+   ,.cfg_power_state_change_ack(cfg_power_state_change_ack)
+   ,.cfg_power_state_change_interrupt(cfg_power_state_change_interrupt)
+   ,.cfg_err_cor_in(cfg_err_cor_in)
+   ,.cfg_err_uncor_in(cfg_err_uncor_in)
+   ,.cfg_flr_done(cfg_flr_done[3:0])
+   ,.cfg_vf_flr_in_process(cfg_vf_flr_in_process[251:0])   
+   ,.cfg_vf_flr_done(cfg_vf_flr_done)                      
+   ,.cfg_vf_flr_func_num(cfg_vf_flr_func_num[7:0])
+   ,.cfg_vf_status(cfg_vf_status[503:0])                   
+   ,.cfg_vf_power_state(cfg_vf_power_state[755:0])         
+   ,.cfg_vf_tph_requester_enable( cfg_vf_tph_requester_enable[251:0])
+   ,.cfg_vf_tph_st_mode(cfg_vf_tph_st_mode[755:0])         
+   ,.cfg_interrupt_msix_vf_enable(cfg_interrupt_msix_vf_enable[251:0])
+   ,.cfg_interrupt_msix_vf_mask(cfg_interrupt_msix_vf_mask[251:0])
+   ,.cfg_flr_in_process(cfg_flr_in_process[3:0])
+   ,.cfg_req_pm_transition_l23_ready(cfg_req_pm_transition_l23_ready)
+   ,.cfg_link_training_enable(cfg_link_training_enable)
+   ,.cfg_interrupt_int(cfg_interrupt_int[3:0])
+   ,.cfg_interrupt_sent(cfg_interrupt_sent)
+   ,.cfg_interrupt_pending(cfg_interrupt_pending[3:0])
+   ,.cfg_interrupt_msi_enable(cfg_interrupt_msi_enable[3:0])
+   ,.cfg_interrupt_msi_int(cfg_interrupt_msi_int[31:0])
+   ,.cfg_interrupt_msi_sent(cfg_interrupt_msi_sent)
+   ,.cfg_interrupt_msi_fail(cfg_interrupt_msi_fail)
+   ,.cfg_interrupt_msi_mmenable(cfg_interrupt_msi_mmenable[11:0])
+   ,.cfg_interrupt_msi_pending_status(cfg_interrupt_msi_pending_status[31:0])
+   ,.cfg_interrupt_msi_pending_status_function_num(cfg_interrupt_msi_pending_status_function_num[1:0])
+   ,.cfg_interrupt_msi_pending_status_data_enable(cfg_interrupt_msi_pending_status_data_enable)
+   ,.cfg_interrupt_msi_mask_update(cfg_interrupt_msi_mask_update)
+   ,.cfg_interrupt_msi_select(cfg_interrupt_msi_select[1:0])
+   ,.cfg_interrupt_msi_data(cfg_interrupt_msi_data[31:0])
+   ,.cfg_interrupt_msix_enable(cfg_interrupt_msix_enable[3:0])
+   ,.cfg_interrupt_msix_mask(cfg_interrupt_msix_mask[3:0])
+   ,.cfg_interrupt_msix_address(cfg_interrupt_msix_address[63:0])
+   ,.cfg_interrupt_msix_data(cfg_interrupt_msix_data[31:0])
+   ,.cfg_interrupt_msix_int(cfg_interrupt_msix_int)
+   ,.cfg_interrupt_msix_vec_pending(cfg_interrupt_msix_vec_pending[1:0])
+   ,.cfg_interrupt_msix_vec_pending_status(cfg_interrupt_msix_vec_pending_status)
+   ,.cfg_interrupt_msi_attr(cfg_interrupt_msi_attr[2:0])
+   ,.cfg_interrupt_msi_tph_present(cfg_interrupt_msi_tph_present)
+   ,.cfg_interrupt_msi_tph_type(cfg_interrupt_msi_tph_type[1:0])
+   ,.cfg_interrupt_msi_tph_st_tag(cfg_interrupt_msi_tph_st_tag[7:0])
+   ,.cfg_interrupt_msi_function_number(cfg_interrupt_msi_function_number[7:0])
+   ,.cfg_ext_read_received(cfg_ext_read_received)
+   ,.cfg_ext_write_received(cfg_ext_write_received)
+   ,.cfg_ext_register_number(cfg_ext_register_number[9:0])
+   ,.cfg_ext_function_number(cfg_ext_function_number[7:0])
+   ,.cfg_ext_write_data(cfg_ext_write_data[31:0])
+   ,.cfg_ext_write_byte_enable(cfg_ext_write_byte_enable[3:0])
+   ,.cfg_ext_read_data(cfg_ext_read_data[31:0])
+   ,.cfg_ext_read_data_valid(cfg_ext_read_data_valid)
+   ,.cfg_pm_aspm_l1_entry_reject(cfg_pm_aspm_l1_entry_reject)
+   ,.cfg_pm_aspm_tx_l0s_entry_disable(cfg_pm_aspm_tx_l0s_entry_disable)
+   ,.user_tph_stt_func_num(8'h00)
+   ,.user_tph_stt_index(6'b0)
+   ,.user_tph_stt_rd_en(1'b0)
+   ,.user_tph_stt_rd_data()
+   ,.conf_req_type(conf_req_type[1:0])
+   ,.conf_req_reg_num(conf_req_reg_num[3:0])
+   ,.conf_req_data(conf_req_data[31:0])
+   ,.conf_req_valid(conf_req_valid)
+   ,.conf_req_ready(conf_req_ready)
+   ,.conf_resp_rdata(conf_resp_rdata[31:0])
+   ,.conf_resp_valid(conf_resp_valid)
+   ,.conf_mcap_design_switch(conf_mcap_design_switch)
+   ,.conf_mcap_eos(conf_mcap_eos)
+   ,.conf_mcap_in_use_by_pcie(conf_mcap_in_use_by_pcie)
+   ,.conf_mcap_request_by_conf(conf_mcap_request_by_conf)
+
+   ,.drp_clk('h0)
+   ,.drp_en('h0)
+   ,.drp_we('h0)
+   ,.drp_addr('h0)
+   ,.drp_di('h0)
+   ,.drp_rdy()
+   ,.drp_do()
+
+   ,.pipe_clk(pipe_clk)
+   ,.core_clk(core_clk)
+   ,.user_clk(user_clk)
+   ,.user_clk2(user_clk2)
+   ,.user_clk_en(user_clk_en)
+   ,.mcap_clk(mcap_clk)
+   ,.mcap_rst_b(mcap_rst_b)
+   ,.pcie_perst0_b(pcie_perst0_b)
+   ,.pcie_perst1_b(pcie_perst1_b)
+   ,.phy_rdy(phy_rdy)
+   ,.cfg_fc_vc_sel(cfg_fc_vc_sel)
+   ,.pl_eq_reset_eieos_count(pl_eq_reset_eieos_count)
+   ,.cfg_ltr_enable(cfg_ltr_enable)
+   ,.s_axis_ccix_tx_tdata(s_axis_ccix_tx_tdata)
+   ,.s_axis_ccix_tx_tvalid(s_axis_ccix_tx_tvalid)
+   ,.s_axis_ccix_tx_tuser(s_axis_ccix_tx_tuser)
+   ,.ccix_tx_credit(ccix_tx_credit)
+   ,.m_axis_ccix_rx_tdata(m_axis_ccix_rx_tdata) // 256-bit data
+   ,.m_axis_ccix_rx_tvalid(m_axis_ccix_rx_tvalid)
+   ,.m_axis_ccix_rx_tuser(m_axis_ccix_rx_tuser) // tuser bus
+   ,.ccix_rx_credit(ccix_rx_credit)
+   ,.ccix_rx_credit_av(ccix_rx_credit_av)
+   ,.ccix_optimized_tlp_tx_and_rx_enable(ccix_optimized_tlp_tx_and_rx_enable)
+   ,.cfg_vc1_enable (cfg_vc1_enable)
+   ,.cfg_vc1_negotiation_pending (cfg_vc1_negotiation_pending)
+
+
+  );
+  
+  reg [3:0] pipe_rx00_eq_control_reg = 4'b0;
+  reg [3:0] pipe_rx01_eq_control_reg = 4'b0;
+  reg [3:0] pipe_rx02_eq_control_reg = 4'b0;
+  reg [3:0] pipe_rx03_eq_control_reg = 4'b0;
+  reg [3:0] pipe_rx04_eq_control_reg = 4'b0;
+  reg [3:0] pipe_rx05_eq_control_reg = 4'b0;
+  reg [3:0] pipe_rx06_eq_control_reg = 4'b0;
+  reg [3:0] pipe_rx07_eq_control_reg = 4'b0;
+  reg [3:0] pipe_rx08_eq_control_reg = 4'b0;
+  reg [3:0] pipe_rx09_eq_control_reg = 4'b0;
+  reg [3:0] pipe_rx10_eq_control_reg = 4'b0;
+  reg [3:0] pipe_rx11_eq_control_reg = 4'b0;
+  reg [3:0] pipe_rx12_eq_control_reg = 4'b0;
+  reg [3:0] pipe_rx13_eq_control_reg = 4'b0;
+  reg [3:0] pipe_rx14_eq_control_reg = 4'b0;
+  reg [3:0] pipe_rx15_eq_control_reg = 4'b0;
+  reg [3:0] pipe_tx00_eq_control_reg = 4'b0;
+  reg [3:0] pipe_tx01_eq_control_reg = 4'b0;
+  reg [3:0] pipe_tx02_eq_control_reg = 4'b0;
+  reg [3:0] pipe_tx03_eq_control_reg = 4'b0;
+  reg [3:0] pipe_tx04_eq_control_reg = 4'b0;
+  reg [3:0] pipe_tx05_eq_control_reg = 4'b0;
+  reg [3:0] pipe_tx06_eq_control_reg = 4'b0;
+  reg [3:0] pipe_tx07_eq_control_reg = 4'b0;
+  reg [3:0] pipe_tx08_eq_control_reg = 4'b0;
+  reg [3:0] pipe_tx09_eq_control_reg = 4'b0;
+  reg [3:0] pipe_tx10_eq_control_reg = 4'b0;
+  reg [3:0] pipe_tx11_eq_control_reg = 4'b0;
+  reg [3:0] pipe_tx12_eq_control_reg = 4'b0;
+  reg [3:0] pipe_tx13_eq_control_reg = 4'b0;
+  reg [3:0] pipe_tx14_eq_control_reg = 4'b0;
+  reg [3:0] pipe_tx15_eq_control_reg = 4'b0;
+
+  always @ (posedge pipe_clk)
+  begin
+   pipe_rx00_eq_control_reg     <= {pipe_rx00_eq_control_reg[1:0], pipe_rx00_eq_control};
+   pipe_rx01_eq_control_reg     <= {pipe_rx01_eq_control_reg[1:0], pipe_rx01_eq_control};
+   pipe_rx02_eq_control_reg     <= {pipe_rx02_eq_control_reg[1:0], pipe_rx02_eq_control};
+   pipe_rx03_eq_control_reg     <= {pipe_rx03_eq_control_reg[1:0], pipe_rx03_eq_control};
+   pipe_rx04_eq_control_reg     <= {pipe_rx04_eq_control_reg[1:0], pipe_rx04_eq_control};
+   pipe_rx05_eq_control_reg     <= {pipe_rx05_eq_control_reg[1:0], pipe_rx05_eq_control};
+   pipe_rx06_eq_control_reg     <= {pipe_rx06_eq_control_reg[1:0], pipe_rx06_eq_control};
+   pipe_rx07_eq_control_reg     <= {pipe_rx07_eq_control_reg[1:0], pipe_rx07_eq_control};
+   pipe_rx08_eq_control_reg     <= {pipe_rx08_eq_control_reg[1:0], pipe_rx08_eq_control};
+   pipe_rx09_eq_control_reg     <= {pipe_rx09_eq_control_reg[1:0], pipe_rx09_eq_control};
+   pipe_rx10_eq_control_reg     <= {pipe_rx10_eq_control_reg[1:0], pipe_rx10_eq_control};
+   pipe_rx11_eq_control_reg     <= {pipe_rx11_eq_control_reg[1:0], pipe_rx11_eq_control};
+   pipe_rx12_eq_control_reg     <= {pipe_rx12_eq_control_reg[1:0], pipe_rx12_eq_control};
+   pipe_rx13_eq_control_reg     <= {pipe_rx13_eq_control_reg[1:0], pipe_rx13_eq_control};
+   pipe_rx14_eq_control_reg     <= {pipe_rx14_eq_control_reg[1:0], pipe_rx14_eq_control};
+   pipe_rx15_eq_control_reg     <= {pipe_rx15_eq_control_reg[1:0], pipe_rx15_eq_control};
+
+   pipe_tx00_eq_control_reg     <= {pipe_tx00_eq_control_reg[1:0], pipe_tx00_eq_control};
+   pipe_tx01_eq_control_reg     <= {pipe_tx01_eq_control_reg[1:0], pipe_tx01_eq_control};
+   pipe_tx02_eq_control_reg     <= {pipe_tx02_eq_control_reg[1:0], pipe_tx02_eq_control};
+   pipe_tx03_eq_control_reg     <= {pipe_tx03_eq_control_reg[1:0], pipe_tx03_eq_control};
+   pipe_tx04_eq_control_reg     <= {pipe_tx04_eq_control_reg[1:0], pipe_tx04_eq_control};
+   pipe_tx05_eq_control_reg     <= {pipe_tx05_eq_control_reg[1:0], pipe_tx05_eq_control};
+   pipe_tx06_eq_control_reg     <= {pipe_tx06_eq_control_reg[1:0], pipe_tx06_eq_control};
+   pipe_tx07_eq_control_reg     <= {pipe_tx07_eq_control_reg[1:0], pipe_tx07_eq_control};
+   pipe_tx08_eq_control_reg     <= {pipe_tx08_eq_control_reg[1:0], pipe_tx08_eq_control};
+   pipe_tx09_eq_control_reg     <= {pipe_tx09_eq_control_reg[1:0], pipe_tx09_eq_control};
+   pipe_tx10_eq_control_reg     <= {pipe_tx10_eq_control_reg[1:0], pipe_tx10_eq_control};
+   pipe_tx11_eq_control_reg     <= {pipe_tx11_eq_control_reg[1:0], pipe_tx11_eq_control};
+   pipe_tx12_eq_control_reg     <= {pipe_tx12_eq_control_reg[1:0], pipe_tx12_eq_control};
+   pipe_tx13_eq_control_reg     <= {pipe_tx13_eq_control_reg[1:0], pipe_tx13_eq_control};
+   pipe_tx14_eq_control_reg     <= {pipe_tx14_eq_control_reg[1:0], pipe_tx14_eq_control};
+   pipe_tx15_eq_control_reg     <= {pipe_tx15_eq_control_reg[1:0], pipe_tx15_eq_control};
+
+  end
+  
+  
+  // generate rx*_eq_done
+  assign pipe_rx00_eq_done = (pipe_rx00_eq_control_reg[3:2] != pipe_rx00_eq_control)? 1'b1 : 1'b0;
+  assign pipe_rx01_eq_done = (pipe_rx01_eq_control_reg[3:2] != pipe_rx01_eq_control)? 1'b1 : 1'b0;
+  assign pipe_rx02_eq_done = (pipe_rx02_eq_control_reg[3:2] != pipe_rx02_eq_control)? 1'b1 : 1'b0;
+  assign pipe_rx03_eq_done = (pipe_rx03_eq_control_reg[3:2] != pipe_rx03_eq_control)? 1'b1 : 1'b0;
+  assign pipe_rx04_eq_done = (pipe_rx04_eq_control_reg[3:2] != pipe_rx04_eq_control)? 1'b1 : 1'b0;
+  assign pipe_rx05_eq_done = (pipe_rx05_eq_control_reg[3:2] != pipe_rx05_eq_control)? 1'b1 : 1'b0;
+  assign pipe_rx06_eq_done = (pipe_rx06_eq_control_reg[3:2] != pipe_rx06_eq_control)? 1'b1 : 1'b0;
+  assign pipe_rx07_eq_done = (pipe_rx07_eq_control_reg[3:2] != pipe_rx07_eq_control)? 1'b1 : 1'b0; 
+  assign pipe_rx08_eq_done = (pipe_rx08_eq_control_reg[3:2] != pipe_rx08_eq_control)? 1'b1 : 1'b0; 
+  assign pipe_rx09_eq_done = (pipe_rx09_eq_control_reg[3:2] != pipe_rx09_eq_control)? 1'b1 : 1'b0; 
+  assign pipe_rx10_eq_done = (pipe_rx10_eq_control_reg[3:2] != pipe_rx10_eq_control)? 1'b1 : 1'b0; 
+  assign pipe_rx11_eq_done = (pipe_rx11_eq_control_reg[3:2] != pipe_rx11_eq_control)? 1'b1 : 1'b0; 
+  assign pipe_rx12_eq_done = (pipe_rx12_eq_control_reg[3:2] != pipe_rx12_eq_control)? 1'b1 : 1'b0; 
+  assign pipe_rx13_eq_done = (pipe_rx13_eq_control_reg[3:2] != pipe_rx13_eq_control)? 1'b1 : 1'b0; 
+  assign pipe_rx14_eq_done = (pipe_rx14_eq_control_reg[3:2] != pipe_rx14_eq_control)? 1'b1 : 1'b0; 
+  assign pipe_rx15_eq_done = (pipe_rx15_eq_control_reg[3:2] != pipe_rx15_eq_control)? 1'b1 : 1'b0; 
+  // generate tx*_eq_done
+  assign pipe_tx00_eq_done = (pipe_tx00_eq_control_reg[3:2] != pipe_tx00_eq_control)? 1'b1 : 1'b0;
+  assign pipe_tx01_eq_done = (pipe_tx01_eq_control_reg[3:2] != pipe_tx01_eq_control)? 1'b1 : 1'b0;
+  assign pipe_tx02_eq_done = (pipe_tx02_eq_control_reg[3:2] != pipe_tx02_eq_control)? 1'b1 : 1'b0;
+  assign pipe_tx03_eq_done = (pipe_tx03_eq_control_reg[3:2] != pipe_tx03_eq_control)? 1'b1 : 1'b0;
+  assign pipe_tx04_eq_done = (pipe_tx04_eq_control_reg[3:2] != pipe_tx04_eq_control)? 1'b1 : 1'b0;
+  assign pipe_tx05_eq_done = (pipe_tx05_eq_control_reg[3:2] != pipe_tx05_eq_control)? 1'b1 : 1'b0;
+  assign pipe_tx06_eq_done = (pipe_tx06_eq_control_reg[3:2] != pipe_tx06_eq_control)? 1'b1 : 1'b0;
+  assign pipe_tx07_eq_done = (pipe_tx07_eq_control_reg[3:2] != pipe_tx07_eq_control)? 1'b1 : 1'b0; 
+  assign pipe_tx08_eq_done = (pipe_tx08_eq_control_reg[3:2] != pipe_tx08_eq_control)? 1'b1 : 1'b0; 
+  assign pipe_tx09_eq_done = (pipe_tx09_eq_control_reg[3:2] != pipe_tx09_eq_control)? 1'b1 : 1'b0; 
+  assign pipe_tx10_eq_done = (pipe_tx10_eq_control_reg[3:2] != pipe_tx10_eq_control)? 1'b1 : 1'b0; 
+  assign pipe_tx11_eq_done = (pipe_tx11_eq_control_reg[3:2] != pipe_tx11_eq_control)? 1'b1 : 1'b0; 
+  assign pipe_tx12_eq_done = (pipe_tx12_eq_control_reg[3:2] != pipe_tx12_eq_control)? 1'b1 : 1'b0; 
+  assign pipe_tx13_eq_done = (pipe_tx13_eq_control_reg[3:2] != pipe_tx13_eq_control)? 1'b1 : 1'b0; 
+  assign pipe_tx14_eq_done = (pipe_tx14_eq_control_reg[3:2] != pipe_tx14_eq_control)? 1'b1 : 1'b0; 
+  assign pipe_tx15_eq_done = (pipe_tx15_eq_control_reg[3:2] != pipe_tx15_eq_control)? 1'b1 : 1'b0; 
+ 
+ // Pipe mode tie-offs
+ assign  common_commands_out[0]    = pipe_clk;
+ assign  common_commands_out[3]    = pipe_tx0_rcvr_det; 
+ assign  common_commands_out[16:10] = 7'b0;
+ assign  pipe_tx_0_sigs[69:42]     = 28'b0;
+ assign  pipe_tx_1_sigs[69:42]     = 28'b0;
+ assign  pipe_tx_2_sigs[69:42]     = 28'b0;
+ assign  pipe_tx_3_sigs[69:42]     = 28'b0;
+ assign  pipe_tx_4_sigs[69:42]     = 28'b0;
+ assign  pipe_tx_5_sigs[69:42]     = 28'b0;
+ assign  pipe_tx_6_sigs[69:42]     = 28'b0;
+ assign  pipe_tx_7_sigs[69:42]     = 28'b0; 
+ assign  pipe_tx_8_sigs[69:42]     = 28'b0; 
+ assign  pipe_tx_9_sigs[69:42]     = 28'b0; 
+ assign  pipe_tx_10_sigs[69:42]     = 28'b0; 
+ assign  pipe_tx_11_sigs[69:42]     = 28'b0; 
+ assign  pipe_tx_12_sigs[69:42]     = 28'b0; 
+ assign  pipe_tx_13_sigs[69:42]     = 28'b0; 
+ assign  pipe_tx_14_sigs[69:42]     = 28'b0; 
+ assign  pipe_tx_15_sigs[69:42]     = 28'b0; 
+
+ end
+endgenerate
+
+generate if (EXT_PIPE_SIM == "FALSE") 
+begin
+  xp4_usp_smsw_model_pipe 
+ #(
+    .TCQ(TCQ)
+   ,.IMPL_TARGET(IMPL_TARGET)
+   ,.AXISTEN_IF_EXT_512_INTFC_RAM_STYLE(AXISTEN_IF_EXT_512_INTFC_RAM_STYLE)
+   ,.CRM_CORE_CLK_FREQ_500(CRM_CORE_CLK_FREQ_500)
+   ,.CRM_USER_CLK_FREQ(CRM_USER_CLK_FREQ)
+   ,.AXISTEN_IF_WIDTH(AXISTEN_IF_WIDTH)
+   ,.AXISTEN_IF_EXT_512_CQ_STRADDLE(AXISTEN_IF_EXT_512_CQ_STRADDLE)
+   ,.AXISTEN_IF_EXT_512_CC_STRADDLE(AXISTEN_IF_EXT_512_CC_STRADDLE)
+   ,.AXISTEN_IF_EXT_512_RQ_STRADDLE(AXISTEN_IF_EXT_512_RQ_STRADDLE)
+   ,.AXISTEN_IF_EXT_512_RC_STRADDLE(AXISTEN_IF_EXT_512_RC_STRADDLE)
+   ,.AXISTEN_IF_EXT_512_RC_4TLP_STRADDLE(AXISTEN_IF_EXT_512_RC_4TLP_STRADDLE)
+   ,.AXISTEN_IF_EXT_512(AXISTEN_IF_EXT_512)
+   ,.AXISTEN_IF_CQ_ALIGNMENT_MODE(AXISTEN_IF_CQ_ALIGNMENT_MODE)
+   ,.AXISTEN_IF_CC_ALIGNMENT_MODE(AXISTEN_IF_CC_ALIGNMENT_MODE)
+   ,.AXISTEN_IF_RQ_ALIGNMENT_MODE(AXISTEN_IF_RQ_ALIGNMENT_MODE)
+   ,.AXISTEN_IF_RC_ALIGNMENT_MODE(AXISTEN_IF_RC_ALIGNMENT_MODE)
+   ,.AXISTEN_IF_RC_STRADDLE(AXISTEN_IF_RC_STRADDLE)
+   ,.AXI4_DATA_WIDTH(AXI4_DATA_WIDTH)
+   ,.AXI4_TKEEP_WIDTH(AXI4_TKEEP_WIDTH)
+   ,.AXI4_CQ_TUSER_WIDTH(AXI4_CQ_TUSER_WIDTH)
+   ,.AXI4_CC_TUSER_WIDTH(AXI4_CC_TUSER_WIDTH)
+   ,.AXI4_RQ_TUSER_WIDTH(AXI4_RQ_TUSER_WIDTH)
+   ,.AXI4_RC_TUSER_WIDTH(AXI4_RC_TUSER_WIDTH)
+   ,.AXI4_CQ_TREADY_WIDTH(AXI4_CQ_TREADY_WIDTH)
+   ,.AXI4_CC_TREADY_WIDTH(AXI4_CC_TREADY_WIDTH)
+   ,.AXI4_RQ_TREADY_WIDTH(AXI4_RQ_TREADY_WIDTH)
+   ,.AXI4_RC_TREADY_WIDTH(AXI4_RC_TREADY_WIDTH)
+   ,.AXISTEN_IF_ENABLE_RX_MSG_INTFC(AXISTEN_IF_ENABLE_RX_MSG_INTFC)
+   ,.AXISTEN_IF_ENABLE_MSG_ROUTE(AXISTEN_IF_ENABLE_MSG_ROUTE)
+   ,.AXISTEN_IF_RX_PARITY_EN(AXISTEN_IF_RX_PARITY_EN)
+   ,.AXISTEN_IF_TX_PARITY_EN(AXISTEN_IF_TX_PARITY_EN)
+   ,.AXISTEN_IF_ENABLE_CLIENT_TAG(AXISTEN_IF_ENABLE_CLIENT_TAG)
+   ,.AXISTEN_IF_ENABLE_256_TAGS(AXISTEN_IF_ENABLE_256_TAGS)
+   ,.AXISTEN_IF_COMPL_TIMEOUT_REG0(AXISTEN_IF_COMPL_TIMEOUT_REG0)
+   ,.AXISTEN_IF_COMPL_TIMEOUT_REG1(AXISTEN_IF_COMPL_TIMEOUT_REG1)
+   ,.AXISTEN_IF_LEGACY_MODE_ENABLE(AXISTEN_IF_LEGACY_MODE_ENABLE)
+   ,.AXISTEN_IF_ENABLE_MESSAGE_RID_CHECK(AXISTEN_IF_ENABLE_MESSAGE_RID_CHECK)
+   ,.AXISTEN_IF_MSIX_TO_RAM_PIPELINE(AXISTEN_IF_MSIX_TO_RAM_PIPELINE)
+   ,.AXISTEN_IF_MSIX_FROM_RAM_PIPELINE(AXISTEN_IF_MSIX_FROM_RAM_PIPELINE)
+   ,.AXISTEN_IF_MSIX_RX_PARITY_EN(AXISTEN_IF_MSIX_RX_PARITY_EN)
+   ,.AXISTEN_IF_ENABLE_INTERNAL_MSIX_TABLE(AXISTEN_IF_ENABLE_INTERNAL_MSIX_TABLE)
+   ,.AXISTEN_IF_SIM_SHORT_CPL_TIMEOUT(AXISTEN_IF_SIM_SHORT_CPL_TIMEOUT)
+   ,.AXISTEN_IF_CQ_EN_POISONED_MEM_WR(AXISTEN_IF_CQ_EN_POISONED_MEM_WR)
+   ,.AXISTEN_IF_RQ_CC_REGISTERED_TREADY(AXISTEN_IF_RQ_CC_REGISTERED_TREADY)
+   ,.PM_ASPML0S_TIMEOUT(PM_ASPML0S_TIMEOUT)
+   ,.PM_L1_REENTRY_DELAY(PM_L1_REENTRY_DELAY)
+   ,.PM_ASPML1_ENTRY_DELAY(PM_ASPML1_ENTRY_DELAY)
+   ,.PM_ENABLE_SLOT_POWER_CAPTURE(PM_ENABLE_SLOT_POWER_CAPTURE)
+   ,.PM_PME_SERVICE_TIMEOUT_DELAY(PM_PME_SERVICE_TIMEOUT_DELAY)
+   ,.PM_PME_TURNOFF_ACK_DELAY(PM_PME_TURNOFF_ACK_DELAY)
+   ,.PL_UPSTREAM_FACING(PL_UPSTREAM_FACING)
+   ,.PL_LINK_CAP_MAX_LINK_WIDTH(PL_LINK_CAP_MAX_LINK_WIDTH)
+   ,.PL_LINK_CAP_MAX_LINK_SPEED(PL_LINK_CAP_MAX_LINK_SPEED)
+   ,.PL_DISABLE_DC_BALANCE(PL_DISABLE_DC_BALANCE)
+   ,.PL_DISABLE_EI_INFER_IN_L0(PL_DISABLE_EI_INFER_IN_L0)
+   ,.PL_N_FTS(PL_N_FTS)
+   ,.PL_DISABLE_UPCONFIG_CAPABLE(PL_DISABLE_UPCONFIG_CAPABLE)
+   ,.PL_DISABLE_RETRAIN_ON_FRAMING_ERROR(PL_DISABLE_RETRAIN_ON_FRAMING_ERROR)
+   ,.PL_DISABLE_RETRAIN_ON_EB_ERROR(PL_DISABLE_RETRAIN_ON_EB_ERROR)
+   ,.PL_DISABLE_RETRAIN_ON_SPECIFIC_FRAMING_ERROR(PL_DISABLE_RETRAIN_ON_SPECIFIC_FRAMING_ERROR)
+   ,.PL_REPORT_ALL_PHY_ERRORS(PL_REPORT_ALL_PHY_ERRORS)
+   ,.PL_DISABLE_LFSR_UPDATE_ON_SKP(PL_DISABLE_LFSR_UPDATE_ON_SKP)
+   ,.PL_LANE0_EQ_CONTROL(PL_LANE0_EQ_CONTROL)
+   ,.PL_LANE1_EQ_CONTROL(PL_LANE1_EQ_CONTROL)
+   ,.PL_LANE2_EQ_CONTROL(PL_LANE2_EQ_CONTROL)
+   ,.PL_LANE3_EQ_CONTROL(PL_LANE3_EQ_CONTROL)
+   ,.PL_LANE4_EQ_CONTROL(PL_LANE4_EQ_CONTROL)
+   ,.PL_LANE5_EQ_CONTROL(PL_LANE5_EQ_CONTROL)
+   ,.PL_LANE6_EQ_CONTROL(PL_LANE6_EQ_CONTROL)
+   ,.PL_LANE7_EQ_CONTROL(PL_LANE7_EQ_CONTROL)
+   ,.PL_LANE8_EQ_CONTROL(PL_LANE8_EQ_CONTROL)
+   ,.PL_LANE9_EQ_CONTROL(PL_LANE9_EQ_CONTROL)
+   ,.PL_LANE10_EQ_CONTROL(PL_LANE10_EQ_CONTROL)
+   ,.PL_LANE11_EQ_CONTROL(PL_LANE11_EQ_CONTROL)
+   ,.PL_LANE12_EQ_CONTROL(PL_LANE12_EQ_CONTROL)
+   ,.PL_LANE13_EQ_CONTROL(PL_LANE13_EQ_CONTROL)
+   ,.PL_LANE14_EQ_CONTROL(PL_LANE14_EQ_CONTROL)
+   ,.PL_LANE15_EQ_CONTROL(PL_LANE15_EQ_CONTROL)
+   ,.PL_EQ_BYPASS_PHASE23(PL_EQ_BYPASS_PHASE23)
+   ,.PL_EQ_ADAPT_ITER_COUNT(PL_EQ_ADAPT_ITER_COUNT)
+   ,.PL_EQ_ADAPT_REJECT_RETRY_COUNT(PL_EQ_ADAPT_REJECT_RETRY_COUNT)
+   ,.PL_EQ_SHORT_ADAPT_PHASE(PL_EQ_SHORT_ADAPT_PHASE)
+   ,.PL_EQ_ADAPT_DISABLE_COEFF_CHECK(PL_EQ_ADAPT_DISABLE_COEFF_CHECK)
+   ,.PL_EQ_ADAPT_DISABLE_PRESET_CHECK(PL_EQ_ADAPT_DISABLE_PRESET_CHECK)
+   ,.PL_EQ_DEFAULT_TX_PRESET(PL_EQ_DEFAULT_TX_PRESET)
+   ,.PL_EQ_DEFAULT_RX_PRESET_HINT(PL_EQ_DEFAULT_RX_PRESET_HINT)
+   ,.PL_EQ_RX_ADAPT_EQ_PHASE0(PL_EQ_RX_ADAPT_EQ_PHASE0)
+   ,.PL_EQ_RX_ADAPT_EQ_PHASE1(PL_EQ_RX_ADAPT_EQ_PHASE1)
+   ,.PL_EQ_DISABLE_MISMATCH_CHECK(PL_EQ_DISABLE_MISMATCH_CHECK)
+   ,.PL_RX_L0S_EXIT_TO_RECOVERY(PL_RX_L0S_EXIT_TO_RECOVERY)
+   ,.PL_EQ_TX_8G_EQ_TS2_ENABLE(PL_EQ_TX_8G_EQ_TS2_ENABLE)
+   ,.PL_DISABLE_AUTO_EQ_SPEED_CHANGE_TO_GEN4(PL_DISABLE_AUTO_EQ_SPEED_CHANGE_TO_GEN4)
+   ,.PL_DISABLE_AUTO_EQ_SPEED_CHANGE_TO_GEN3(PL_DISABLE_AUTO_EQ_SPEED_CHANGE_TO_GEN3)
+   ,.PL_DISABLE_AUTO_SPEED_CHANGE_TO_GEN2(PL_DISABLE_AUTO_SPEED_CHANGE_TO_GEN2)
+   ,.PL_DESKEW_ON_SKIP_IN_GEN12(PL_DESKEW_ON_SKIP_IN_GEN12)
+   ,.PL_INFER_EI_DISABLE_REC_RC(PL_INFER_EI_DISABLE_REC_RC)
+   ,.PL_INFER_EI_DISABLE_REC_SPD(PL_INFER_EI_DISABLE_REC_SPD)
+   ,.PL_INFER_EI_DISABLE_LPBK_ACTIVE(PL_INFER_EI_DISABLE_LPBK_ACTIVE)
+   ,.PL_RX_ADAPT_TIMER_RRL_GEN3(PL_RX_ADAPT_TIMER_RRL_GEN3)
+   ,.PL_RX_ADAPT_TIMER_RRL_CLOBBER_TX_TS(PL_RX_ADAPT_TIMER_RRL_CLOBBER_TX_TS)
+   ,.PL_RX_ADAPT_TIMER_RRL_GEN4(PL_RX_ADAPT_TIMER_RRL_GEN4)
+   ,.PL_RX_ADAPT_TIMER_CLWS_GEN3(PL_RX_ADAPT_TIMER_CLWS_GEN3)
+   ,.PL_RX_ADAPT_TIMER_CLWS_CLOBBER_TX_TS(PL_RX_ADAPT_TIMER_CLWS_CLOBBER_TX_TS)
+   ,.PL_RX_ADAPT_TIMER_CLWS_GEN4(PL_RX_ADAPT_TIMER_CLWS_GEN4)
+   ,.PL_DISABLE_LANE_REVERSAL(PL_DISABLE_LANE_REVERSAL)
+   ,.PL_CFG_STATE_ROBUSTNESS_ENABLE(PL_CFG_STATE_ROBUSTNESS_ENABLE)
+   ,.PL_REDO_EQ_SOURCE_SELECT(PL_REDO_EQ_SOURCE_SELECT)
+   ,.PL_DEEMPH_SOURCE_SELECT(PL_DEEMPH_SOURCE_SELECT)
+   ,.PL_EXIT_LOOPBACK_ON_EI_ENTRY(PL_EXIT_LOOPBACK_ON_EI_ENTRY)
+   ,.PL_QUIESCE_GUARANTEE_DISABLE(PL_QUIESCE_GUARANTEE_DISABLE)
+   ,.PL_SRIS_ENABLE(PL_SRIS_ENABLE)
+   ,.PL_SRIS_SKPOS_GEN_SPD_VEC(PL_SRIS_SKPOS_GEN_SPD_VEC)
+   ,.PL_SRIS_SKPOS_REC_SPD_VEC(PL_SRIS_SKPOS_REC_SPD_VEC)
+   ,.PL_SIM_FAST_LINK_TRAINING(PL_SIM_FAST_LINK_TRAINING)
+   ,.PL_USER_SPARE(PL_USER_SPARE)
+   ,.LL_ACK_TIMEOUT_EN(LL_ACK_TIMEOUT_EN)
+   ,.LL_ACK_TIMEOUT(LL_ACK_TIMEOUT)
+   ,.LL_ACK_TIMEOUT_FUNC(LL_ACK_TIMEOUT_FUNC)
+   ,.LL_REPLAY_TIMEOUT_EN(LL_REPLAY_TIMEOUT_EN)
+   ,.LL_REPLAY_TIMEOUT(LL_REPLAY_TIMEOUT)
+   ,.LL_REPLAY_TIMEOUT_FUNC(LL_REPLAY_TIMEOUT_FUNC)
+   ,.LL_REPLAY_TO_RAM_PIPELINE(LL_REPLAY_TO_RAM_PIPELINE)
+   ,.LL_REPLAY_FROM_RAM_PIPELINE(LL_REPLAY_FROM_RAM_PIPELINE)
+   ,.LL_DISABLE_SCHED_TX_NAK(LL_DISABLE_SCHED_TX_NAK)
+   ,.LL_TX_TLP_PARITY_CHK(LL_TX_TLP_PARITY_CHK)
+   ,.LL_RX_TLP_PARITY_GEN(LL_RX_TLP_PARITY_GEN)
+   ,.LL_USER_SPARE(LL_USER_SPARE)
+   ,.IS_SWITCH_PORT(IS_SWITCH_PORT)
+   ,.CFG_BYPASS_MODE_ENABLE(CFG_BYPASS_MODE_ENABLE)
+   ,.TL_PF_ENABLE_REG(TL_PF_ENABLE_REG)
+   ,.TL_CREDITS_CD(TL_CREDITS_CD)
+   ,.TL_CREDITS_CH(TL_CREDITS_CH)
+   ,.TL_COMPLETION_RAM_SIZE(TL_COMPLETION_RAM_SIZE)
+   ,.TL_COMPLETION_RAM_NUM_TLPS(TL_COMPLETION_RAM_NUM_TLPS)
+   ,.TL_CREDITS_NPD(TL_CREDITS_NPD)
+   ,.TL_CREDITS_NPH(TL_CREDITS_NPH)
+   ,.TL_CREDITS_PD(TL_CREDITS_PD)
+   ,.TL_CREDITS_PH(TL_CREDITS_PH)
+   ,.TL_RX_COMPLETION_TO_RAM_WRITE_PIPELINE(TL_RX_COMPLETION_TO_RAM_WRITE_PIPELINE)
+   ,.TL_RX_COMPLETION_TO_RAM_READ_PIPELINE(TL_RX_COMPLETION_TO_RAM_READ_PIPELINE)
+   ,.TL_RX_COMPLETION_FROM_RAM_READ_PIPELINE(TL_RX_COMPLETION_FROM_RAM_READ_PIPELINE)
+   ,.TL_POSTED_RAM_SIZE(TL_POSTED_RAM_SIZE)
+   ,.TL_RX_POSTED_TO_RAM_WRITE_PIPELINE(TL_RX_POSTED_TO_RAM_WRITE_PIPELINE)
+   ,.TL_RX_POSTED_TO_RAM_READ_PIPELINE(TL_RX_POSTED_TO_RAM_READ_PIPELINE)
+   ,.TL_RX_POSTED_FROM_RAM_READ_PIPELINE(TL_RX_POSTED_FROM_RAM_READ_PIPELINE)
+   ,.TL_TX_MUX_STRICT_PRIORITY(TL_TX_MUX_STRICT_PRIORITY)
+   ,.TL_TX_TLP_STRADDLE_ENABLE(TL_TX_TLP_STRADDLE_ENABLE)
+   ,.TL_TX_TLP_TERMINATE_PARITY(TL_TX_TLP_TERMINATE_PARITY)
+   ,.TL_FC_UPDATE_MIN_INTERVAL_TLP_COUNT(TL_FC_UPDATE_MIN_INTERVAL_TLP_COUNT)
+   ,.TL_FC_UPDATE_MIN_INTERVAL_TIME(TL_FC_UPDATE_MIN_INTERVAL_TIME)
+   ,.TL_USER_SPARE(TL_USER_SPARE)
+   ,.PF0_CLASS_CODE(PF0_CLASS_CODE)
+   ,.PF1_CLASS_CODE(PF1_CLASS_CODE)
+   ,.PF2_CLASS_CODE(PF2_CLASS_CODE)
+   ,.PF3_CLASS_CODE(PF3_CLASS_CODE)
+   ,.PF0_INTERRUPT_PIN(PF0_INTERRUPT_PIN)
+   ,.PF1_INTERRUPT_PIN(PF1_INTERRUPT_PIN)
+   ,.PF2_INTERRUPT_PIN(PF2_INTERRUPT_PIN)
+   ,.PF3_INTERRUPT_PIN(PF3_INTERRUPT_PIN)
+   ,.PF0_CAPABILITY_POINTER(PF0_CAPABILITY_POINTER)
+   ,.PF1_CAPABILITY_POINTER(PF1_CAPABILITY_POINTER)
+   ,.PF2_CAPABILITY_POINTER(PF2_CAPABILITY_POINTER)
+   ,.PF3_CAPABILITY_POINTER(PF3_CAPABILITY_POINTER)
+   ,.VF0_CAPABILITY_POINTER(VF0_CAPABILITY_POINTER)
+   ,.LEGACY_CFG_EXTEND_INTERFACE_ENABLE(LEGACY_CFG_EXTEND_INTERFACE_ENABLE)
+   ,.EXTENDED_CFG_EXTEND_INTERFACE_ENABLE(EXTENDED_CFG_EXTEND_INTERFACE_ENABLE)
+   ,.TL2CFG_IF_PARITY_CHK(TL2CFG_IF_PARITY_CHK)
+   ,.HEADER_TYPE_OVERRIDE(HEADER_TYPE_OVERRIDE)
+   ,.PF0_BAR0_CONTROL(PF0_BAR0_CONTROL)
+   ,.PF1_BAR0_CONTROL(PF1_BAR0_CONTROL)
+   ,.PF2_BAR0_CONTROL(PF2_BAR0_CONTROL)
+   ,.PF3_BAR0_CONTROL(PF3_BAR0_CONTROL)
+   ,.PF0_BAR0_APERTURE_SIZE(PF0_BAR0_APERTURE_SIZE)
+   ,.PF1_BAR0_APERTURE_SIZE(PF1_BAR0_APERTURE_SIZE)
+   ,.PF2_BAR0_APERTURE_SIZE(PF2_BAR0_APERTURE_SIZE)
+   ,.PF3_BAR0_APERTURE_SIZE(PF3_BAR0_APERTURE_SIZE)
+   ,.PF0_BAR1_CONTROL(PF0_BAR1_CONTROL)
+   ,.PF1_BAR1_CONTROL(PF1_BAR1_CONTROL)
+   ,.PF2_BAR1_CONTROL(PF2_BAR1_CONTROL)
+   ,.PF3_BAR1_CONTROL(PF3_BAR1_CONTROL)
+   ,.PF0_BAR1_APERTURE_SIZE(PF0_BAR1_APERTURE_SIZE)
+   ,.PF1_BAR1_APERTURE_SIZE(PF1_BAR1_APERTURE_SIZE)
+   ,.PF2_BAR1_APERTURE_SIZE(PF2_BAR1_APERTURE_SIZE)
+   ,.PF3_BAR1_APERTURE_SIZE(PF3_BAR1_APERTURE_SIZE)
+   ,.PF0_BAR2_CONTROL(PF0_BAR2_CONTROL)
+   ,.PF1_BAR2_CONTROL(PF1_BAR2_CONTROL)
+   ,.PF2_BAR2_CONTROL(PF2_BAR2_CONTROL)
+   ,.PF3_BAR2_CONTROL(PF3_BAR2_CONTROL)
+   ,.PF0_BAR2_APERTURE_SIZE(PF0_BAR2_APERTURE_SIZE)
+   ,.PF1_BAR2_APERTURE_SIZE(PF1_BAR2_APERTURE_SIZE)
+   ,.PF2_BAR2_APERTURE_SIZE(PF2_BAR2_APERTURE_SIZE)
+   ,.PF3_BAR2_APERTURE_SIZE(PF3_BAR2_APERTURE_SIZE)
+   ,.PF0_BAR3_CONTROL(PF0_BAR3_CONTROL)
+   ,.PF1_BAR3_CONTROL(PF1_BAR3_CONTROL)
+   ,.PF2_BAR3_CONTROL(PF2_BAR3_CONTROL)
+   ,.PF3_BAR3_CONTROL(PF3_BAR3_CONTROL)
+   ,.PF0_BAR3_APERTURE_SIZE(PF0_BAR3_APERTURE_SIZE)
+   ,.PF1_BAR3_APERTURE_SIZE(PF1_BAR3_APERTURE_SIZE)
+   ,.PF2_BAR3_APERTURE_SIZE(PF2_BAR3_APERTURE_SIZE)
+   ,.PF3_BAR3_APERTURE_SIZE(PF3_BAR3_APERTURE_SIZE)
+   ,.PF0_BAR4_CONTROL(PF0_BAR4_CONTROL)
+   ,.PF1_BAR4_CONTROL(PF1_BAR4_CONTROL)
+   ,.PF2_BAR4_CONTROL(PF2_BAR4_CONTROL)
+   ,.PF3_BAR4_CONTROL(PF3_BAR4_CONTROL)
+   ,.PF0_BAR4_APERTURE_SIZE(PF0_BAR4_APERTURE_SIZE)
+   ,.PF1_BAR4_APERTURE_SIZE(PF1_BAR4_APERTURE_SIZE)
+   ,.PF2_BAR4_APERTURE_SIZE(PF2_BAR4_APERTURE_SIZE)
+   ,.PF3_BAR4_APERTURE_SIZE(PF3_BAR4_APERTURE_SIZE)
+   ,.PF0_BAR5_CONTROL(PF0_BAR5_CONTROL)
+   ,.PF1_BAR5_CONTROL(PF1_BAR5_CONTROL)
+   ,.PF2_BAR5_CONTROL(PF2_BAR5_CONTROL)
+   ,.PF3_BAR5_CONTROL(PF3_BAR5_CONTROL)
+   ,.PF0_BAR5_APERTURE_SIZE(PF0_BAR5_APERTURE_SIZE)
+   ,.PF1_BAR5_APERTURE_SIZE(PF1_BAR5_APERTURE_SIZE)
+   ,.PF2_BAR5_APERTURE_SIZE(PF2_BAR5_APERTURE_SIZE)
+   ,.PF3_BAR5_APERTURE_SIZE(PF3_BAR5_APERTURE_SIZE)
+   ,.PF0_EXPANSION_ROM_ENABLE(PF0_EXPANSION_ROM_ENABLE)
+   ,.PF1_EXPANSION_ROM_ENABLE(PF1_EXPANSION_ROM_ENABLE)
+   ,.PF2_EXPANSION_ROM_ENABLE(PF2_EXPANSION_ROM_ENABLE)
+   ,.PF3_EXPANSION_ROM_ENABLE(PF3_EXPANSION_ROM_ENABLE)
+   ,.PF0_EXPANSION_ROM_APERTURE_SIZE(PF0_EXPANSION_ROM_APERTURE_SIZE)
+   ,.PF1_EXPANSION_ROM_APERTURE_SIZE(PF1_EXPANSION_ROM_APERTURE_SIZE)
+   ,.PF2_EXPANSION_ROM_APERTURE_SIZE(PF2_EXPANSION_ROM_APERTURE_SIZE)
+   ,.PF3_EXPANSION_ROM_APERTURE_SIZE(PF3_EXPANSION_ROM_APERTURE_SIZE)
+   ,.PF0_PCIE_CAP_NEXTPTR(PF0_PCIE_CAP_NEXTPTR)
+   ,.PF1_PCIE_CAP_NEXTPTR(PF1_PCIE_CAP_NEXTPTR)
+   ,.PF2_PCIE_CAP_NEXTPTR(PF2_PCIE_CAP_NEXTPTR)
+   ,.PF3_PCIE_CAP_NEXTPTR(PF3_PCIE_CAP_NEXTPTR)
+   ,.VFG0_PCIE_CAP_NEXTPTR(VFG0_PCIE_CAP_NEXTPTR)
+   ,.VFG1_PCIE_CAP_NEXTPTR(VFG1_PCIE_CAP_NEXTPTR)
+   ,.VFG2_PCIE_CAP_NEXTPTR(VFG2_PCIE_CAP_NEXTPTR)
+   ,.VFG3_PCIE_CAP_NEXTPTR(VFG3_PCIE_CAP_NEXTPTR)
+   ,.PF0_DEV_CAP_MAX_PAYLOAD_SIZE(PF0_DEV_CAP_MAX_PAYLOAD_SIZE)
+   ,.PF1_DEV_CAP_MAX_PAYLOAD_SIZE(PF1_DEV_CAP_MAX_PAYLOAD_SIZE)
+   ,.PF2_DEV_CAP_MAX_PAYLOAD_SIZE(PF2_DEV_CAP_MAX_PAYLOAD_SIZE)
+   ,.PF3_DEV_CAP_MAX_PAYLOAD_SIZE(PF3_DEV_CAP_MAX_PAYLOAD_SIZE)
+   ,.PF0_DEV_CAP_EXT_TAG_SUPPORTED(PF0_DEV_CAP_EXT_TAG_SUPPORTED)
+   ,.PF0_DEV_CAP_ENDPOINT_L0S_LATENCY(PF0_DEV_CAP_ENDPOINT_L0S_LATENCY)
+   ,.PF0_DEV_CAP_ENDPOINT_L1_LATENCY(PF0_DEV_CAP_ENDPOINT_L1_LATENCY)
+   ,.PF0_DEV_CAP_FUNCTION_LEVEL_RESET_CAPABLE(PF0_DEV_CAP_FUNCTION_LEVEL_RESET_CAPABLE)
+   ,.PF0_LINK_CAP_ASPM_SUPPORT(PF0_LINK_CAP_ASPM_SUPPORT)
+   ,.PF0_LINK_CONTROL_RCB(PF0_LINK_CONTROL_RCB)
+   ,.PF0_LINK_STATUS_SLOT_CLOCK_CONFIG(PF0_LINK_STATUS_SLOT_CLOCK_CONFIG)
+   ,.PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN1(PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN1)
+   ,.PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN2(PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN2)
+   ,.PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN3(PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN3)
+   ,.PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN4(PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN4)
+   ,.PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN1(PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN1)
+   ,.PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN2(PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN2)
+   ,.PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN3(PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN3)
+   ,.PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN4(PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN4)
+   ,.PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN1(PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN1)
+   ,.PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN2(PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN2)
+   ,.PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN3(PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN3)
+   ,.PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN4(PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN4)
+   ,.PF0_LINK_CAP_L1_EXIT_LATENCY_GEN1(PF0_LINK_CAP_L1_EXIT_LATENCY_GEN1)
+   ,.PF0_LINK_CAP_L1_EXIT_LATENCY_GEN2(PF0_LINK_CAP_L1_EXIT_LATENCY_GEN2)
+   ,.PF0_LINK_CAP_L1_EXIT_LATENCY_GEN3(PF0_LINK_CAP_L1_EXIT_LATENCY_GEN3)
+   ,.PF0_LINK_CAP_L1_EXIT_LATENCY_GEN4(PF0_LINK_CAP_L1_EXIT_LATENCY_GEN4)
+   ,.PF0_DEV_CAP2_CPL_TIMEOUT_DISABLE(PF0_DEV_CAP2_CPL_TIMEOUT_DISABLE)
+   ,.PF0_DEV_CAP2_32B_ATOMIC_COMPLETER_SUPPORT(PF0_DEV_CAP2_32B_ATOMIC_COMPLETER_SUPPORT)
+   ,.PF0_DEV_CAP2_64B_ATOMIC_COMPLETER_SUPPORT(PF0_DEV_CAP2_64B_ATOMIC_COMPLETER_SUPPORT)
+   ,.PF0_DEV_CAP2_128B_CAS_ATOMIC_COMPLETER_SUPPORT(PF0_DEV_CAP2_128B_CAS_ATOMIC_COMPLETER_SUPPORT)
+   ,.PF0_DEV_CAP2_LTR_SUPPORT(PF0_DEV_CAP2_LTR_SUPPORT)
+   ,.PF0_DEV_CAP2_TPH_COMPLETER_SUPPORT(PF0_DEV_CAP2_TPH_COMPLETER_SUPPORT)
+   ,.PF0_DEV_CAP2_OBFF_SUPPORT(PF0_DEV_CAP2_OBFF_SUPPORT)
+   ,.PF0_DEV_CAP2_ARI_FORWARD_ENABLE(PF0_DEV_CAP2_ARI_FORWARD_ENABLE)
+   ,.PF0_MSI_CAP_NEXTPTR(PF0_MSI_CAP_NEXTPTR)
+   ,.PF1_MSI_CAP_NEXTPTR(PF1_MSI_CAP_NEXTPTR)
+   ,.PF2_MSI_CAP_NEXTPTR(PF2_MSI_CAP_NEXTPTR)
+   ,.PF3_MSI_CAP_NEXTPTR(PF3_MSI_CAP_NEXTPTR)
+   ,.PF0_MSI_CAP_PERVECMASKCAP(PF0_MSI_CAP_PERVECMASKCAP)
+   ,.PF1_MSI_CAP_PERVECMASKCAP(PF1_MSI_CAP_PERVECMASKCAP)
+   ,.PF2_MSI_CAP_PERVECMASKCAP(PF2_MSI_CAP_PERVECMASKCAP)
+   ,.PF3_MSI_CAP_PERVECMASKCAP(PF3_MSI_CAP_PERVECMASKCAP)
+   ,.PF0_MSI_CAP_MULTIMSGCAP(PF0_MSI_CAP_MULTIMSGCAP)
+   ,.PF1_MSI_CAP_MULTIMSGCAP(PF1_MSI_CAP_MULTIMSGCAP)
+   ,.PF2_MSI_CAP_MULTIMSGCAP(PF2_MSI_CAP_MULTIMSGCAP)
+   ,.PF3_MSI_CAP_MULTIMSGCAP(PF3_MSI_CAP_MULTIMSGCAP)
+   ,.PF0_MSIX_CAP_NEXTPTR(PF0_MSIX_CAP_NEXTPTR)
+   ,.PF1_MSIX_CAP_NEXTPTR(PF1_MSIX_CAP_NEXTPTR)
+   ,.PF2_MSIX_CAP_NEXTPTR(PF2_MSIX_CAP_NEXTPTR)
+   ,.PF3_MSIX_CAP_NEXTPTR(PF3_MSIX_CAP_NEXTPTR)
+   ,.VFG0_MSIX_CAP_NEXTPTR(VFG0_MSIX_CAP_NEXTPTR)
+   ,.VFG1_MSIX_CAP_NEXTPTR(VFG1_MSIX_CAP_NEXTPTR)
+   ,.VFG2_MSIX_CAP_NEXTPTR(VFG2_MSIX_CAP_NEXTPTR)
+   ,.VFG3_MSIX_CAP_NEXTPTR(VFG3_MSIX_CAP_NEXTPTR)
+   ,.PF0_MSIX_CAP_PBA_BIR(PF0_MSIX_CAP_PBA_BIR)
+   ,.PF1_MSIX_CAP_PBA_BIR(PF1_MSIX_CAP_PBA_BIR)
+   ,.PF2_MSIX_CAP_PBA_BIR(PF2_MSIX_CAP_PBA_BIR)
+   ,.PF3_MSIX_CAP_PBA_BIR(PF3_MSIX_CAP_PBA_BIR)
+   ,.VFG0_MSIX_CAP_PBA_BIR(VFG0_MSIX_CAP_PBA_BIR)
+   ,.VFG1_MSIX_CAP_PBA_BIR(VFG1_MSIX_CAP_PBA_BIR)
+   ,.VFG2_MSIX_CAP_PBA_BIR(VFG2_MSIX_CAP_PBA_BIR)
+   ,.VFG3_MSIX_CAP_PBA_BIR(VFG3_MSIX_CAP_PBA_BIR)
+   ,.PF0_MSIX_CAP_PBA_OFFSET(PF0_MSIX_CAP_PBA_OFFSET)
+   ,.PF1_MSIX_CAP_PBA_OFFSET(PF1_MSIX_CAP_PBA_OFFSET)
+   ,.PF2_MSIX_CAP_PBA_OFFSET(PF2_MSIX_CAP_PBA_OFFSET)
+   ,.PF3_MSIX_CAP_PBA_OFFSET(PF3_MSIX_CAP_PBA_OFFSET)
+   ,.VFG0_MSIX_CAP_PBA_OFFSET(VFG0_MSIX_CAP_PBA_OFFSET)
+   ,.VFG1_MSIX_CAP_PBA_OFFSET(VFG1_MSIX_CAP_PBA_OFFSET)
+   ,.VFG2_MSIX_CAP_PBA_OFFSET(VFG2_MSIX_CAP_PBA_OFFSET)
+   ,.VFG3_MSIX_CAP_PBA_OFFSET(VFG3_MSIX_CAP_PBA_OFFSET)
+   ,.PF0_MSIX_CAP_TABLE_BIR(PF0_MSIX_CAP_TABLE_BIR)
+   ,.PF1_MSIX_CAP_TABLE_BIR(PF1_MSIX_CAP_TABLE_BIR)
+   ,.PF2_MSIX_CAP_TABLE_BIR(PF2_MSIX_CAP_TABLE_BIR)
+   ,.PF3_MSIX_CAP_TABLE_BIR(PF3_MSIX_CAP_TABLE_BIR)
+   ,.VFG0_MSIX_CAP_TABLE_BIR(VFG0_MSIX_CAP_TABLE_BIR)
+   ,.VFG1_MSIX_CAP_TABLE_BIR(VFG1_MSIX_CAP_TABLE_BIR)
+   ,.VFG2_MSIX_CAP_TABLE_BIR(VFG2_MSIX_CAP_TABLE_BIR)
+   ,.VFG3_MSIX_CAP_TABLE_BIR(VFG3_MSIX_CAP_TABLE_BIR)
+   ,.PF0_MSIX_CAP_TABLE_OFFSET(PF0_MSIX_CAP_TABLE_OFFSET)
+   ,.PF1_MSIX_CAP_TABLE_OFFSET(PF1_MSIX_CAP_TABLE_OFFSET)
+   ,.PF2_MSIX_CAP_TABLE_OFFSET(PF2_MSIX_CAP_TABLE_OFFSET)
+   ,.PF3_MSIX_CAP_TABLE_OFFSET(PF3_MSIX_CAP_TABLE_OFFSET)
+   ,.VFG0_MSIX_CAP_TABLE_OFFSET(VFG0_MSIX_CAP_TABLE_OFFSET)
+   ,.VFG1_MSIX_CAP_TABLE_OFFSET(VFG1_MSIX_CAP_TABLE_OFFSET)
+   ,.VFG2_MSIX_CAP_TABLE_OFFSET(VFG2_MSIX_CAP_TABLE_OFFSET)
+   ,.VFG3_MSIX_CAP_TABLE_OFFSET(VFG3_MSIX_CAP_TABLE_OFFSET)
+   ,.PF0_MSIX_CAP_TABLE_SIZE(PF0_MSIX_CAP_TABLE_SIZE)
+   ,.PF1_MSIX_CAP_TABLE_SIZE(PF1_MSIX_CAP_TABLE_SIZE)
+   ,.PF2_MSIX_CAP_TABLE_SIZE(PF2_MSIX_CAP_TABLE_SIZE)
+   ,.PF3_MSIX_CAP_TABLE_SIZE(PF3_MSIX_CAP_TABLE_SIZE)
+   ,.VFG0_MSIX_CAP_TABLE_SIZE(VFG0_MSIX_CAP_TABLE_SIZE)
+   ,.VFG1_MSIX_CAP_TABLE_SIZE(VFG1_MSIX_CAP_TABLE_SIZE)
+   ,.VFG2_MSIX_CAP_TABLE_SIZE(VFG2_MSIX_CAP_TABLE_SIZE)
+   ,.VFG3_MSIX_CAP_TABLE_SIZE(VFG3_MSIX_CAP_TABLE_SIZE)
+   ,.PF0_MSIX_VECTOR_COUNT(PF0_MSIX_VECTOR_COUNT)
+   ,.PF0_PM_CAP_ID(PF0_PM_CAP_ID)
+   ,.PF0_PM_CAP_NEXTPTR(PF0_PM_CAP_NEXTPTR)
+   ,.PF1_PM_CAP_NEXTPTR(PF1_PM_CAP_NEXTPTR)
+   ,.PF2_PM_CAP_NEXTPTR(PF2_PM_CAP_NEXTPTR)
+   ,.PF3_PM_CAP_NEXTPTR(PF3_PM_CAP_NEXTPTR)
+   ,.PF0_PM_CAP_PMESUPPORT_D3HOT(PF0_PM_CAP_PMESUPPORT_D3HOT)
+   ,.PF0_PM_CAP_PMESUPPORT_D1(PF0_PM_CAP_PMESUPPORT_D1)
+   ,.PF0_PM_CAP_PMESUPPORT_D0(PF0_PM_CAP_PMESUPPORT_D0)
+   ,.PF0_PM_CAP_SUPP_D1_STATE(PF0_PM_CAP_SUPP_D1_STATE)
+   ,.PF0_PM_CAP_VER_ID(PF0_PM_CAP_VER_ID)
+   ,.PF0_PM_CSR_NOSOFTRESET(PF0_PM_CSR_NOSOFTRESET)
+   ,.PM_ENABLE_L23_ENTRY(PM_ENABLE_L23_ENTRY)
+   ,.DNSTREAM_LINK_NUM(DNSTREAM_LINK_NUM)
+   ,.AUTO_FLR_RESPONSE(AUTO_FLR_RESPONSE)
+   ,.PF0_DSN_CAP_NEXTPTR(PF0_DSN_CAP_NEXTPTR)
+   ,.PF1_DSN_CAP_NEXTPTR(PF1_DSN_CAP_NEXTPTR)
+   ,.PF2_DSN_CAP_NEXTPTR(PF2_DSN_CAP_NEXTPTR)
+   ,.PF3_DSN_CAP_NEXTPTR(PF3_DSN_CAP_NEXTPTR)
+   ,.DSN_CAP_ENABLE(DSN_CAP_ENABLE)
+   ,.PF0_VC_CAP_VER(PF0_VC_CAP_VER)
+   ,.PF0_VC_CAP_NEXTPTR(PF0_VC_CAP_NEXTPTR)
+   ,.PF0_VC_CAP_ENABLE(PF0_VC_CAP_ENABLE)
+   ,.PF0_SECONDARY_PCIE_CAP_NEXTPTR(PF0_SECONDARY_PCIE_CAP_NEXTPTR)
+   ,.PF0_AER_CAP_NEXTPTR(PF0_AER_CAP_NEXTPTR)
+   ,.PF1_AER_CAP_NEXTPTR(PF1_AER_CAP_NEXTPTR)
+   ,.PF2_AER_CAP_NEXTPTR(PF2_AER_CAP_NEXTPTR)
+   ,.PF3_AER_CAP_NEXTPTR(PF3_AER_CAP_NEXTPTR)
+   ,.PF0_AER_CAP_ECRC_GEN_AND_CHECK_CAPABLE(PF0_AER_CAP_ECRC_GEN_AND_CHECK_CAPABLE)
+   ,.ARI_CAP_ENABLE(ARI_CAP_ENABLE)
+   ,.PF0_ARI_CAP_NEXTPTR(PF0_ARI_CAP_NEXTPTR)
+   ,.PF1_ARI_CAP_NEXTPTR(PF1_ARI_CAP_NEXTPTR)
+   ,.PF2_ARI_CAP_NEXTPTR(PF2_ARI_CAP_NEXTPTR)
+   ,.PF3_ARI_CAP_NEXTPTR(PF3_ARI_CAP_NEXTPTR)
+   ,.VFG0_ARI_CAP_NEXTPTR(VFG0_ARI_CAP_NEXTPTR)
+   ,.VFG1_ARI_CAP_NEXTPTR(VFG1_ARI_CAP_NEXTPTR)
+   ,.VFG2_ARI_CAP_NEXTPTR(VFG2_ARI_CAP_NEXTPTR)
+   ,.VFG3_ARI_CAP_NEXTPTR(VFG3_ARI_CAP_NEXTPTR)
+   ,.PF0_ARI_CAP_VER(PF0_ARI_CAP_VER)
+   ,.PF0_ARI_CAP_NEXT_FUNC(PF0_ARI_CAP_NEXT_FUNC)
+   ,.PF1_ARI_CAP_NEXT_FUNC(PF1_ARI_CAP_NEXT_FUNC)
+   ,.PF2_ARI_CAP_NEXT_FUNC(PF2_ARI_CAP_NEXT_FUNC)
+   ,.PF3_ARI_CAP_NEXT_FUNC(PF3_ARI_CAP_NEXT_FUNC)
+   ,.PF0_LTR_CAP_NEXTPTR(PF0_LTR_CAP_NEXTPTR)
+   ,.PF0_LTR_CAP_VER(PF0_LTR_CAP_VER)
+   ,.PF0_LTR_CAP_MAX_SNOOP_LAT(PF0_LTR_CAP_MAX_SNOOP_LAT)
+   ,.PF0_LTR_CAP_MAX_NOSNOOP_LAT(PF0_LTR_CAP_MAX_NOSNOOP_LAT)
+   ,.LTR_TX_MESSAGE_ON_LTR_ENABLE(LTR_TX_MESSAGE_ON_LTR_ENABLE)
+   ,.LTR_TX_MESSAGE_ON_FUNC_POWER_STATE_CHANGE(LTR_TX_MESSAGE_ON_FUNC_POWER_STATE_CHANGE)
+   ,.LTR_TX_MESSAGE_MINIMUM_INTERVAL(LTR_TX_MESSAGE_MINIMUM_INTERVAL)
+   ,.SRIOV_CAP_ENABLE(SRIOV_CAP_ENABLE)
+   ,.PF0_SRIOV_CAP_NEXTPTR(PF0_SRIOV_CAP_NEXTPTR)
+   ,.PF1_SRIOV_CAP_NEXTPTR(PF1_SRIOV_CAP_NEXTPTR)
+   ,.PF2_SRIOV_CAP_NEXTPTR(PF2_SRIOV_CAP_NEXTPTR)
+   ,.PF3_SRIOV_CAP_NEXTPTR(PF3_SRIOV_CAP_NEXTPTR)
+   ,.PF0_SRIOV_CAP_VER(PF0_SRIOV_CAP_VER)
+   ,.PF1_SRIOV_CAP_VER(PF1_SRIOV_CAP_VER)
+   ,.PF2_SRIOV_CAP_VER(PF2_SRIOV_CAP_VER)
+   ,.PF3_SRIOV_CAP_VER(PF3_SRIOV_CAP_VER)
+   ,.PF0_SRIOV_ARI_CAPBL_HIER_PRESERVED(PF0_SRIOV_ARI_CAPBL_HIER_PRESERVED)
+   ,.PF1_SRIOV_ARI_CAPBL_HIER_PRESERVED(PF1_SRIOV_ARI_CAPBL_HIER_PRESERVED)
+   ,.PF2_SRIOV_ARI_CAPBL_HIER_PRESERVED(PF2_SRIOV_ARI_CAPBL_HIER_PRESERVED)
+   ,.PF3_SRIOV_ARI_CAPBL_HIER_PRESERVED(PF3_SRIOV_ARI_CAPBL_HIER_PRESERVED)
+   ,.PF0_SRIOV_CAP_INITIAL_VF(PF0_SRIOV_CAP_INITIAL_VF)
+   ,.PF1_SRIOV_CAP_INITIAL_VF(PF1_SRIOV_CAP_INITIAL_VF)
+   ,.PF2_SRIOV_CAP_INITIAL_VF(PF2_SRIOV_CAP_INITIAL_VF)
+   ,.PF3_SRIOV_CAP_INITIAL_VF(PF3_SRIOV_CAP_INITIAL_VF)
+   ,.PF0_SRIOV_CAP_TOTAL_VF(PF0_SRIOV_CAP_TOTAL_VF)
+   ,.PF1_SRIOV_CAP_TOTAL_VF(PF1_SRIOV_CAP_TOTAL_VF)
+   ,.PF2_SRIOV_CAP_TOTAL_VF(PF2_SRIOV_CAP_TOTAL_VF)
+   ,.PF3_SRIOV_CAP_TOTAL_VF(PF3_SRIOV_CAP_TOTAL_VF)
+   ,.PF0_SRIOV_FUNC_DEP_LINK(PF0_SRIOV_FUNC_DEP_LINK)
+   ,.PF1_SRIOV_FUNC_DEP_LINK(PF1_SRIOV_FUNC_DEP_LINK)
+   ,.PF2_SRIOV_FUNC_DEP_LINK(PF2_SRIOV_FUNC_DEP_LINK)
+   ,.PF3_SRIOV_FUNC_DEP_LINK(PF3_SRIOV_FUNC_DEP_LINK)
+   ,.PF0_SRIOV_FIRST_VF_OFFSET(PF0_SRIOV_FIRST_VF_OFFSET)
+   ,.PF1_SRIOV_FIRST_VF_OFFSET(PF1_SRIOV_FIRST_VF_OFFSET)
+   ,.PF2_SRIOV_FIRST_VF_OFFSET(PF2_SRIOV_FIRST_VF_OFFSET)
+   ,.PF3_SRIOV_FIRST_VF_OFFSET(PF3_SRIOV_FIRST_VF_OFFSET)
+   ,.PF0_SRIOV_VF_DEVICE_ID(PF0_SRIOV_VF_DEVICE_ID)
+   ,.PF1_SRIOV_VF_DEVICE_ID(PF1_SRIOV_VF_DEVICE_ID)
+   ,.PF2_SRIOV_VF_DEVICE_ID(PF2_SRIOV_VF_DEVICE_ID)
+   ,.PF3_SRIOV_VF_DEVICE_ID(PF3_SRIOV_VF_DEVICE_ID)
+   ,.PF0_SRIOV_SUPPORTED_PAGE_SIZE(PF0_SRIOV_SUPPORTED_PAGE_SIZE)
+   ,.PF1_SRIOV_SUPPORTED_PAGE_SIZE(PF1_SRIOV_SUPPORTED_PAGE_SIZE)
+   ,.PF2_SRIOV_SUPPORTED_PAGE_SIZE(PF2_SRIOV_SUPPORTED_PAGE_SIZE)
+   ,.PF3_SRIOV_SUPPORTED_PAGE_SIZE(PF3_SRIOV_SUPPORTED_PAGE_SIZE)
+   ,.PF0_SRIOV_BAR0_CONTROL(PF0_SRIOV_BAR0_CONTROL)
+   ,.PF1_SRIOV_BAR0_CONTROL(PF1_SRIOV_BAR0_CONTROL)
+   ,.PF2_SRIOV_BAR0_CONTROL(PF2_SRIOV_BAR0_CONTROL)
+   ,.PF3_SRIOV_BAR0_CONTROL(PF3_SRIOV_BAR0_CONTROL)
+   ,.PF0_SRIOV_BAR0_APERTURE_SIZE(PF0_SRIOV_BAR0_APERTURE_SIZE)
+   ,.PF1_SRIOV_BAR0_APERTURE_SIZE(PF1_SRIOV_BAR0_APERTURE_SIZE)
+   ,.PF2_SRIOV_BAR0_APERTURE_SIZE(PF2_SRIOV_BAR0_APERTURE_SIZE)
+   ,.PF3_SRIOV_BAR0_APERTURE_SIZE(PF3_SRIOV_BAR0_APERTURE_SIZE)
+   ,.PF0_SRIOV_BAR1_CONTROL(PF0_SRIOV_BAR1_CONTROL)
+   ,.PF1_SRIOV_BAR1_CONTROL(PF1_SRIOV_BAR1_CONTROL)
+   ,.PF2_SRIOV_BAR1_CONTROL(PF2_SRIOV_BAR1_CONTROL)
+   ,.PF3_SRIOV_BAR1_CONTROL(PF3_SRIOV_BAR1_CONTROL)
+   ,.PF0_SRIOV_BAR1_APERTURE_SIZE(PF0_SRIOV_BAR1_APERTURE_SIZE)
+   ,.PF1_SRIOV_BAR1_APERTURE_SIZE(PF1_SRIOV_BAR1_APERTURE_SIZE)
+   ,.PF2_SRIOV_BAR1_APERTURE_SIZE(PF2_SRIOV_BAR1_APERTURE_SIZE)
+   ,.PF3_SRIOV_BAR1_APERTURE_SIZE(PF3_SRIOV_BAR1_APERTURE_SIZE)
+   ,.PF0_SRIOV_BAR2_CONTROL(PF0_SRIOV_BAR2_CONTROL)
+   ,.PF1_SRIOV_BAR2_CONTROL(PF1_SRIOV_BAR2_CONTROL)
+   ,.PF2_SRIOV_BAR2_CONTROL(PF2_SRIOV_BAR2_CONTROL)
+   ,.PF3_SRIOV_BAR2_CONTROL(PF3_SRIOV_BAR2_CONTROL)
+   ,.PF0_SRIOV_BAR2_APERTURE_SIZE(PF0_SRIOV_BAR2_APERTURE_SIZE)
+   ,.PF1_SRIOV_BAR2_APERTURE_SIZE(PF1_SRIOV_BAR2_APERTURE_SIZE)
+   ,.PF2_SRIOV_BAR2_APERTURE_SIZE(PF2_SRIOV_BAR2_APERTURE_SIZE)
+   ,.PF3_SRIOV_BAR2_APERTURE_SIZE(PF3_SRIOV_BAR2_APERTURE_SIZE)
+   ,.PF0_SRIOV_BAR3_CONTROL(PF0_SRIOV_BAR3_CONTROL)
+   ,.PF1_SRIOV_BAR3_CONTROL(PF1_SRIOV_BAR3_CONTROL)
+   ,.PF2_SRIOV_BAR3_CONTROL(PF2_SRIOV_BAR3_CONTROL)
+   ,.PF3_SRIOV_BAR3_CONTROL(PF3_SRIOV_BAR3_CONTROL)
+   ,.PF0_SRIOV_BAR3_APERTURE_SIZE(PF0_SRIOV_BAR3_APERTURE_SIZE)
+   ,.PF1_SRIOV_BAR3_APERTURE_SIZE(PF1_SRIOV_BAR3_APERTURE_SIZE)
+   ,.PF2_SRIOV_BAR3_APERTURE_SIZE(PF2_SRIOV_BAR3_APERTURE_SIZE)
+   ,.PF3_SRIOV_BAR3_APERTURE_SIZE(PF3_SRIOV_BAR3_APERTURE_SIZE)
+   ,.PF0_SRIOV_BAR4_CONTROL(PF0_SRIOV_BAR4_CONTROL)
+   ,.PF1_SRIOV_BAR4_CONTROL(PF1_SRIOV_BAR4_CONTROL)
+   ,.PF2_SRIOV_BAR4_CONTROL(PF2_SRIOV_BAR4_CONTROL)
+   ,.PF3_SRIOV_BAR4_CONTROL(PF3_SRIOV_BAR4_CONTROL)
+   ,.PF0_SRIOV_BAR4_APERTURE_SIZE(PF0_SRIOV_BAR4_APERTURE_SIZE)
+   ,.PF1_SRIOV_BAR4_APERTURE_SIZE(PF1_SRIOV_BAR4_APERTURE_SIZE)
+   ,.PF2_SRIOV_BAR4_APERTURE_SIZE(PF2_SRIOV_BAR4_APERTURE_SIZE)
+   ,.PF3_SRIOV_BAR4_APERTURE_SIZE(PF3_SRIOV_BAR4_APERTURE_SIZE)
+   ,.PF0_SRIOV_BAR5_CONTROL(PF0_SRIOV_BAR5_CONTROL)
+   ,.PF1_SRIOV_BAR5_CONTROL(PF1_SRIOV_BAR5_CONTROL)
+   ,.PF2_SRIOV_BAR5_CONTROL(PF2_SRIOV_BAR5_CONTROL)
+   ,.PF3_SRIOV_BAR5_CONTROL(PF3_SRIOV_BAR5_CONTROL)
+   ,.PF0_SRIOV_BAR5_APERTURE_SIZE(PF0_SRIOV_BAR5_APERTURE_SIZE)
+   ,.PF1_SRIOV_BAR5_APERTURE_SIZE(PF1_SRIOV_BAR5_APERTURE_SIZE)
+   ,.PF2_SRIOV_BAR5_APERTURE_SIZE(PF2_SRIOV_BAR5_APERTURE_SIZE)
+   ,.PF3_SRIOV_BAR5_APERTURE_SIZE(PF3_SRIOV_BAR5_APERTURE_SIZE)
+   ,.PF0_TPHR_CAP_NEXTPTR(PF0_TPHR_CAP_NEXTPTR)
+   ,.PF1_TPHR_CAP_NEXTPTR(PF1_TPHR_CAP_NEXTPTR)
+   ,.PF2_TPHR_CAP_NEXTPTR(PF2_TPHR_CAP_NEXTPTR)
+   ,.PF3_TPHR_CAP_NEXTPTR(PF3_TPHR_CAP_NEXTPTR)
+   ,.VFG0_TPHR_CAP_NEXTPTR(VFG0_TPHR_CAP_NEXTPTR)
+   ,.VFG1_TPHR_CAP_NEXTPTR(VFG1_TPHR_CAP_NEXTPTR)
+   ,.VFG2_TPHR_CAP_NEXTPTR(VFG2_TPHR_CAP_NEXTPTR)
+   ,.VFG3_TPHR_CAP_NEXTPTR(VFG3_TPHR_CAP_NEXTPTR)
+   ,.PF0_TPHR_CAP_VER(PF0_TPHR_CAP_VER)
+   ,.PF0_TPHR_CAP_INT_VEC_MODE(PF0_TPHR_CAP_INT_VEC_MODE)
+   ,.PF0_TPHR_CAP_DEV_SPECIFIC_MODE(PF0_TPHR_CAP_DEV_SPECIFIC_MODE)
+   ,.PF0_TPHR_CAP_ST_TABLE_LOC(PF0_TPHR_CAP_ST_TABLE_LOC)
+   ,.PF0_TPHR_CAP_ST_TABLE_SIZE(PF0_TPHR_CAP_ST_TABLE_SIZE)
+   ,.PF0_TPHR_CAP_ST_MODE_SEL(PF0_TPHR_CAP_ST_MODE_SEL)
+   ,.PF1_TPHR_CAP_ST_MODE_SEL(PF1_TPHR_CAP_ST_MODE_SEL)
+   ,.PF2_TPHR_CAP_ST_MODE_SEL(PF2_TPHR_CAP_ST_MODE_SEL)
+   ,.PF3_TPHR_CAP_ST_MODE_SEL(PF3_TPHR_CAP_ST_MODE_SEL)
+   ,.VFG0_TPHR_CAP_ST_MODE_SEL(VFG0_TPHR_CAP_ST_MODE_SEL)
+   ,.VFG1_TPHR_CAP_ST_MODE_SEL(VFG1_TPHR_CAP_ST_MODE_SEL)
+   ,.VFG2_TPHR_CAP_ST_MODE_SEL(VFG2_TPHR_CAP_ST_MODE_SEL)
+   ,.VFG3_TPHR_CAP_ST_MODE_SEL(VFG3_TPHR_CAP_ST_MODE_SEL)
+   ,.PF0_TPHR_CAP_ENABLE(PF0_TPHR_CAP_ENABLE)
+   ,.TPH_TO_RAM_PIPELINE(TPH_TO_RAM_PIPELINE)
+   ,.TPH_FROM_RAM_PIPELINE(TPH_FROM_RAM_PIPELINE)
+   ,.MCAP_ENABLE(MCAP_ENABLE)
+   ,.MCAP_CONFIGURE_OVERRIDE(MCAP_CONFIGURE_OVERRIDE)
+   ,.MCAP_CAP_NEXTPTR(MCAP_CAP_NEXTPTR)
+   ,.MCAP_VSEC_ID(MCAP_VSEC_ID)
+   ,.MCAP_VSEC_REV(MCAP_VSEC_REV)
+   ,.MCAP_VSEC_LEN(MCAP_VSEC_LEN)
+   ,.MCAP_FPGA_BITSTREAM_VERSION(MCAP_FPGA_BITSTREAM_VERSION)
+   ,.MCAP_INTERRUPT_ON_MCAP_EOS(MCAP_INTERRUPT_ON_MCAP_EOS)
+   ,.MCAP_INTERRUPT_ON_MCAP_ERROR(MCAP_INTERRUPT_ON_MCAP_ERROR)
+   ,.MCAP_INPUT_GATE_DESIGN_SWITCH(MCAP_INPUT_GATE_DESIGN_SWITCH)
+   ,.MCAP_EOS_DESIGN_SWITCH(MCAP_EOS_DESIGN_SWITCH)
+   ,.MCAP_GATE_MEM_ENABLE_DESIGN_SWITCH(MCAP_GATE_MEM_ENABLE_DESIGN_SWITCH)
+   ,.MCAP_GATE_IO_ENABLE_DESIGN_SWITCH(MCAP_GATE_IO_ENABLE_DESIGN_SWITCH)
+   ,.SIM_JTAG_IDCODE(SIM_JTAG_IDCODE)
+   ,.DEBUG_AXIST_DISABLE_FEATURE_BIT(DEBUG_AXIST_DISABLE_FEATURE_BIT)
+   ,.DEBUG_TL_DISABLE_RX_TLP_ORDER_CHECKS(DEBUG_TL_DISABLE_RX_TLP_ORDER_CHECKS)
+   ,.DEBUG_TL_DISABLE_FC_TIMEOUT(DEBUG_TL_DISABLE_FC_TIMEOUT)
+   ,.DEBUG_PL_DISABLE_SCRAMBLING(DEBUG_PL_DISABLE_SCRAMBLING)
+   ,.DEBUG_PL_DISABLE_REC_ENTRY_ON_DYNAMIC_DSKEW_FAIL (DEBUG_PL_DISABLE_REC_ENTRY_ON_DYNAMIC_DSKEW_FAIL )
+   ,.DEBUG_PL_DISABLE_REC_ENTRY_ON_RX_BUFFER_UNDER_OVER_FLOW (DEBUG_PL_DISABLE_REC_ENTRY_ON_RX_BUFFER_UNDER_OVER_FLOW )
+   ,.DEBUG_PL_DISABLE_LES_UPDATE_ON_SKP_ERROR(DEBUG_PL_DISABLE_LES_UPDATE_ON_SKP_ERROR)
+   ,.DEBUG_PL_DISABLE_LES_UPDATE_ON_SKP_PARITY_ERROR(DEBUG_PL_DISABLE_LES_UPDATE_ON_SKP_PARITY_ERROR)
+   ,.DEBUG_PL_DISABLE_LES_UPDATE_ON_DEFRAMER_ERROR(DEBUG_PL_DISABLE_LES_UPDATE_ON_DEFRAMER_ERROR)
+   ,.DEBUG_PL_SIM_RESET_LFSR(DEBUG_PL_SIM_RESET_LFSR)
+   ,.DEBUG_PL_SPARE(DEBUG_PL_SPARE)
+   ,.DEBUG_LL_SPARE(DEBUG_LL_SPARE)
+   ,.DEBUG_TL_SPARE(DEBUG_TL_SPARE)
+   ,.DEBUG_AXI4ST_SPARE(DEBUG_AXI4ST_SPARE)
+   ,.DEBUG_CFG_SPARE(DEBUG_CFG_SPARE)
+   ,.DEBUG_CAR_SPARE(DEBUG_CAR_SPARE)
+   ,.TEST_MODE_PIN_CHAR(TEST_MODE_PIN_CHAR)
+   ,.SPARE_BIT0(SPARE_BIT0)
+   ,.SPARE_BIT1(SPARE_BIT1)
+   ,.SPARE_BIT2(SPARE_BIT2)
+   ,.SPARE_BIT3(SPARE_BIT3)
+   ,.SPARE_BIT4(SPARE_BIT4)
+   ,.SPARE_BIT5(SPARE_BIT5)
+   ,.SPARE_BIT6(SPARE_BIT6)
+   ,.SPARE_BIT7(SPARE_BIT7)
+   ,.SPARE_BIT8(SPARE_BIT8)
+   ,.SPARE_BYTE0(SPARE_BYTE0)
+   ,.SPARE_BYTE1(SPARE_BYTE1)
+   ,.SPARE_BYTE2(SPARE_BYTE2)
+   ,.SPARE_BYTE3(SPARE_BYTE3)
+   ,.SPARE_WORD0(SPARE_WORD0)
+   ,.SPARE_WORD1(SPARE_WORD1)
+   ,.SPARE_WORD2(SPARE_WORD2)
+   ,.SPARE_WORD3(SPARE_WORD3)
+   ,.AXISTEN_IF_CCIX_RX_CREDIT_LIMIT(AXISTEN_IF_CCIX_RX_CREDIT_LIMIT)
+   ,.AXISTEN_IF_CCIX_TX_CREDIT_LIMIT(AXISTEN_IF_CCIX_TX_CREDIT_LIMIT)
+   ,.AXISTEN_IF_CCIX_TX_REGISTERED_TREADY(AXISTEN_IF_CCIX_TX_REGISTERED_TREADY)
+   ,.CCIX_DIRECT_ATTACH_MODE(CCIX_DIRECT_ATTACH_MODE)
+   ,.CCIX_ENABLE(CCIX_ENABLE)
+   ,.CCIX_VENDOR_ID(CCIX_VENDOR_ID)
+   ,.PF0_ATS_CAP_INV_QUEUE_DEPTH(PF0_ATS_CAP_INV_QUEUE_DEPTH)
+   ,.PF0_ATS_CAP_NEXTPTR(PF0_ATS_CAP_NEXTPTR)
+   ,.PF0_ATS_CAP_ON(PF0_ATS_CAP_ON)
+   ,.PF0_PRI_CAP_NEXTPTR(PF0_PRI_CAP_NEXTPTR)
+   ,.PF0_PRI_CAP_ON(PF0_PRI_CAP_ON)
+   ,.PF0_PRI_OST_PR_CAPACITY(PF0_PRI_OST_PR_CAPACITY)
+   ,.PF0_VC_ARB_CAPABILITY(PF0_VC_ARB_CAPABILITY)
+   ,.PF0_VC_ARB_TBL_OFFSET(PF0_VC_ARB_TBL_OFFSET)
+   ,.PF0_VC_EXTENDED_COUNT(PF0_VC_EXTENDED_COUNT)
+   ,.PF0_VC_LOW_PRIORITY_EXTENDED_COUNT(PF0_VC_LOW_PRIORITY_EXTENDED_COUNT)
+   ,.PF1_ATS_CAP_INV_QUEUE_DEPTH(PF1_ATS_CAP_INV_QUEUE_DEPTH)
+   ,.PF1_ATS_CAP_NEXTPTR(PF1_ATS_CAP_NEXTPTR)
+   ,.PF1_ATS_CAP_ON(PF1_ATS_CAP_ON)
+   ,.PF1_PRI_CAP_NEXTPTR(PF1_PRI_CAP_NEXTPTR)
+   ,.PF1_PRI_CAP_ON(PF1_PRI_CAP_ON)
+   ,.PF1_PRI_OST_PR_CAPACITY(PF1_PRI_OST_PR_CAPACITY)
+   ,.PF2_ATS_CAP_INV_QUEUE_DEPTH(PF2_ATS_CAP_INV_QUEUE_DEPTH)
+   ,.PF2_ATS_CAP_NEXTPTR(PF2_ATS_CAP_NEXTPTR)
+   ,.PF2_ATS_CAP_ON(PF2_ATS_CAP_ON)
+   ,.PF2_PRI_CAP_NEXTPTR(PF2_PRI_CAP_NEXTPTR)
+   ,.PF2_PRI_CAP_ON(PF2_PRI_CAP_ON)
+   ,.PF2_PRI_OST_PR_CAPACITY(PF2_PRI_OST_PR_CAPACITY)
+   ,.PF3_ATS_CAP_INV_QUEUE_DEPTH(PF3_ATS_CAP_INV_QUEUE_DEPTH)
+   ,.PF3_ATS_CAP_NEXTPTR(PF3_ATS_CAP_NEXTPTR)
+   ,.PF3_ATS_CAP_ON(PF3_ATS_CAP_ON)
+   ,.PF3_PRI_CAP_NEXTPTR(PF3_PRI_CAP_NEXTPTR)
+   ,.PF3_PRI_CAP_ON(PF3_PRI_CAP_ON)
+   ,.PF3_PRI_OST_PR_CAPACITY(PF3_PRI_OST_PR_CAPACITY)
+   ,.PL_CTRL_SKP_GEN_ENABLE(PL_CTRL_SKP_GEN_ENABLE)
+   ,.PL_CTRL_SKP_PARITY_AND_CRC_CHECK_DISABLE(PL_CTRL_SKP_PARITY_AND_CRC_CHECK_DISABLE)
+   ,.PL_USER_SPARE2(PL_USER_SPARE2)
+   ,.TL_CREDITS_CD_VC1(TL_CREDITS_CD_VC1)
+   ,.TL_CREDITS_CH_VC1(TL_CREDITS_CH_VC1)
+   ,.TL_CREDITS_NPD_VC1(TL_CREDITS_NPD_VC1)
+   ,.TL_CREDITS_NPH_VC1(TL_CREDITS_NPH_VC1)
+   ,.TL_CREDITS_PD_VC1(TL_CREDITS_PD_VC1)
+   ,.TL_CREDITS_PH_VC1(TL_CREDITS_PH_VC1)
+   ,.TL_FC_UPDATE_MIN_INTERVAL_TIME_VC1(TL_FC_UPDATE_MIN_INTERVAL_TIME_VC1)
+   ,.TL_FC_UPDATE_MIN_INTERVAL_TLP_COUNT_VC1(TL_FC_UPDATE_MIN_INTERVAL_TLP_COUNT_VC1)
+   ,.TL_FEATURE_ENABLE_FC_SCALING(TL_FEATURE_ENABLE_FC_SCALING)
+   ,.VFG0_ATS_CAP_INV_QUEUE_DEPTH(VFG0_ATS_CAP_INV_QUEUE_DEPTH)
+   ,.VFG0_ATS_CAP_NEXTPTR(VFG0_ATS_CAP_NEXTPTR)
+   ,.VFG0_ATS_CAP_ON(VFG0_ATS_CAP_ON)
+   ,.VFG1_ATS_CAP_INV_QUEUE_DEPTH(VFG1_ATS_CAP_INV_QUEUE_DEPTH)
+   ,.VFG1_ATS_CAP_NEXTPTR(VFG1_ATS_CAP_NEXTPTR)
+   ,.VFG1_ATS_CAP_ON(VFG1_ATS_CAP_ON)
+   ,.VFG2_ATS_CAP_INV_QUEUE_DEPTH(VFG2_ATS_CAP_INV_QUEUE_DEPTH)
+   ,.VFG2_ATS_CAP_NEXTPTR(VFG2_ATS_CAP_NEXTPTR)
+   ,.VFG2_ATS_CAP_ON(VFG2_ATS_CAP_ON)
+   ,.VFG3_ATS_CAP_INV_QUEUE_DEPTH(VFG3_ATS_CAP_INV_QUEUE_DEPTH)
+   ,.VFG3_ATS_CAP_NEXTPTR(VFG3_ATS_CAP_NEXTPTR)
+   ,.VFG3_ATS_CAP_ON(VFG3_ATS_CAP_ON)
+  ) pcie_4_0_pipe_smsw_inst ( 
+
+    .pipe_rx00_char_is_k(pipe_rx00_char_is_k[1:0])
+   ,.pipe_rx01_char_is_k(pipe_rx01_char_is_k[1:0])
+   ,.pipe_rx02_char_is_k(pipe_rx02_char_is_k[1:0])
+   ,.pipe_rx03_char_is_k(pipe_rx03_char_is_k[1:0])
+   ,.pipe_rx04_char_is_k(pipe_rx04_char_is_k[1:0])
+   ,.pipe_rx05_char_is_k(pipe_rx05_char_is_k[1:0])
+   ,.pipe_rx06_char_is_k(pipe_rx06_char_is_k[1:0])
+   ,.pipe_rx07_char_is_k(pipe_rx07_char_is_k[1:0])
+   ,.pipe_rx08_char_is_k(pipe_rx08_char_is_k[1:0])
+   ,.pipe_rx09_char_is_k(pipe_rx09_char_is_k[1:0])
+   ,.pipe_rx10_char_is_k(pipe_rx10_char_is_k[1:0])
+   ,.pipe_rx11_char_is_k(pipe_rx11_char_is_k[1:0])
+   ,.pipe_rx12_char_is_k(pipe_rx12_char_is_k[1:0])
+   ,.pipe_rx13_char_is_k(pipe_rx13_char_is_k[1:0])
+   ,.pipe_rx14_char_is_k(pipe_rx14_char_is_k[1:0])
+   ,.pipe_rx15_char_is_k(pipe_rx15_char_is_k[1:0])
+   ,.pipe_rx00_valid(pipe_rx00_valid)
+   ,.pipe_rx01_valid(pipe_rx01_valid)
+   ,.pipe_rx02_valid(pipe_rx02_valid)
+   ,.pipe_rx03_valid(pipe_rx03_valid)
+   ,.pipe_rx04_valid(pipe_rx04_valid)
+   ,.pipe_rx05_valid(pipe_rx05_valid)
+   ,.pipe_rx06_valid(pipe_rx06_valid)
+   ,.pipe_rx07_valid(pipe_rx07_valid)
+   ,.pipe_rx08_valid(pipe_rx08_valid)
+   ,.pipe_rx09_valid(pipe_rx09_valid)
+   ,.pipe_rx10_valid(pipe_rx10_valid)
+   ,.pipe_rx11_valid(pipe_rx11_valid)
+   ,.pipe_rx12_valid(pipe_rx12_valid)
+   ,.pipe_rx13_valid(pipe_rx13_valid)
+   ,.pipe_rx14_valid(pipe_rx14_valid)
+   ,.pipe_rx15_valid(pipe_rx15_valid)
+   ,.pipe_rx00_data(pipe_rx00_data[31:0])
+   ,.pipe_rx01_data(pipe_rx01_data[31:0])
+   ,.pipe_rx02_data(pipe_rx02_data[31:0])
+   ,.pipe_rx03_data(pipe_rx03_data[31:0])
+   ,.pipe_rx04_data(pipe_rx04_data[31:0])
+   ,.pipe_rx05_data(pipe_rx05_data[31:0])
+   ,.pipe_rx06_data(pipe_rx06_data[31:0])
+   ,.pipe_rx07_data(pipe_rx07_data[31:0])
+   ,.pipe_rx08_data( pipe_tx_rate==2'b11 ? pipe_rx00_data[63:32] : pipe_rx08_data[31:0] )
+   ,.pipe_rx09_data( pipe_tx_rate==2'b11 ? pipe_rx01_data[63:32] : pipe_rx09_data[31:0] )
+   ,.pipe_rx10_data( pipe_tx_rate==2'b11 ? pipe_rx02_data[63:32] : pipe_rx10_data[31:0] )
+   ,.pipe_rx11_data( pipe_tx_rate==2'b11 ? pipe_rx03_data[63:32] : pipe_rx11_data[31:0] )
+   ,.pipe_rx12_data( pipe_tx_rate==2'b11 ? pipe_rx04_data[63:32] : pipe_rx12_data[31:0] )
+   ,.pipe_rx13_data( pipe_tx_rate==2'b11 ? pipe_rx05_data[63:32] : pipe_rx13_data[31:0] )
+   ,.pipe_rx14_data( pipe_tx_rate==2'b11 ? pipe_rx06_data[63:32] : pipe_rx14_data[31:0] )
+   ,.pipe_rx15_data( pipe_tx_rate==2'b11 ? pipe_rx07_data[63:32] : pipe_rx15_data[31:0] )
+   ,.pipe_rx00_polarity(pipe_rx00_polarity)
+   ,.pipe_rx01_polarity(pipe_rx01_polarity)
+   ,.pipe_rx02_polarity(pipe_rx02_polarity)
+   ,.pipe_rx03_polarity(pipe_rx03_polarity)
+   ,.pipe_rx04_polarity(pipe_rx04_polarity)
+   ,.pipe_rx05_polarity(pipe_rx05_polarity)
+   ,.pipe_rx06_polarity(pipe_rx06_polarity)
+   ,.pipe_rx07_polarity(pipe_rx07_polarity)
+   ,.pipe_rx08_polarity(pipe_rx08_polarity)
+   ,.pipe_rx09_polarity(pipe_rx09_polarity)
+   ,.pipe_rx10_polarity(pipe_rx10_polarity)
+   ,.pipe_rx11_polarity(pipe_rx11_polarity)
+   ,.pipe_rx12_polarity(pipe_rx12_polarity)
+   ,.pipe_rx13_polarity(pipe_rx13_polarity)
+   ,.pipe_rx14_polarity(pipe_rx14_polarity)
+   ,.pipe_rx15_polarity(pipe_rx15_polarity)
+   ,.pipe_rx00_status(pipe_rx00_status[2:0])
+   ,.pipe_rx01_status(pipe_rx01_status[2:0])
+   ,.pipe_rx02_status(pipe_rx02_status[2:0])
+   ,.pipe_rx03_status(pipe_rx03_status[2:0])
+   ,.pipe_rx04_status(pipe_rx04_status[2:0])
+   ,.pipe_rx05_status(pipe_rx05_status[2:0])
+   ,.pipe_rx06_status(pipe_rx06_status[2:0])
+   ,.pipe_rx07_status(pipe_rx07_status[2:0])
+   ,.pipe_rx08_status(pipe_rx08_status[2:0])
+   ,.pipe_rx09_status(pipe_rx09_status[2:0])
+   ,.pipe_rx10_status(pipe_rx10_status[2:0])
+   ,.pipe_rx11_status(pipe_rx11_status[2:0])
+   ,.pipe_rx12_status(pipe_rx12_status[2:0])
+   ,.pipe_rx13_status(pipe_rx13_status[2:0])
+   ,.pipe_rx14_status(pipe_rx14_status[2:0])
+   ,.pipe_rx15_status(pipe_rx15_status[2:0])
+   ,.pipe_rx00_phy_status(pipe_rx00_phy_status)
+   ,.pipe_rx01_phy_status(pipe_rx01_phy_status)
+   ,.pipe_rx02_phy_status(pipe_rx02_phy_status)
+   ,.pipe_rx03_phy_status(pipe_rx03_phy_status)
+   ,.pipe_rx04_phy_status(pipe_rx04_phy_status)
+   ,.pipe_rx05_phy_status(pipe_rx05_phy_status)
+   ,.pipe_rx06_phy_status(pipe_rx06_phy_status)
+   ,.pipe_rx07_phy_status(pipe_rx07_phy_status)
+   ,.pipe_rx08_phy_status(pipe_rx08_phy_status)
+   ,.pipe_rx09_phy_status(pipe_rx09_phy_status)
+   ,.pipe_rx10_phy_status(pipe_rx10_phy_status)
+   ,.pipe_rx11_phy_status(pipe_rx11_phy_status)
+   ,.pipe_rx12_phy_status(pipe_rx12_phy_status)
+   ,.pipe_rx13_phy_status(pipe_rx13_phy_status)
+   ,.pipe_rx14_phy_status(pipe_rx14_phy_status)
+   ,.pipe_rx15_phy_status(pipe_rx15_phy_status)
+   ,.pipe_rx00_elec_idle(pipe_rx00_elec_idle)
+   ,.pipe_rx01_elec_idle(pipe_rx01_elec_idle)
+   ,.pipe_rx02_elec_idle(pipe_rx02_elec_idle)
+   ,.pipe_rx03_elec_idle(pipe_rx03_elec_idle)
+   ,.pipe_rx04_elec_idle(pipe_rx04_elec_idle)
+   ,.pipe_rx05_elec_idle(pipe_rx05_elec_idle)
+   ,.pipe_rx06_elec_idle(pipe_rx06_elec_idle)
+   ,.pipe_rx07_elec_idle(pipe_rx07_elec_idle)
+   ,.pipe_rx08_elec_idle(pipe_rx08_elec_idle)
+   ,.pipe_rx09_elec_idle(pipe_rx09_elec_idle)
+   ,.pipe_rx10_elec_idle(pipe_rx10_elec_idle)
+   ,.pipe_rx11_elec_idle(pipe_rx11_elec_idle)
+   ,.pipe_rx12_elec_idle(pipe_rx12_elec_idle)
+   ,.pipe_rx13_elec_idle(pipe_rx13_elec_idle)
+   ,.pipe_rx14_elec_idle(pipe_rx14_elec_idle)
+   ,.pipe_rx15_elec_idle(pipe_rx15_elec_idle)
+   ,.pipe_rx00_data_valid(pipe_rx00_data_valid)
+   ,.pipe_rx01_data_valid(pipe_rx01_data_valid)
+   ,.pipe_rx02_data_valid(pipe_rx02_data_valid)
+   ,.pipe_rx03_data_valid(pipe_rx03_data_valid)
+   ,.pipe_rx04_data_valid(pipe_rx04_data_valid)
+   ,.pipe_rx05_data_valid(pipe_rx05_data_valid)
+   ,.pipe_rx06_data_valid(pipe_rx06_data_valid)
+   ,.pipe_rx07_data_valid(pipe_rx07_data_valid)
+   ,.pipe_rx08_data_valid(pipe_rx08_data_valid)
+   ,.pipe_rx09_data_valid(pipe_rx09_data_valid)
+   ,.pipe_rx10_data_valid(pipe_rx10_data_valid)
+   ,.pipe_rx11_data_valid(pipe_rx11_data_valid)
+   ,.pipe_rx12_data_valid(pipe_rx12_data_valid)
+   ,.pipe_rx13_data_valid(pipe_rx13_data_valid)
+   ,.pipe_rx14_data_valid(pipe_rx14_data_valid)
+   ,.pipe_rx15_data_valid(pipe_rx15_data_valid)
+   ,.pipe_rx00_start_block(pipe_rx00_start_block[1:0])
+   ,.pipe_rx01_start_block(pipe_rx01_start_block[1:0])
+   ,.pipe_rx02_start_block(pipe_rx02_start_block[1:0])
+   ,.pipe_rx03_start_block(pipe_rx03_start_block[1:0])
+   ,.pipe_rx04_start_block(pipe_rx04_start_block[1:0])
+   ,.pipe_rx05_start_block(pipe_rx05_start_block[1:0])
+   ,.pipe_rx06_start_block(pipe_rx06_start_block[1:0])
+   ,.pipe_rx07_start_block(pipe_rx07_start_block[1:0])
+   ,.pipe_rx08_start_block(pipe_rx08_start_block[1:0])
+   ,.pipe_rx09_start_block(pipe_rx09_start_block[1:0])
+   ,.pipe_rx10_start_block(pipe_rx10_start_block[1:0])
+   ,.pipe_rx11_start_block(pipe_rx11_start_block[1:0])
+   ,.pipe_rx12_start_block(pipe_rx12_start_block[1:0])
+   ,.pipe_rx13_start_block(pipe_rx13_start_block[1:0])
+   ,.pipe_rx14_start_block(pipe_rx14_start_block[1:0])
+   ,.pipe_rx15_start_block(pipe_rx15_start_block[1:0])
+   ,.pipe_rx00_sync_header(pipe_rx00_sync_header[1:0])
+   ,.pipe_rx01_sync_header(pipe_rx01_sync_header[1:0])
+   ,.pipe_rx02_sync_header(pipe_rx02_sync_header[1:0])
+   ,.pipe_rx03_sync_header(pipe_rx03_sync_header[1:0])
+   ,.pipe_rx04_sync_header(pipe_rx04_sync_header[1:0])
+   ,.pipe_rx05_sync_header(pipe_rx05_sync_header[1:0])
+   ,.pipe_rx06_sync_header(pipe_rx06_sync_header[1:0])
+   ,.pipe_rx07_sync_header(pipe_rx07_sync_header[1:0])
+   ,.pipe_rx08_sync_header(pipe_rx08_sync_header[1:0])
+   ,.pipe_rx09_sync_header(pipe_rx09_sync_header[1:0])
+   ,.pipe_rx10_sync_header(pipe_rx10_sync_header[1:0])
+   ,.pipe_rx11_sync_header(pipe_rx11_sync_header[1:0])
+   ,.pipe_rx12_sync_header(pipe_rx12_sync_header[1:0])
+   ,.pipe_rx13_sync_header(pipe_rx13_sync_header[1:0])
+   ,.pipe_rx14_sync_header(pipe_rx14_sync_header[1:0])
+   ,.pipe_rx15_sync_header(pipe_rx15_sync_header[1:0])
+   ,.pipe_tx00_compliance(pipe_tx00_compliance)
+   ,.pipe_tx01_compliance(pipe_tx01_compliance)
+   ,.pipe_tx02_compliance(pipe_tx02_compliance)
+   ,.pipe_tx03_compliance(pipe_tx03_compliance)
+   ,.pipe_tx04_compliance(pipe_tx04_compliance)
+   ,.pipe_tx05_compliance(pipe_tx05_compliance)
+   ,.pipe_tx06_compliance(pipe_tx06_compliance)
+   ,.pipe_tx07_compliance(pipe_tx07_compliance)
+   ,.pipe_tx08_compliance(pipe_tx08_compliance)
+   ,.pipe_tx09_compliance(pipe_tx09_compliance)
+   ,.pipe_tx10_compliance(pipe_tx10_compliance)
+   ,.pipe_tx11_compliance(pipe_tx11_compliance)
+   ,.pipe_tx12_compliance(pipe_tx12_compliance)
+   ,.pipe_tx13_compliance(pipe_tx13_compliance)
+   ,.pipe_tx14_compliance(pipe_tx14_compliance)
+   ,.pipe_tx15_compliance(pipe_tx15_compliance)
+   ,.pipe_tx00_char_is_k(pipe_tx00_char_is_k[1:0])
+   ,.pipe_tx01_char_is_k(pipe_tx01_char_is_k[1:0])
+   ,.pipe_tx02_char_is_k(pipe_tx02_char_is_k[1:0])
+   ,.pipe_tx03_char_is_k(pipe_tx03_char_is_k[1:0])
+   ,.pipe_tx04_char_is_k(pipe_tx04_char_is_k[1:0])
+   ,.pipe_tx05_char_is_k(pipe_tx05_char_is_k[1:0])
+   ,.pipe_tx06_char_is_k(pipe_tx06_char_is_k[1:0])
+   ,.pipe_tx07_char_is_k(pipe_tx07_char_is_k[1:0])
+   ,.pipe_tx08_char_is_k(pipe_tx08_char_is_k[1:0])
+   ,.pipe_tx09_char_is_k(pipe_tx09_char_is_k[1:0])
+   ,.pipe_tx10_char_is_k(pipe_tx10_char_is_k[1:0])
+   ,.pipe_tx11_char_is_k(pipe_tx11_char_is_k[1:0])
+   ,.pipe_tx12_char_is_k(pipe_tx12_char_is_k[1:0])
+   ,.pipe_tx13_char_is_k(pipe_tx13_char_is_k[1:0])
+   ,.pipe_tx14_char_is_k(pipe_tx14_char_is_k[1:0])
+   ,.pipe_tx15_char_is_k(pipe_tx15_char_is_k[1:0])
+   ,.pipe_tx00_data(pipe_tx00_data[31:0])
+   ,.pipe_tx01_data(pipe_tx01_data[31:0])
+   ,.pipe_tx02_data(pipe_tx02_data[31:0])
+   ,.pipe_tx03_data(pipe_tx03_data[31:0])
+   ,.pipe_tx04_data(pipe_tx04_data[31:0])
+   ,.pipe_tx05_data(pipe_tx05_data[31:0])
+   ,.pipe_tx06_data(pipe_tx06_data[31:0])
+   ,.pipe_tx07_data(pipe_tx07_data[31:0])
+   ,.pipe_tx08_data(pipe_tx08_data[31:0])
+   ,.pipe_tx09_data(pipe_tx09_data[31:0])
+   ,.pipe_tx10_data(pipe_tx10_data[31:0])
+   ,.pipe_tx11_data(pipe_tx11_data[31:0])
+   ,.pipe_tx12_data(pipe_tx12_data[31:0])
+   ,.pipe_tx13_data(pipe_tx13_data[31:0])
+   ,.pipe_tx14_data(pipe_tx14_data[31:0])
+   ,.pipe_tx15_data(pipe_tx15_data[31:0])
+   ,.pipe_tx00_elec_idle(pipe_tx00_elec_idle)
+   ,.pipe_tx01_elec_idle(pipe_tx01_elec_idle)
+   ,.pipe_tx02_elec_idle(pipe_tx02_elec_idle)
+   ,.pipe_tx03_elec_idle(pipe_tx03_elec_idle)
+   ,.pipe_tx04_elec_idle(pipe_tx04_elec_idle)
+   ,.pipe_tx05_elec_idle(pipe_tx05_elec_idle)
+   ,.pipe_tx06_elec_idle(pipe_tx06_elec_idle)
+   ,.pipe_tx07_elec_idle(pipe_tx07_elec_idle)
+   ,.pipe_tx08_elec_idle(pipe_tx08_elec_idle)
+   ,.pipe_tx09_elec_idle(pipe_tx09_elec_idle)
+   ,.pipe_tx10_elec_idle(pipe_tx10_elec_idle)
+   ,.pipe_tx11_elec_idle(pipe_tx11_elec_idle)
+   ,.pipe_tx12_elec_idle(pipe_tx12_elec_idle)
+   ,.pipe_tx13_elec_idle(pipe_tx13_elec_idle)
+   ,.pipe_tx14_elec_idle(pipe_tx14_elec_idle)
+   ,.pipe_tx15_elec_idle(pipe_tx15_elec_idle)
+   ,.pipe_tx00_powerdown(pipe_tx00_powerdown[1:0])
+   ,.pipe_tx01_powerdown(pipe_tx01_powerdown[1:0])
+   ,.pipe_tx02_powerdown(pipe_tx02_powerdown[1:0])
+   ,.pipe_tx03_powerdown(pipe_tx03_powerdown[1:0])
+   ,.pipe_tx04_powerdown(pipe_tx04_powerdown[1:0])
+   ,.pipe_tx05_powerdown(pipe_tx05_powerdown[1:0])
+   ,.pipe_tx06_powerdown(pipe_tx06_powerdown[1:0])
+   ,.pipe_tx07_powerdown(pipe_tx07_powerdown[1:0])
+   ,.pipe_tx08_powerdown(pipe_tx08_powerdown[1:0])
+   ,.pipe_tx09_powerdown(pipe_tx09_powerdown[1:0])
+   ,.pipe_tx10_powerdown(pipe_tx10_powerdown[1:0])
+   ,.pipe_tx11_powerdown(pipe_tx11_powerdown[1:0])
+   ,.pipe_tx12_powerdown(pipe_tx12_powerdown[1:0])
+   ,.pipe_tx13_powerdown(pipe_tx13_powerdown[1:0])
+   ,.pipe_tx14_powerdown(pipe_tx14_powerdown[1:0])
+   ,.pipe_tx15_powerdown(pipe_tx15_powerdown[1:0])
+   ,.pipe_tx00_data_valid(pipe_tx00_data_valid)
+   ,.pipe_tx01_data_valid(pipe_tx01_data_valid)
+   ,.pipe_tx02_data_valid(pipe_tx02_data_valid)
+   ,.pipe_tx03_data_valid(pipe_tx03_data_valid)
+   ,.pipe_tx04_data_valid(pipe_tx04_data_valid)
+   ,.pipe_tx05_data_valid(pipe_tx05_data_valid)
+   ,.pipe_tx06_data_valid(pipe_tx06_data_valid)
+   ,.pipe_tx07_data_valid(pipe_tx07_data_valid)
+   ,.pipe_tx08_data_valid(pipe_tx08_data_valid)
+   ,.pipe_tx09_data_valid(pipe_tx09_data_valid)
+   ,.pipe_tx10_data_valid(pipe_tx10_data_valid)
+   ,.pipe_tx11_data_valid(pipe_tx11_data_valid)
+   ,.pipe_tx12_data_valid(pipe_tx12_data_valid)
+   ,.pipe_tx13_data_valid(pipe_tx13_data_valid)
+   ,.pipe_tx14_data_valid(pipe_tx14_data_valid)
+   ,.pipe_tx15_data_valid(pipe_tx15_data_valid)
+   ,.pipe_tx00_start_block(pipe_tx00_start_block)
+   ,.pipe_tx01_start_block(pipe_tx01_start_block)
+   ,.pipe_tx02_start_block(pipe_tx02_start_block)
+   ,.pipe_tx03_start_block(pipe_tx03_start_block)
+   ,.pipe_tx04_start_block(pipe_tx04_start_block)
+   ,.pipe_tx05_start_block(pipe_tx05_start_block)
+   ,.pipe_tx06_start_block(pipe_tx06_start_block)
+   ,.pipe_tx07_start_block(pipe_tx07_start_block)
+   ,.pipe_tx08_start_block(pipe_tx08_start_block)
+   ,.pipe_tx09_start_block(pipe_tx09_start_block)
+   ,.pipe_tx10_start_block(pipe_tx10_start_block)
+   ,.pipe_tx11_start_block(pipe_tx11_start_block)
+   ,.pipe_tx12_start_block(pipe_tx12_start_block)
+   ,.pipe_tx13_start_block(pipe_tx13_start_block)
+   ,.pipe_tx14_start_block(pipe_tx14_start_block)
+   ,.pipe_tx15_start_block(pipe_tx15_start_block)
+   ,.pipe_tx00_sync_header(pipe_tx00_sync_header[1:0])
+   ,.pipe_tx01_sync_header(pipe_tx01_sync_header[1:0])
+   ,.pipe_tx02_sync_header(pipe_tx02_sync_header[1:0])
+   ,.pipe_tx03_sync_header(pipe_tx03_sync_header[1:0])
+   ,.pipe_tx04_sync_header(pipe_tx04_sync_header[1:0])
+   ,.pipe_tx05_sync_header(pipe_tx05_sync_header[1:0])
+   ,.pipe_tx06_sync_header(pipe_tx06_sync_header[1:0])
+   ,.pipe_tx07_sync_header(pipe_tx07_sync_header[1:0])
+   ,.pipe_tx08_sync_header(pipe_tx08_sync_header[1:0])
+   ,.pipe_tx09_sync_header(pipe_tx09_sync_header[1:0])
+   ,.pipe_tx10_sync_header(pipe_tx10_sync_header[1:0])
+   ,.pipe_tx11_sync_header(pipe_tx11_sync_header[1:0])
+   ,.pipe_tx12_sync_header(pipe_tx12_sync_header[1:0])
+   ,.pipe_tx13_sync_header(pipe_tx13_sync_header[1:0])
+   ,.pipe_tx14_sync_header(pipe_tx14_sync_header[1:0])
+   ,.pipe_tx15_sync_header(pipe_tx15_sync_header[1:0])
+   ,.pipe_rx00_eq_control(pipe_rx00_eq_control[1:0])
+   ,.pipe_rx01_eq_control(pipe_rx01_eq_control[1:0])
+   ,.pipe_rx02_eq_control(pipe_rx02_eq_control[1:0])
+   ,.pipe_rx03_eq_control(pipe_rx03_eq_control[1:0])
+   ,.pipe_rx04_eq_control(pipe_rx04_eq_control[1:0])
+   ,.pipe_rx05_eq_control(pipe_rx05_eq_control[1:0])
+   ,.pipe_rx06_eq_control(pipe_rx06_eq_control[1:0])
+   ,.pipe_rx07_eq_control(pipe_rx07_eq_control[1:0])
+   ,.pipe_rx08_eq_control(pipe_rx08_eq_control[1:0])
+   ,.pipe_rx09_eq_control(pipe_rx09_eq_control[1:0])
+   ,.pipe_rx10_eq_control(pipe_rx10_eq_control[1:0])
+   ,.pipe_rx11_eq_control(pipe_rx11_eq_control[1:0])
+   ,.pipe_rx12_eq_control(pipe_rx12_eq_control[1:0])
+   ,.pipe_rx13_eq_control(pipe_rx13_eq_control[1:0])
+   ,.pipe_rx14_eq_control(pipe_rx14_eq_control[1:0])
+   ,.pipe_rx15_eq_control(pipe_rx15_eq_control[1:0])
+   ,.pipe_rx00_eq_lp_lf_fs_sel(pipe_rx00_eq_lp_lf_fs_sel)
+   ,.pipe_rx01_eq_lp_lf_fs_sel(pipe_rx01_eq_lp_lf_fs_sel)
+   ,.pipe_rx02_eq_lp_lf_fs_sel(pipe_rx02_eq_lp_lf_fs_sel)
+   ,.pipe_rx03_eq_lp_lf_fs_sel(pipe_rx03_eq_lp_lf_fs_sel)
+   ,.pipe_rx04_eq_lp_lf_fs_sel(pipe_rx04_eq_lp_lf_fs_sel)
+   ,.pipe_rx05_eq_lp_lf_fs_sel(pipe_rx05_eq_lp_lf_fs_sel)
+   ,.pipe_rx06_eq_lp_lf_fs_sel(pipe_rx06_eq_lp_lf_fs_sel)
+   ,.pipe_rx07_eq_lp_lf_fs_sel(pipe_rx07_eq_lp_lf_fs_sel)
+   ,.pipe_rx08_eq_lp_lf_fs_sel(pipe_rx08_eq_lp_lf_fs_sel)
+   ,.pipe_rx09_eq_lp_lf_fs_sel(pipe_rx09_eq_lp_lf_fs_sel)
+   ,.pipe_rx10_eq_lp_lf_fs_sel(pipe_rx10_eq_lp_lf_fs_sel)
+   ,.pipe_rx11_eq_lp_lf_fs_sel(pipe_rx11_eq_lp_lf_fs_sel)
+   ,.pipe_rx12_eq_lp_lf_fs_sel(pipe_rx12_eq_lp_lf_fs_sel)
+   ,.pipe_rx13_eq_lp_lf_fs_sel(pipe_rx13_eq_lp_lf_fs_sel)
+   ,.pipe_rx14_eq_lp_lf_fs_sel(pipe_rx14_eq_lp_lf_fs_sel)
+   ,.pipe_rx15_eq_lp_lf_fs_sel(pipe_rx15_eq_lp_lf_fs_sel)
+   ,.pipe_rx00_eq_lp_new_tx_coeff_or_preset(pipe_rx00_eq_lp_new_tx_coeff_or_preset[17:0])
+   ,.pipe_rx01_eq_lp_new_tx_coeff_or_preset(pipe_rx01_eq_lp_new_tx_coeff_or_preset[17:0])
+   ,.pipe_rx02_eq_lp_new_tx_coeff_or_preset(pipe_rx02_eq_lp_new_tx_coeff_or_preset[17:0])
+   ,.pipe_rx03_eq_lp_new_tx_coeff_or_preset(pipe_rx03_eq_lp_new_tx_coeff_or_preset[17:0])
+   ,.pipe_rx04_eq_lp_new_tx_coeff_or_preset(pipe_rx04_eq_lp_new_tx_coeff_or_preset[17:0])
+   ,.pipe_rx05_eq_lp_new_tx_coeff_or_preset(pipe_rx05_eq_lp_new_tx_coeff_or_preset[17:0])
+   ,.pipe_rx06_eq_lp_new_tx_coeff_or_preset(pipe_rx06_eq_lp_new_tx_coeff_or_preset[17:0])
+   ,.pipe_rx07_eq_lp_new_tx_coeff_or_preset(pipe_rx07_eq_lp_new_tx_coeff_or_preset[17:0])
+   ,.pipe_rx08_eq_lp_new_tx_coeff_or_preset(pipe_rx08_eq_lp_new_tx_coeff_or_preset[17:0])
+   ,.pipe_rx09_eq_lp_new_tx_coeff_or_preset(pipe_rx09_eq_lp_new_tx_coeff_or_preset[17:0])
+   ,.pipe_rx10_eq_lp_new_tx_coeff_or_preset(pipe_rx10_eq_lp_new_tx_coeff_or_preset[17:0])
+   ,.pipe_rx11_eq_lp_new_tx_coeff_or_preset(pipe_rx11_eq_lp_new_tx_coeff_or_preset[17:0])
+   ,.pipe_rx12_eq_lp_new_tx_coeff_or_preset(pipe_rx12_eq_lp_new_tx_coeff_or_preset[17:0])
+   ,.pipe_rx13_eq_lp_new_tx_coeff_or_preset(pipe_rx13_eq_lp_new_tx_coeff_or_preset[17:0])
+   ,.pipe_rx14_eq_lp_new_tx_coeff_or_preset(pipe_rx14_eq_lp_new_tx_coeff_or_preset[17:0])
+   ,.pipe_rx15_eq_lp_new_tx_coeff_or_preset(pipe_rx15_eq_lp_new_tx_coeff_or_preset[17:0])
+   ,.pipe_rx00_eq_lp_adapt_done(pipe_rx00_eq_lp_adapt_done)
+   ,.pipe_rx01_eq_lp_adapt_done(pipe_rx01_eq_lp_adapt_done)
+   ,.pipe_rx02_eq_lp_adapt_done(pipe_rx02_eq_lp_adapt_done)
+   ,.pipe_rx03_eq_lp_adapt_done(pipe_rx03_eq_lp_adapt_done)
+   ,.pipe_rx04_eq_lp_adapt_done(pipe_rx04_eq_lp_adapt_done)
+   ,.pipe_rx05_eq_lp_adapt_done(pipe_rx05_eq_lp_adapt_done)
+   ,.pipe_rx06_eq_lp_adapt_done(pipe_rx06_eq_lp_adapt_done)
+   ,.pipe_rx07_eq_lp_adapt_done(pipe_rx07_eq_lp_adapt_done)
+   ,.pipe_rx08_eq_lp_adapt_done(pipe_rx08_eq_lp_adapt_done)
+   ,.pipe_rx09_eq_lp_adapt_done(pipe_rx09_eq_lp_adapt_done)
+   ,.pipe_rx10_eq_lp_adapt_done(pipe_rx10_eq_lp_adapt_done)
+   ,.pipe_rx11_eq_lp_adapt_done(pipe_rx11_eq_lp_adapt_done)
+   ,.pipe_rx12_eq_lp_adapt_done(pipe_rx12_eq_lp_adapt_done)
+   ,.pipe_rx13_eq_lp_adapt_done(pipe_rx13_eq_lp_adapt_done)
+   ,.pipe_rx14_eq_lp_adapt_done(pipe_rx14_eq_lp_adapt_done)
+   ,.pipe_rx15_eq_lp_adapt_done(pipe_rx15_eq_lp_adapt_done)
+   ,.pipe_rx00_eq_done(pipe_rx00_eq_done)
+   ,.pipe_rx01_eq_done(pipe_rx01_eq_done)
+   ,.pipe_rx02_eq_done(pipe_rx02_eq_done)
+   ,.pipe_rx03_eq_done(pipe_rx03_eq_done)
+   ,.pipe_rx04_eq_done(pipe_rx04_eq_done)
+   ,.pipe_rx05_eq_done(pipe_rx05_eq_done)
+   ,.pipe_rx06_eq_done(pipe_rx06_eq_done)
+   ,.pipe_rx07_eq_done(pipe_rx07_eq_done)
+   ,.pipe_rx08_eq_done(pipe_rx08_eq_done)
+   ,.pipe_rx09_eq_done(pipe_rx09_eq_done)
+   ,.pipe_rx10_eq_done(pipe_rx10_eq_done)
+   ,.pipe_rx11_eq_done(pipe_rx11_eq_done)
+   ,.pipe_rx12_eq_done(pipe_rx12_eq_done)
+   ,.pipe_rx13_eq_done(pipe_rx13_eq_done)
+   ,.pipe_rx14_eq_done(pipe_rx14_eq_done)
+   ,.pipe_rx15_eq_done(pipe_rx15_eq_done)
+   ,.pipe_tx00_eq_control(pipe_tx00_eq_control[1:0])
+   ,.pipe_tx01_eq_control(pipe_tx01_eq_control[1:0])
+   ,.pipe_tx02_eq_control(pipe_tx02_eq_control[1:0])
+   ,.pipe_tx03_eq_control(pipe_tx03_eq_control[1:0])
+   ,.pipe_tx04_eq_control(pipe_tx04_eq_control[1:0])
+   ,.pipe_tx05_eq_control(pipe_tx05_eq_control[1:0])
+   ,.pipe_tx06_eq_control(pipe_tx06_eq_control[1:0])
+   ,.pipe_tx07_eq_control(pipe_tx07_eq_control[1:0])
+   ,.pipe_tx08_eq_control(pipe_tx08_eq_control[1:0])
+   ,.pipe_tx09_eq_control(pipe_tx09_eq_control[1:0])
+   ,.pipe_tx10_eq_control(pipe_tx10_eq_control[1:0])
+   ,.pipe_tx11_eq_control(pipe_tx11_eq_control[1:0])
+   ,.pipe_tx12_eq_control(pipe_tx12_eq_control[1:0])
+   ,.pipe_tx13_eq_control(pipe_tx13_eq_control[1:0])
+   ,.pipe_tx14_eq_control(pipe_tx14_eq_control[1:0])
+   ,.pipe_tx15_eq_control(pipe_tx15_eq_control[1:0])
+   ,.pipe_tx00_eq_deemph(pipe_tx00_eq_deemph[5:0])
+   ,.pipe_tx01_eq_deemph(pipe_tx01_eq_deemph[5:0])
+   ,.pipe_tx02_eq_deemph(pipe_tx02_eq_deemph[5:0])
+   ,.pipe_tx03_eq_deemph(pipe_tx03_eq_deemph[5:0])
+   ,.pipe_tx04_eq_deemph(pipe_tx04_eq_deemph[5:0])
+   ,.pipe_tx05_eq_deemph(pipe_tx05_eq_deemph[5:0])
+   ,.pipe_tx06_eq_deemph(pipe_tx06_eq_deemph[5:0])
+   ,.pipe_tx07_eq_deemph(pipe_tx07_eq_deemph[5:0])
+   ,.pipe_tx08_eq_deemph(pipe_tx08_eq_deemph[5:0])
+   ,.pipe_tx09_eq_deemph(pipe_tx09_eq_deemph[5:0])
+   ,.pipe_tx10_eq_deemph(pipe_tx10_eq_deemph[5:0])
+   ,.pipe_tx11_eq_deemph(pipe_tx11_eq_deemph[5:0])
+   ,.pipe_tx12_eq_deemph(pipe_tx12_eq_deemph[5:0])
+   ,.pipe_tx13_eq_deemph(pipe_tx13_eq_deemph[5:0])
+   ,.pipe_tx14_eq_deemph(pipe_tx14_eq_deemph[5:0])
+   ,.pipe_tx15_eq_deemph(pipe_tx15_eq_deemph[5:0])
+   ,.pipe_tx00_eq_coeff(pipe_tx00_eq_coeff[17:0])
+   ,.pipe_tx01_eq_coeff(pipe_tx01_eq_coeff[17:0])
+   ,.pipe_tx02_eq_coeff(pipe_tx02_eq_coeff[17:0])
+   ,.pipe_tx03_eq_coeff(pipe_tx03_eq_coeff[17:0])
+   ,.pipe_tx04_eq_coeff(pipe_tx04_eq_coeff[17:0])
+   ,.pipe_tx05_eq_coeff(pipe_tx05_eq_coeff[17:0])
+   ,.pipe_tx06_eq_coeff(pipe_tx06_eq_coeff[17:0])
+   ,.pipe_tx07_eq_coeff(pipe_tx07_eq_coeff[17:0])
+   ,.pipe_tx08_eq_coeff(pipe_tx08_eq_coeff[17:0])
+   ,.pipe_tx09_eq_coeff(pipe_tx09_eq_coeff[17:0])
+   ,.pipe_tx10_eq_coeff(pipe_tx10_eq_coeff[17:0])
+   ,.pipe_tx11_eq_coeff(pipe_tx11_eq_coeff[17:0])
+   ,.pipe_tx12_eq_coeff(pipe_tx12_eq_coeff[17:0])
+   ,.pipe_tx13_eq_coeff(pipe_tx13_eq_coeff[17:0])
+   ,.pipe_tx14_eq_coeff(pipe_tx14_eq_coeff[17:0])
+   ,.pipe_tx15_eq_coeff(pipe_tx15_eq_coeff[17:0])
+   ,.pipe_tx00_eq_done(pipe_tx00_eq_done)
+   ,.pipe_tx01_eq_done(pipe_tx01_eq_done)
+   ,.pipe_tx02_eq_done(pipe_tx02_eq_done)
+   ,.pipe_tx03_eq_done(pipe_tx03_eq_done)
+   ,.pipe_tx04_eq_done(pipe_tx04_eq_done)
+   ,.pipe_tx05_eq_done(pipe_tx05_eq_done)
+   ,.pipe_tx06_eq_done(pipe_tx06_eq_done)
+   ,.pipe_tx07_eq_done(pipe_tx07_eq_done)
+   ,.pipe_tx08_eq_done(pipe_tx08_eq_done)
+   ,.pipe_tx09_eq_done(pipe_tx09_eq_done)
+   ,.pipe_tx10_eq_done(pipe_tx10_eq_done)
+   ,.pipe_tx11_eq_done(pipe_tx11_eq_done)
+   ,.pipe_tx12_eq_done(pipe_tx12_eq_done)
+   ,.pipe_tx13_eq_done(pipe_tx13_eq_done)
+   ,.pipe_tx14_eq_done(pipe_tx14_eq_done)
+   ,.pipe_tx15_eq_done(pipe_tx15_eq_done)
+   ,.pipe_rx_eq_lp_tx_preset(pipe_rx_eq_lp_tx_preset[3:0])
+   ,.pipe_rx_eq_lp_lf_fs(pipe_rx_eq_lp_lf_fs[5:0])
+   ,.pipe_tx_rcvr_det(pipe_tx_rcvr_det)
+   ,.pipe_tx_rate(pipe_tx_rate[1:0])
+   ,.pipe_tx_deemph(pipe_tx_deemph)
+   ,.pipe_tx_margin(pipe_tx_margin[2:0])
+   ,.pipe_tx_swing(pipe_tx_swing)
+   ,.pipe_tx_reset(pipe_tx_reset)
+   ,.pipe_eq_fs(pipe_eq_fs[5:0])
+   ,.pipe_eq_lf(pipe_eq_lf[5:0])
+   ,.pl_gen2_upstream_prefer_deemph(pl_gen2_upstream_prefer_deemph)
+   ,.pl_eq_in_progress(pl_eq_in_progress)
+   ,.pl_eq_phase(pl_eq_phase[1:0])
+   ,.pl_redo_eq(pl_redo_eq)
+   ,.pl_redo_eq_speed(pl_redo_eq_speed)
+   ,.pl_eq_mismatch(pl_eq_mismatch)
+   ,.pl_redo_eq_pending(pl_redo_eq_pending)
+   ,.m_axis_cq_tdata(m_axis_cq_tdata[AXI4_DATA_WIDTH-1:0])
+   ,.s_axis_cc_tdata(s_axis_cc_tdata[AXI4_DATA_WIDTH-1:0])
+   ,.s_axis_rq_tdata(s_axis_rq_tdata[AXI4_DATA_WIDTH-1:0])
+   ,.m_axis_rc_tdata(m_axis_rc_tdata[AXI4_DATA_WIDTH-1:0])
+   ,.m_axis_cq_tuser(m_axis_cq_tuser[AXI4_CQ_TUSER_WIDTH-1:0])
+   ,.s_axis_cc_tuser(s_axis_cc_tuser[AXI4_CC_TUSER_WIDTH-1:0])
+   ,.m_axis_cq_tlast(m_axis_cq_tlast)
+   ,.s_axis_rq_tlast(s_axis_rq_tlast)
+   ,.m_axis_rc_tlast(m_axis_rc_tlast)
+   ,.s_axis_cc_tlast(s_axis_cc_tlast)
+   ,.pcie_cq_np_req(pcie_cq_np_req[1:0])
+   ,.pcie_cq_np_req_count(pcie_cq_np_req_count[5:0])
+   ,.s_axis_rq_tuser(s_axis_rq_tuser[AXI4_RQ_TUSER_WIDTH-1:0])
+   ,.m_axis_rc_tuser(m_axis_rc_tuser[AXI4_RC_TUSER_WIDTH-1:0])
+   ,.m_axis_cq_tkeep(m_axis_cq_tkeep[AXI4_TKEEP_WIDTH-1:0])
+   ,.s_axis_cc_tkeep(s_axis_cc_tkeep[AXI4_TKEEP_WIDTH-1:0])
+   ,.s_axis_rq_tkeep(s_axis_rq_tkeep[AXI4_TKEEP_WIDTH-1:0])
+   ,.m_axis_rc_tkeep(m_axis_rc_tkeep[AXI4_TKEEP_WIDTH-1:0])
+   ,.m_axis_cq_tvalid(m_axis_cq_tvalid)
+   ,.s_axis_cc_tvalid(s_axis_cc_tvalid)
+   ,.s_axis_rq_tvalid(s_axis_rq_tvalid)
+   ,.m_axis_rc_tvalid(m_axis_rc_tvalid)
+   ,.m_axis_cq_tready({AXI4_CQ_TREADY_WIDTH{m_axis_cq_tready}})
+   ,.s_axis_cc_tready(s_axis_cc_tready)
+   ,.s_axis_rq_tready(s_axis_rq_tready)
+   ,.m_axis_rc_tready({AXI4_RC_TREADY_WIDTH{m_axis_rc_tready}})
+   ,.pcie_rq_seq_num0(pcie_rq_seq_num0[5:0])
+   ,.pcie_rq_seq_num_vld0(pcie_rq_seq_num_vld0)
+   ,.pcie_rq_seq_num1(pcie_rq_seq_num1[5:0])
+   ,.pcie_rq_seq_num_vld1(pcie_rq_seq_num_vld1)
+   ,.pcie_rq_tag0(pcie_rq_tag0[7:0])
+   ,.pcie_rq_tag_vld0(pcie_rq_tag_vld0)
+   ,.pcie_rq_tag1(pcie_rq_tag1[7:0])
+   ,.pcie_rq_tag_vld1(pcie_rq_tag_vld1)
+   ,.pcie_tfc_nph_av(pcie_tfc_nph_av[3:0])
+   ,.pcie_tfc_npd_av(pcie_tfc_npd_av[3:0])
+   ,.pcie_rq_tag_av(pcie_rq_tag_av[3:0])
+   ,.axi_user_out( )
+   ,.axi_user_in(8'h00)
+   ,.cfg_mgmt_addr(cfg_mgmt_addr[9:0])
+   ,.cfg_mgmt_function_number(cfg_mgmt_function_number[7:0])
+   ,.cfg_mgmt_write(cfg_mgmt_write)
+   ,.cfg_mgmt_write_data(cfg_mgmt_write_data[31:0])
+   ,.cfg_mgmt_byte_enable(cfg_mgmt_byte_enable[3:0])
+   ,.cfg_mgmt_read(cfg_mgmt_read)
+   ,.cfg_mgmt_read_data(cfg_mgmt_read_data[31:0])
+   ,.cfg_mgmt_read_write_done(cfg_mgmt_read_write_done)
+   ,.cfg_mgmt_debug_access(cfg_mgmt_debug_access)
+   ,.cfg_phy_link_down(cfg_phy_link_down)
+   ,.cfg_phy_link_status(cfg_phy_link_status[1:0])
+   ,.cfg_negotiated_width(cfg_negotiated_width[2:0])
+   ,.cfg_current_speed(cfg_current_speed[1:0])
+   ,.cfg_max_payload(cfg_max_payload[1:0])
+   ,.cfg_max_read_req(cfg_max_read_req[2:0])
+   ,.cfg_function_status(cfg_function_status[15:0])
+   ,.cfg_function_power_state(cfg_function_power_state[11:0])
+   ,.cfg_link_power_state(cfg_link_power_state[1:0])
+   ,.cfg_err_cor_out(cfg_err_cor_out)
+   ,.cfg_err_nonfatal_out(cfg_err_nonfatal_out)
+   ,.cfg_err_fatal_out(cfg_err_fatal_out)
+   ,.cfg_local_error_valid(cfg_local_error_valid)
+   ,.cfg_local_error_out(cfg_local_error_out[4:0])
+   ,.cfg_ltssm_state(cfg_ltssm_state[5:0])
+   ,.cfg_rx_pm_state(cfg_rx_pm_state[1:0])
+   ,.cfg_tx_pm_state(cfg_tx_pm_state[1:0])
+   ,.cfg_rcb_status(cfg_rcb_status[3:0])
+   ,.cfg_obff_enable(cfg_obff_enable[1:0])
+   ,.cfg_pl_status_change(cfg_pl_status_change)
+   ,.cfg_tph_requester_enable(cfg_tph_requester_enable[3:0])
+   ,.cfg_tph_st_mode(cfg_tph_st_mode[11:0])
+   ,.cfg_msg_received(cfg_msg_received)
+   ,.cfg_msg_received_data(cfg_msg_received_data[7:0])
+   ,.cfg_msg_received_type(cfg_msg_received_type[4:0])
+   ,.cfg_msg_transmit(cfg_msg_transmit_int)
+   ,.cfg_msg_transmit_type(cfg_msg_transmit_type[2:0])
+   ,.cfg_msg_transmit_data(cfg_msg_transmit_data[31:0])
+   ,.cfg_msg_transmit_done(cfg_msg_transmit_done)
+   ,.cfg_fc_ph(cfg_fc_ph[7:0])
+   ,.cfg_fc_pd(cfg_fc_pd[11:0])
+   ,.cfg_fc_nph(cfg_fc_nph[7:0])
+   ,.cfg_fc_npd(cfg_fc_npd[11:0])
+   ,.cfg_fc_cplh(cfg_fc_cplh[7:0])
+   ,.cfg_fc_cpld(cfg_fc_cpld[11:0])
+   ,.cfg_fc_sel(cfg_fc_sel[2:0])
+   ,.cfg_hot_reset_in(cfg_hot_reset_in)
+   ,.cfg_hot_reset_out(cfg_hot_reset_out)
+   ,.cfg_config_space_enable(cfg_config_space_enable)
+   ,.cfg_dsn(cfg_dsn[63:0])
+   ,.cfg_dev_id_pf0(cfg_dev_id_pf0[15:0])
+   ,.cfg_dev_id_pf1(cfg_dev_id_pf1[15:0])
+   ,.cfg_dev_id_pf2(cfg_dev_id_pf2[15:0])
+   ,.cfg_dev_id_pf3(cfg_dev_id_pf3[15:0])
+   ,.cfg_vend_id(cfg_vend_id[15:0])
+   ,.cfg_rev_id_pf0(cfg_rev_id_pf0[7:0])
+   ,.cfg_rev_id_pf1(cfg_rev_id_pf1[7:0])
+   ,.cfg_rev_id_pf2(cfg_rev_id_pf2[7:0])
+   ,.cfg_rev_id_pf3(cfg_rev_id_pf3[7:0])
+   ,.cfg_subsys_id_pf0(cfg_subsys_id_pf0[15:0])
+   ,.cfg_subsys_id_pf1(cfg_subsys_id_pf1[15:0])
+   ,.cfg_subsys_id_pf2(cfg_subsys_id_pf2[15:0])
+   ,.cfg_subsys_id_pf3(cfg_subsys_id_pf3[15:0])
+   ,.cfg_subsys_vend_id(cfg_subsys_vend_id[15:0])
+   ,.cfg_ds_port_number(cfg_ds_port_number[7:0])
+   ,.cfg_ds_bus_number(cfg_ds_bus_number[7:0])
+   ,.cfg_ds_device_number(cfg_ds_device_number[4:0])
+   ,.cfg_ds_function_number(3'b0)
+   ,.cfg_bus_number(cfg_bus_number[7:0])
+   ,.cfg_power_state_change_ack(cfg_power_state_change_ack)
+   ,.cfg_power_state_change_interrupt(cfg_power_state_change_interrupt)
+   ,.cfg_err_cor_in(cfg_err_cor_in)
+   ,.cfg_err_uncor_in(cfg_err_uncor_in)
+   ,.cfg_flr_done(cfg_flr_done[3:0])
+   ,.cfg_vf_flr_in_process(cfg_vf_flr_in_process[251:0])   
+   ,.cfg_vf_flr_done(cfg_vf_flr_done)                      
+   ,.cfg_vf_flr_func_num(cfg_vf_flr_func_num[7:0])
+   ,.cfg_vf_status(cfg_vf_status[503:0])                   
+   ,.cfg_vf_power_state(cfg_vf_power_state[755:0])         
+   ,.cfg_vf_tph_requester_enable( cfg_vf_tph_requester_enable[251:0])
+   ,.cfg_vf_tph_st_mode(cfg_vf_tph_st_mode[755:0])         
+   ,.cfg_interrupt_msix_vf_enable(cfg_interrupt_msix_vf_enable[251:0])
+   ,.cfg_interrupt_msix_vf_mask(cfg_interrupt_msix_vf_mask[251:0])
+   ,.cfg_flr_in_process(cfg_flr_in_process[3:0])
+   ,.cfg_req_pm_transition_l23_ready(cfg_req_pm_transition_l23_ready)
+   ,.cfg_link_training_enable(cfg_link_training_enable)
+   ,.cfg_interrupt_int(cfg_interrupt_int[3:0])
+   ,.cfg_interrupt_sent(cfg_interrupt_sent)
+   ,.cfg_interrupt_pending(cfg_interrupt_pending[3:0])
+   ,.cfg_interrupt_msi_enable(cfg_interrupt_msi_enable[3:0])
+   ,.cfg_interrupt_msi_int(cfg_interrupt_msi_int[31:0])
+   ,.cfg_interrupt_msi_sent(cfg_interrupt_msi_sent)
+   ,.cfg_interrupt_msi_fail(cfg_interrupt_msi_fail)
+   ,.cfg_interrupt_msi_mmenable(cfg_interrupt_msi_mmenable[11:0])
+   ,.cfg_interrupt_msi_pending_status(cfg_interrupt_msi_pending_status[31:0])
+   ,.cfg_interrupt_msi_pending_status_function_num(cfg_interrupt_msi_pending_status_function_num[1:0])
+   ,.cfg_interrupt_msi_pending_status_data_enable(cfg_interrupt_msi_pending_status_data_enable)
+   ,.cfg_interrupt_msi_mask_update(cfg_interrupt_msi_mask_update)
+   ,.cfg_interrupt_msi_select(cfg_interrupt_msi_select[1:0])
+   ,.cfg_interrupt_msi_data(cfg_interrupt_msi_data[31:0])
+   ,.cfg_interrupt_msix_enable(cfg_interrupt_msix_enable[3:0])
+   ,.cfg_interrupt_msix_mask(cfg_interrupt_msix_mask[3:0])
+   ,.cfg_interrupt_msix_address(cfg_interrupt_msix_address[63:0])
+   ,.cfg_interrupt_msix_data(cfg_interrupt_msix_data[31:0])
+   ,.cfg_interrupt_msix_int(cfg_interrupt_msix_int)
+   ,.cfg_interrupt_msix_vec_pending(cfg_interrupt_msix_vec_pending[1:0])
+   ,.cfg_interrupt_msix_vec_pending_status(cfg_interrupt_msix_vec_pending_status)
+   ,.cfg_interrupt_msi_attr(cfg_interrupt_msi_attr[2:0])
+   ,.cfg_interrupt_msi_tph_present(cfg_interrupt_msi_tph_present)
+   ,.cfg_interrupt_msi_tph_type(cfg_interrupt_msi_tph_type[1:0])
+   ,.cfg_interrupt_msi_tph_st_tag(cfg_interrupt_msi_tph_st_tag[7:0])
+   ,.cfg_interrupt_msi_function_number(cfg_interrupt_msi_function_number[7:0])
+   ,.cfg_ext_read_received(cfg_ext_read_received)
+   ,.cfg_ext_write_received(cfg_ext_write_received)
+   ,.cfg_ext_register_number(cfg_ext_register_number[9:0])
+   ,.cfg_ext_function_number(cfg_ext_function_number[7:0])
+   ,.cfg_ext_write_data(cfg_ext_write_data[31:0])
+   ,.cfg_ext_write_byte_enable(cfg_ext_write_byte_enable[3:0])
+   ,.cfg_ext_read_data(cfg_ext_read_data[31:0])
+   ,.cfg_ext_read_data_valid(cfg_ext_read_data_valid)
+   ,.cfg_pm_aspm_l1_entry_reject(cfg_pm_aspm_l1_entry_reject)
+   ,.cfg_pm_aspm_tx_l0s_entry_disable(cfg_pm_aspm_tx_l0s_entry_disable)
+   ,.user_tph_stt_func_num(8'h00)
+   ,.user_tph_stt_index(6'b0)
+   ,.user_tph_stt_rd_en(1'b0)
+   ,.user_tph_stt_rd_data()
+   ,.conf_req_type(conf_req_type[1:0])
+   ,.conf_req_reg_num(conf_req_reg_num[3:0])
+   ,.conf_req_data(conf_req_data[31:0])
+   ,.conf_req_valid(conf_req_valid)
+   ,.conf_req_ready(conf_req_ready)
+   ,.conf_resp_rdata(conf_resp_rdata[31:0])
+   ,.conf_resp_valid(conf_resp_valid)
+   ,.conf_mcap_design_switch(conf_mcap_design_switch)
+   ,.conf_mcap_eos(conf_mcap_eos)
+   ,.conf_mcap_in_use_by_pcie(conf_mcap_in_use_by_pcie)
+   ,.conf_mcap_request_by_conf(conf_mcap_request_by_conf)
+
+   ,.drp_clk('h0)
+   ,.drp_en('h0)
+   ,.drp_we('h0)
+   ,.drp_addr('h0)
+   ,.drp_di('h0)
+   ,.drp_rdy()
+   ,.drp_do()
+   ,.pipe_clk(pipe_clk)
+   ,.core_clk(core_clk)
+   ,.user_clk(user_clk)
+   ,.user_clk2(user_clk2)
+   ,.user_clk_en(user_clk_en)
+   ,.mcap_clk(mcap_clk)
+   ,.mcap_rst_b(mcap_rst_b)
+   ,.pcie_perst0_b(pcie_perst0_b)
+   ,.pcie_perst1_b(pcie_perst1_b)
+   ,.phy_rdy(phy_rdy)
+   ,.cfg_fc_vc_sel(cfg_fc_vc_sel)
+   ,.pl_eq_reset_eieos_count(pl_eq_reset_eieos_count)
+   ,.cfg_ltr_enable(cfg_ltr_enable)
+   ,.s_axis_ccix_tx_tdata(s_axis_ccix_tx_tdata)
+   ,.s_axis_ccix_tx_tvalid(s_axis_ccix_tx_tvalid)
+   ,.s_axis_ccix_tx_tuser(s_axis_ccix_tx_tuser)
+   ,.ccix_tx_credit(ccix_tx_credit)
+   ,.m_axis_ccix_rx_tdata(m_axis_ccix_rx_tdata) // 256-bit data
+   ,.m_axis_ccix_rx_tvalid(m_axis_ccix_rx_tvalid)
+   ,.m_axis_ccix_rx_tuser(m_axis_ccix_rx_tuser) // tuser bus
+   ,.ccix_rx_credit(ccix_rx_credit)
+   ,.ccix_rx_credit_av(ccix_rx_credit_av)
+   ,.ccix_optimized_tlp_tx_and_rx_enable(ccix_optimized_tlp_tx_and_rx_enable)
+   ,.cfg_vc1_enable (cfg_vc1_enable)
+   ,.cfg_vc1_negotiation_pending (cfg_vc1_negotiation_pending)
+
+
+  );
+
+  BUFG_GT bufg_gt_sysclk (.CE (1'd1), .CEMASK (1'd0), .CLR (1'd0), .CLRMASK (1'd0), .DIV (3'd0), .I (sys_clk), .O (sys_clk_bufg));
+
+  always @(posedge user_clk or posedge sys_or_hot_rst) begin
+   if (sys_or_hot_rst) begin
+      as_cdr_hold_req_user    <= 1'b0;
+      as_mac_in_detect_user   <= 1'b1;
+   end else begin
+      // If LTSSM state is Recovery.Speed, L1.Entry, L1.Idle, Loopback.Entry_slave, or Loopback.Speed
+      as_cdr_hold_req_user    <= (cfg_ltssm_state == 6'h0C) | (cfg_ltssm_state == 6'h17) |
+                                 (cfg_ltssm_state == 6'h18) | (cfg_ltssm_state == 6'h24) |
+                                 (cfg_ltssm_state == 6'h2D);
+      // If LTSSM state is Detect.Quiet or Detect.Active
+      as_mac_in_detect_user   <= (cfg_ltssm_state == 6'h00) | (cfg_ltssm_state == 6'h01);
+   end
+  end
+
+  // Sync to PIPE_CLK
+  always @(posedge pipe_clk or posedge sys_or_hot_rst) begin
+   if (sys_or_hot_rst) begin
+      as_cdr_hold_req_ff    <= 1'b0;
+      as_cdr_hold_req_ff1   <= 1'b0;
+      as_mac_in_detect_ff   <= 1'b1;
+      as_mac_in_detect_ff1  <= 1'b1;
+   end else begin
+      as_cdr_hold_req_ff    <= as_cdr_hold_req_user;
+      as_cdr_hold_req_ff1   <= as_cdr_hold_req_ff;
+      as_mac_in_detect_ff   <= as_mac_in_detect_user;
+      as_mac_in_detect_ff1  <= as_mac_in_detect_ff;
+   end
+  end
+
+xp4_usp_smsw_phy_top #
+  (
+    //--------------------------------------------------------------------------
+    //  Parameters
+    //--------------------------------------------------------------------------
+    .FPGA_FAMILY      ( FPGA_FAMILY ),
+    .FPGA_XCVR        ( FPGA_XCVR ),
+    .PIPELINE_STAGES  ( PIPE_PIPELINE_STAGES ),
+    .PHY_SIM_EN       ( ((PL_SIM_FAST_LINK_TRAINING != 2'b0) ? "TRUE" : "FALSE") ),     
+    .PHY_LANE         ( PL_LINK_CAP_MAX_LINK_WIDTH ),   
+    .PHY_MAX_SPEED    ( (PL_LINK_CAP_MAX_LINK_SPEED[3] ? 4 : (PL_LINK_CAP_MAX_LINK_SPEED[2] ? 3 : (PL_LINK_CAP_MAX_LINK_SPEED[1] ? 2 : 1))) ),                    
+    .PHY_ASYNC_EN     ( ((PF0_LINK_STATUS_SLOT_CLOCK_CONFIG == "TRUE") ? "FALSE" : "TRUE" ) ),
+    .PHY_REFCLK_FREQ  ( PHY_REFCLK_FREQ ),           
+    .PHY_MCAPCLK_FREQ ( (((CRM_USER_CLK_FREQ == 2'b00) & (CRM_MCAP_CLK_FREQ == 1'b0)) ? 1 : 2) ),
+    .PHY_USERCLK_FREQ ( (((CRM_USER_CLK_FREQ == 2'b10) | ((CRM_USER_CLK_FREQ == 2'b11) & (CRM_CORE_CLK_FREQ_500 == "TRUE"))) ? ((FPGA_XCVR == "HLF")? 2: 3) :
+                                                                                                                               (CRM_USER_CLK_FREQ == 2'b01) ? 2 : 1) ),           
+    .PHY_CORECLK_FREQ ( ((CRM_CORE_CLK_FREQ_500 == "TRUE") ? ((FPGA_XCVR == "HLF")? 1: 2) : 1) ) 
+  ) gt_top_smsw_i (                                         
+
+    //--------------------------------------------------------------------------
+    //  Clock & Reset Ports
+    //--------------------------------------------------------------------------
+    .PHY_REFCLK          ( sys_clk_bufg ),      
+    .PHY_USERCLK         ( user_clk ),  
+    .PHY_MCAPCLK         ( mcap_clk ),  
+    .PHY_GTREFCLK        ( sys_clk_gt ),               
+    .PHY_RST_N           ( sys_rst_n ),           
+   
+    .PHY_PCLK            ( pipe_clk ),  
+    .PHY_CORECLK         ( core_clk ), 
+                            
+                                               
+    //--------------------------------------------------------------------------
+    //  Serial Line Ports
+    //--------------------------------------------------------------------------
+    
+    .PHY_RXP            ( pci_exp_rxp ),               
+    .PHY_RXN            ( pci_exp_rxn ),               
+                         
+    .PHY_TXP            ( pci_exp_txp ),               
+    .PHY_TXN            ( pci_exp_txn ),   
+                                                                       
+    //--------------------------------------------------------------------------
+    //  TX Data Ports 
+    //--------------------------------------------------------------------------
+    
+    .PHY_TXDATA         (PHY_TXDATA),            
+    .PHY_TXDATAK        (PHY_TXDATAK),
+    .PHY_TXDATA_VALID   (PHY_TXDATA_VALID),
+    .PHY_TXSTART_BLOCK  (PHY_TXSTART_BLOCK),
+    .PHY_TXSYNC_HEADER  (PHY_TXSYNC_HEADER), 
+
+    //--------------------------------------------------------------------------
+    //  RX Data Ports 
+    //--------------------------------------------------------------------------
+
+    .PHY_RXDATA         ( PHY_RXDATA ),
+    .PHY_RXDATAK        ( PHY_RXDATAK ), 
+    .PHY_RXDATA_VALID   ( PHY_RXDATA_VALID ),
+    .PHY_RXSTART_BLOCK  ( PHY_RXSTART_BLOCK ), 
+    .PHY_RXSYNC_HEADER  ( rxsync_header_nogate ),
+
+    //--------------------------------------------------------------------------
+    //  PHY Command Port
+    //--------------------------------------------------------------------------
+   
+    .PHY_TXDETECTRX     ( pipe_tx_rcvr_det ),  
+    .PHY_TXELECIDLE     (PHY_TXELECIDLE),                    
+    .PHY_TXCOMPLIANCE   (PHY_TXCOMPLIANCE), 
+    .PHY_RXPOLARITY     (PHY_RXPOLARITY),
+    .PHY_POWERDOWN      ( pipe_tx00_powerdown ), 
+    .PHY_RATE           ( pipe_tx_rate ),
+    
+    //--------------------------------------------------------------------------   
+    //  PHY Status Ports
+    //-------------------------------------------------------------------------- 
+    
+    .PHY_RXVALID        ( PHY_RXVALID  ),
+    .PHY_PHYSTATUS      ( PHY_PHYSTATUS  ),
+    .PHY_PHYSTATUS_RST  ( phy_rdy_phystatus ),
+    .PHY_RXELECIDLE     ( PHY_RXELECIDLE ), 
+    .PHY_RXSTATUS       ( PHY_RXSTATUS  ),
+    
+    //--------------------------------------------------------------------------
+    //  TX Driver Ports
+    //--------------------------------------------------------------------------
+    
+    .PHY_TXMARGIN       ( pipe_tx_margin ),          
+    .PHY_TXSWING        ( pipe_tx_swing  ),           
+    .PHY_TXDEEMPH       ( pipe_tx_deemph  ),    
+    
+    //--------------------------------------------------------------------------   
+    //  TX Equalization Ports for Gen3
+    //--------------------------------------------------------------------------  
+    
+    .PHY_TXEQ_CTRL      (PHY_TXEQ_CTRL),
+    .PHY_TXEQ_PRESET    (PHY_TXEQ_PRESET),
+    .PHY_TXEQ_COEFF     (PHY_TXEQ_COEFF), 
+    .PHY_TXEQ_FS        ( pipe_eq_fs ),           
+    .PHY_TXEQ_LF        ( pipe_eq_lf ),           
+    .PHY_TXEQ_NEW_COEFF ( PHY_TXEQ_NEW_COEFF ),
+    .PHY_TXEQ_DONE      ( PHY_TXEQ_DONE ),
+                                                                 
+    //--------------------------------------------------------------------------
+    //  RX Equalization Ports for Gen3
+    //--------------------------------------------------------------------------                                               
+    
+    .PHY_RXEQ_CTRL        (PHY_RXEQ_CTRL), 
+    .PHY_RXEQ_TXPRESET    ( {PL_LINK_CAP_MAX_LINK_WIDTH{pipe_rx_eq_lp_tx_preset}} ),
+    .PHY_RXEQ_PRESET_SEL  ( PHY_RXEQ_LFFS_SEL  ),
+    .PHY_RXEQ_NEW_TXCOEFF ( PHY_RXEQ_NEW_TXCOEFF ),
+    .PHY_RXEQ_DONE        ( PHY_RXEQ_DONE  ),
+    .PHY_RXEQ_ADAPT_DONE  ( PHY_RXEQ_ADAPT_DONE ),
+
+    //--------------------------------------------------------------------------
+    //  Assist Signals
+    //--------------------------------------------------------------------------
+
+    .AS_MAC_IN_DETECT     ( as_mac_in_detect_ff1 ),
+    .AS_CDR_HOLD_REQ      ( as_cdr_hold_req_ff1 )
+);
+
+ assign  common_commands_out = 17'd0;
+ assign  pipe_tx_0_sigs = 70'd0; 
+ assign  pipe_tx_1_sigs = 70'd0;
+ assign  pipe_tx_2_sigs = 70'd0;
+ assign  pipe_tx_3_sigs = 70'd0;
+ assign  pipe_tx_4_sigs = 70'd0;
+ assign  pipe_tx_5_sigs = 70'd0;
+ assign  pipe_tx_6_sigs = 70'd0;
+ assign  pipe_tx_7_sigs = 70'd0;
+ assign  pipe_tx_8_sigs = 70'd0; 
+ assign  pipe_tx_9_sigs = 70'd0;
+ assign  pipe_tx_10_sigs = 70'd0;
+ assign  pipe_tx_11_sigs = 70'd0;
+ assign  pipe_tx_12_sigs = 70'd0;
+ assign  pipe_tx_13_sigs = 70'd0;
+ assign  pipe_tx_14_sigs = 70'd0;
+ assign  pipe_tx_15_sigs = 70'd0;
+ assign  phy_rdy = ~phy_rdy_phystatus;
+end
+endgenerate
+
+assign { pipe_rx15_data[63:0], pipe_rx14_data[63:0], 
+	       pipe_rx13_data[63:0], pipe_rx12_data[63:0],
+	       pipe_rx11_data[63:0], pipe_rx10_data[63:0], 
+	       pipe_rx09_data[63:0], pipe_rx08_data[63:0], 
+	       pipe_rx07_data[63:0], pipe_rx06_data[63:0], 
+	       pipe_rx05_data[63:0], pipe_rx04_data[63:0], 
+         pipe_rx03_data[63:0], pipe_rx02_data[63:0], 
+	       pipe_rx01_data[63:0], pipe_rx00_data[63:0]} = (PL_LINK_CAP_MAX_LINK_WIDTH == 16 ? PHY_RXDATA : {{((16-PL_LINK_CAP_MAX_LINK_WIDTH) * 64){1'b0}},PHY_RXDATA});
+
+assign { pipe_rx15_char_is_k[1:0], pipe_rx14_char_is_k[1:0], 
+	       pipe_rx13_char_is_k[1:0], pipe_rx12_char_is_k[1:0], 
+         pipe_rx11_char_is_k[1:0], pipe_rx10_char_is_k[1:0], 
+	       pipe_rx09_char_is_k[1:0], pipe_rx08_char_is_k[1:0], 
+         pipe_rx07_char_is_k[1:0], pipe_rx06_char_is_k[1:0], 
+	       pipe_rx05_char_is_k[1:0], pipe_rx04_char_is_k[1:0], 
+         pipe_rx03_char_is_k[1:0], pipe_rx02_char_is_k[1:0], 
+	       pipe_rx01_char_is_k[1:0], pipe_rx00_char_is_k[1:0]} = (PL_LINK_CAP_MAX_LINK_WIDTH == 16 ? PHY_RXDATAK : {{((16-PL_LINK_CAP_MAX_LINK_WIDTH) * 2){1'b0}},PHY_RXDATAK});
+
+assign { pipe_rx15_data_valid, pipe_rx14_data_valid, 
+	       pipe_rx13_data_valid, pipe_rx12_data_valid, 
+         pipe_rx11_data_valid, pipe_rx10_data_valid, 
+	       pipe_rx09_data_valid, pipe_rx08_data_valid, 
+         pipe_rx07_data_valid, pipe_rx06_data_valid, 
+	       pipe_rx05_data_valid, pipe_rx04_data_valid, 
+         pipe_rx03_data_valid, pipe_rx02_data_valid, 
+	       pipe_rx01_data_valid, pipe_rx00_data_valid} = (PL_LINK_CAP_MAX_LINK_WIDTH == 16 ? PHY_RXDATA_VALID : {{((16-PL_LINK_CAP_MAX_LINK_WIDTH) * 1){1'b0}},PHY_RXDATA_VALID});
+
+assign { pipe_rx15_start_block[1:0], pipe_rx14_start_block[1:0], 
+	       pipe_rx13_start_block[1:0], pipe_rx12_start_block[1:0], 
+         pipe_rx11_start_block[1:0], pipe_rx10_start_block[1:0], 
+	       pipe_rx09_start_block[1:0], pipe_rx08_start_block[1:0], 
+         pipe_rx07_start_block[1:0], pipe_rx06_start_block[1:0], 
+	       pipe_rx05_start_block[1:0], pipe_rx04_start_block[1:0], 
+         pipe_rx03_start_block[1:0], pipe_rx02_start_block[1:0], 
+	       pipe_rx01_start_block[1:0], pipe_rx00_start_block[1:0]} = (PL_LINK_CAP_MAX_LINK_WIDTH == 16 ? PHY_RXSTART_BLOCK : {{((16-PL_LINK_CAP_MAX_LINK_WIDTH) * 2){1'b0}},PHY_RXSTART_BLOCK});
+
+assign { pipe_rx15_sync_header[1:0], pipe_rx14_sync_header[1:0], 
+	       pipe_rx13_sync_header[1:0], pipe_rx12_sync_header[1:0], 
+         pipe_rx11_sync_header[1:0], pipe_rx10_sync_header[1:0], 
+	       pipe_rx09_sync_header[1:0], pipe_rx08_sync_header[1:0],
+         pipe_rx07_sync_header[1:0], pipe_rx06_sync_header[1:0], 
+	       pipe_rx05_sync_header[1:0], pipe_rx04_sync_header[1:0], 
+         pipe_rx03_sync_header[1:0], pipe_rx02_sync_header[1:0], 
+	       pipe_rx01_sync_header[1:0], pipe_rx00_sync_header[1:0]} = (PL_LINK_CAP_MAX_LINK_WIDTH == 16 ? PHY_RXSYNC_HEADER : {{((16-PL_LINK_CAP_MAX_LINK_WIDTH) * 2){1'b0}},PHY_RXSYNC_HEADER});
+
+assign { pipe_rx15_valid, pipe_rx14_valid, 
+	       pipe_rx13_valid, pipe_rx12_valid, 
+         pipe_rx11_valid, pipe_rx10_valid, 
+	       pipe_rx09_valid, pipe_rx08_valid, 
+         pipe_rx07_valid, pipe_rx06_valid, 
+	       pipe_rx05_valid, pipe_rx04_valid, 
+         pipe_rx03_valid, pipe_rx02_valid, 
+	       pipe_rx01_valid, pipe_rx00_valid} = (PL_LINK_CAP_MAX_LINK_WIDTH == 16 ? PHY_RXVALID : {{((16-PL_LINK_CAP_MAX_LINK_WIDTH) * 1){1'b0}},PHY_RXVALID});
+
+
+// Soft fix to pass phystatus[0] (the last-done lane) to all other lanes in TO_2_DETECT state to make sure all other lanes are done.
+
+always @(posedge pipe_clk or posedge sys_or_hot_rst) begin
+   if (sys_or_hot_rst) begin
+      pipe_tx_rate_ff   <= 2'b00;
+   end else begin
+      pipe_tx_rate_ff   <= pipe_tx_rate;
+   end
+end
+
+always @(posedge pipe_clk or posedge sys_or_hot_rst) begin
+   if (sys_or_hot_rst) begin
+      speed_change_in_progress <= 1'b0;
+   end else if (pipe_tx_rate != pipe_tx_rate_ff) begin
+      speed_change_in_progress <= 1'b1;
+   end else if (pipe_rx00_phy_status) begin
+      speed_change_in_progress <= 1'b0;
+   end
+end
+
+assign phy_status_fix   = (speed_change_in_progress)? {PL_LINK_CAP_MAX_LINK_WIDTH{PHY_PHYSTATUS[0]}}: PHY_PHYSTATUS;
+
+assign { pipe_rx15_phy_status, pipe_rx14_phy_status, 
+	       pipe_rx13_phy_status, pipe_rx12_phy_status, 
+         pipe_rx11_phy_status, pipe_rx10_phy_status, 
+	       pipe_rx09_phy_status, pipe_rx08_phy_status, 
+         pipe_rx07_phy_status, pipe_rx06_phy_status, 
+	       pipe_rx05_phy_status, pipe_rx04_phy_status, 
+         pipe_rx03_phy_status, pipe_rx02_phy_status, 
+	       pipe_rx01_phy_status, pipe_rx00_phy_status} = (PL_LINK_CAP_MAX_LINK_WIDTH == 16 ? phy_status_fix : {{((16-PL_LINK_CAP_MAX_LINK_WIDTH) * 1){1'b0}},phy_status_fix});
+
+assign { pipe_rx15_elec_idle, pipe_rx14_elec_idle, pipe_rx13_elec_idle, pipe_rx12_elec_idle, 
+         pipe_rx11_elec_idle, pipe_rx10_elec_idle, pipe_rx09_elec_idle, pipe_rx08_elec_idle, 
+         pipe_rx07_elec_idle, pipe_rx06_elec_idle, pipe_rx05_elec_idle, pipe_rx04_elec_idle, 
+         pipe_rx03_elec_idle, pipe_rx02_elec_idle, pipe_rx01_elec_idle, pipe_rx00_elec_idle} = (PL_LINK_CAP_MAX_LINK_WIDTH == 16 ? PHY_RXELECIDLE : {{((16-PL_LINK_CAP_MAX_LINK_WIDTH) * 1){1'b0}},PHY_RXELECIDLE});
+
+assign { pipe_rx15_status, pipe_rx14_status, pipe_rx13_status, pipe_rx12_status, 
+         pipe_rx11_status, pipe_rx10_status, pipe_rx09_status, pipe_rx08_status, 
+         pipe_rx07_status, pipe_rx06_status, pipe_rx05_status, pipe_rx04_status, 
+         pipe_rx03_status, pipe_rx02_status, pipe_rx01_status, pipe_rx00_status} = (PL_LINK_CAP_MAX_LINK_WIDTH == 16 ? PHY_RXSTATUS : {{((16-PL_LINK_CAP_MAX_LINK_WIDTH) * 3){1'b0}},PHY_RXSTATUS});
+
+assign { pipe_tx15_eq_coeff, pipe_tx14_eq_coeff, 
+	       pipe_tx13_eq_coeff, pipe_tx12_eq_coeff, 
+         pipe_tx11_eq_coeff, pipe_tx10_eq_coeff, 
+	       pipe_tx09_eq_coeff, pipe_tx08_eq_coeff, 
+         pipe_tx07_eq_coeff, pipe_tx06_eq_coeff, 
+	       pipe_tx05_eq_coeff, pipe_tx04_eq_coeff, 
+         pipe_tx03_eq_coeff, pipe_tx02_eq_coeff, 
+	       pipe_tx01_eq_coeff, pipe_tx00_eq_coeff} = (PL_LINK_CAP_MAX_LINK_WIDTH == 16 ? PHY_TXEQ_NEW_COEFF : {{((16-PL_LINK_CAP_MAX_LINK_WIDTH) * 18){1'b0}},PHY_TXEQ_NEW_COEFF});
+
+assign { pipe_tx15_eq_done, pipe_tx14_eq_done, 
+	       pipe_tx13_eq_done, pipe_tx12_eq_done, 
+         pipe_tx11_eq_done, pipe_tx10_eq_done, 
+	       pipe_tx09_eq_done, pipe_tx08_eq_done, 
+         pipe_tx07_eq_done, pipe_tx06_eq_done, 
+	       pipe_tx05_eq_done, pipe_tx04_eq_done, 
+         pipe_tx03_eq_done, pipe_tx02_eq_done, 
+	       pipe_tx01_eq_done, pipe_tx00_eq_done} = (PL_LINK_CAP_MAX_LINK_WIDTH == 16 ? PHY_TXEQ_DONE : {{((16-PL_LINK_CAP_MAX_LINK_WIDTH) * 1){1'b0}},PHY_TXEQ_DONE});
+
+assign { pipe_rx15_eq_lp_lf_fs_sel, pipe_rx14_eq_lp_lf_fs_sel, 
+	       pipe_rx13_eq_lp_lf_fs_sel, pipe_rx12_eq_lp_lf_fs_sel, 
+         pipe_rx11_eq_lp_lf_fs_sel, pipe_rx10_eq_lp_lf_fs_sel, 
+	       pipe_rx09_eq_lp_lf_fs_sel, pipe_rx08_eq_lp_lf_fs_sel, 
+         pipe_rx07_eq_lp_lf_fs_sel, pipe_rx06_eq_lp_lf_fs_sel, 
+	       pipe_rx05_eq_lp_lf_fs_sel, pipe_rx04_eq_lp_lf_fs_sel, 
+         pipe_rx03_eq_lp_lf_fs_sel, pipe_rx02_eq_lp_lf_fs_sel, 
+	       pipe_rx01_eq_lp_lf_fs_sel, pipe_rx00_eq_lp_lf_fs_sel} = (PL_LINK_CAP_MAX_LINK_WIDTH == 16 ? PHY_RXEQ_LFFS_SEL : {{((16-PL_LINK_CAP_MAX_LINK_WIDTH) * 1){1'b0}},PHY_RXEQ_LFFS_SEL});
+
+assign { pipe_rx15_eq_lp_new_tx_coeff_or_preset, pipe_rx14_eq_lp_new_tx_coeff_or_preset, 
+	       pipe_rx13_eq_lp_new_tx_coeff_or_preset, pipe_rx12_eq_lp_new_tx_coeff_or_preset, 
+         pipe_rx11_eq_lp_new_tx_coeff_or_preset, pipe_rx10_eq_lp_new_tx_coeff_or_preset, 
+	       pipe_rx09_eq_lp_new_tx_coeff_or_preset, pipe_rx08_eq_lp_new_tx_coeff_or_preset, 
+         pipe_rx07_eq_lp_new_tx_coeff_or_preset, pipe_rx06_eq_lp_new_tx_coeff_or_preset, 
+	       pipe_rx05_eq_lp_new_tx_coeff_or_preset, pipe_rx04_eq_lp_new_tx_coeff_or_preset, 
+         pipe_rx03_eq_lp_new_tx_coeff_or_preset, pipe_rx02_eq_lp_new_tx_coeff_or_preset, 
+	       pipe_rx01_eq_lp_new_tx_coeff_or_preset, pipe_rx00_eq_lp_new_tx_coeff_or_preset} = (PL_LINK_CAP_MAX_LINK_WIDTH == 16 ? PHY_RXEQ_NEW_TXCOEFF : {{((16-PL_LINK_CAP_MAX_LINK_WIDTH) * 18){1'b0}},PHY_RXEQ_NEW_TXCOEFF});
+
+assign { pipe_rx15_eq_done, pipe_rx14_eq_done, pipe_rx13_eq_done, pipe_rx12_eq_done, 
+         pipe_rx11_eq_done, pipe_rx10_eq_done, pipe_rx09_eq_done, pipe_rx08_eq_done, 
+         pipe_rx07_eq_done, pipe_rx06_eq_done, pipe_rx05_eq_done, pipe_rx04_eq_done, 
+         pipe_rx03_eq_done, pipe_rx02_eq_done, pipe_rx01_eq_done, pipe_rx00_eq_done} = (PL_LINK_CAP_MAX_LINK_WIDTH == 16 ? PHY_RXEQ_DONE : {{((16-PL_LINK_CAP_MAX_LINK_WIDTH) * 1){1'b0}},PHY_RXEQ_DONE});
+
+assign { pipe_rx15_eq_lp_adapt_done, pipe_rx14_eq_lp_adapt_done, 
+	       pipe_rx13_eq_lp_adapt_done, pipe_rx12_eq_lp_adapt_done, 
+         pipe_rx11_eq_lp_adapt_done, pipe_rx10_eq_lp_adapt_done, 
+	       pipe_rx09_eq_lp_adapt_done, pipe_rx08_eq_lp_adapt_done, 
+         pipe_rx07_eq_lp_adapt_done, pipe_rx06_eq_lp_adapt_done, 
+	       pipe_rx05_eq_lp_adapt_done, pipe_rx04_eq_lp_adapt_done, 
+         pipe_rx03_eq_lp_adapt_done, pipe_rx02_eq_lp_adapt_done, 
+	       pipe_rx01_eq_lp_adapt_done, pipe_rx00_eq_lp_adapt_done} = (PL_LINK_CAP_MAX_LINK_WIDTH == 16 ? PHY_RXEQ_ADAPT_DONE : {{((16-PL_LINK_CAP_MAX_LINK_WIDTH) * 1){1'b0}},PHY_RXEQ_ADAPT_DONE});
+
+assign   sys_rst_n = sys_reset; //pcie_perst0_b; // Use the reset from pcie_4_0_pipe
+assign   mcap_rst_b = ~sys_reset;
+assign   user_lnk_up_int = (cfg_phy_link_status == 2'b11) ? 1'b1 : 1'b0;
+assign   sys_or_hot_rst = ~sys_rst_n || cfg_hot_reset_out;
+
+always @(posedge user_clk) begin
+
+  if (!sys_rst_n) begin
+
+    reg_user_lnk_up <= #TCQ 1'b0;
+
+  end else begin
+
+    reg_user_lnk_up <= #TCQ user_lnk_up_int;
+
+  end
+
+end
+assign     user_lnk_up = reg_user_lnk_up;
+
+always @(posedge user_clk or posedge sys_or_hot_rst) begin
+
+  if (sys_or_hot_rst) begin
+
+    user_reset_int <= #TCQ 1'b1;
+
+  end else if (cfg_phy_link_status[1] && !cfg_phy_link_down) begin
+
+    user_reset_int <= #TCQ 1'b0;
+    
+   end else if (cfg_phy_link_down) begin
+
+    user_reset_int <= #TCQ 1'b1;
+  end
+
+end
+
+always @(posedge user_clk or posedge sys_or_hot_rst) begin
+
+  if (sys_or_hot_rst) begin
+
+    reg_user_reset <= #TCQ 1'b1;
+
+  end else begin
+
+    reg_user_reset <= #TCQ user_reset_int;
+
+  end
+
+end
+assign user_reset = reg_user_reset;
+
+
+assign PHY_TXDATA = ( PL_LINK_CAP_MAX_LINK_WIDTH==16 ?
+                         { 32'h0, pipe_tx15_data[31:0], 32'h0, pipe_tx14_data[31:0], 
+			                     32'h0, pipe_tx13_data[31:0], 32'h0, pipe_tx12_data[31:0], 
+			                     32'h0, pipe_tx11_data[31:0], 32'h0, pipe_tx10_data[31:0], 
+			                     32'h0, pipe_tx09_data[31:0], 32'h0, pipe_tx08_data[31:0], 
+			                     pipe_tx15_data[31:0], pipe_tx07_data[31:0], pipe_tx14_data[31:0], pipe_tx06_data[31:0],
+                           pipe_tx13_data[31:0], pipe_tx05_data[31:0], pipe_tx12_data[31:0], pipe_tx04_data[31:0], 
+                           pipe_tx11_data[31:0], pipe_tx03_data[31:0], pipe_tx10_data[31:0], pipe_tx02_data[31:0],
+                           pipe_tx09_data[31:0], pipe_tx01_data[31:0], pipe_tx08_data[31:0], pipe_tx00_data[31:0]} :
+                      PL_LINK_CAP_MAX_LINK_WIDTH==8 ?
+			                   { pipe_tx15_data[31:0], pipe_tx07_data[31:0], pipe_tx14_data[31:0], pipe_tx06_data[31:0], 
+			                     pipe_tx13_data[31:0], pipe_tx05_data[31:0], pipe_tx12_data[31:0], pipe_tx04_data[31:0], 
+                           pipe_tx11_data[31:0], pipe_tx03_data[31:0], pipe_tx10_data[31:0], pipe_tx02_data[31:0], 
+			                     pipe_tx09_data[31:0], pipe_tx01_data[31:0], pipe_tx08_data[31:0], pipe_tx00_data[31:0]} :
+                      PL_LINK_CAP_MAX_LINK_WIDTH==4 ?
+			                   { pipe_tx11_data[31:0], pipe_tx03_data[31:0], pipe_tx10_data[31:0], pipe_tx02_data[31:0], 
+			                     pipe_tx09_data[31:0], pipe_tx01_data[31:0], pipe_tx08_data[31:0], pipe_tx00_data[31:0]} :
+                      PL_LINK_CAP_MAX_LINK_WIDTH==2 ?
+			                   { pipe_tx09_data[31:0], pipe_tx01_data[31:0], pipe_tx08_data[31:0], pipe_tx00_data[31:0]} : 
+			                   {pipe_tx08_data[31:0], pipe_tx00_data[31:0]} );            
+
+ assign PHY_TXDATAK = ( PL_LINK_CAP_MAX_LINK_WIDTH==16 ?
+                         { pipe_tx15_char_is_k[1:0], pipe_tx14_char_is_k[1:0], pipe_tx13_char_is_k[1:0], pipe_tx12_char_is_k[1:0], 
+                           pipe_tx11_char_is_k[1:0], pipe_tx10_char_is_k[1:0], pipe_tx09_char_is_k[1:0], pipe_tx08_char_is_k[1:0], 
+                           pipe_tx07_char_is_k[1:0], pipe_tx06_char_is_k[1:0], pipe_tx05_char_is_k[1:0], pipe_tx04_char_is_k[1:0], 
+                           pipe_tx03_char_is_k[1:0], pipe_tx02_char_is_k[1:0], pipe_tx01_char_is_k[1:0], pipe_tx00_char_is_k[1:0]} :
+                        PL_LINK_CAP_MAX_LINK_WIDTH==8 ?
+                         { pipe_tx07_char_is_k[1:0], pipe_tx06_char_is_k[1:0], pipe_tx05_char_is_k[1:0], pipe_tx04_char_is_k[1:0], 
+                           pipe_tx03_char_is_k[1:0], pipe_tx02_char_is_k[1:0], pipe_tx01_char_is_k[1:0], pipe_tx00_char_is_k[1:0]} :
+                        PL_LINK_CAP_MAX_LINK_WIDTH==4 ?
+                         { pipe_tx03_char_is_k[1:0], pipe_tx02_char_is_k[1:0], pipe_tx01_char_is_k[1:0], pipe_tx00_char_is_k[1:0]} :
+                        PL_LINK_CAP_MAX_LINK_WIDTH==2 ?
+                         { pipe_tx01_char_is_k[1:0], pipe_tx00_char_is_k[1:0]} : pipe_tx00_char_is_k[1:0] );
+
+assign PHY_TXDATA_VALID = ( PL_LINK_CAP_MAX_LINK_WIDTH==16 ?
+                         { pipe_tx15_data_valid, pipe_tx14_data_valid, pipe_tx13_data_valid, pipe_tx12_data_valid, 
+                           pipe_tx11_data_valid, pipe_tx10_data_valid, pipe_tx09_data_valid, pipe_tx08_data_valid, 
+                           pipe_tx07_data_valid, pipe_tx06_data_valid, pipe_tx05_data_valid, pipe_tx04_data_valid, 
+                           pipe_tx03_data_valid, pipe_tx02_data_valid, pipe_tx01_data_valid, pipe_tx00_data_valid} :
+                          PL_LINK_CAP_MAX_LINK_WIDTH==8 ?
+                         { pipe_tx07_data_valid, pipe_tx06_data_valid, pipe_tx05_data_valid, pipe_tx04_data_valid, 
+                           pipe_tx03_data_valid, pipe_tx02_data_valid, pipe_tx01_data_valid, pipe_tx00_data_valid} :
+                          PL_LINK_CAP_MAX_LINK_WIDTH==4 ?
+                         { pipe_tx03_data_valid, pipe_tx02_data_valid, pipe_tx01_data_valid, pipe_tx00_data_valid} :
+                          PL_LINK_CAP_MAX_LINK_WIDTH==2 ?
+                         { pipe_tx01_data_valid, pipe_tx00_data_valid} : pipe_tx00_data_valid );
+
+assign PHY_TXSTART_BLOCK = ( PL_LINK_CAP_MAX_LINK_WIDTH==16 ?
+                         { pipe_tx15_start_block, pipe_tx15_start_block, pipe_tx15_start_block, pipe_tx15_start_block, 
+                           pipe_tx11_start_block, pipe_tx10_start_block, pipe_tx09_start_block, pipe_tx08_start_block,                      
+                           pipe_tx07_start_block, pipe_tx06_start_block, pipe_tx05_start_block, pipe_tx04_start_block, 
+                           pipe_tx03_start_block, pipe_tx02_start_block, pipe_tx01_start_block, pipe_tx00_start_block} :
+                          PL_LINK_CAP_MAX_LINK_WIDTH==8 ?
+                         { pipe_tx07_start_block, pipe_tx06_start_block, pipe_tx05_start_block, pipe_tx04_start_block, 
+                           pipe_tx03_start_block, pipe_tx02_start_block, pipe_tx01_start_block, pipe_tx00_start_block} :
+                          PL_LINK_CAP_MAX_LINK_WIDTH==4 ?
+                         { pipe_tx03_start_block, pipe_tx02_start_block, pipe_tx01_start_block, pipe_tx00_start_block} :
+                          PL_LINK_CAP_MAX_LINK_WIDTH==2 ?
+                         { pipe_tx01_start_block, pipe_tx00_start_block} : pipe_tx00_start_block );
+
+assign PHY_TXSYNC_HEADER = ( PL_LINK_CAP_MAX_LINK_WIDTH==16 ?
+                         { pipe_tx15_sync_header[1:0], pipe_tx14_sync_header[1:0], pipe_tx13_sync_header[1:0], pipe_tx12_sync_header[1:0], 
+                           pipe_tx11_sync_header[1:0], pipe_tx10_sync_header[1:0], pipe_tx09_sync_header[1:0], pipe_tx08_sync_header[1:0],
+                           pipe_tx07_sync_header[1:0], pipe_tx06_sync_header[1:0], pipe_tx05_sync_header[1:0], pipe_tx04_sync_header[1:0], 
+                           pipe_tx03_sync_header[1:0], pipe_tx02_sync_header[1:0], pipe_tx01_sync_header[1:0], pipe_tx00_sync_header[1:0]} :
+                          PL_LINK_CAP_MAX_LINK_WIDTH==8 ?
+                         { pipe_tx07_sync_header[1:0], pipe_tx06_sync_header[1:0], pipe_tx05_sync_header[1:0], pipe_tx04_sync_header[1:0], 
+                           pipe_tx03_sync_header[1:0], pipe_tx02_sync_header[1:0], pipe_tx01_sync_header[1:0], pipe_tx00_sync_header[1:0]} :
+                          PL_LINK_CAP_MAX_LINK_WIDTH==4 ?
+                         { pipe_tx03_sync_header[1:0], pipe_tx02_sync_header[1:0], pipe_tx01_sync_header[1:0], pipe_tx00_sync_header[1:0]} :
+                          PL_LINK_CAP_MAX_LINK_WIDTH==2 ?
+                         { pipe_tx01_sync_header[1:0], pipe_tx00_sync_header[1:0]} : pipe_tx00_sync_header[1:0] );
+
+assign PHY_TXELECIDLE = ( PL_LINK_CAP_MAX_LINK_WIDTH==16 ?
+                        { pipe_tx15_elec_idle, pipe_tx14_elec_idle, pipe_tx13_elec_idle, pipe_tx12_elec_idle, 
+                          pipe_tx11_elec_idle, pipe_tx10_elec_idle, pipe_tx09_elec_idle, pipe_tx08_elec_idle, 
+                          pipe_tx07_elec_idle, pipe_tx06_elec_idle, pipe_tx05_elec_idle, pipe_tx04_elec_idle, 
+                          pipe_tx03_elec_idle, pipe_tx02_elec_idle, pipe_tx01_elec_idle, pipe_tx00_elec_idle} :
+                          PL_LINK_CAP_MAX_LINK_WIDTH==8 ?
+                        { pipe_tx07_elec_idle, pipe_tx06_elec_idle, pipe_tx05_elec_idle, pipe_tx04_elec_idle, 
+                          pipe_tx03_elec_idle, pipe_tx02_elec_idle, pipe_tx01_elec_idle, pipe_tx00_elec_idle} :
+                          PL_LINK_CAP_MAX_LINK_WIDTH==4 ?
+                        { pipe_tx03_elec_idle, pipe_tx02_elec_idle, pipe_tx01_elec_idle, pipe_tx00_elec_idle} :
+                          PL_LINK_CAP_MAX_LINK_WIDTH==2 ?
+                        { pipe_tx01_elec_idle, pipe_tx00_elec_idle} : pipe_tx00_elec_idle );
+
+
+assign PHY_TXCOMPLIANCE = ( PL_LINK_CAP_MAX_LINK_WIDTH==16 ?
+                        { pipe_tx15_compliance, pipe_tx14_compliance, pipe_tx13_compliance, pipe_tx12_compliance, 
+                          pipe_tx11_compliance, pipe_tx10_compliance, pipe_tx09_compliance, pipe_tx08_compliance, 
+                          pipe_tx07_compliance, pipe_tx06_compliance, pipe_tx05_compliance, pipe_tx04_compliance, 
+                          pipe_tx03_compliance, pipe_tx02_compliance, pipe_tx01_compliance, pipe_tx00_compliance} :
+                          PL_LINK_CAP_MAX_LINK_WIDTH==8 ?
+                        { pipe_tx07_compliance, pipe_tx06_compliance, pipe_tx05_compliance, pipe_tx04_compliance, 
+                          pipe_tx03_compliance, pipe_tx02_compliance, pipe_tx01_compliance, pipe_tx00_compliance} :
+                          PL_LINK_CAP_MAX_LINK_WIDTH==4 ?
+                        { pipe_tx03_compliance, pipe_tx02_compliance, pipe_tx01_compliance, pipe_tx00_compliance} :
+                          PL_LINK_CAP_MAX_LINK_WIDTH==2 ?
+                        { pipe_tx01_compliance, pipe_tx00_compliance} : pipe_tx00_compliance );
+
+assign PHY_RXPOLARITY =  ( 
+                          PL_LINK_CAP_MAX_LINK_WIDTH==16 ?
+                        { pipe_rx15_polarity, pipe_rx14_polarity, pipe_rx13_polarity, pipe_rx12_polarity, 
+                          pipe_rx11_polarity, pipe_rx10_polarity, pipe_rx09_polarity, pipe_rx08_polarity, 
+                          pipe_rx07_polarity, pipe_rx06_polarity, pipe_rx05_polarity, pipe_rx04_polarity, 
+                          pipe_rx03_polarity, pipe_rx02_polarity, pipe_rx01_polarity, pipe_rx00_polarity} :
+                          PL_LINK_CAP_MAX_LINK_WIDTH==8 ?
+                        { pipe_rx07_polarity, pipe_rx06_polarity, pipe_rx05_polarity, pipe_rx04_polarity, 
+                          pipe_rx03_polarity, pipe_rx02_polarity, pipe_rx01_polarity, pipe_rx00_polarity} :
+                          PL_LINK_CAP_MAX_LINK_WIDTH==4 ?
+                        { pipe_rx03_polarity, pipe_rx02_polarity, pipe_rx01_polarity, pipe_rx00_polarity} :
+                          PL_LINK_CAP_MAX_LINK_WIDTH==2 ?
+                        { pipe_rx01_polarity, pipe_rx00_polarity} : pipe_rx00_polarity );
+
+assign PHY_TXEQ_CTRL = ( PL_LINK_CAP_MAX_LINK_WIDTH==16 ? 
+                          { pipe_tx15_eq_control, pipe_tx14_eq_control, pipe_tx13_eq_control, pipe_tx12_eq_control, 
+			    pipe_tx11_eq_control, pipe_tx10_eq_control, pipe_tx09_eq_control, pipe_tx08_eq_control, 
+			    pipe_tx07_eq_control, pipe_tx06_eq_control, pipe_tx05_eq_control, pipe_tx04_eq_control, 
+                            pipe_tx03_eq_control, pipe_tx02_eq_control, pipe_tx01_eq_control, pipe_tx00_eq_control} :
+                          PL_LINK_CAP_MAX_LINK_WIDTH==8 ?
+                          { pipe_tx07_eq_control, pipe_tx06_eq_control, pipe_tx05_eq_control, pipe_tx04_eq_control, 
+                            pipe_tx03_eq_control, pipe_tx02_eq_control, pipe_tx01_eq_control, pipe_tx00_eq_control} :
+                          PL_LINK_CAP_MAX_LINK_WIDTH==4 ?
+                          { pipe_tx03_eq_control, pipe_tx02_eq_control, pipe_tx01_eq_control, pipe_tx00_eq_control} :
+                          PL_LINK_CAP_MAX_LINK_WIDTH==2 ?
+                          { pipe_tx01_eq_control, pipe_tx00_eq_control} : pipe_tx00_eq_control );
+
+assign PHY_TXEQ_PRESET = (  PL_LINK_CAP_MAX_LINK_WIDTH==16 ?
+                          { pipe_tx15_eq_deemph[3:0], pipe_tx14_eq_deemph[3:0], pipe_tx13_eq_deemph[3:0], pipe_tx12_eq_deemph[3:0],
+                            pipe_tx11_eq_deemph[3:0], pipe_tx10_eq_deemph[3:0], pipe_tx09_eq_deemph[3:0], pipe_tx08_eq_deemph[3:0],
+                            pipe_tx07_eq_deemph[3:0], pipe_tx06_eq_deemph[3:0], pipe_tx05_eq_deemph[3:0], pipe_tx04_eq_deemph[3:0],
+                            pipe_tx03_eq_deemph[3:0], pipe_tx02_eq_deemph[3:0], pipe_tx01_eq_deemph[3:0], pipe_tx00_eq_deemph[3:0]} :
+                          PL_LINK_CAP_MAX_LINK_WIDTH==8 ?
+                          { pipe_tx07_eq_deemph[3:0], pipe_tx06_eq_deemph[3:0], pipe_tx05_eq_deemph[3:0], pipe_tx04_eq_deemph[3:0],
+                            pipe_tx03_eq_deemph[3:0], pipe_tx02_eq_deemph[3:0], pipe_tx01_eq_deemph[3:0], pipe_tx00_eq_deemph[3:0]} :
+                          PL_LINK_CAP_MAX_LINK_WIDTH==4 ?
+                          { pipe_tx03_eq_deemph[3:0], pipe_tx02_eq_deemph[3:0], pipe_tx01_eq_deemph[3:0], pipe_tx00_eq_deemph[3:0]} :
+                          PL_LINK_CAP_MAX_LINK_WIDTH==2 ?
+                          { pipe_tx01_eq_deemph[3:0], pipe_tx00_eq_deemph[3:0]} :  pipe_tx00_eq_deemph[3:0] );
+
+assign PHY_TXEQ_COEFF = ( PL_LINK_CAP_MAX_LINK_WIDTH==16 ?
+                          { pipe_tx15_eq_deemph, pipe_tx14_eq_deemph, pipe_tx13_eq_deemph, pipe_tx12_eq_deemph,
+                            pipe_tx11_eq_deemph, pipe_tx10_eq_deemph, pipe_tx09_eq_deemph, pipe_tx08_eq_deemph,
+                            pipe_tx07_eq_deemph, pipe_tx06_eq_deemph, pipe_tx05_eq_deemph, pipe_tx04_eq_deemph,
+                            pipe_tx03_eq_deemph, pipe_tx02_eq_deemph, pipe_tx01_eq_deemph, pipe_tx00_eq_deemph} :
+                          PL_LINK_CAP_MAX_LINK_WIDTH==8 ?
+                          { pipe_tx07_eq_deemph, pipe_tx06_eq_deemph, pipe_tx05_eq_deemph, pipe_tx04_eq_deemph,
+                            pipe_tx03_eq_deemph, pipe_tx02_eq_deemph, pipe_tx01_eq_deemph, pipe_tx00_eq_deemph} :
+                          PL_LINK_CAP_MAX_LINK_WIDTH==4 ?
+                          { pipe_tx03_eq_deemph, pipe_tx02_eq_deemph, pipe_tx01_eq_deemph, pipe_tx00_eq_deemph} :
+                          PL_LINK_CAP_MAX_LINK_WIDTH==2 ?
+                          { pipe_tx01_eq_deemph, pipe_tx00_eq_deemph} : pipe_tx00_eq_deemph );
+
+assign PHY_RXEQ_CTRL = ( PL_LINK_CAP_MAX_LINK_WIDTH==16 ?
+                          { pipe_rx15_eq_control, pipe_rx14_eq_control, pipe_rx13_eq_control, pipe_rx12_eq_control, 
+                            pipe_rx11_eq_control, pipe_rx10_eq_control, pipe_rx09_eq_control, pipe_rx08_eq_control, 
+                            pipe_rx07_eq_control, pipe_rx06_eq_control, pipe_rx05_eq_control, pipe_rx04_eq_control, 
+                            pipe_rx03_eq_control, pipe_rx02_eq_control, pipe_rx01_eq_control, pipe_rx00_eq_control} :
+                          PL_LINK_CAP_MAX_LINK_WIDTH==8 ?
+                          { pipe_rx07_eq_control, pipe_rx06_eq_control, pipe_rx05_eq_control, pipe_rx04_eq_control, 
+                            pipe_rx03_eq_control, pipe_rx02_eq_control, pipe_rx01_eq_control, pipe_rx00_eq_control} :
+                          PL_LINK_CAP_MAX_LINK_WIDTH==4 ?
+                          { pipe_rx03_eq_control, pipe_rx02_eq_control, pipe_rx01_eq_control, pipe_rx00_eq_control} :
+                          PL_LINK_CAP_MAX_LINK_WIDTH==2 ?
+                          { pipe_rx01_eq_control, pipe_rx00_eq_control} : pipe_rx00_eq_control );
+
+endmodule
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2023 AMD, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD, Inc. and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : UltraScale+ FPGA PCI Express v4.0 Integrated Block
+// File       : xp4_usp_smsw_phy_top.v
+// Version    : 1.1 
+//-----------------------------------------------------------------------------
+/*****************************************************************************
+** Description:
+**    PCIe Gen4 PHY supports:
+**       - Gen1: per-lane 16b @ 125MHz
+**       - Gen2: per-lane 16b @ 250MHz
+**       - Gen3: per-lane 32b @ 250Mhz
+**       - Gen4: per-lane 64b @ 250MHz
+**
+******************************************************************************/
+//--------------------------------------------------------------------------------------------------
+//  Design :  PHY Wrapper
+//  Module :  PHY Wrapper
+//--------------------------------------------------------------------------------------------------
+
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_phy_top #(
+   // Parameters
+   parameter         FPGA_FAMILY       = "US",     // "US" = UltraScale; "USM" = Diablo
+   parameter         FPGA_XCVR         = "H",      // "H" = GTH; "Y" = GTY; "Y64" = GTY-64b
+   parameter integer PIPELINE_STAGES   = 0,        // 0 = no pipeline; 1 = 1 stage; 2 = 2 stages; 3 = 3 stages
+   parameter         PHY_SIM_EN        = "FALSE",  // "FALSE" = Normal; "TRUE"  = Simulation
+   parameter integer PHY_LANE          = 1,        // Valid settings: 1, 2, 4, 8, 16(only for Gen1/2/3)
+   parameter integer PHY_MAX_SPEED     = 3,        // 1 = Gen1 Capable; 2 = Gen2 Capable; 3 = Gen3 Capable; 4 = Gen4 Capable   
+   parameter         PHY_ASYNC_EN      = "FALSE",  // "FALSE" = Sync Clocking; "TRUE"  = Async Clocking
+   parameter         PHY_REFCLK_FREQ   = 0,        // 0 = 100 MHz; 1 = 125 MHz; 2 = 250 MHz
+   parameter integer PHY_CORECLK_FREQ  = 2,        // 1 = 250 MHz; 2 = 500 MHz
+   parameter integer PHY_USERCLK_FREQ  = 3,        // 1 = 62.5 MHz; 2 = 125 MHz; 3 = 250 MHz; 4 = 500 MHz
+   parameter integer PHY_MCAPCLK_FREQ  = 2,        // 1 = 62.5 MHz; 2 = 125 MHz
+   parameter integer PHY_GT_TXPRESET   = 0,        // Valid settings: 0 to 10
+   parameter integer PHY_LP_TXPRESET   = 5         // Valid settings: 5
+)  (                                                         
+   // Clock & Reset
+   input  wire                         PHY_REFCLK,          
+   input  wire                         PHY_GTREFCLK,     
+   input  wire                         PHY_RST_N,           
+   
+   output wire                         PHY_CORECLK, 
+   output wire                         PHY_USERCLK,                          
+   output wire                         PHY_MCAPCLK,                          
+   output wire                         PHY_PCLK,  
+  
+   // TX Data 
+   input  wire [(PHY_LANE*64)-1:0]     PHY_TXDATA,            
+   input  wire [(PHY_LANE* 2)-1:0]     PHY_TXDATAK,    
+   input  wire [PHY_LANE-1:0]          PHY_TXDATA_VALID,
+   input  wire [PHY_LANE-1:0]          PHY_TXSTART_BLOCK,      
+   input  wire [(PHY_LANE* 2)-1:0]     PHY_TXSYNC_HEADER,                    
+
+   output wire [PHY_LANE-1:0]          PHY_TXP,    // Serial Line      
+   output wire [PHY_LANE-1:0]          PHY_TXN,    // Serial Line  
+
+   // RX Data
+   input  wire [PHY_LANE-1:0]          PHY_RXP,    // Serial Line           
+   input  wire [PHY_LANE-1:0]          PHY_RXN,    // Serial Line
+
+   output wire [(PHY_LANE*64)-1:0]     PHY_RXDATA,            
+   output wire [(PHY_LANE* 2)-1:0]     PHY_RXDATAK,       
+   output wire [PHY_LANE-1:0]          PHY_RXDATA_VALID,         
+   output wire [(PHY_LANE* 2)-1:0]     PHY_RXSTART_BLOCK,        
+   output wire [(PHY_LANE* 2)-1:0]     PHY_RXSYNC_HEADER,        
+
+   // PHY Command
+   input  wire                         PHY_TXDETECTRX,        
+   input  wire [PHY_LANE-1:0]          PHY_TXELECIDLE,        
+   input  wire [PHY_LANE-1:0]          PHY_TXCOMPLIANCE,      
+   input  wire [PHY_LANE-1:0]          PHY_RXPOLARITY,        
+   input  wire [1:0]                   PHY_POWERDOWN,         
+   input  wire [1:0]                   PHY_RATE,              
+    
+   // PHY Status
+   output wire [PHY_LANE-1:0]          PHY_RXVALID,               
+   output wire [PHY_LANE-1:0]          PHY_PHYSTATUS,          
+   output wire                         PHY_PHYSTATUS_RST,         
+   output wire [PHY_LANE-1:0]          PHY_RXELECIDLE,         
+   output wire [(PHY_LANE*3)-1:0]      PHY_RXSTATUS,                       
+    
+   // TX Driver
+   input  wire [ 2:0]                  PHY_TXMARGIN,          
+   input  wire                         PHY_TXSWING,           
+   input  wire                         PHY_TXDEEMPH,    
+    
+   // TX Equalization (Gen3/4)
+   input  wire [(PHY_LANE*2)-1:0]      PHY_TXEQ_CTRL,      
+   input  wire [(PHY_LANE*4)-1:0]      PHY_TXEQ_PRESET,       
+   input  wire [(PHY_LANE*6)-1:0]      PHY_TXEQ_COEFF,                                                            
+
+   output wire [ 5:0]                  PHY_TXEQ_FS,           
+   output wire [ 5:0]                  PHY_TXEQ_LF,           
+   output wire [(PHY_LANE*18)-1:0]     PHY_TXEQ_NEW_COEFF,        
+   output wire [PHY_LANE-1:0]          PHY_TXEQ_DONE,         
+
+   // RX Equalization (Gen3/4)
+   input  wire [(PHY_LANE*2)-1:0]      PHY_RXEQ_CTRL,     
+   input  wire [(PHY_LANE*4)-1:0]      PHY_RXEQ_TXPRESET,      
+
+   output wire [PHY_LANE-1:0]          PHY_RXEQ_PRESET_SEL,    
+   output wire [(PHY_LANE*18)-1:0]     PHY_RXEQ_NEW_TXCOEFF,   
+   output wire [PHY_LANE-1:0]          PHY_RXEQ_ADAPT_DONE,     
+   output wire [PHY_LANE-1:0]          PHY_RXEQ_DONE,
+
+   // Assist Signals
+   input  wire                         AS_MAC_IN_DETECT,
+   input  wire                         AS_CDR_HOLD_REQ
+   );
+
+   localparam  TCQ   = 1;
+
+   wire                 phy_userclk_int;
+   wire                 phy_mcapclk_int;
+   wire                 phy_pclk;
+   wire                 phy_pclk2;
+   wire  [PHY_LANE-1:0]          phy_rxvalid_pclk2;
+   wire  [PHY_LANE-1:0]          phy_phystatus_pclk2;
+   wire                 phy_phystatus_rst_pclk2;
+   wire  [(PHY_LANE* 3)-1:0]     phy_rxstatus_pclk2;
+   wire  [5:0]          phy_txeq_fs_pclk2;
+   wire  [5:0]          phy_txeq_lf_pclk2;
+   wire  [(PHY_LANE* 18)-1:0]    phy_txeq_new_coeff_pclk2;
+   wire  [PHY_LANE-1:0]          phy_txeq_done_pclk2;
+   wire  [PHY_LANE-1:0]          phy_rxeq_preset_sel_pclk2;
+   wire  [(PHY_LANE* 18)-1:0]    phy_rxeq_new_txcoeff_pclk2;
+   wire  [PHY_LANE-1:0]          phy_rxeq_done_pclk2;
+   wire  [PHY_LANE-1:0]          phy_rxeq_adapt_done_pclk2;
+
+   wire                 phy_txdetectrx_32b;
+   wire  [PHY_LANE-1:0]          phy_txelecidle_32b;
+   wire  [PHY_LANE-1:0]          phy_txcompliance_32b;
+   wire  [PHY_LANE-1:0]          phy_rxpolarity_32b;
+   wire  [1:0]          phy_powerdown_32b;
+   wire  [1:0]          phy_rate_32b;
+
+   wire  [(PHY_LANE*32)-1:0]     phy_txdata_32b;            
+   wire  [(PHY_LANE* 2)-1:0]     phy_txdatak_32b;            
+   wire  [PHY_LANE-1:0]          phy_txdata_valid_32b;
+   wire  [PHY_LANE-1:0]          phy_txstart_block_32b;      
+   wire  [(PHY_LANE* 2)-1:0]     phy_txsync_header_32b;  
+   wire  [(PHY_LANE*2)-1:0]      phy_txeq_ctrl_pclk2;            
+   wire  [(PHY_LANE*4)-1:0]      phy_txeq_preset_pclk2;            
+   wire  [(PHY_LANE*6)-1:0]      phy_txeq_coeff_pclk2;
+
+   wire  [(PHY_LANE*64)-1:0]     phy_txdata_64b;            
+
+   wire  [(PHY_LANE*32)-1:0]     phy_rxdata_32b;            
+   wire  [(PHY_LANE* 2)-1:0]     phy_rxdatak_32b;            
+   wire  [PHY_LANE-1:0]          phy_rxdata_valid_32b;
+   wire  [PHY_LANE-1:0]          phy_rxstart_block_32b;      
+   wire  [(PHY_LANE* 2)-1:0]     phy_rxsync_header_32b; 
+
+   wire  [(PHY_LANE*64)-1:0]     phy_rxdata_64b;            
+   wire  [(PHY_LANE* 2)-1:0]     phy_rxstart_block_64b;      
+
+   wire  [(PHY_LANE*64)-1:0]     phy_txdata_pl;            
+   wire  [(PHY_LANE* 2)-1:0]     phy_txdatak_pl;            
+   wire  [PHY_LANE-1:0]          phy_txdata_valid_pl;
+   wire  [PHY_LANE-1:0]          phy_txstart_block_pl;      
+   wire  [(PHY_LANE* 2)-1:0]     phy_txsync_header_pl;  
+
+   wire  [(PHY_LANE*64)-1:0]     phy_rxdata_pl;            
+   wire  [(PHY_LANE* 2)-1:0]     phy_rxdatak_pl;            
+   wire  [PHY_LANE-1:0]          phy_rxdata_valid_pl;
+   wire  [(PHY_LANE* 2)-1:0]     phy_rxstart_block_pl;      
+   wire  [(PHY_LANE* 2)-1:0]     phy_rxsync_header_pl; 
+
+   wire                 phy_txdetectrx_pl;        
+   wire  [PHY_LANE-1:0]          phy_txelecidle_pl;        
+   wire  [PHY_LANE-1:0]          phy_txcompliance_pl;      
+   wire  [PHY_LANE-1:0]          phy_rxpolarity_pl;        
+   wire  [1:0]          phy_powerdown_pl;         
+   wire  [1:0]          phy_rate_pl;   
+
+   wire  [PHY_LANE-1:0]          phy_rxvalid_pl;               
+   wire  [PHY_LANE-1:0]          phy_phystatus_pl;          
+   wire  [PHY_LANE-1:0]          phy_rxelecidle_pl;         
+   wire  [(PHY_LANE*3)-1:0]      phy_rxstatus_pl;          
+
+   wire  [ 2:0]         phy_txmargin_pl;          
+   wire                 phy_txswing_pl;           
+   wire                 phy_txdeemph_pl;  
+
+   wire  [(PHY_LANE*2)-1:0]      phy_txeq_ctrl_pl;      
+   wire  [(PHY_LANE*4)-1:0]      phy_txeq_preset_pl;       
+   wire  [(PHY_LANE*6)-1:0]      phy_txeq_coeff_pl;                                                            
+
+   wire  [ 5:0]         phy_txeq_fs_pl;           
+   wire  [ 5:0]         phy_txeq_lf_pl;           
+   wire  [(PHY_LANE*18)-1:0]     phy_txeq_new_coeff_pl;        
+   wire  [PHY_LANE-1:0]          phy_txeq_done_pl;         
+
+   wire  [(PHY_LANE*2)-1:0]      phy_rxeq_ctrl_pl;     
+   wire  [(PHY_LANE*4)-1:0]      phy_rxeq_txpreset_pl;      
+
+   wire  [PHY_LANE-1:0]          phy_rxeq_preset_sel_pl;    
+   wire  [(PHY_LANE*18)-1:0]     phy_rxeq_new_txcoeff_pl;   
+   wire  [PHY_LANE-1:0]          phy_rxeq_adapt_done_pl;     
+   wire  [PHY_LANE-1:0]          phy_rxeq_done_pl;
+
+   wire                 as_mac_in_detect_pl;
+   wire                 as_cdr_hold_req_pl;
+
+   wire  [PHY_LANE-1:0]          com_det_lower;
+   wire  [PHY_LANE-1:0]          com_det_upper;
+   wire  [PHY_LANE-1:0]          idl_det_lower;
+   wire  [PHY_LANE-1:0]          idl_det_upper;
+   wire  [PHY_LANE-1:0]          eios_det_c0;
+   wire  [PHY_LANE-1:0]          eios_det_c1;
+   wire  [PHY_LANE-1:0]          eios_det_c2;
+   wire  [PHY_LANE-1:0]          eios_det_c3;
+   wire  [(PHY_LANE* 3)-1:0]     phy_rxstatus_raw;
+
+   reg                  phy_rxelecidle_ff;
+   reg                  phy_rxelecidle_ff2;
+   reg                  phy_rxcdrhold_wire;
+   reg                  phy_rxcdrhold_pclk2;
+
+   reg   [PHY_LANE-1:0]          phy_rxstatus_mask_wire, phy_rxstatus_mask;
+   reg   [PHY_LANE-1:0]          saved_com_det_lower_wire, saved_com_det_lower;
+   reg   [PHY_LANE-1:0]          saved_com_det_upper_wire, saved_com_det_upper;
+
+   //--------------------------------------------------------------------------
+   //  Pipeline Stages
+   //--------------------------------------------------------------------------        
+   (* keep = "true", max_fanout = 500 *) wire   phy_phystatus_rst_int;
+   assign phy_phystatus_rst_int  = PHY_PHYSTATUS_RST;
+
+      // Programmable stages to ease GT lane routing
+      xp4_usp_smsw_phy_pipeline #(
+         //  Parameters
+         .PIPELINE_STAGES  ( PIPELINE_STAGES ),
+         .PHY_LANE         ( PHY_LANE ),
+         .TCQ              ( TCQ )
+      ) phy_pipeline_smsw (                                         
+         // Clock & Reset Ports
+         .phy_pclk               ( PHY_PCLK ),  
+         .phy_rst                ( phy_phystatus_rst_int ),  
+
+         // TX Data
+         .phy_txdata_i           ( PHY_TXDATA ),
+         .phy_txdatak_i          ( PHY_TXDATAK ),
+         .phy_txdata_valid_i     ( PHY_TXDATA_VALID ),
+         .phy_txstart_block_i    ( PHY_TXSTART_BLOCK ),
+         .phy_txsync_header_i    ( PHY_TXSYNC_HEADER ),
+
+         .phy_txdata_o           ( phy_txdata_pl ),
+         .phy_txdatak_o          ( phy_txdatak_pl ),
+         .phy_txdata_valid_o     ( phy_txdata_valid_pl ),
+         .phy_txstart_block_o    ( phy_txstart_block_pl ),
+         .phy_txsync_header_o    ( phy_txsync_header_pl ),
+
+         // RX Data
+         .phy_rxdata_i           ( phy_rxdata_pl ),            
+         .phy_rxdatak_i          ( phy_rxdatak_pl ),       
+         .phy_rxdata_valid_i     ( phy_rxdata_valid_pl ),         
+         .phy_rxstart_block_i    ( phy_rxstart_block_pl ),        
+         .phy_rxsync_header_i    ( phy_rxsync_header_pl ),   
+
+         .phy_rxdata_o           ( PHY_RXDATA ),            
+         .phy_rxdatak_o          ( PHY_RXDATAK ),       
+         .phy_rxdata_valid_o     ( PHY_RXDATA_VALID ),         
+         .phy_rxstart_block_o    ( PHY_RXSTART_BLOCK ),        
+         .phy_rxsync_header_o    ( PHY_RXSYNC_HEADER ),   
+
+         //  PHY Command
+         .phy_txdetectrx_i       ( PHY_TXDETECTRX ),  
+         .phy_txelecidle_i       ( PHY_TXELECIDLE ),                    
+         .phy_txcompliance_i     ( PHY_TXCOMPLIANCE ), 
+         .phy_rxpolarity_i       ( PHY_RXPOLARITY ),
+         .phy_powerdown_i        ( PHY_POWERDOWN ), 
+         .phy_rate_i             ( PHY_RATE ),
+
+         .phy_txdetectrx_o       ( phy_txdetectrx_pl ),  
+         .phy_txelecidle_o       ( phy_txelecidle_pl ),                    
+         .phy_txcompliance_o     ( phy_txcompliance_pl ), 
+         .phy_rxpolarity_o       ( phy_rxpolarity_pl ),
+         .phy_powerdown_o        ( phy_powerdown_pl ), 
+         .phy_rate_o             ( phy_rate_pl ),    
+
+         //  PHY Status
+         .phy_rxvalid_i          ( phy_rxvalid_pl ),
+         .phy_phystatus_i        ( phy_phystatus_pl ),
+         .phy_rxelecidle_i       ( phy_rxelecidle_pl ), 
+         .phy_rxstatus_i         ( phy_rxstatus_pl ),
+
+         .phy_rxvalid_o          ( PHY_RXVALID ),
+         .phy_phystatus_o        ( PHY_PHYSTATUS ),
+         .phy_rxelecidle_o       ( PHY_RXELECIDLE ), 
+         .phy_rxstatus_o         ( PHY_RXSTATUS ),
+        
+         //  TX Driver
+         .phy_txmargin_i         ( PHY_TXMARGIN ),          
+         .phy_txswing_i          ( PHY_TXSWING ),           
+         .phy_txdeemph_i         ( PHY_TXDEEMPH ),   
+
+         .phy_txmargin_o         ( phy_txmargin_pl ),          
+         .phy_txswing_o          ( phy_txswing_pl ),           
+         .phy_txdeemph_o         ( phy_txdeemph_pl ),        
+
+         //  TX Equalization (Gen3/4)
+         .phy_txeq_ctrl_i        ( PHY_TXEQ_CTRL ),
+         .phy_txeq_preset_i      ( PHY_TXEQ_PRESET ),
+         .phy_txeq_coeff_i       ( PHY_TXEQ_COEFF ), 
+
+         .phy_txeq_ctrl_o        ( phy_txeq_ctrl_pl ),
+         .phy_txeq_preset_o      ( phy_txeq_preset_pl ),
+         .phy_txeq_coeff_o       ( phy_txeq_coeff_pl ), 
+
+         .phy_txeq_fs_i          ( phy_txeq_fs_pl ),           
+         .phy_txeq_lf_i          ( phy_txeq_lf_pl ),           
+         .phy_txeq_new_coeff_i   ( phy_txeq_new_coeff_pl ),
+         .phy_txeq_done_i        ( phy_txeq_done_pl ),
+
+         .phy_txeq_fs_o          ( PHY_TXEQ_FS ),           
+         .phy_txeq_lf_o          ( PHY_TXEQ_LF ),           
+         .phy_txeq_new_coeff_o   ( PHY_TXEQ_NEW_COEFF ),
+         .phy_txeq_done_o        ( PHY_TXEQ_DONE ),   
+
+         //  RX Equalization (Gen3/4)
+         .phy_rxeq_ctrl_i        ( PHY_RXEQ_CTRL ), 
+         .phy_rxeq_txpreset_i    ( PHY_RXEQ_TXPRESET ),
+
+         .phy_rxeq_ctrl_o        ( phy_rxeq_ctrl_pl ), 
+         .phy_rxeq_txpreset_o    ( phy_rxeq_txpreset_pl ),
+
+         .phy_rxeq_preset_sel_i  ( phy_rxeq_preset_sel_pl ),
+         .phy_rxeq_new_txcoeff_i ( phy_rxeq_new_txcoeff_pl ),
+         .phy_rxeq_adapt_done_i  ( phy_rxeq_adapt_done_pl ),
+         .phy_rxeq_done_i        ( phy_rxeq_done_pl ),
+
+         .phy_rxeq_preset_sel_o  ( PHY_RXEQ_PRESET_SEL ),
+         .phy_rxeq_new_txcoeff_o ( PHY_RXEQ_NEW_TXCOEFF ),
+         .phy_rxeq_adapt_done_o  ( PHY_RXEQ_ADAPT_DONE ),
+         .phy_rxeq_done_o        ( PHY_RXEQ_DONE ),
+
+         // Assist Signals
+         .as_mac_in_detect_i     ( AS_MAC_IN_DETECT ),
+         .as_cdr_hold_req_i      ( AS_CDR_HOLD_REQ ),
+
+         .as_mac_in_detect_o     ( as_mac_in_detect_pl ),
+         .as_cdr_hold_req_o      ( as_cdr_hold_req_pl )
+      );
+
+
+         assign phy_txdetectrx_32b     = phy_txdetectrx_pl;
+         assign phy_txelecidle_32b     = phy_txelecidle_pl;
+         assign phy_txcompliance_32b   = phy_txcompliance_pl;
+         assign phy_rxpolarity_32b     = phy_rxpolarity_pl;
+         assign phy_powerdown_32b      = phy_powerdown_pl;
+         assign phy_rate_32b           = phy_rate_pl;
+         assign phy_txdata_64b         = phy_txdata_pl;
+         assign phy_txdatak_32b        = phy_txdatak_pl;
+         assign phy_txdata_valid_32b   = phy_txdata_valid_pl;
+         assign phy_txstart_block_32b  = phy_txstart_block_pl;
+         assign phy_txsync_header_32b  = phy_txsync_header_pl;
+         assign phy_txeq_ctrl_pclk2    = phy_txeq_ctrl_pl;
+         assign phy_txeq_preset_pclk2  = phy_txeq_preset_pl;
+         assign phy_txeq_coeff_pclk2   = phy_txeq_coeff_pl;
+         assign PHY_PCLK               = phy_pclk2;
+         assign phy_rxdata_pl          = phy_rxdata_64b;          // 64b
+         assign phy_rxdatak_pl         = phy_rxdatak_32b;
+         assign phy_rxdata_valid_pl    = phy_rxdata_valid_32b;
+         assign phy_rxstart_block_pl   = phy_rxstart_block_64b;   // 2b
+         assign phy_rxsync_header_pl   = phy_rxsync_header_32b;
+         assign phy_rxvalid_pl         = phy_rxvalid_pclk2;
+         assign phy_phystatus_pl       = phy_phystatus_pclk2;
+         assign PHY_PHYSTATUS_RST      = phy_phystatus_rst_pclk2;
+         assign phy_rxstatus_raw       = phy_rxstatus_pclk2;
+         assign phy_txeq_fs_pl         = phy_txeq_fs_pclk2;
+         assign phy_txeq_lf_pl         = phy_txeq_lf_pclk2;
+         assign phy_txeq_new_coeff_pl  = phy_txeq_new_coeff_pclk2;
+         assign phy_txeq_done_pl       = phy_txeq_done_pclk2;
+         assign phy_rxeq_preset_sel_pl = phy_rxeq_preset_sel_pclk2;
+         assign phy_rxeq_new_txcoeff_pl= phy_rxeq_new_txcoeff_pclk2;
+         assign phy_rxeq_done_pl       = phy_rxeq_done_pclk2;
+         assign phy_rxeq_adapt_done_pl = phy_rxeq_adapt_done_pclk2;
+
+ 
+
+   //--------------------------------------------------------------------------
+   //  CDRHOLD Logic
+   //--------------------------------------------------------------------------  
+
+   `PHYREG(phy_pclk2, phy_phystatus_rst_pclk2, phy_rxelecidle_ff, phy_rxelecidle_pl[0], 'd1)
+   `PHYREG(phy_pclk2, phy_phystatus_rst_pclk2, phy_rxelecidle_ff2, phy_rxelecidle_ff, 'd1)
+
+   always @(*) begin 
+      if (as_cdr_hold_req_pl & phy_rxelecidle_pl[0]) begin
+         phy_rxcdrhold_wire   = 1'b1;
+      end else if (phy_rxelecidle_ff2 & ~phy_rxelecidle_pl[0]) begin
+         phy_rxcdrhold_wire   = 1'b0;
+      end else begin
+         phy_rxcdrhold_wire   = phy_rxcdrhold_pclk2;
+      end
+   end
+
+   `PHYREG(phy_pclk2, phy_phystatus_rst_pclk2, phy_rxcdrhold_pclk2, phy_rxcdrhold_wire, 'd0)
+
+   //--------------------------------------------------------------------------
+   // Mask invalid RXSTATUS for Gen1/2 after EIOS, can be removed once GT fixes it
+   //--------------------------------------------------------------------------
+
+   assign phy_rxstatus_pl = phy_rxstatus_raw;
+
+
+   //--------------------------------------------------------------------------
+   //  UltraScale GTH PHY Wrapper
+   //--------------------------------------------------------------------------   
+
+   wire [((((PHY_LANE-1)>>2)+1)*16)-1:0]  gtcom_drpaddr_tie_off   = 'd0;
+   wire [(PHY_LANE-1)>>2:0]               gtcom_drpen_tie_off     = 'd0;
+   wire [(PHY_LANE-1)>>2:0]               gtcom_drpwe_tie_off     = 'd0;
+   wire [((((PHY_LANE-1)>>2)+1)*16)-1:0]  gtcom_drpdi_tie_off     = 'd0;
+
+   assign PHY_USERCLK   = ((PHY_USERCLK_FREQ == 3 && PHY_CORECLK_FREQ == 1) ||
+                           (PHY_USERCLK_FREQ == 4 && PHY_CORECLK_FREQ == 2))  ? PHY_CORECLK : phy_userclk_int;
+
+   assign PHY_MCAPCLK   = ((PHY_MCAPCLK_FREQ == 1 && PHY_USERCLK_FREQ == 1) ||
+                           (PHY_MCAPCLK_FREQ == 2 && PHY_USERCLK_FREQ == 2))  ? phy_userclk_int : phy_mcapclk_int;
+
+   generate
+      if (FPGA_FAMILY == "USM") begin: diablo_gt
+         xp4_usp_smsw_gt_phy_wrapper #(
+            // Parameters
+            .PHY_SIM_EN       ( PHY_SIM_EN ),     
+            .PHY_GT_XCVR      ( (FPGA_XCVR == "Y")? "GTY": "GTH" ),
+            .PHY_REFCLK_MODE  ( (PHY_ASYNC_EN == "FALSE")? 0: 1 ),
+            .PHY_LANE         ( PHY_LANE ),   
+            .PHY_MAX_SPEED    ( PHY_MAX_SPEED ),                    
+            .PHY_REFCLK_FREQ  ( PHY_REFCLK_FREQ ),           
+            .PHY_CORECLK_FREQ ( PHY_CORECLK_FREQ ),       
+            .PHY_USERCLK_FREQ ( PHY_USERCLK_FREQ ),   
+            .PHY_MCAPCLK_FREQ ( PHY_MCAPCLK_FREQ ),
+            .PHY_GT_TXPRESET  ( PHY_GT_TXPRESET ),
+            .PHY_LP_TXPRESET  ( PHY_LP_TXPRESET )
+         ) diablo_gt_phy_wrapper_smsw (                                         
+            // Clock & Reset Ports
+            .PHY_REFCLK             ( PHY_REFCLK ),      
+            .PHY_GTREFCLK           ( PHY_GTREFCLK ),               
+            .PHY_RST_N              ( PHY_RST_N ),  
+      
+            .PHY_PCLK               ( phy_pclk2 ),  
+            .PHY_PCLK2              ( phy_pclk ),  
+            .PHY_CORECLK            ( PHY_CORECLK ), 
+            .PHY_USERCLK            ( phy_userclk_int ),                          
+            .PHY_MCAPCLK            ( phy_mcapclk_int ), // New in Diablo
+                                                     
+            // Serial Line Ports
+            .PHY_RXP                ( PHY_RXP ),               
+            .PHY_RXN                ( PHY_RXN ),               
+                               
+            .PHY_TXP                ( PHY_TXP ),               
+            .PHY_TXN                ( PHY_TXN ),   
+                                                                             
+            // TX Data Ports 
+            .PHY_TXDATA             ( phy_txdata_64b ),            
+            .PHY_TXDATAK            ( phy_txdatak_32b ),                
+            .PHY_TXDATA_VALID       ( phy_txdata_valid_32b ),                
+            .PHY_TXSTART_BLOCK      ( phy_txstart_block_32b ),                      
+            .PHY_TXSYNC_HEADER      ( phy_txsync_header_32b ),                                          
+      
+            // RX Data Ports 
+            .PHY_RXDATA             ( phy_rxdata_64b ),            
+            .PHY_RXDATAK            ( phy_rxdatak_32b ),                
+            .PHY_RXDATA_VALID       ( phy_rxdata_valid_32b ),                
+            .PHY_RXSTART_BLOCK      ( phy_rxstart_block_64b ),                      
+            .PHY_RXSYNC_HEADER      ( phy_rxsync_header_32b ),                                          
+      
+            // PHY Command Port
+            .PHY_TXDETECTRX         ( phy_txdetectrx_32b ),
+            .PHY_TXELECIDLE         ( phy_txelecidle_32b ),                    
+            .PHY_TXCOMPLIANCE       ( phy_txcompliance_32b ),                          
+            .PHY_RXPOLARITY         ( phy_rxpolarity_32b ),            
+            .PHY_POWERDOWN          ( phy_powerdown_32b ),
+            .PHY_RATE               ( phy_rate_32b ),  
+            .PHY_RXCDRHOLD          ( phy_rxcdrhold_pclk2 ),
+          
+            // PHY Status Ports
+            .PHY_RXVALID            ( phy_rxvalid_pclk2 ),            
+            .PHY_PHYSTATUS          ( phy_phystatus_pclk2 ),            
+      
+            .PHY_PHYSTATUS_RST      ( phy_phystatus_rst_pclk2 ),
+            .PHY_RXELECIDLE         ( phy_rxelecidle_pl ),                    
+            .PHY_RXSTATUS           ( phy_rxstatus_pclk2 ),                                            
+          
+            // TX Driver Ports
+            .PHY_TXMARGIN           ( phy_txmargin_pl ),          
+            .PHY_TXSWING            ( phy_txswing_pl ),   
+            .PHY_TXDEEMPH           ( {1'b0, phy_txdeemph_pl} ),  // 2b in Diablo   
+      
+            // TX Equalization Ports for Gen3
+            .PHY_TXEQ_CTRL          ( phy_txeq_ctrl_pclk2 ),
+            .PHY_TXEQ_PRESET        ( phy_txeq_preset_pclk2 ),
+            .PHY_TXEQ_COEFF         ( phy_txeq_coeff_pclk2 ),
+      
+            .PHY_TXEQ_FS            ( phy_txeq_fs_pclk2 ),           
+            .PHY_TXEQ_LF            ( phy_txeq_lf_pclk2 ),           
+            .PHY_TXEQ_NEW_COEFF     ( phy_txeq_new_coeff_pclk2 ),
+            .PHY_TXEQ_DONE          ( phy_txeq_done_pclk2 ),
+                                                                       
+            // RX Equalization Ports for Gen3
+            .PHY_RXEQ_CTRL          ( phy_rxeq_ctrl_pl ), 
+            .PHY_RXEQ_PRESET        ( {PHY_LANE{3'b0}} ), 
+            .PHY_RXEQ_LFFS          ( {PHY_LANE{6'b0}} ),         
+            .PHY_RXEQ_TXPRESET      ( phy_rxeq_txpreset_pl ),
+      
+            .PHY_RXEQ_LFFS_SEL      ( phy_rxeq_preset_sel_pclk2 ),      
+            .PHY_RXEQ_NEW_TXCOEFF   ( phy_rxeq_new_txcoeff_pclk2 ),   
+            .PHY_RXEQ_DONE          ( phy_rxeq_done_pclk2 ),        
+            .PHY_RXEQ_ADAPT_DONE    ( phy_rxeq_adapt_done_pclk2 ),
+      
+            // USB Ports
+            .USB_TXONESZEROS        ( {PHY_LANE{1'b0}} ),   // New in Diablo
+            .USB_RXEQTRAINING       ( {PHY_LANE{1'b0}} ),   // New in Diablo
+            .USB_RXTERMINATION      ( {PHY_LANE{1'b0}} ),   // New in Diablo
+            .USB_POWERPRESENT       ( ),  // New in Diablo
+      
+            // DRP Port
+            .GT_DRPCLK              ( 1'b0 ),   // New in Diablo
+            .GTCOM_DRPADDR          ( gtcom_drpaddr_tie_off ), // New in Diablo
+            .GTCOM_DRPEN            ( gtcom_drpen_tie_off ),   // New in Diablo
+            .GTCOM_DRPWE            ( gtcom_drpwe_tie_off ),   // New in Diablo
+            .GTCOM_DRPDI            ( gtcom_drpdi_tie_off ),   // New in Diablo
+            .GTCOM_DRPRDY           ( ),  // New in Diablo
+            .GTCOM_DRPDO            ( ),  // New in Diablo 
+
+            // Debug Ports   // Not used
+            .DBG_RATE_DONE          ( {PHY_LANE{1'b0}} ),
+            .DBG_RATE_START         ( ),  // New in Diablo
+            .DBG_RATE_IDLE          ( ),  // New in Diablo
+            .DBG_RXCDRLOCK          ( ),  // New in Diablo
+            .DBG_GEN34_EIOS_DET     ( ),  // New in Diablo
+            .DBG_TXOUTCLK           ( ),  // New in Diablo
+            .DBG_RXOUTCLK           ( ),  // New in Diablo
+            .DBG_TXOUTCLKFABRIC     ( ),  // New in Diablo
+            .DBG_RXOUTCLKFABRIC     ( ),  // New in Diablo
+            .DBG_TXOUTCLKPCS        ( ),  // New in Diablo
+            .DBG_RXOUTCLKPCS        ( ),  // New in Diablo
+            .DBG_RXRECCLKOUT        ( ),  // New in Diablo
+            .DBG_TXPMARESET         ( {PHY_LANE{1'b0}} ),   // New in Diablo
+            .DBG_RXPMARESET         ( {PHY_LANE{1'b0}} ),   // New in Diablo
+            .DBG_TXPCSRESET         ( {PHY_LANE{1'b0}} ),   // New in Diablo
+            .DBG_RXPCSRESET         ( {PHY_LANE{1'b0}} ),   // New in Diablo
+            .DBG_RXBUFRESET         ( {PHY_LANE{1'b0}} ),   // New in Diablo
+            .DBG_RXCDRRESET         ( {PHY_LANE{1'b0}} ),   // New in Diablo
+            .DBG_RXDFELPMRESET      ( {PHY_LANE{1'b0}} ),   // New in Diablo
+            .DBG_RRST_N             ( ),  // New in Diablo
+            .DBG_PRST_N             ( ),  // New in Diablo
+            .DBG_GTPOWERGOOD        ( ),  // New in Diablo
+            .DBG_CPLLLOCK           ( ),  // New in Diablo
+            .DBG_QPLL0LOCK          ( ),  // New in Diablo
+            .DBG_QPLL1LOCK          ( ),  // New in Diablo
+            .DBG_TXPROGDIVRESETDONE ( ),  // New in Diablo
+            .DBG_TXPMARESETDONE     ( ),  // New in Diablo
+            .DBG_RXPMARESETDONE     ( ),  // New in Diablo
+            .DBG_TXRESETDONE        ( ),  // New in Diablo
+            .DBG_RXRESETDONE        ( ),  // New in Diablo
+            .DBG_TXSYNCDONE         ( ),  // New in Diablo
+            .DBG_RST_IDLE           ( ),  // New in Diablo
+      
+            // PRBS Debug Ports
+            .DBG_LOOPBACK           ( 3'b0 ),   // New in Diablo
+            .DBG_PRBSSEL            ( 4'b0 ),   // New in Diablo
+            .DBG_TXPRBSFORCEERR     ( 1'b0 ),   // New in Diablo
+            .DBG_RXPRBSCNTRESET     ( 1'b0 ),   // New in Diablo
+            .DBG_RXPRBSERR          ( ),  // New in Diablo
+            .DBG_RXPRBSLOCKED       ( ),  // New in Diablo
+            .PHY_PCIE_MAC_IN_DETECT ( as_mac_in_detect_pl ) // New in Diablo
+         );
+      end 
+   endgenerate
+
+endmodule
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2023 AMD, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD, Inc. and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : UltraScale+ FPGA PCI Express v4.0 Integrated Block
+// File       : xp4_usp_smsw_gt_phy_wrapper.v
+// Version    : 1.1 
+//-----------------------------------------------------------------------------
+//--------------------------------------------------------------------------------------------------
+//  Design  :  Diablo PHY Wrapper REFERENCE DESIGN
+//  Module  :  PHY Wrapper Top
+//--------------------------------------------------------------------------------------------------
+//  *** AMD INTERNAL *** 
+//--------------------------------------------------------------------------------------------------
+//  Version :  0.73
+//--------------------------------------------------------------------------------------------------
+
+//--------------------------------------------------------------------------------------------------
+//  PHY Wrapper Design Hierarchy in Static Mode
+//--------------------------------------------------------------------------------------------------
+//  PHY Wrapper Top :
+//      - Clock 
+//      - Reset
+//      - PHY Lane :
+//          - TX Equalization (Gen3/Gen4)
+//          - RX Equalization (Gen3/Gen4)
+//          - GT Channel (one channel for every lane)
+//      - PHY Quad :
+//          - GT Common (one quad for every four lanes)
+//--------------------------------------------------------------------------------------------------
+
+//--------------------------------------------------------------------------------------------------
+//  PHY Wrapper Design Hierarchy in GT Wizard Mode
+//--------------------------------------------------------------------------------------------------
+//  PHY Wrapper Top :
+//      - Clock 
+//      - Reset
+//      - PHY Lane :
+//          - TX Equalization (Gen3/Gen4)
+//          - RX Equalization (Gen3/Gen4)
+//      - GT Wizard Top :
+//          - GT Wizard Core
+//              - GT Channel (one channel for every lane)
+//              - GT Common (one quad for every four lanes)
+//--------------------------------------------------------------------------------------------------
+
+//--------------------------------------------------------------------------------------------------
+//  PHY Wrapper User Parameter Encoding
+//--------------------------------------------------------------------------------------------------
+//  PHY_SIM_EN                : "FALSE" = Normal
+//                            : "TRUE"  = Simulation
+//  PHY_GT_XCVR               : "GTH" = GTH Transceiver
+//                            : "GTY" = GTY Transceiver
+//                            : "GTY64" = GTY with 64-bit support for PCIe Gen4
+//  PHY_MODE                  : 0 = PCIe 4.0
+//                            : 1 = USB  3.0
+//  PHY_REFCLK_MODE           : 0 =          0 ppm (Common   REFCLK)
+//                            : 1 = up to  600 ppm (Seperate REFCLK without SSC)
+//                            : 2 = up to 5600 ppm (Seperate REFCLK with independent SSC)
+//  PHY_GTWIZARD              : "FALSE" = Use Static Wrapper mode
+//                            : "TRUE"  = Use GT Wizard Generated Wrapper mode
+//  PHY_LANE                  : 1, 2, 4, 8, 16 
+//  PHY_MAX_SPEED             : 1 = PCIe Gen1 ( 2.5 Gbps) Capable or USB3 Gen1 ( 5.0 Gb/s)        
+//                            : 2 = PCIe Gen2 ( 5.0 Gbps) Capable
+//                            : 3 = PCIe Gen3 ( 8.0 Gbps) Capable 
+//                            : 4 = PCIe Gen4 (16.0 Gbps) Capable
+//  PHY_GEN12_CDR_CTRL_ON_EIDLE : "FALSE" = Will not auto reset CDR upon EIOS detection (Gen1/Gen2)
+//                            : "TRUE"  = Will     auto reset CDR upon EIOS detection (Gen1/Gen2)
+//  PHY_GEN34_CDR_CTRL_ON_EIDLE : "FALSE" = Will not auto reset CDR upon EIOS detection (Gen3/Gen4)
+//                            : "TRUE"  = Will     auto reset CDR upon EIOS detection (Gen3/Gen4)
+//  PHY_REFCLK_FREQ           : 0 = 100.0 MHz 
+//                            : 1 = 125.0 MHz
+//                            : 2 = 250.0 MHz
+//  PHY_CORECLK_FREQ          : 1 = 250.0 MHz
+//                            : 2 = 500.0 MHz
+//  PHY_USERCLK_FREQ          : 1 =  62.5 MHz
+//                            : 2 = 125.0 MHz
+//                            : 3 = 250.0 MHz
+//                            : 4 = 500.0 MHz
+//  PHY_MCAPCLK_FREQ          : 1 =  62.5 MHz
+//                            : 2 = 125.0 MHz
+//                            : 3 = 250.0 MHz
+//                            : 4 = 500.0 MHz
+//  PHY_GT_TXPRESET           : 0 to 10 
+//  PHY_LP_TXPRESET           : 0 to 10 
+//--------------------------------------------------------------------------------------------------
+
+`timescale 1ps / 1ps
+
+//--------------------------------------------------------------------------------------------------
+//  PHY Wrapper Top
+//--------------------------------------------------------------------------------------------------
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_gt_phy_wrapper #
+(
+    //--------------------------------------------------------------------------
+    //  Parameters
+    //--------------------------------------------------------------------------
+    parameter         PHY_SIM_EN                 = "FALSE",   
+    parameter         PHY_GT_XCVR                = "GTY",
+    parameter         PHY_GTWIZARD               = "FALSE",
+    parameter integer PHY_MODE                   = 0,  
+    parameter integer PHY_REFCLK_MODE            = 0,       
+    parameter integer PHY_LANE                   = 1,   
+    parameter integer PHY_MAX_SPEED              = 4,  
+    parameter         PHY_GEN12_CDR_CTRL_ON_EIDLE = "TRUE",                
+    parameter         PHY_GEN34_CDR_CTRL_ON_EIDLE = "TRUE",     
+    parameter integer PHY_REFCLK_FREQ            = 0, 
+    parameter integer PHY_CORECLK_FREQ           = 2,       
+    parameter integer PHY_USERCLK_FREQ           = 4,           
+    parameter integer PHY_MCAPCLK_FREQ           = 4,    
+    parameter integer PHY_GT_TXPRESET            = 0,
+    parameter integer PHY_LP_TXPRESET            = 4         
+)                                                            
+(                                         
+    //--------------------------------------------------------------------------
+    //  Clock & Reset Ports
+    //--------------------------------------------------------------------------
+    input                               PHY_REFCLK,                             // For PHY Wrapper
+    input                               PHY_GTREFCLK,                           // For GT
+    input                               PHY_RST_N,                              // System RST
+   
+    output                              PHY_PCLK,                               
+    output                              PHY_PCLK2,                              // For PCIe IP                          
+    output                              PHY_CORECLK,                            // For PCIe IP
+    output                              PHY_USERCLK,                            // For PCIe IP
+    output                              PHY_MCAPCLK,                            // For PCIe IP
+  
+    //--------------------------------------------------------------------------
+    //  Serial Line Ports
+    //--------------------------------------------------------------------------
+    input       [PHY_LANE-1:0]          PHY_RXP,               
+    input       [PHY_LANE-1:0]          PHY_RXN,               
+
+    output      [PHY_LANE-1:0]          PHY_TXP,               
+    output      [PHY_LANE-1:0]          PHY_TXN,   
+ 
+    //--------------------------------------------------------------------------
+    //  TX Data Ports 
+    //--------------------------------------------------------------------------
+    input       [(PHY_LANE*64)-1:0]     PHY_TXDATA,         
+    input       [(PHY_LANE* 2)-1:0]     PHY_TXDATAK,    
+    input       [PHY_LANE-1:0]          PHY_TXDATA_VALID,
+    input       [PHY_LANE-1:0]          PHY_TXSTART_BLOCK,      
+    input       [(PHY_LANE* 2)-1:0]     PHY_TXSYNC_HEADER,                    
+
+    //--------------------------------------------------------------------------
+    //  RX Data Ports 
+    //--------------------------------------------------------------------------
+    output      [(PHY_LANE*64)-1:0]     PHY_RXDATA,         
+    output      [(PHY_LANE* 2)-1:0]     PHY_RXDATAK,       
+    output      [PHY_LANE-1:0]          PHY_RXDATA_VALID,         
+    output      [(PHY_LANE* 2)-1:0]     PHY_RXSTART_BLOCK,  
+    output      [(PHY_LANE* 2)-1:0]     PHY_RXSYNC_HEADER,
+    
+    //--------------------------------------------------------------------------
+    //  PHY Command Port
+    //--------------------------------------------------------------------------
+    input                               PHY_TXDETECTRX,        
+    input       [PHY_LANE-1:0]          PHY_TXELECIDLE,        
+    input       [PHY_LANE-1:0]          PHY_TXCOMPLIANCE,      
+    input       [PHY_LANE-1:0]          PHY_RXPOLARITY,        
+    input       [1:0]                   PHY_POWERDOWN,         
+    input       [1:0]                   PHY_RATE,    
+    input                               PHY_RXCDRHOLD,                          // For Gen3/Gen4 RX EQ             
+    
+    //--------------------------------------------------------------------------   
+    //  PHY Status Ports
+    //-------------------------------------------------------------------------- 
+    output      [PHY_LANE-1:0]          PHY_RXVALID,               
+    output      [PHY_LANE-1:0]          PHY_PHYSTATUS,          
+    output                              PHY_PHYSTATUS_RST,                      // For PCIe IP
+    output      [PHY_LANE-1:0]          PHY_RXELECIDLE,         
+    output      [(PHY_LANE*3)-1:0]      PHY_RXSTATUS,                       
+    
+    //--------------------------------------------------------------------------
+    //  TX Driver Ports
+    //--------------------------------------------------------------------------
+    input       [ 2:0]                  PHY_TXMARGIN,          
+    input                               PHY_TXSWING,           
+    input       [ 1:0]                  PHY_TXDEEMPH,    
+    
+    //--------------------------------------------------------------------------   
+    //  TX Equalization Ports (Gen3/Gen4)
+    //--------------------------------------------------------------------------  
+    input       [(PHY_LANE*2)-1:0]      PHY_TXEQ_CTRL,      
+    input       [(PHY_LANE*4)-1:0]      PHY_TXEQ_PRESET,       
+    input       [(PHY_LANE*6)-1:0]      PHY_TXEQ_COEFF,                                                            
+
+    output      [ 5:0]                  PHY_TXEQ_FS,           
+    output      [ 5:0]                  PHY_TXEQ_LF,           
+    output      [(PHY_LANE*18)-1:0]     PHY_TXEQ_NEW_COEFF,        
+    output      [PHY_LANE-1:0]          PHY_TXEQ_DONE,         
+
+    //--------------------------------------------------------------------------
+    //  RX Equalization Ports (Gen3/Gen4)
+    //--------------------------------------------------------------------------                                                
+    input       [(PHY_LANE*2)-1:0]      PHY_RXEQ_CTRL,     
+    input       [(PHY_LANE*3)-1:0]      PHY_RXEQ_PRESET,  
+    input       [(PHY_LANE*4)-1:0]      PHY_RXEQ_TXPRESET,      
+    input       [(PHY_LANE*6)-1:0]      PHY_RXEQ_LFFS,                                                         
+
+    output      [PHY_LANE-1:0]          PHY_RXEQ_LFFS_SEL,    
+    output      [(PHY_LANE*18)-1:0]     PHY_RXEQ_NEW_TXCOEFF,   
+    output      [PHY_LANE-1:0]          PHY_RXEQ_ADAPT_DONE,     
+    output      [PHY_LANE-1:0]          PHY_RXEQ_DONE,         
+    
+    //--------------------------------------------------------------------------
+    //  GT Channel Ports (USB3)
+    //--------------------------------------------------------------------------
+    input       [PHY_LANE-1:0]          USB_TXONESZEROS,                        
+    input       [PHY_LANE-1:0]          USB_RXEQTRAINING,                       
+    input       [PHY_LANE-1:0]          USB_RXTERMINATION,                        
+    
+    output      [PHY_LANE-1:0]          USB_POWERPRESENT,    
+    
+    //--------------------------------------------------------------------------
+    //  GT Common DRP Ports 
+    //--------------------------------------------------------------------------
+    input                                           GT_DRPCLK,
+    input       [((((PHY_LANE-1)>>2)+1)*16)-1:0]    GTCOM_DRPADDR,                                       
+    input       [   (PHY_LANE-1)>>2          :0]    GTCOM_DRPEN,                                             
+    input       [   (PHY_LANE-1)>>2          :0]    GTCOM_DRPWE,     
+    input       [((((PHY_LANE-1)>>2)+1)*16)-1:0]    GTCOM_DRPDI,                                      
+                                                                         
+    output      [   (PHY_LANE-1)>>2          :0]    GTCOM_DRPRDY,    
+    output      [((((PHY_LANE-1)>>2)+1)*16)-1:0]    GTCOM_DRPDO,       
+    
+    //----------------------------------------------------------------------------------------------
+    //  GT Debug Ports
+    //----------------------------------------------------------------------------------------------       
+    input       [PHY_LANE-1:0]          DBG_RATE_DONE,
+    
+    output      [PHY_LANE-1:0]          DBG_RATE_START,             
+    output      [PHY_LANE-1:0]          DBG_RATE_IDLE,
+    output      [PHY_LANE-1:0]          DBG_RXCDRLOCK,     
+    output      [PHY_LANE-1:0]          DBG_GEN34_EIOS_DET, 
+    
+    //--------------------------------------------------------------------------
+    // CLK Debug Ports (Requires BUFG if used)
+    //--------------------------------------------------------------------------
+    output      [PHY_LANE-1:0]          DBG_TXOUTCLK, 
+    output      [PHY_LANE-1:0]          DBG_RXOUTCLK, 
+    output      [PHY_LANE-1:0]          DBG_TXOUTCLKFABRIC,                                                              
+    output      [PHY_LANE-1:0]          DBG_RXOUTCLKFABRIC,                                                              
+    output      [PHY_LANE-1:0]          DBG_TXOUTCLKPCS,                                                              
+    output      [PHY_LANE-1:0]          DBG_RXOUTCLKPCS,                 
+    output      [PHY_LANE-1:0]          DBG_RXRECCLKOUT, 
+        
+    //--------------------------------------------------------------------------
+    // RST Debug Ports
+    //--------------------------------------------------------------------------     
+    input       [PHY_LANE-1:0]          DBG_TXPMARESET,                                            
+    input       [PHY_LANE-1:0]          DBG_RXPMARESET,                                            
+    input       [PHY_LANE-1:0]          DBG_TXPCSRESET,   
+    input       [PHY_LANE-1:0]          DBG_RXPCSRESET,
+    input       [PHY_LANE-1:0]          DBG_RXBUFRESET,
+    input       [PHY_LANE-1:0]          DBG_RXCDRRESET,
+    input       [PHY_LANE-1:0]          DBG_RXDFELPMRESET,
+   
+    output                              DBG_RRST_N,
+    output                              DBG_PRST_N,       
+    output      [PHY_LANE-1:0]          DBG_GTPOWERGOOD,  
+    output      [PHY_LANE-1:0]          DBG_CPLLLOCK,      
+    output      [(PHY_LANE-1)>>2:0]     DBG_QPLL0LOCK,    
+    output      [(PHY_LANE-1)>>2:0]     DBG_QPLL1LOCK,  
+    output      [PHY_LANE-1:0]          DBG_TXPROGDIVRESETDONE,
+    output      [PHY_LANE-1:0]          DBG_TXPMARESETDONE,   
+    output      [PHY_LANE-1:0]          DBG_RXPMARESETDONE, 
+    output      [PHY_LANE-1:0]          DBG_TXRESETDONE,
+    output      [PHY_LANE-1:0]          DBG_RXRESETDONE,    
+    output      [PHY_LANE-1:0]          DBG_TXSYNCDONE,  
+    output                              DBG_RST_IDLE,               
+
+    //--------------------------------------------------------------------------
+    //  PRBS Debug Ports
+    //--------------------------------------------------------------------------
+    input       [ 2:0]                  DBG_LOOPBACK,                                              
+    input       [ 3:0]                  DBG_PRBSSEL,
+    input                               DBG_TXPRBSFORCEERR,
+    input                               DBG_RXPRBSCNTRESET,                                                                                                      
+
+    output      [PHY_LANE-1:0]          DBG_RXPRBSERR,                                              
+    output      [PHY_LANE-1:0]          DBG_RXPRBSLOCKED,
+    
+    //---------------------------------------------------------------------------
+    //   Receiver Detect (Remote TX detecting our RX)
+    //---------------------------------------------------------------------------
+    input                               PHY_PCIE_MAC_IN_DETECT 
+);
+
+//--------------------------------------------------------------------------------------------------
+//  Internal Signals
+//--------------------------------------------------------------------------------------------------
+
+    //--------------------------------------------------------------------------
+    //  Clock 
+    //--------------------------------------------------------------------------
+    wire                                pclk; 
+    wire                                pclk2_gt;
+  
+    //--------------------------------------------------------------------------
+    //  Reset
+    //--------------------------------------------------------------------------
+    wire                                rrst_n;
+    wire                                prst_n;
+    
+    wire                                rst_cpllpd;
+    wire                                rst_cpllreset;  
+    wire                                rst_qpllpd;  
+    wire                                rst_qpllreset;
+    wire                                rst_txprogdivreset;
+    wire                                rst_gtreset;
+    wire                                rst_userrdy; 
+    wire                                rst_txsync_start;
+    wire                                rst_idle;
+
+    //--------------------------------------------------------------------------
+    //  TX Equalization (Gen3/Gen4)
+    //-------------------------------------------------------------------------- 
+    wire        [(PHY_LANE*5)-1:0]      txeq_precursor; 
+    wire        [(PHY_LANE*7)-1:0]      txeq_maincursor; 
+    wire        [(PHY_LANE*5)-1:0]      txeq_postcursor; 
+    wire        [(PHY_LANE*18)-1:0]     txeq_new_coeff; 
+    wire        [PHY_LANE-1:0]          txeq_done;  
+    
+    //--------------------------------------------------------------------------
+    //  RX Equalization (Gen3/Gen4)
+    //-------------------------------------------------------------------------- 
+    wire        [PHY_LANE-1:0]          rxeq_lffs_sel;   
+    wire        [(PHY_LANE*18)-1:0]     rxeq_new_txcoeff;    
+    wire        [PHY_LANE-1:0]          rxeq_adapt_done;     
+    wire        [PHY_LANE-1:0]          rxeq_done;   
+    
+    //--------------------------------------------------------------------------
+    //  GT Channel 
+    //--------------------------------------------------------------------------
+    wire        [PHY_LANE-1:0]          gt_bufgtce;    
+    wire        [(PHY_LANE*3)-1:0]      gt_bufgtcemask;
+    wire        [PHY_LANE-1:0]          gt_bufgtreset;
+    wire        [(PHY_LANE*3)-1:0]      gt_bufgtrstmask;   
+    wire        [(PHY_LANE*9)-1:0]      gt_bufgtdiv;
+    wire        [PHY_LANE-1:0]          gt_txoutclk; 
+
+    wire        [PHY_LANE-1:0]          gt_gtpowergood;
+    wire        [PHY_LANE-1:0]          gt_txprogdivresetdone;
+    wire        [PHY_LANE-1:0]          gt_txresetdone;
+    wire        [PHY_LANE-1:0]          gt_rxresetdone;
+    
+    wire        [(PHY_LANE*3)-1:0]      gt_qpllrate;                           
+    
+    wire        [PHY_LANE-1:0]          gt_phystatus;
+    wire        [PHY_LANE-1:0]          gt_rxelecidle;
+    
+    wire        [PHY_LANE-1:0]          gt_pcieuserphystatusrst;
+    wire        [(PHY_LANE*2)-1:0]      gt_pcierateqpllpd;                 
+    wire        [(PHY_LANE*2)-1:0]      gt_pcierateqpllreset;               
+    wire        [PHY_LANE-1:0]          gt_pcierateidle;            
+    wire        [PHY_LANE-1:0]          gt_pciesynctxsyncdone;                 
+    wire        [PHY_LANE-1:0]          gt_pcierategen3;  
+    wire        [PHY_LANE-1:0]          gt_pcieusergen3rdy; 
+    wire        [PHY_LANE-1:0]          gt_pcieuserratestart;  
+    
+    wire        [PHY_LANE-1:0]          gt_txphaligndone;                                          
+    wire        [PHY_LANE-1:0]          gt_txsyncout;                          
+    
+    wire        [PHY_LANE-1:0]          gt_cplllock;     
+    wire        [PHY_LANE-1:0]          gt_rxcdrlock;    
+    
+    wire        [PHY_LANE-1:0]          gt_rxcdrhold;
+    wire        [PHY_LANE-1:0]          gt_gen34_eios_det;
+                                   
+    wire        [PHY_LANE-1:0]          gt_rxratedone;
+    wire        [PHY_LANE-1:0]          gt_rxtermination;
+
+    //--------------------------------------------------------------------------
+    //  GT Common
+    //--------------------------------------------------------------------------
+    wire        [(PHY_LANE-1)>>2:0]     gtcom_qpll0lock;
+    wire        [(PHY_LANE-1)>>2:0]     gtcom_qpll0outclk;          
+    wire        [(PHY_LANE-1)>>2:0]     gtcom_qpll0outrefclk;       
+                                       
+    wire        [(PHY_LANE-1)>>2:0]     gtcom_qpll1lock;
+    wire        [(PHY_LANE-1)>>2:0]     gtcom_qpll1outclk;          
+    wire        [(PHY_LANE-1)>>2:0]     gtcom_qpll1outrefclk;       
+
+    //--------------------------------------------------------------------------
+    //  Signals for GT Common
+    //--------------------------------------------------------------------------
+    wire        [(PHY_LANE-1)>>2:0]     qpll0pd;                    
+    wire        [(PHY_LANE-1)>>2:0]     qpll0reset;                 
+    wire        [(PHY_LANE-1)>>2:0]     qpll1pd;                    
+    wire        [(PHY_LANE-1)>>2:0]     qpll1reset;                 
+                                       
+    //--------------------------------------------------------------------------
+    //  Signals converted from per lane
+    //--------------------------------------------------------------------------
+    wire                                qpll0lock_all;                         
+    wire                                qpll1lock_all;
+    wire                                txsyncallin_all;                       
+
+    //--------------------------------------------------------------------------
+    //  GT DRP signals
+    //--------------------------------------------------------------------------    
+    
+    wire        [(PHY_LANE*10)-1:0]     gt_drpaddr = {PHY_LANE{10'd0}}; 
+    wire        [PHY_LANE-1:0]          gt_drpen   = {PHY_LANE{1'b0}};
+    wire        [PHY_LANE-1:0]          gt_drpwe   = {PHY_LANE{1'b0}};
+    wire        [(PHY_LANE*16)-1:0]     gt_drpdi   = {PHY_LANE{16'd0}};
+
+    wire        [PHY_LANE-1:0]          gt_drprdy;
+    wire        [(PHY_LANE*16)-1:0]     gt_drpdo;  
+
+    //--------------------------------------------------------------------------
+    // Reciever Detect RX termination signals 
+    //--------------------------------------------------------------------------    
+    
+    wire        [PHY_LANE-1:0]         rxterm_rxtermination;
+
+    //--------------------------------------------------------------------------
+    //  CDR Control signals
+    //-------------------------------------------------------------------------- 
+    
+    wire        [PHY_LANE-1:0]         cdrctrl_rxcdrhold;
+    wire        [PHY_LANE-1:0]         cdrctrl_rxcdrfreqreset;
+    wire        [PHY_LANE-1:0]         cdrctrl_resetovrd;
+    
+    //--------------------------------------------------------------------------
+    //  PHYSTATUS Reset Synchronizer for PCLK
+    //--------------------------------------------------------------------------
+
+    (* ASYNC_REG = "TRUE", SHIFT_EXTRACT = "NO", keep = "true", max_fanout = 500 *) reg [3:0] rst_psrst_n_r;
+
+    //----
+    //  
+    //----
+
+    wire                                bufg_gt_ce;
+    wire                                bufg_gt_reset;
+   (* keep = "true" *) wire [2:0]       PHY_TXOUTCLKSEL;
+
+    assign bufg_gt_ce = rrst_n ? gt_bufgtce[0] : 1'b1;
+    assign bufg_gt_reset = !rst_cpllreset ? gt_bufgtreset[0] : 1'b0;
+    assign PHY_TXOUTCLKSEL = rst_cpllreset ? 3'h3 : 3'h5; 
+
+   // 64-bit support for PCIe Gen4
+    localparam PHY_GEN4_64BIT_EN = (PHY_GT_XCVR == "GTY64") ? "TRUE" : "FALSE";
+//--------------------------------------------------------------------------------------------------
+//  PHY Clock 
+//--------------------------------------------------------------------------------------------------
+xp4_usp_smsw_gt_phy_clk #
+(
+    .PHY_MAX_SPEED                      (PHY_MAX_SPEED),
+    .PHY_GEN4_64BIT_EN                  (PHY_GEN4_64BIT_EN),
+    .PHY_CORECLK_FREQ                   (PHY_CORECLK_FREQ),   
+    .PHY_USERCLK_FREQ                   (PHY_USERCLK_FREQ),  
+    .PHY_MCAPCLK_FREQ                   (PHY_MCAPCLK_FREQ) 
+)
+phy_clk_smsw_i
+(
+    //--------------------------------------------------------------------------
+    //  CLK Port
+    //--------------------------------------------------------------------------
+    .CLK_TXOUTCLK                       (gt_txoutclk[0]),                       // From master lane 0
+    .CLK_PCLK2_GT                       (pclk2_gt),                             // To all [TX/RX]USRCLK2
+
+    //--------------------------------------------------------------------------
+    //  PCLK Ports
+    //--------------------------------------------------------------------------   
+    .CLK_PCLK_CE                        (bufg_gt_ce),                  
+    .CLK_PCLK_CEMASK                    (gt_bufgtcemask[0]), 
+    .CLK_PCLK_CLR                       (bufg_gt_reset),                     
+    .CLK_PCLK_CLRMASK                   (gt_bufgtrstmask[0]),   
+    .CLK_PCLK_DIV                       (gt_bufgtdiv[2:0]),    
+    .CLK_PCLK                           (pclk),
+    
+    //--------------------------------------------------------------------------
+    //  PCLK2 Ports
+    //--------------------------------------------------------------------------    
+    .CLK_PCLK2_CE                       (bufg_gt_ce),                  
+    .CLK_PCLK2_CEMASK                   (gt_bufgtcemask[0]), 
+    .CLK_PCLK2_CLR                      (bufg_gt_reset),                     
+    .CLK_PCLK2_CLRMASK                  (gt_bufgtrstmask[0]),   
+    .CLK_PCLK2_DIV                      (gt_bufgtdiv[8:6]),    
+    .CLK_PCLK2                          (PHY_PCLK2),
+    
+    //--------------------------------------------------------------------------
+    //  CORECLK Ports
+    //--------------------------------------------------------------------------
+    .CLK_CORECLK_CE                     (bufg_gt_ce),                               
+    .CLK_CORECLK_CEMASK                 (rst_idle),            
+    .CLK_CORECLK_CLR                    (bufg_gt_reset),                     
+    .CLK_CORECLK_CLRMASK                (rst_idle),                                        
+    .CLK_CORECLK                        (PHY_CORECLK), 
+    
+    //--------------------------------------------------------------------------
+    //  USERCLK Ports
+    //--------------------------------------------------------------------------                      
+    .CLK_USERCLK_CE                     (bufg_gt_ce),                       
+    .CLK_USERCLK_CEMASK                 (rst_idle),
+    .CLK_USERCLK_CLR                    (bufg_gt_reset),                     
+    .CLK_USERCLK_CLRMASK                (rst_idle),
+    .CLK_USERCLK                        (PHY_USERCLK),
+    
+    //--------------------------------------------------------------------------
+    //  MCAPCLK Ports
+    //--------------------------------------------------------------------------                     
+    .CLK_MCAPCLK_CE                     (bufg_gt_ce),
+    .CLK_MCAPCLK_CEMASK                 (rst_idle),
+    .CLK_MCAPCLK_CLR                    (bufg_gt_reset),                     
+    .CLK_MCAPCLK_CLRMASK                (rst_idle),
+    .CLK_MCAPCLK                        (PHY_MCAPCLK) 
+);
+
+
+
+//--------------------------------------------------------------------------------------------------
+//  PHY Reset
+//--------------------------------------------------------------------------------------------------
+xp4_usp_smsw_gt_phy_rst #
+(
+    .PHY_LANE                           (PHY_LANE),
+    .PHY_MAX_SPEED                      (PHY_MAX_SPEED)            
+)
+phy_rst_smsw_i
+(
+    //-------------------------------------------------------------------------- 
+    //  Input Ports
+    //--------------------------------------------------------------------------       
+    .RST_REFCLK                         (PHY_REFCLK),   
+    .RST_PCLK                           (pclk),                         
+    .RST_N                              (PHY_RST_N),  
+    .RST_GTPOWERGOOD                    (gt_gtpowergood),                
+    .RST_CPLLLOCK                       (gt_cplllock),   
+    .RST_QPLL1LOCK                      (gtcom_qpll1lock), 
+    .RST_QPLL0LOCK                      (gtcom_qpll0lock),
+    .RST_TXPROGDIVRESETDONE             (gt_txprogdivresetdone),                           
+    .RST_TXRESETDONE                    (gt_txresetdone), 
+    .RST_RXRESETDONE                    (gt_rxresetdone), 
+    .RST_TXSYNC_DONE                    (gt_pciesynctxsyncdone),     
+    .RST_PHYSTATUS                      (gt_phystatus),                                             
+
+    //-------------------------------------------------------------------------- 
+    //  Output Ports
+    //--------------------------------------------------------------------------   
+    .RST_RRST_N                         (rrst_n),
+    .RST_PRST_N                         (prst_n), 
+    .RST_CPLLPD                         (rst_cpllpd),               
+    .RST_CPLLRESET                      (rst_cpllreset),  
+    .RST_QPLLPD                         (rst_qpllpd),
+    .RST_QPLLRESET                      (rst_qpllreset),  
+    .RST_TXPROGDIVRESET                 (rst_txprogdivreset),                              
+    .RST_GTRESET                        (rst_gtreset),               
+    .RST_USERRDY                        (rst_userrdy),   
+    .RST_TXSYNC_START                   (rst_txsync_start),                                
+    .RST_IDLE                           (rst_idle)                          
+);
+   
+
+
+//--------------------------------------------------------------------------------------------------
+//  Generate PHY Lane - Begin
+//--------------------------------------------------------------------------------------------------
+genvar i;   
+    
+generate for (i=0; i<PHY_LANE; i=i+1) 
+
+    begin : phy_lane
+    
+    //----------------------------------------------------------------------------------------------
+    //  PHY TX Equalization (Gen3)
+    //----------------------------------------------------------------------------------------------
+    xp4_usp_smsw_gt_phy_txeq #
+    (
+        .PHY_GT_TXPRESET                (PHY_GT_TXPRESET)                
+    )
+    phy_txeq_smsw_i
+    (
+        //---------------------------------------------------------------------- 
+        //  Input Ports
+        //----------------------------------------------------------------------  
+        .TXEQ_CLK                       (pclk),
+        .TXEQ_RST_N                     (prst_n),    
+        .TXEQ_CTRL                      (PHY_TXEQ_CTRL[(2*i)+1:(2*i)]), 
+        .TXEQ_PRESET                    (PHY_TXEQ_PRESET[(4*i)+3:(4*i)]), 
+        .TXEQ_COEFF                     (PHY_TXEQ_COEFF[(6*i)+5:(6*i)]),
+
+        //---------------------------------------------------------------------- 
+        //  Output Ports
+        //----------------------------------------------------------------------   
+        .TXEQ_PRECURSOR                 (txeq_precursor[(5*i)+4:(5*i)]),        
+        .TXEQ_MAINCURSOR                (txeq_maincursor[(7*i)+6:(7*i)]),       
+        .TXEQ_POSTCURSOR                (txeq_postcursor[(5*i)+4:(5*i)]),       
+        .TXEQ_NEW_COEFF                 (txeq_new_coeff[(18*i)+17:(18*i)]),          
+        .TXEQ_DONE                      (txeq_done[i])      
+    );                                                   
+
+
+
+    //----------------------------------------------------------------------------------------------
+    //  PHY RX Equalization (Gen3)
+    //----------------------------------------------------------------------------------------------
+    xp4_usp_smsw_gt_phy_rxeq #
+    (
+        .PHY_SIM_EN                     (PHY_SIM_EN),
+        .PHY_LP_TXPRESET                (PHY_LP_TXPRESET)                
+    )
+    phy_rxeq_smsw_i
+    (
+        //---------------------------------------------------------------------- 
+        //  Input Ports
+        //----------------------------------------------------------------------  
+        .RXEQ_CLK                       (pclk),
+        .RXEQ_RST_N                     (prst_n),  
+        .RXEQ_CTRL                      (PHY_RXEQ_CTRL[(2*i)+1:(2*i)]), 
+        .RXEQ_PRESET                    (PHY_RXEQ_PRESET[(3*i)+2:(3*i)]), 
+        .RXEQ_TXPRESET                  (PHY_RXEQ_TXPRESET[(4*i)+3:(4*i)]),
+        .RXEQ_TXCOEFF                   (PHY_TXEQ_COEFF[(6*i)+5:(6*i)]),
+        .RXEQ_LFFS                      (PHY_RXEQ_LFFS[(6*i)+5:(6*i)]),
+
+        //---------------------------------------------------------------------- 
+        //  Output Ports
+        //----------------------------------------------------------------------     
+        .RXEQ_LFFS_SEL                  (rxeq_lffs_sel[i]),   
+        .RXEQ_NEW_TXCOEFF               (rxeq_new_txcoeff[(18*i)+17:(18*i)]),    
+        .RXEQ_ADAPT_DONE                (rxeq_adapt_done[i]),      
+        .RXEQ_DONE                      (rxeq_done[i])      
+    );
+
+    //----------------------------------------------------------------------------------------------
+    //  Receiver detect RX termination
+    //----------------------------------------------------------------------------------------------    
+    xp4_usp_smsw_gt_receiver_detect_rxterm #
+    ( 
+      .CONSECUTIVE_CYCLE_OF_RXELECIDLE ((PHY_REFCLK_FREQ==0)?64:(PHY_REFCLK_FREQ==1)?80:160)
+    )
+    receiver_detect_termination_smsw_i
+    (
+      //---------- Input -------------------------------------
+      .RXTERM_CLK                        (PHY_REFCLK), 
+      .RXTERM_RST_N                      (rrst_n), 
+      .RXTERM_RXELECIDLE                 (PHY_RXELECIDLE[i]), 
+      .RXTERM_MAC_IN_DETECT              (PHY_PCIE_MAC_IN_DETECT), 
+    
+      //---------- Output ------------------------------------
+      .RXTERM_RXTERMINATION              (rxterm_rxtermination[i]),
+      .RXTERM_FSM                        () 
+    );
+    
+    assign gt_rxtermination[i] = (PHY_MODE == 0) ? rxterm_rxtermination[i] : USB_RXTERMINATION[i];
+
+    //--------------------------------------------------------------------------------------------------
+    //  Reset CDR upon EIOS/EIDLE detection
+    //--------------------------------------------------------------------------------------------------
+    xp4_usp_smsw_gt_cdr_ctrl_on_eidle #
+    (
+        .PHY_GEN12_CDR_CTRL_ON_EIDLE (PHY_GEN12_CDR_CTRL_ON_EIDLE),   
+        .PHY_GEN34_CDR_CTRL_ON_EIDLE (PHY_GEN34_CDR_CTRL_ON_EIDLE), 
+        .PHY_REFCLK_MODE             (PHY_REFCLK_MODE),
+        .PHY_REFCLK_FREQ             (PHY_REFCLK_FREQ)
+    )
+    cdr_ctrl_on_eidle_smsw_i
+    (
+        //----------------------------------------------------------------------------
+        //  Input Ports
+        //----------------------------------------------------------------------------
+        .CDRCTRL_PCLK                               (pclk2_gt),
+        .CDRCTRL_PCLK_RST_N                         (rst_psrst_n_r[3]),
+        .CDRCTRL_CLK                                (PHY_REFCLK),
+        .CDRCTRL_RST_N                              (rst_idle),
+        .CDRCTRL_RATE                               (PHY_RATE),
+        .CDRCTRL_RXELECIDLE                         (gt_rxelecidle[i]),
+        .CDRCTRL_GEN34_EIOS_DET                     (gt_gen34_eios_det[i]),
+        .CDRCTRL_RXCDRHOLD_IN                       (PHY_RXCDRHOLD),
+        .CDRCTRL_RXCDRFREQRESET_IN                  (1'b0),
+        .CDRCTRL_RXRATEDONE                         (gt_rxratedone[i]),
+        //----------------------------------------------------------------------------
+        //  Output Ports
+        //----------------------------------------------------------------------------  
+        .CDRCTRL_RXCDRHOLD_OUT                      (cdrctrl_rxcdrhold[i]),
+        .CDRCTRL_RXCDRFREQRESET_OUT                 (cdrctrl_rxcdrfreqreset[i]),
+        .CDRCTRL_RESETOVRD_OUT                      (cdrctrl_resetovrd[i])
+    );
+      
+    assign gt_rxcdrhold[i] = (PHY_GEN12_CDR_CTRL_ON_EIDLE == "TRUE") || (PHY_GEN34_CDR_CTRL_ON_EIDLE == "TRUE") ? cdrctrl_rxcdrhold[i] : PHY_RXCDRHOLD;
+    
+    //----------------------------------------------------------------------------------------------
+    //  Use Static GT Wrapper
+    //----------------------------------------------------------------------------------------------
+    if (PHY_GTWIZARD == "FALSE")
+    
+        begin : gt_wrapper_smsw
+    
+        //----------------------------------------------------------------------
+        //  GT Channel
+        //----------------------------------------------------------------------
+        xp4_usp_smsw_gt_gt_channel #
+        (
+            .PHY_SIM_EN                     (PHY_SIM_EN),   
+            .PHY_GT_XCVR                    (PHY_GT_XCVR),
+            .PHY_MODE                       (PHY_MODE),
+            .PHY_REFCLK_MODE                (PHY_REFCLK_MODE),
+            .PHY_LANE                       (PHY_LANE),    
+            .PHY_MAX_SPEED                  (PHY_MAX_SPEED),
+            .PHY_GEN4_64BIT_EN              (PHY_GEN4_64BIT_EN),
+            .PHY_GEN12_CDR_CTRL_ON_EIDLE     (PHY_GEN12_CDR_CTRL_ON_EIDLE),
+            .PHY_GEN34_CDR_CTRL_ON_EIDLE     (PHY_GEN34_CDR_CTRL_ON_EIDLE),
+            .PHY_REFCLK_FREQ                (PHY_REFCLK_FREQ),    
+            .PHY_CORECLK_FREQ               (PHY_CORECLK_FREQ),         
+            .GT_LANE_NUM                    (i)                      
+        )
+        gt_channel_smsw_i
+        (  
+        
+            //------------------------------------------------------------------
+            //  Clock Ports
+            //------------------------------------------------------------------
+            .GT_GTREFCLK0                   (PHY_GTREFCLK),
+            .GT_TXUSRCLK                    (pclk),
+            .GT_RXUSRCLK                    (pclk), 
+            .GT_TXUSRCLK2                   (pclk2_gt),
+            .GT_RXUSRCLK2                   (pclk2_gt), 
+            
+            .GT_TXOUTCLK                    (gt_txoutclk[i]), 
+            .GT_RXOUTCLK                    (DBG_RXOUTCLK[i]), 
+            .GT_TXOUTCLKFABRIC              (DBG_TXOUTCLKFABRIC[i]),                                                        
+            .GT_RXOUTCLKFABRIC              (DBG_RXOUTCLKFABRIC[i]),                                                        
+            .GT_TXOUTCLKPCS                 (DBG_TXOUTCLKPCS[i]),                                                        
+            .GT_RXOUTCLKPCS                 (DBG_RXOUTCLKPCS[i]),  
+            .GT_RXRECCLKOUT                 (DBG_RXRECCLKOUT[i]),
+            
+	    .GT_TXOUTCLKSEL                 (PHY_TXOUTCLKSEL),
+
+            //------------------------------------------------------------------
+            //  BUFG_GT Controller Ports                                               
+            //------------------------------------------------------------------ 
+            .GT_BUFGTCE                     (gt_bufgtce[i]),     
+            .GT_BUFGTCEMASK                 (gt_bufgtcemask[(3*i)+2:(3*i)]), 
+            .GT_BUFGTRESET                  (gt_bufgtreset[i]),
+            .GT_BUFGTRSTMASK                (gt_bufgtrstmask[(3*i)+2:(3*i)]),   
+            .GT_BUFGTDIV                    (gt_bufgtdiv[(9*i)+8:(9*i)]),
+            
+            //------------------------------------------------------------------
+            //  Reset Ports
+            //------------------------------------------------------------------
+            .GT_CPLLPD                      (rst_cpllpd),
+            .GT_CPLLRESET                   (rst_cpllreset),
+            .GT_TXPROGDIVRESET              (rst_txprogdivreset),
+            .GT_GTTXRESET                   (rst_gtreset),
+            .GT_GTRXRESET                   (rst_gtreset), 
+            .GT_TXUSERRDY                   (rst_userrdy),
+            .GT_RXUSERRDY                   (rst_userrdy),              
+                             
+            .GT_TXPMARESET                  (DBG_TXPMARESET[i]),                                            
+            .GT_RXPMARESET                  (DBG_RXPMARESET[i]),                                            
+            .GT_TXPCSRESET                  (DBG_TXPCSRESET[i]),   
+            .GT_RXPCSRESET                  (DBG_RXPCSRESET[i]),  
+            .GT_RXBUFRESET                  (DBG_RXBUFRESET[i]),
+            .GT_RXCDRRESET                  (DBG_RXCDRRESET[i]),  
+            .GT_RXDFELPMRESET               (DBG_RXDFELPMRESET[i]), 
+            .GT_RXCDRFREQRESET              (cdrctrl_rxcdrfreqreset[i]),
+            
+            .GT_RESETOVRD                   (cdrctrl_resetovrd[i]),
+                             
+            .GT_GTPOWERGOOD                 (gt_gtpowergood[i]), 
+            .GT_TXPROGDIVRESETDONE          (gt_txprogdivresetdone[i]),     
+            .GT_TXPMARESETDONE              (DBG_TXPMARESETDONE[i]),     
+            .GT_RXPMARESETDONE              (DBG_RXPMARESETDONE[i]),             
+            .GT_TXRESETDONE                 (gt_txresetdone[i]),
+            .GT_RXRESETDONE                 (gt_rxresetdone[i]),                
+
+            //------------------------------------------------------------------
+            //  QPLL Ports
+            //------------------------------------------------------------------
+            .GT_QPLL0CLK                    (gtcom_qpll0outclk[i>>2]),                       
+            .GT_QPLL0REFCLK                 (gtcom_qpll0outrefclk[i>>2]), 
+            .GT_QPLL0LOCK                   (qpll0lock_all),                    // From all lanes
+            .GT_QPLL1CLK                    (gtcom_qpll1outclk[i>>2]),
+            .GT_QPLL1REFCLK                 (gtcom_qpll1outrefclk[i>>2]), 
+            .GT_QPLL1LOCK                   (qpll1lock_all),                    // From all lanes
+            
+            .GT_QPLLRATE                    (gt_qpllrate[(3*i)+2:(3*i)]),
+            
+            //------------------------------------------------------------------
+            //  Serial Line Ports
+            //------------------------------------------------------------------
+            .GT_RXP                         (PHY_RXP[i]),
+            .GT_RXN                         (PHY_RXN[i]),
+            
+            .GT_TXP                         (PHY_TXP[i]),
+            .GT_TXN                         (PHY_TXN[i]),
+            
+            //------------------------------------------------------------------
+            //  TX Data Ports
+            //------------------------------------------------------------------
+            .GT_TXDATA                      (PHY_TXDATA[(64*i)+63:(64*i)]),
+            .GT_TXDATAK                     (PHY_TXDATAK[(2*i)+1:(2*i)]),
+            .GT_TXDATA_VALID                (PHY_TXDATA_VALID[i]),
+            .GT_TXSTART_BLOCK               (PHY_TXSTART_BLOCK[i]),
+            .GT_TXSYNC_HEADER               (PHY_TXSYNC_HEADER[(2*i)+1:(2*i)]),
+            
+            //------------------------------------------------------------------
+            //  RX Data Ports
+            //------------------------------------------------------------------
+            .GT_RXDATA                      (PHY_RXDATA[(64*i)+63:(64*i)]),
+            .GT_RXDATAK                     (PHY_RXDATAK[(2*i)+1:(2*i)]),
+            .GT_RXDATA_VALID                (PHY_RXDATA_VALID[i]),
+            .GT_RXSTART_BLOCK               (PHY_RXSTART_BLOCK[(2*i)+1:(2*i)]),
+            .GT_RXSYNC_HEADER               (PHY_RXSYNC_HEADER[(2*i)+1:(2*i)]),
+            
+            //------------------------------------------------------------------
+            //  PHY Command Ports
+            //------------------------------------------------------------------
+            .GT_TXDETECTRX                  (PHY_TXDETECTRX),
+            .GT_TXELECIDLE                  (PHY_TXELECIDLE[i]), 
+            .GT_TXCOMPLIANCE                (PHY_TXCOMPLIANCE[i]),
+            .GT_RXPOLARITY                  (PHY_RXPOLARITY[i]),
+            .GT_POWERDOWN                   (PHY_POWERDOWN),
+            .GT_RATE                        (PHY_RATE), 
+            .GT_RXCDRHOLD                   (gt_rxcdrhold[i]),      
+                
+            //------------------------------------------------------------------
+            //  PHY Status Ports
+            //------------------------------------------------------------------
+            .GT_RXVALID                     (PHY_RXVALID[i]),
+            .GT_PHYSTATUS                   (gt_phystatus[i]),
+            .GT_RXELECIDLE                  (gt_rxelecidle[i]),
+            .GT_RXSTATUS                    (PHY_RXSTATUS[(3*i)+2:(3*i)]),
+                
+            //------------------------------------------------------------------
+            //  TX Driver Ports
+            //------------------------------------------------------------------
+            .GT_TXMARGIN                    (PHY_TXMARGIN),
+            .GT_TXSWING                     (PHY_TXSWING),
+            .GT_TXDEEMPH                    (PHY_TXDEEMPH),  
+            
+            //------------------------------------------------------------------
+            //  TX Equalization Ports (Gen3) 
+            //------------------------------------------------------------------
+            .GT_TXPRECURSOR                 (txeq_precursor[(5*i)+4:(5*i)]),
+            .GT_TXMAINCURSOR                (txeq_maincursor[(7*i)+6:(7*i)]),
+            .GT_TXPOSTCURSOR                (txeq_postcursor[(5*i)+4:(5*i)]),
+            
+            //------------------------------------------------------------------
+            //  PCIe Ports (Advance feature)
+            //------------------------------------------------------------------
+            .GT_PCIERSTIDLE                 (rst_idle),        
+            .GT_PCIERSTTXSYNCSTART          (rst_txsync_start), 
+            .GT_PCIEEQRXEQADAPTDONE         (1'd0),                             // Not used in top level
+            .GT_PCIEUSERRATEDONE            (DBG_RATE_DONE[i]),                 // For debug only
+        
+            .GT_PCIEUSERPHYSTATUSRST        (gt_pcieuserphystatusrst[i]),    
+            .GT_PCIERATEQPLLPD              (gt_pcierateqpllpd[(2*i)+1:(2*i)]),     
+            .GT_PCIERATEQPLLRESET           (gt_pcierateqpllreset[(2*i)+1:(2*i)]), 
+            .GT_PCIERATEIDLE                (gt_pcierateidle[i]),            
+            .GT_PCIESYNCTXSYNCDONE          (gt_pciesynctxsyncdone[i]),  
+            .GT_PCIERATEGEN3                (gt_pcierategen3[i]),               // Not used in top level
+            .GT_PCIEUSERGEN3RDY             (gt_pcieusergen3rdy[i]),            // Not used in top level
+            .GT_PCIEUSERRATESTART           (gt_pcieuserratestart[i]),          // For debug
+            
+            //------------------------------------------------------------------
+            //  USB Ports
+            //------------------------------------------------------------------
+            .GT_TXONESZEROS                 (USB_TXONESZEROS[i]),                        
+            .GT_RXEQTRAINING                (USB_RXEQTRAINING[i]),                       
+            .GT_RXTERMINATION               (gt_rxtermination[i]),                        
+    
+            .GT_POWERPRESENT                (USB_POWERPRESENT[i]),    
+            
+            //------------------------------------------------------------------
+            //  TX Sync Alignment Ports
+            //------------------------------------------------------------------
+            .GT_TXSYNCALLIN                 (txsyncallin_all),                  // From all lanes
+            .GT_TXSYNCIN                    (gt_txsyncout[0]),                  // From master lane 0        
+        
+            .GT_TXPHALIGNDONE               (gt_txphaligndone[i]),            
+            .GT_TXSYNCOUT                   (gt_txsyncout[i]),
+            
+             //-----------------------------------------------------------------
+             //  Loopback and PRBS Ports
+             //-----------------------------------------------------------------  
+            .GT_LOOPBACK                    (DBG_LOOPBACK),                                              
+            .GT_PRBSSEL                     (DBG_PRBSSEL),
+            .GT_TXPRBSFORCEERR              (DBG_TXPRBSFORCEERR), 
+            .GT_RXPRBSCNTRESET              (DBG_RXPRBSCNTRESET),                                                                                                      
+        
+            .GT_RXPRBSERR                   (DBG_RXPRBSERR[i]),                                              
+            .GT_RXPRBSLOCKED                (DBG_RXPRBSLOCKED[i]),  
+        
+            //------------------------------------------------------------------
+            //  GT Status Ports
+            //------------------------------------------------------------------                                              
+            .GT_MASTER_CPLLLOCK             (gt_cplllock[0]),                   // From master lane 0 
+            
+            .GT_CPLLLOCK                    (gt_cplllock[i]),  
+            .GT_RXCDRLOCK                   (gt_rxcdrlock[i]),
+            .GT_GEN34_EIOS_DET              (gt_gen34_eios_det[i]),
+            .GT_RXRATEDONE                  (gt_rxratedone[i]),
+            
+            //------------------------------------------------------------------
+            //  DRP Ports
+            //------------------------------------------------------------------
+            .GT_DRPCLK                      (PHY_REFCLK),
+            .GT_DRPADDR                     (10'd0),
+            .GT_DRPEN                       (1'b0),
+            .GT_DRPWE                       (1'b0),
+            .GT_DRPDI                       (16'd0),
+
+            .GT_DRPRDY                      (),
+            .GT_DRPDO                       ()            
+        );
+end // gt_channel            
+        //------------------------------------------------------------------------------------------
+        //  PHY Quad - Generate one Quad for every four Lanes
+        //------------------------------------------------------------------------------------------
+        if ((i%4)==0) 
+                       
+            begin : phy_quad   
+                 
+            //------------------------------------------------------------------
+            //  Generate QPLL Powerdown and Reset
+            //------------------------------------------------------------------
+            //  * QPLL reset and powerdown for Quad 1 driven by       Master Lane 0
+            //  * QPLL reset and powerdown for Quad 2 driven by Local Master Lane 4
+            //------------------------------------------------------------------        
+            assign qpll1pd[i>>2]    = (PHY_MAX_SPEED != 3) ? 1'd1 : (i > 3) ? (rst_qpllpd    || gt_pcierateqpllpd[(i*2)+1]) : 
+                                                                              (rst_qpllpd    || gt_pcierateqpllpd[1]);
+                                             
+            assign qpll1reset[i>>2] = (PHY_MAX_SPEED != 3) ? 1'd1 : (i > 3) ? (rst_qpllreset || gt_pcierateqpllreset[(i*2)+1]) : 
+                                                                              (rst_qpllreset || gt_pcierateqpllreset[1]);            
+            
+            assign qpll0pd[i>>2]    = (PHY_MAX_SPEED != 4) ? 1'd1 : (i > 3) ? (rst_qpllpd    || gt_pcierateqpllpd[(i*2)+0]) : 
+                                                                              (rst_qpllpd    || gt_pcierateqpllpd[0]);
+                                             
+            assign qpll0reset[i>>2] = (PHY_MAX_SPEED != 4) ? 1'd1 : (i > 3) ? (rst_qpllreset || gt_pcierateqpllreset[(i*2)+0]) : 
+                                                                              (rst_qpllreset || gt_pcierateqpllreset[0]);                                 
+        
+    if (PHY_GTWIZARD == "FALSE") begin : gt_common_smsw_int
+            //------------------------------------------------------------------
+            //  GT Common Module                                                   
+            //------------------------------------------------------------------
+            xp4_usp_smsw_gt_gt_common #
+            (
+                //--------------------------------------------------------------
+                //  User Attributes
+                //--------------------------------------------------------------
+                .PHY_SIM_EN                 (PHY_SIM_EN),   
+                .PHY_GT_XCVR                (PHY_GT_XCVR),
+                .PHY_MAX_SPEED              (PHY_MAX_SPEED),
+                .PHY_REFCLK_FREQ            (PHY_REFCLK_FREQ)          
+            )
+            gt_common_smsw_i
+            (    
+                //--------------------------------------------------------------
+                //  Clock Ports
+                //--------------------------------------------------------------
+                .GTCOM_REFCLK               (PHY_GTREFCLK),
+                
+                .GTCOM_QPLL0LOCK            (gtcom_qpll0lock[i>>2]),
+                .GTCOM_QPLL0OUTCLK          (gtcom_qpll0outclk[i>>2]),
+                .GTCOM_QPLL0OUTREFCLK       (gtcom_qpll0outrefclk[i>>2]),
+                
+                .GTCOM_QPLL1LOCK            (gtcom_qpll1lock[i>>2]),
+                .GTCOM_QPLL1OUTCLK          (gtcom_qpll1outclk[i>>2]),
+                .GTCOM_QPLL1OUTREFCLK       (gtcom_qpll1outrefclk[i>>2]),
+                
+                //--------------------------------------------------------------
+                //  Reset Ports
+                //--------------------------------------------------------------             
+                .GTCOM_QPLL0PD              (qpll0pd[i>>2]),         
+                .GTCOM_QPLL0RESET           (qpll0reset[i>>2]),
+                
+                .GTCOM_QPLL1PD              (qpll1pd[i>>2]),         
+                .GTCOM_QPLL1RESET           (qpll1reset[i>>2]),
+                
+                //--------------------------------------------------------------
+                //  PCIe Ports
+                //--------------------------------------------------------------    
+                .GTCOM_QPLLRATE             ({1'd0, PHY_RATE}),               
+                
+                //--------------------------------------------------------------
+                //  DRP Ports
+                //--------------------------------------------------------------
+                .GTCOM_DRPCLK               (GT_DRPCLK),                                     
+                .GTCOM_DRPADDR              (GTCOM_DRPADDR[(16*(i>>2))+15:(16*(i>>2))]),                        
+                .GTCOM_DRPEN                (GTCOM_DRPEN[i>>2]),                             
+                .GTCOM_DRPWE                (GTCOM_DRPWE[i>>2]),
+                .GTCOM_DRPDI                (GTCOM_DRPDI[(16*(i>>2))+15:(16*(i>>2))]),                     
+                                                                             
+                .GTCOM_DRPRDY               (GTCOM_DRPRDY[i>>2]),
+                .GTCOM_DRPDO                (GTCOM_DRPDO[(16*(i>>2))+15:(16*(i>>2))])
+            );
+           end // gt_common_int
+
+            end // phy_quad 
+            
+        end // phy_lane
+       
+endgenerate 
+//--------------------------------------------------------------------------------------------------
+//  Generate - End
+//--------------------------------------------------------------------------------------------------
+generate
+    if (PHY_GTWIZARD == "TRUE") begin :gt_wizard_smsw
+
+xp4_usp_smsw_gtwizard_top #
+        (
+            .PHY_LANE                       (PHY_LANE),                    
+            .PHY_MAX_SPEED                  (PHY_MAX_SPEED),
+            .PHY_GT_XCVR                    (PHY_GT_XCVR)
+        )
+        gtwizard_top_smsw_i
+        (  
+        
+            //------------------------------------------------------------------
+            //  Clock Ports *
+            //------------------------------------------------------------------
+            .GT_GTREFCLK0                   (PHY_GTREFCLK),                     
+            .GT_TXUSRCLK                    ({PHY_LANE{pclk}}),
+            .GT_RXUSRCLK                    ({PHY_LANE{pclk}}), 
+            .GT_TXUSRCLK2                   ({PHY_LANE{pclk2_gt}}),
+            .GT_RXUSRCLK2                   ({PHY_LANE{pclk2_gt}}), 
+            
+            .GT_RXOUTCLK                    (DBG_RXOUTCLK), 
+            .GT_TXOUTCLKFABRIC              (DBG_TXOUTCLKFABRIC),                                                        
+            .GT_RXOUTCLKFABRIC              (DBG_RXOUTCLKFABRIC),                                                        
+            .GT_TXOUTCLKPCS                 (DBG_TXOUTCLKPCS),                                                        
+            .GT_RXOUTCLKPCS                 (DBG_RXOUTCLKPCS),  
+            .GT_RXRECCLKOUT                 (DBG_RXRECCLKOUT),
+            .GT_TXOUTCLKSEL                 ({PHY_LANE{PHY_TXOUTCLKSEL}}),
+            //------------------------------------------------------------------
+            //  BUFG_GT Controller Ports *                                               
+            //------------------------------------------------------------------ 
+            .GT_BUFGTCE                     (gt_bufgtce),     
+            .GT_BUFGTCEMASK                 (gt_bufgtcemask), 
+            .GT_BUFGTRESET                  (gt_bufgtreset),
+            .GT_BUFGTRSTMASK                (gt_bufgtrstmask),   
+            .GT_BUFGTDIV                    (gt_bufgtdiv),
+            .GT_TXOUTCLK                    (gt_txoutclk),   
+            
+            //------------------------------------------------------------------  
+            //  Reset Ports *                                                      
+            //------------------------------------------------------------------  
+            .GT_CPLLPD                      ({PHY_LANE{rst_cpllpd}}),              
+            .GT_CPLLRESET                   ({PHY_LANE{rst_cpllreset}}),           
+            .GT_TXPROGDIVRESET              ({PHY_LANE{rst_txprogdivreset}}),        
+            .GT_RXPROGDIVRESET              ({PHY_LANE{rst_txprogdivreset}}),        
+            .GT_GTTXRESET                   ({PHY_LANE{rst_gtreset}}),             
+            .GT_GTRXRESET                   ({PHY_LANE{rst_gtreset}}),             
+            .GT_TXUSERRDY                   ({PHY_LANE{rst_userrdy}}),             
+            .GT_RXUSERRDY                   ({PHY_LANE{rst_userrdy}}),             
+                                                                                  
+            .GT_TXPMARESET                  (DBG_TXPMARESET),                                            
+            .GT_RXPMARESET                  (DBG_RXPMARESET),                                            
+            .GT_TXPCSRESET                  (DBG_TXPCSRESET),   
+            .GT_RXPCSRESET                  (DBG_RXPCSRESET),  
+            .GT_RXBUFRESET                  (DBG_RXBUFRESET),
+            .GT_RXCDRRESET                  (DBG_RXCDRRESET),  
+            .GT_RXDFELPMRESET               (DBG_RXDFELPMRESET),                                
+
+            .GT_GTPOWERGOOD                 (gt_gtpowergood),                     
+            .GT_TXPROGDIVRESETDONE          (gt_txprogdivresetdone),              
+            .GT_TXRESETDONE                 (gt_txresetdone),                     
+            .GT_RXRESETDONE                 (gt_rxresetdone),                     
+            .GT_TXPMARESETDONE              (DBG_TXPMARESETDONE),     
+            .GT_RXPMARESETDONE              (DBG_RXPMARESETDONE),             
+            
+            //--------------------------------------------------------------
+            //  Common QPLL Ports *
+            //--------------------------------------------------------------
+            .GTCOM_QPLLPD                   (rst_qpllpd),         
+            .GTCOM_QPLLRESET                (rst_qpllreset), 
+            
+            .GTCOM_QPLL1LOCK                (gtcom_qpll1lock),
+            .GTCOM_QPLL0LOCK                (gtcom_qpll0lock),
+
+            .GTCOM_QPLL0OUTCLK              (gtcom_qpll0outclk),
+            .GTCOM_QPLL0OUTREFCLK           (gtcom_qpll0outrefclk),
+            .GTCOM_QPLL1OUTCLK              (gtcom_qpll1outclk),
+            .GTCOM_QPLL1OUTREFCLK           (gtcom_qpll1outrefclk),
+            //--------------------------------------------------------------
+            //  Common DRP Ports *
+            //--------------------------------------------------------------
+            .GTCOM_DRPCLK                   (GT_DRPCLK),                                     
+            .GTCOM_DRPADDR                  (GTCOM_DRPADDR),                        
+            .GTCOM_DRPEN                    (GTCOM_DRPEN),                             
+            .GTCOM_DRPWE                    (GTCOM_DRPWE),
+            .GTCOM_DRPDI                    (GTCOM_DRPDI),                     
+                                                                             
+            .GTCOM_DRPRDY                   (GTCOM_DRPRDY),
+            .GTCOM_DRPDO                    (GTCOM_DRPDO),
+
+            .GT_DRPCLK                      ({PHY_LANE{PHY_REFCLK}}),
+            .GT_DRPADDR                     (gt_drpaddr),
+            .GT_DRPEN                       (gt_drpen),
+            .GT_DRPWE                       (gt_drpwe),
+            .GT_DRPDI                       (gt_drpdi),
+
+            .GT_DRPRDY                      (gt_drprdy),
+            .GT_DRPDO                       (gt_drpdo),            
+            //------------------------------------------------------------------
+            //  Serial Line Ports *
+            //------------------------------------------------------------------
+            .GT_RXP                         (PHY_RXP),
+            .GT_RXN                         (PHY_RXN),
+            
+            .GT_TXP                         (PHY_TXP),
+            .GT_TXN                         (PHY_TXN),
+            
+            //------------------------------------------------------------------
+            //  TX Data Ports *
+            //------------------------------------------------------------------
+            .GT_TXDATA                      (PHY_TXDATA),
+            .GT_TXDATAK                     (PHY_TXDATAK),
+            .GT_TXDATA_VALID                (PHY_TXDATA_VALID),
+            .GT_TXSTART_BLOCK               (PHY_TXSTART_BLOCK),
+            .GT_TXSYNC_HEADER               (PHY_TXSYNC_HEADER),
+            
+            //------------------------------------------------------------------
+            //  RX Data Ports *
+            //------------------------------------------------------------------
+            .GT_RXDATA                      (PHY_RXDATA),
+            .GT_RXDATAK                     (PHY_RXDATAK),
+            .GT_RXDATA_VALID                (PHY_RXDATA_VALID),
+            .GT_RXSTART_BLOCK               (PHY_RXSTART_BLOCK),
+            .GT_RXSYNC_HEADER               (PHY_RXSYNC_HEADER),
+            
+            //------------------------------------------------------------------
+            //  PHY Command Ports *
+            //------------------------------------------------------------------
+            .GT_TXDETECTRX                  ({PHY_LANE{PHY_TXDETECTRX}}),
+            .GT_TXELECIDLE                  (PHY_TXELECIDLE), 
+            .GT_TXCOMPLIANCE                (PHY_TXCOMPLIANCE),
+            .GT_RXPOLARITY                  (PHY_RXPOLARITY),
+            .GT_POWERDOWN                   ({PHY_LANE{PHY_POWERDOWN}}),
+            .GT_RATE                        ({PHY_LANE{PHY_RATE}}),       
+            .GT_RXCDRHOLD                   (gt_rxcdrhold),      
+                
+            //------------------------------------------------------------------
+            //  PHY Status Ports *
+            //------------------------------------------------------------------
+            .GT_RXVALID                     (PHY_RXVALID),
+            .GT_PHYSTATUS                   (gt_phystatus),
+            .GT_RXELECIDLE                  (gt_rxelecidle),
+            .GT_RXSTATUS                    (PHY_RXSTATUS),
+                
+            //------------------------------------------------------------------
+            //  TX Driver Ports *
+            //------------------------------------------------------------------
+            .GT_TXMARGIN                    ({PHY_LANE{PHY_TXMARGIN}}),
+            .GT_TXSWING                     ({PHY_LANE{PHY_TXSWING}}),
+            .GT_TXDEEMPH                    ({PHY_LANE{PHY_TXDEEMPH}}),  
+            
+            //------------------------------------------------------------------
+            //  TX Equalization Ports (Gen3) *
+            //------------------------------------------------------------------
+            .GT_TXPRECURSOR                 (txeq_precursor),
+            .GT_TXMAINCURSOR                (txeq_maincursor),
+            .GT_TXPOSTCURSOR                (txeq_postcursor),
+            
+            //------------------------------------------------------------------
+            //  PCIe PCS (Advance Feature) *
+            //------------------------------------------------------------------
+            .GT_PCIERSTIDLE                 ({PHY_LANE{rst_idle}}),        
+            .GT_PCIERSTTXSYNCSTART          ({PHY_LANE{rst_txsync_start}}), 
+            .GT_PCIEEQRXEQADAPTDONE         ({PHY_LANE{1'd0}}),                 // Not used
+            .GT_PCIEUSERRATEDONE            (DBG_RATE_DONE),                 // For debug only
+        
+            .GT_PCIEUSERPHYSTATUSRST        (gt_pcieuserphystatusrst),    
+            .GT_PCIERATEQPLLPD              (gt_pcierateqpllpd),     
+            .GT_PCIERATEQPLLRESET           (gt_pcierateqpllreset), 
+            .GT_PCIERATEIDLE                (gt_pcierateidle),            
+            .GT_PCIESYNCTXSYNCDONE          (gt_pciesynctxsyncdone),  
+            .GT_PCIERATEGEN3                (gt_pcierategen3),    
+            .GT_PCIEUSERGEN3RDY             (gt_pcieusergen3rdy),  
+            .GT_PCIEUSERRATESTART           (gt_pcieuserratestart), 
+            
+            .GT_TXPHALIGNDONE               (gt_txphaligndone),            
+             //-----------------------------------------------------------------
+             //  Loopback and PRBS Ports *
+             //-----------------------------------------------------------------  
+						.GT_LOOPBACK                    ({PHY_LANE{DBG_LOOPBACK}}),                                              
+            .GT_PRBSSEL                     ({PHY_LANE{DBG_PRBSSEL}}),
+            .GT_TXPRBSFORCEERR              ({PHY_LANE{DBG_TXPRBSFORCEERR}}), 
+            .GT_TXINHIBIT                   ({PHY_LANE{1'd0}}),
+            .GT_RXPRBSCNTRESET              ({PHY_LANE{DBG_RXPRBSCNTRESET}}),                                                                                                      
+            
+            .GT_RXPRBSERR                   (DBG_RXPRBSERR),                                              
+            .GT_RXPRBSLOCKED                (DBG_RXPRBSLOCKED),  
+        
+            .GT_TXDLYSRESETDONE             ( ),//(GT_TXDLYSRESETDONE ),    
+            .GT_TXPHINITDONE                ( ),//(GT_TXPHINITDONE),
+            .GT_RXCOMMADET                  ( ),//(GT_RXCOMMADET),
+            .GT_RXBUFSTATUS                 ( ),//(GT_RXBUFSTATUS),
+            //------------------------------------------------------------------
+            //  GT Status Ports *
+            //------------------------------------------------------------------                                                   
+            .GT_CPLLLOCK                    (gt_cplllock),  
+            .GT_RXCDRLOCK                   (gt_rxcdrlock),
+
+            .GT_GEN34_EIOS_DET              (gt_gen34_eios_det),
+            .GT_RXRATEDONE                  (gt_rxratedone),
+
+            //------------------------------------------------------------------
+            //  GT RX Termination
+            //------------------------------------------------------------------   
+            .GT_RXTERMINATION               (gt_rxtermination)
+        );
+    end
+endgenerate 
+
+//--------------------------------------------------------------------------------------------------
+//  Convert per-lane signals to per-design 
+//--------------------------------------------------------------------------------------------------
+    assign qpll0lock_all   = &gtcom_qpll0lock;
+    assign qpll1lock_all   = &gtcom_qpll1lock;
+    assign txsyncallin_all = &gt_txphaligndone;
+
+//------------------------------------------------------------------------------
+//  PHYSTATUS Reset Synchronizer for PCLK 
+//------------------------------------------------------------------------------
+
+always @ (posedge pclk or negedge rst_idle)
+  begin
+    if (!rst_idle)
+      rst_psrst_n_r <= 4'd0;
+    else
+      rst_psrst_n_r <= {rst_psrst_n_r[2:0], 1'd1};
+  end
+
+//--------------------------------------------------------------------------------------------------
+//  PHY Wrapper Outputs
+//--------------------------------------------------------------------------------------------------
+assign PHY_PCLK               = pclk;
+assign PHY_PHYSTATUS          = gt_phystatus;
+assign PHY_PHYSTATUS_RST      = !rst_psrst_n_r[3];
+assign PHY_RXELECIDLE         = gt_rxelecidle;
+
+//------------------------------------------------------------------------------
+//  TX Equalization Outputs (Gen3/Gen4) 
+//------------------------------------------------------------------------------
+assign PHY_TXEQ_FS            = 6'd40;                                          // Value based on GT TX driver characteristic                                    
+assign PHY_TXEQ_LF            = 6'd12;                                          // Value based on GT TX driver characteristic
+assign PHY_TXEQ_NEW_COEFF     = txeq_new_coeff;        
+assign PHY_TXEQ_DONE          = txeq_done;                                                   
+      
+//------------------------------------------------------------------------------
+//  RX Equalization Outputs (Gen3/Gen4)
+//------------------------------------------------------------------------------     
+assign PHY_RXEQ_LFFS_SEL      = rxeq_lffs_sel;                                                  
+assign PHY_RXEQ_NEW_TXCOEFF   = rxeq_new_txcoeff;     
+assign PHY_RXEQ_ADAPT_DONE    = rxeq_adapt_done;   
+assign PHY_RXEQ_DONE          = rxeq_done;   
+
+//------------------------------------------------------------------------------
+//  Debug Outputs 
+//------------------------------------------------------------------------------ 
+assign DBG_RATE_START         = gt_pcieuserratestart;
+assign DBG_RST_IDLE           = rst_idle;
+assign DBG_RATE_IDLE          = gt_pcierateidle;
+assign DBG_RXCDRLOCK          = gt_rxcdrlock;     
+
+assign DBG_TXOUTCLK           = gt_txoutclk;     
+    
+assign DBG_RRST_N             = rrst_n;
+assign DBG_PRST_N             = prst_n;
+assign DBG_GTPOWERGOOD        = gt_gtpowergood;
+assign DBG_CPLLLOCK           = gt_cplllock;
+assign DBG_QPLL0LOCK          = gtcom_qpll0lock;
+assign DBG_QPLL1LOCK          = gtcom_qpll1lock;
+assign DBG_TXPROGDIVRESETDONE = gt_txprogdivresetdone;
+assign DBG_TXRESETDONE        = gt_txresetdone;
+assign DBG_RXRESETDONE        = gt_rxresetdone;
+assign DBG_TXSYNCDONE         = gt_pciesynctxsyncdone;
+assign DBG_GEN34_EIOS_DET     = gt_gen34_eios_det;
+                                           
+           
+
+endmodule
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2023 AMD, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD, Inc. and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : UltraScale+ FPGA PCI Express v4.0 Integrated Block
+// File       : xp4_usp_smsw_gt_cdr_ctrl_on_eidle.v
+// Version    : 1.1 
+//-----------------------------------------------------------------------------
+//--------------------------------------------------------------------------------------------------
+//  Design :  PHY Wrapper
+//  Module :  CDR Control Upon EIDLE Detection
+//--------------------------------------------------------------------------------------------------
+
+`timescale 1ps / 1ps
+
+//--------------------------------------------------------------------------------------------------
+//  CDR Control Upon EIDLE Detection Module
+//--------------------------------------------------------------------------------------------------
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_gt_cdr_ctrl_on_eidle #
+(
+    parameter         PHY_GEN12_CDR_CTRL_ON_EIDLE = "FALSE",
+    parameter         PHY_GEN34_CDR_CTRL_ON_EIDLE = "FALSE",
+    parameter integer PHY_REFCLK_MODE            = 0,
+    parameter integer SYNC_STAGE                 = 3,
+    parameter integer PHY_REFCLK_FREQ            = 0
+)
+(
+    //-------------------------------------------------------------------------- 
+    //  Input Ports
+    //-------------------------------------------------------------------------- 
+    input                               CDRCTRL_PCLK,
+    input                               CDRCTRL_PCLK_RST_N,
+    input                               CDRCTRL_CLK,
+    input                               CDRCTRL_RST_N,
+    input     [ 1:0]                    CDRCTRL_RATE,
+    input                               CDRCTRL_RXELECIDLE,
+    input                               CDRCTRL_GEN34_EIOS_DET,
+    input                               CDRCTRL_RXCDRHOLD_IN,    
+    input                               CDRCTRL_RXCDRFREQRESET_IN,
+    input                               CDRCTRL_RXRATEDONE,
+    
+    //-------------------------------------------------------------------------- 
+    //  Output Ports
+    //-------------------------------------------------------------------------- 
+    output                              CDRCTRL_RXCDRFREQRESET_OUT,
+    output                              CDRCTRL_RXCDRHOLD_OUT,
+    output                              CDRCTRL_RESETOVRD_OUT
+);
+    //--------------------------------------------------------------------------
+    //  Synchronized Signals
+    //--------------------------------------------------------------------------                                     
+    wire                                gen3or4;
+    reg         [ 1:0]                  rate_r;     
+    reg         [ 1:0]                  rate_r2;
+    wire                                rxelecidle_a;
+    reg         [ 1:0]                  rxelecidle_r;
+    wire                                gen34_eios_det_a;
+    reg         [ 1:0]                  gen34_eios_det_r;
+    wire                                rxcdrhold_in_r;
+    reg                                 rate_change;
+    wire                                rate_change_a;
+    
+    reg        [6:0]    rxelecidle_cycle_count;
+    wire        ctrl_fsm_not_in_solid_deassert;
+    //-------------------------------------------------------------------------- 
+    //  FSM Signals
+    //-------------------------------------------------------------------------- 
+    reg [ 2:0] fsm;
+    
+    reg                                 rxcdrhold = 1'd0;     
+    reg        [ 7:0]                   counter_max = 8'd0;
+    reg        [ 7:0]                   wait_ctr = 8'd0;
+    reg                                 resetovrd = 1'd0;
+    reg                                 rxcdrfreqreset = 1'd0;
+    
+    reg                                 exit = 1'd0;
+    wire                                rst_n;
+
+    localparam MAX_COUNT_ENTER = (PHY_REFCLK_FREQ == 2) ? 8'd9 : 
+                                 (PHY_REFCLK_FREQ == 1) ? 8'd4  : 8'd3;
+    
+    localparam MAX_COUNT_EXIT = (PHY_REFCLK_FREQ == 2)  ? 8'd75 : 
+                                 (PHY_REFCLK_FREQ == 1) ? 8'd38 : 8'd30;
+    
+    assign rst_n = CDRCTRL_RST_N;
+
+    reg [3:0] gen34_eios_det_extend;
+    reg [7:0] rate_change_extend = 8'd0;
+    reg rxelecidle_int = 0;
+    reg gen34_eios_det_pclk;
+    reg rate_change_extend_pclk;
+    
+    always @(posedge CDRCTRL_PCLK) 
+    begin
+      if (!CDRCTRL_PCLK_RST_N) begin
+        gen34_eios_det_extend <= 4'd0;
+        gen34_eios_det_pclk <= 1'd0;
+      end 
+      else begin
+        gen34_eios_det_extend <= {gen34_eios_det_extend[2:0],CDRCTRL_GEN34_EIOS_DET};
+        gen34_eios_det_pclk <= |gen34_eios_det_extend;
+      end
+    end
+    
+    //--------------------------------------------------------------------------------------------------
+    //  Input Synchronizer or Pipeline
+    //--------------------------------------------------------------------------------------------------
+    xp4_usp_smsw_sync #(.WIDTH (1), .STAGE (SYNC_STAGE)) sync_gen34          (.CLK (CDRCTRL_CLK), .D (CDRCTRL_RATE[1]),         .Q (gen3or4));
+    xp4_usp_smsw_sync #(.WIDTH (1), .STAGE (SYNC_STAGE)) sync_rxelecidle     (.CLK (CDRCTRL_CLK), .D (CDRCTRL_RXELECIDLE),      .Q (rxelecidle_a));
+    xp4_usp_smsw_sync #(.WIDTH (1), .STAGE (SYNC_STAGE)) sync_gen34_eios_det (.CLK (CDRCTRL_CLK), .D (gen34_eios_det_pclk),     .Q (gen34_eios_det_a));
+    xp4_usp_smsw_sync #(.WIDTH (1), .STAGE (SYNC_STAGE)) sync_rxcdrreset_in  (.CLK (CDRCTRL_CLK), .D (CDRCTRL_RXCDRHOLD_IN),    .Q (rxcdrhold_in_r));
+    
+    always @ (posedge CDRCTRL_CLK) 
+    begin
+      if (!rst_n) begin
+        rxelecidle_r <= 2'd3;
+        gen34_eios_det_r <= 2'd0;
+      end 
+      else begin 
+        rxelecidle_r <= {rxelecidle_r[0], rxelecidle_a}; 
+        gen34_eios_det_r <= {gen34_eios_det_r[0], gen34_eios_det_a}; 
+      end
+    end 
+    
+generate
+    if (PHY_REFCLK_MODE <= 1) 
+    begin : non_sris
+    //--------------------------------------------------------------------------
+    //  FSM Encoding
+    //-------------------------------------------------------------------------- 
+    localparam FSM_IDLE                  = 3'd0;
+    localparam FSM_GEN12_RXELECIDLE_EXIT = 3'd1;
+    localparam FSM_GEN34_RXELECIDLE_EXIT = 3'd2;
+
+  assign ctrl_fsm_not_in_solid_deassert = (fsm == FSM_IDLE);
+    
+      always @ (posedge CDRCTRL_CLK) 
+      begin 
+        if (ctrl_fsm_not_in_solid_deassert) begin
+          rxelecidle_cycle_count <= 7'd0;
+        end 
+        else begin
+          if (!rxelecidle_r[1])
+            rxelecidle_cycle_count <= rxelecidle_cycle_count + 7'd1;        
+          else 
+            rxelecidle_cycle_count <= 7'd0;
+        end
+      end
+      
+      always @(posedge CDRCTRL_CLK)
+      begin 
+        if (ctrl_fsm_not_in_solid_deassert) begin
+          rxelecidle_int <= 1'b0;
+        end 
+        else begin
+          if (rxelecidle_cycle_count > 64)
+            rxelecidle_int <= 1'b1;
+          else 
+            rxelecidle_int <= rxelecidle_int;
+        end
+      end
+    
+    //--------------------------------------------------------------------------------------------------
+    //  Hold CDR upon EIOS/EIDLE detection FSM
+    //--------------------------------------------------------------------------------------------------
+      always @ (posedge CDRCTRL_CLK)
+      begin
+
+          if (!rst_n)
+              begin
+              fsm        <= FSM_IDLE;
+              rxcdrhold  <= 1'd0;
+              end
+          else
+              begin
+              
+              case (fsm)
+                  
+              //------------------------------------------------------------------------------------------
+              //  Stay in IDLE state until EIOS/EIDLE rising edge is detected
+              //------------------------------------------------------------------------------------------
+              FSM_IDLE :
+              
+                  begin
+                 if ((PHY_GEN12_CDR_CTRL_ON_EIDLE == "TRUE") && (!gen3or4) && (!rxelecidle_r[1]&rxelecidle_r[0]))
+                      begin
+                      fsm       <= FSM_GEN12_RXELECIDLE_EXIT;
+                      rxcdrhold <= 1'd1;
+                      end
+                 else if ((PHY_GEN34_CDR_CTRL_ON_EIDLE == "TRUE") && (gen3or4) && (!gen34_eios_det_r[1]&gen34_eios_det_r[0]))
+                      begin
+                      fsm       <= FSM_GEN34_RXELECIDLE_EXIT;
+                      rxcdrhold <= 1'd1;
+                      end
+                  else
+                      begin
+                      fsm       <= FSM_IDLE;
+                      rxcdrhold <= rxcdrhold_in_r;
+                      end
+                  end     
+                  
+              //------------------------------------------------------------------------------------------
+              //  Gen1/Gen2:  Hold RXCDRRESET until RXELECIDLE exit
+              //------------------------------------------------------------------------------------------
+              FSM_GEN12_RXELECIDLE_EXIT:
+              
+                  begin
+                  if (rxelecidle_int)
+                      begin
+                      fsm        <= FSM_IDLE;
+                      rxcdrhold  <= 1'd0;
+                      end
+                  else
+                      begin
+                      fsm        <= FSM_GEN12_RXELECIDLE_EXIT;
+                      rxcdrhold  <= 1'd1;
+                      end
+                  end    
+                  
+              //------------------------------------------------------------------------------------------
+              //  Gen3/Gen4:  Hold RXCDRRESET until RXELECIDLE exit
+              //------------------------------------------------------------------------------------------
+              FSM_GEN34_RXELECIDLE_EXIT:
+              
+                  begin
+                  if ((!gen34_eios_det_r[0]) & rxelecidle_int)
+                      begin
+                      fsm        <= FSM_IDLE;
+                      rxcdrhold  <= 1'd0;
+                      end
+                  else
+                      begin
+                      fsm        <= FSM_GEN34_RXELECIDLE_EXIT;
+                      rxcdrhold  <= 1'd1;
+                      end
+                  end    
+                  
+              //------------------------------------------------------------------------------------------
+              //  Default State
+              //------------------------------------------------------------------------------------------
+              default :
+              
+                  begin
+                  fsm        <= FSM_IDLE;
+                  rxcdrhold <= 1'd0;
+                  end
+
+              endcase
+              
+              end
+              
+      end
+    end 
+endgenerate
+
+generate
+  if (PHY_REFCLK_MODE == 2) begin : sris
+  
+    reg [7:0]rx_rate_done_extend = 8'd0;
+    reg rx_rate_done_extend_pclk = 1'd0;
+    wire rate_done_a;
+    reg rate_change_in_prog = 1'd0;
+  
+    always @(posedge CDRCTRL_PCLK)
+    begin
+      if (!CDRCTRL_PCLK_RST_N) begin
+        rate_r <= 2'd0;
+        rate_r2 <= 2'd0;
+        rate_change <= 1'b0;
+        rate_change_extend_pclk <= 1'd0;
+        rate_change_extend <= 7'd0;
+        rx_rate_done_extend_pclk <= 1'd0;
+        rx_rate_done_extend <= 7'd0;        
+      end
+      else begin
+        rate_r <= CDRCTRL_RATE;
+        rate_r2 <= rate_r;
+
+        if (rate_r2 != rate_r) 
+          rate_change <= 1'b1;
+        else
+          rate_change <= 1'b0;
+          
+        rate_change_extend <= {rate_change_extend[6:0],rate_change};
+        rate_change_extend_pclk <= |rate_change_extend;  
+
+        rx_rate_done_extend <= {rx_rate_done_extend[6:0],CDRCTRL_RXRATEDONE};
+        rx_rate_done_extend_pclk <= |rx_rate_done_extend;          
+        
+      end  
+    end
+    
+    xp4_usp_smsw_sync #(.WIDTH (1), .STAGE (SYNC_STAGE)) sync_rate_change    (.CLK (CDRCTRL_CLK), .D (rate_change_extend_pclk), .Q (rate_change_a));
+    xp4_usp_smsw_sync #(.WIDTH (1), .STAGE (SYNC_STAGE)) sync_rate_done      (.CLK (CDRCTRL_CLK), .D (rx_rate_done_extend_pclk), .Q (rate_done_a));
+    
+    //--------------------------------------------------------------------------
+    //  FSM Encoding
+    //-------------------------------------------------------------------------- 
+    localparam FSM_IDLE                                 = 3'd0;
+    localparam FSM_COUNTER                              = 3'd1;
+    localparam FSM_GEN12_RXELECIDLE_EXIT_OR_RATE_CHANGE = 3'd2;
+    localparam FSM_GEN34_RXELECIDLE_EXIT_OR_RATE_CHANGE = 3'd3;
+    localparam FSM_WAIT_RATE_DONE                       = 3'd4;
+    
+    //--------------------------------------------------------------------------------------------------
+    //  Reset CDR upon EIOS/EIDLE detection FSM
+    //--------------------------------------------------------------------------------------------------
+      always @ (posedge CDRCTRL_CLK)
+      begin
+
+          if (!rst_n)
+              begin
+              fsm            <= FSM_IDLE;
+              resetovrd      <= 1'd0;
+              rxcdrfreqreset <= 1'd0;
+              wait_ctr       <= 8'd0;
+              counter_max    <= 8'd0;
+              exit           <= 1'd0;
+              rate_change_in_prog <= 1'd0;
+              end
+          else
+              begin
+              
+              case (fsm)
+                  
+              //------------------------------------------------------------------------------------------
+              //  Stay in IDLE state until EIOS/EIDLE rising edge is detected
+              //------------------------------------------------------------------------------------------
+              FSM_IDLE :
+              
+                begin
+                exit           <= 1'd0;
+                
+                counter_max <= MAX_COUNT_ENTER;
+                
+                 if ((PHY_GEN12_CDR_CTRL_ON_EIDLE == "TRUE") && ((!gen3or4) && (!rxelecidle_r[1]&rxelecidle_r[0])) || (rate_change_in_prog && !rxelecidle_r[0]) )
+                      begin
+                      fsm        <= FSM_COUNTER;
+                      resetovrd  <= 1'd1;
+                      rxcdrfreqreset <= 1'd0;
+                      end
+                 else if ((PHY_GEN34_CDR_CTRL_ON_EIDLE == "TRUE") && (gen3or4) && (!gen34_eios_det_r[1]&gen34_eios_det_r[0]) || (rate_change_in_prog && !rxelecidle_r[0]))
+                      begin
+                      fsm        <= FSM_COUNTER;
+                      resetovrd  <= 1'd1;
+                      rxcdrfreqreset <= 1'd0;
+                      end
+                  else
+                      begin
+                      fsm       <= FSM_IDLE;
+                      resetovrd <= 1'd0;
+                      rxcdrfreqreset <= 1'd0;
+                      end
+                      
+                  end     
+              
+              FSM_COUNTER : 
+              
+                begin
+                  if (wait_ctr < counter_max)
+                  begin
+                    wait_ctr <= wait_ctr + 1'b1;
+                    fsm <= FSM_COUNTER;
+                  end
+                  else begin
+                    wait_ctr <= 8'd0;
+                    
+                    if (!exit && !gen3or4) begin
+                      rxcdrfreqreset <= 1'd1;
+                      fsm <= FSM_GEN12_RXELECIDLE_EXIT_OR_RATE_CHANGE;
+                    end
+                    else if (!exit && gen3or4) begin
+                      rxcdrfreqreset <= 1'd1;
+                      fsm <= FSM_GEN34_RXELECIDLE_EXIT_OR_RATE_CHANGE;
+                    end
+                    else if (exit && rate_change_in_prog) begin
+                      fsm <= FSM_WAIT_RATE_DONE;
+                      resetovrd <= 1'd0;
+                    end
+                    else begin
+                      fsm <= FSM_IDLE;
+                      resetovrd <= 1'd0;
+                    end
+                  end
+                end
+              
+              //------------------------------------------------------------------------------------------
+              //  Gen1/Gen2:  Hold RXCDRREQRESET until RXELECIDLE exit or rate change detected
+              //------------------------------------------------------------------------------------------
+              FSM_GEN12_RXELECIDLE_EXIT_OR_RATE_CHANGE:
+              
+                  begin
+                  
+                  exit <= 1'd1;
+                  
+                  counter_max <= 8'd30;
+                  
+                  if (!rxelecidle_r[0] || rate_change_a)
+                      begin
+                      rate_change_in_prog <= rate_change_a;
+                      fsm            <= FSM_COUNTER;
+                      rxcdrfreqreset <= 1'd0;
+                      end
+                  else
+                      begin
+                      fsm        <= FSM_GEN12_RXELECIDLE_EXIT_OR_RATE_CHANGE;
+                      end
+                  end
+                  
+              //------------------------------------------------------------------------------------------
+              //  Gen3/Gen4:  Hold RXCDRREQRESET until RXELECIDLE exit or rate change detected
+              //------------------------------------------------------------------------------------------
+              FSM_GEN34_RXELECIDLE_EXIT_OR_RATE_CHANGE:
+                  begin 
+ 
+                  exit <= 1'd1;
+ 
+                  counter_max <= MAX_COUNT_EXIT;
+                  
+                  if (((!gen34_eios_det_r[0]) & (!rxelecidle_r[0])) || rate_change_a)
+                      begin
+                      rate_change_in_prog <= rate_change_a;
+                      fsm            <= FSM_COUNTER;
+                      rxcdrfreqreset <= 1'd0;
+                      end
+                  else
+                      begin
+                      fsm            <= FSM_GEN34_RXELECIDLE_EXIT_OR_RATE_CHANGE;
+                      end
+                  end    
+
+              FSM_WAIT_RATE_DONE:
+                begin 
+                  
+                  if (rate_done_a) 
+                    fsm <= FSM_IDLE;
+                  else 
+                    fsm <= FSM_WAIT_RATE_DONE;
+               
+                end                  
+              
+              //------------------------------------------------------------------------------------------
+              //  Default State
+              //------------------------------------------------------------------------------------------
+              default :
+              
+                  begin
+                  fsm            <= FSM_IDLE;
+                  resetovrd      <= 1'd0;
+                  rxcdrfreqreset <= 1'd0;
+                  wait_ctr       <= 8'd0;
+                  counter_max    <= 8'd0;         
+                  exit           <= 1'd0;
+                  end
+
+              endcase
+              
+              end
+        end      
+      end
+endgenerate
+
+//--------------------------------------------------------------------------------------------------
+//  HOLD CDR upon EIOS/EIDLE Detection Outputs
+//--------------------------------------------------------------------------------------------------
+assign CDRCTRL_RXCDRHOLD_OUT = rxcdrhold;
+
+//--------------------------------------------------------------------------------------------------
+//  RESET CDR upon EIOS/EIDLE Detection Outputs
+//--------------------------------------------------------------------------------------------------
+assign CDRCTRL_RXCDRFREQRESET_OUT = rxcdrfreqreset;
+assign CDRCTRL_RESETOVRD_OUT = resetovrd;
+
+
+endmodule
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2023 AMD, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD, Inc. and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : UltraScale+ FPGA PCI Express v4.0 Integrated Block
+// File       : xp4_usp_smsw_gt_gt_channel.v
+// Version    : 1.1 
+//-----------------------------------------------------------------------------
+//--------------------------------------------------------------------------------------------------
+//  Design :  PHY Wrapper 
+//  Module :  GT Channel
+//--------------------------------------------------------------------------------------------------
+
+`timescale 1ps / 1ps
+
+//--------------------------------------------------------------------------------------------------
+//  GT Channel Module
+//--------------------------------------------------------------------------------------------------
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_gt_gt_channel #
+(
+    parameter         PHY_SIM_EN                 = "FALSE", 
+    parameter         PHY_GT_XCVR                = "GTY",
+    parameter integer PHY_MODE                   = 0,
+    parameter integer PHY_REFCLK_MODE            = 0,
+    parameter integer PHY_LANE                   = 1,
+    parameter integer PHY_MAX_SPEED              = 3,
+    parameter         PHY_GEN4_64BIT_EN          = "FALSE",
+    parameter         PHY_GEN12_CDR_CTRL_ON_EIDLE = "FALSE",   
+    parameter         PHY_GEN34_CDR_CTRL_ON_EIDLE = "FALSE", 
+    parameter integer PHY_REFCLK_FREQ            = 0,                
+    parameter integer PHY_CORECLK_FREQ           = 2,
+    parameter         GT_LANE_NUM                = 0
+)
+(    
+    //--------------------------------------------------------------------------
+    //  Clock Ports
+    //--------------------------------------------------------------------------
+    input                               GT_GTREFCLK0,
+    input                               GT_TXUSRCLK,
+    input                               GT_RXUSRCLK,
+    input                               GT_TXUSRCLK2,
+    input                               GT_RXUSRCLK2,    
+
+    output                              GT_TXOUTCLK, 
+    output                              GT_RXOUTCLK,
+    output                              GT_TXOUTCLKFABRIC,                                                        
+    output                              GT_RXOUTCLKFABRIC,                                                        
+    output                              GT_TXOUTCLKPCS,                                                        
+    output                              GT_RXOUTCLKPCS,  
+    output                              GT_RXRECCLKOUT,
+
+    input       [ 2:0]                  GT_TXOUTCLKSEL,             
+    
+    //--------------------------------------------------------------------------   
+    //  BUFG_GT Controller Ports                                                                        
+    //--------------------------------------------------------------------------                   
+    output                              GT_BUFGTCE,       
+    output      [ 2:0]                  GT_BUFGTCEMASK, 
+    output                              GT_BUFGTRESET,
+    output      [ 2:0]                  GT_BUFGTRSTMASK,
+    output      [ 8:0]                  GT_BUFGTDIV,   
+                
+    //--------------------------------------------------------------------------
+    //  Reset Ports
+    //--------------------------------------------------------------------------
+    input                               GT_CPLLPD,
+    input                               GT_CPLLRESET,
+    input                               GT_TXPROGDIVRESET,
+    input                               GT_GTTXRESET,
+    input                               GT_GTRXRESET,
+    input                               GT_TXUSERRDY,
+    input                               GT_RXUSERRDY,
+    
+    input                               GT_TXPMARESET,                                            
+    input                               GT_RXPMARESET,                                            
+    input                               GT_TXPCSRESET,   
+    input                               GT_RXPCSRESET,  
+    input                               GT_RXBUFRESET,
+    input                               GT_RXCDRRESET,
+    input                               GT_RXDFELPMRESET,
+    input                               GT_RXCDRFREQRESET,
+    
+    input                               GT_RESETOVRD,
+                                        
+    output                              GT_GTPOWERGOOD,
+    output                              GT_TXPROGDIVRESETDONE,  
+    output                              GT_TXPMARESETDONE,
+    output                              GT_RXPMARESETDONE,
+    output                              GT_TXRESETDONE,
+    output                              GT_RXRESETDONE,                 
+    
+    //--------------------------------------------------------------------------
+    //  QPLL Ports
+    //--------------------------------------------------------------------------
+    input                               GT_QPLL0CLK,
+    input                               GT_QPLL0REFCLK,
+    input                               GT_QPLL0LOCK,
+    input                               GT_QPLL1CLK,
+    input                               GT_QPLL1REFCLK,
+    input                               GT_QPLL1LOCK,
+    
+    output      [ 2:0]                  GT_QPLLRATE,
+    
+    //--------------------------------------------------------------------------
+    //  Serial Line Ports
+    //--------------------------------------------------------------------------
+    input                               GT_RXN,
+    input                               GT_RXP,
+    
+    output                              GT_TXP,
+    output                              GT_TXN,
+    
+    //--------------------------------------------------------------------------
+    //  TX Data Ports 
+    //--------------------------------------------------------------------------
+    input       [63:0]                  GT_TXDATA,
+    input       [ 1:0]                  GT_TXDATAK,   
+    input                               GT_TXDATA_VALID,
+    input                               GT_TXSTART_BLOCK,      
+    input       [ 1:0]                  GT_TXSYNC_HEADER,  
+    
+    //--------------------------------------------------------------------------
+    //  RX Data Ports 
+    //--------------------------------------------------------------------------
+    output      [63:0]                  GT_RXDATA,
+    output      [ 1:0]                  GT_RXDATAK,
+    output                              GT_RXDATA_VALID,
+    output      [ 1:0]                  GT_RXSTART_BLOCK,      
+    output      [ 1:0]                  GT_RXSYNC_HEADER,     
+    
+    //--------------------------------------------------------------------------
+    //  PHY Command Ports
+    //--------------------------------------------------------------------------
+    input                               GT_TXDETECTRX,
+    input                               GT_TXELECIDLE,
+    input                               GT_TXCOMPLIANCE,
+    input                               GT_RXPOLARITY,
+    input       [ 1:0]                  GT_POWERDOWN,
+    input       [ 1:0]                  GT_RATE,
+    input                               GT_RXCDRHOLD,
+      
+    //--------------------------------------------------------------------------
+    //  PHY Status Ports
+    //--------------------------------------------------------------------------
+    output                              GT_RXVALID,
+    output                              GT_PHYSTATUS,
+    output                              GT_RXELECIDLE,
+    output      [ 2:0]                  GT_RXSTATUS,
+      
+    //--------------------------------------------------------------------------
+    //  TX Equalization Ports 
+    //--------------------------------------------------------------------------
+    input       [ 2:0]                  GT_TXMARGIN,
+    input                               GT_TXSWING,
+    input       [ 1:0]                  GT_TXDEEMPH,
+    
+    //--------------------------------------------------------------------------
+    //  TX Equalization Ports (Gen3)
+    //--------------------------------------------------------------------------
+    input       [ 4:0]                  GT_TXPRECURSOR,
+    input       [ 6:0]                  GT_TXMAINCURSOR,
+    input       [ 4:0]                  GT_TXPOSTCURSOR,      
+    
+    //--------------------------------------------------------------------------
+    //  PCIe Ports
+    //--------------------------------------------------------------------------
+    input                               GT_PCIERSTIDLE,        
+    input                               GT_PCIERSTTXSYNCSTART, 
+    input                               GT_PCIEEQRXEQADAPTDONE,
+    input                               GT_PCIEUSERRATEDONE,
+             
+    output                              GT_PCIEUSERPHYSTATUSRST,    
+    output      [ 1:0]                  GT_PCIERATEQPLLPD,                  
+    output      [ 1:0]                  GT_PCIERATEQPLLRESET,                
+    output                              GT_PCIERATEIDLE,            
+    output                              GT_PCIESYNCTXSYNCDONE,                      
+    output                              GT_PCIERATEGEN3,    
+    output                              GT_PCIEUSERGEN3RDY, 
+    output                              GT_PCIEUSERRATESTART,  
+                
+    //--------------------------------------------------------------------------
+    //  USB Ports
+    //--------------------------------------------------------------------------
+    input                               GT_TXONESZEROS,                        
+    input                               GT_RXEQTRAINING,                       
+    input                               GT_RXTERMINATION,                        
+    
+    output                              GT_POWERPRESENT,                                 
+                                                          
+    //--------------------------------------------------------------------------
+    //  TX Sync Alignment Ports
+    //--------------------------------------------------------------------------                                                      
+    input                               GT_TXSYNCALLIN,
+    input                               GT_TXSYNCIN,                                        
+                
+    output                              GT_TXPHALIGNDONE,            
+    output                              GT_TXSYNCOUT,
+   
+    //--------------------------------------------------------------------------
+    //  Loopback & PRBS Ports
+    //--------------------------------------------------------------------------     
+    input       [ 2:0]                  GT_LOOPBACK,                                              
+    input       [ 3:0]                  GT_PRBSSEL,
+    input                               GT_TXPRBSFORCEERR, 
+    input                               GT_RXPRBSCNTRESET,                                                                                                      
+
+    output                              GT_RXPRBSERR,                                              
+    output                              GT_RXPRBSLOCKED,  
+      
+    //--------------------------------------------------------------------------
+    //  GT Status Ports
+    //--------------------------------------------------------------------------   
+    input                               GT_MASTER_CPLLLOCK,
+                                                                                                                      
+    output                              GT_CPLLLOCK,
+    output                              GT_RXCDRLOCK,
+    output                              GT_GEN34_EIOS_DET,
+    output                              GT_RXRATEDONE,
+
+    //--------------------------------------------------------------------------
+    //  DRP Ports
+    //--------------------------------------------------------------------------
+    input                               GT_DRPCLK,
+    input      [9:0]                    GT_DRPADDR,
+    input                               GT_DRPEN,
+    input                               GT_DRPWE,
+    input      [15:0]                   GT_DRPDI,
+    
+    output                              GT_DRPRDY,
+    output     [15:0]                   GT_DRPDO    
+);
+
+//-------------------------------------------------------------------------------------------------
+//  Internal Signals
+//-------------------------------------------------------------------------------------------------- 
+    wire        [127:0]                 txdata;
+    wire        [ 15:0]                 txctrl0;
+    wire        [ 15:0]                 txctrl1;
+    wire        [  7:0]                 txctrl2;
+    
+    wire        [127:0]                 rxdata;
+    wire        [ 15:0]                 rxctrl0;
+    
+    wire                                pcierategen3;
+    wire        [ 15:0]                 pcsrsvdout;
+    
+    wire                                rxelecidle_int;
+    wire                                phy_rxcdrreset;
+    wire                                rxcdrreset_int;
+ 
+ 
+ 
+    //----------------------------------------------------------------------------------------------
+    //  Single vs. Mulit-lane Selection
+    //----------------------------------------------------------------------------------------------
+    localparam [ 0:0] MULTI_LANE     = (PHY_LANE    == 1) ? 1'b0 : 1'b1;
+    localparam [ 0:0] MASTER_LANE    = (GT_LANE_NUM == 0) ? 1'b1 : 1'b0;
+    localparam [ 0:0] LOCAL_MASTER   = 1'b1;                                                        // Default for GTH                                      
+
+
+
+    //----------------------------------------------------------------------------------------------
+    //  PHY Mode
+    //----------------------------------------------------------------------------------------------
+    localparam        PCS_PCIE_EN = (PHY_MODE == 1) ? "FALSE" : "TRUE";
+    localparam [ 0:0] USB_MODE    = (PHY_MODE == 1) ? 1'b1    : 1'b0;
+
+
+
+    //----------------------------------------------------------------------------------------------
+    //  CPLL_FBDIV - CPLL Feedback (N1) Divider
+    //----------------------------------------------------------------------------------------------
+    localparam CPLL_FBDIV_45 = (PHY_MAX_SPEED < 3) ? 5 : 4;
+    
+    
+    
+    //----------------------------------------------------------------------------------------------
+    //  CPLL_FBDIV - CPLL Feedback (N2) Divider
+    //----------------------------------------------------------------------------------------------
+    localparam CPLL_FBDIV = (PHY_REFCLK_FREQ == 2) ?  2 : 
+                            (PHY_REFCLK_FREQ == 1) ?  4 : 5;            
+    
+    
+    
+    //----------------------------------------------------------------------------------------------
+    // [TX/RX]OUT_DIV - Output Clock Divider
+    //----------------------------------------------------------------------------------------------
+    localparam OUT_DIV = (PHY_MODE      == 1) ? 1 :
+                         (PHY_MAX_SPEED  < 3) ? 2 : 4;  
+    
+    
+    
+    //----------------------------------------------------------------------------------------------
+    //  [TX/RX]_CLK25_DIV - Clock (25 MHz) Divider
+    //----------------------------------------------------------------------------------------------
+    localparam CLK25_DIV = (PHY_REFCLK_FREQ == 2) ? 10 : 
+                           (PHY_REFCLK_FREQ == 1) ?  5 : 4;
+                   
+                   
+                       
+    //----------------------------------------------------------------------------------------------
+    //  [TX/RX]_PROGDIV_CFG - Programmable Divider Configuration
+    //
+    //    Gen1/Gen2 : 250 MHz
+    //    Gen3      : 250 or 500 MHz
+    //    Gen4      : 500 MHz
+    //----------------------------------------------------------------------------------------------
+    localparam PROGDIV_CFG = (PHY_MAX_SPEED     < 3) ? 10.0 :                                          
+                             (PHY_MAX_SPEED    == 4) ?  4.0 :                                       
+                             (PHY_CORECLK_FREQ == 1) ?  8.0 : 4.0;                                 
+                       
+                       
+    
+    //----------------------------------------------------------------------------------------------
+    //  [TX/RX]PLLCLKSEL - PLL Clock Select   
+    //                                                    
+    //    2'b00 = CPLL                                                                          
+    //    2'b01 = Reserved                                                                          
+    //    2'b11 = QPLL0                                                                         
+    //    2'b10 = QPLL1                                                                           
+    //----------------------------------------------------------------------------------------------
+    localparam [ 1:0] PLLCLKSEL = (PHY_MAX_SPEED  < 3) ? 2'b00 : 
+                                  (PHY_MAX_SPEED == 3) ? 2'b10 : 2'b11;                                                             
+              
+                                    
+              
+    //----------------------------------------------------------------------------------------------
+    //  [TX/RX]SYSCLKSEL - System Clock Select   
+    //                                                    
+    //    2'b00 = CPLL                                                                          
+    //    2'b01 = Reserved                                                                          
+    //    2'b10 = QPLL0                                                                         
+    //    2'b11 = QPLL1                                                                           
+    //----------------------------------------------------------------------------------------------                 
+    localparam [ 1:0] SYSCLKSEL = (PHY_MAX_SPEED  < 3) ? 2'b00 : 
+                                  (PHY_MAX_SPEED == 3) ? 2'b11 : 2'b10;                          
+                                  
+                                           
+                          
+     //----------------------------------------------------------------------------------------------
+    //  OOBDIVCTL - OOB Divider Control   
+    //                                                    
+    //    2'd0 = div1                                                                        
+    //    2'd1 = div2                                                                        
+    //    2'd2 = div4                                                                        
+    //    2'd3 = div8                                                                         
+    //----------------------------------------------------------------------------------------------                 
+    localparam [ 1:0] OOBDIVCTL = (PHY_REFCLK_FREQ == 2) ? 2'd2 : 2'd1; 
+                                          
+                          
+                                                                                                    
+    //----------------------------------------------------------------------------------------------
+    //  PCIE_PLL_SEL_MODE_GENx - PLL Select Mode for PCIe
+    //
+    //    2'b00 = CPLL
+    //    2'b10 = QPLL0
+    //    2'b11 = QPLL1
+    //----------------------------------------------------------------------------------------------
+    localparam [ 1:0] PCIE_PLL_SEL_MODE_GEN12 = (PHY_MAX_SPEED  < 3) ? 2'b00 : 
+                                                (PHY_MAX_SPEED == 3) ? 2'b11 : 2'b10;                 
+   
+    localparam [ 1:0] PCIE_PLL_SEL_MODE_GEN3  = (PHY_MAX_SPEED  < 3) ? 2'b00 :
+                                                (PHY_MAX_SPEED == 3) ? 2'b11 : 2'b10;  
+      
+    localparam [ 1:0] PCIE_PLL_SEL_MODE_GEN4  = (PHY_MAX_SPEED  < 3) ? 2'b00 :         
+                                                (PHY_MAX_SPEED == 3) ? 2'b11 : 2'b10;  
+                            
+                            
+                            
+    //----------------------------------------------------------------------------------------------
+    //  PCIE_[TX/RX]PMA_CFG - PCIe PMA Configuration    
+    //                                         
+    //    [   15] : Reserved                                                        
+    //    [14:13] : [TX/RX]_INT_DATAWIDTH_G4                                                                    
+    //    [12: 9] : [TX/RX]_DATA_WIDTH_G4                                                     
+    //    [ 8: 6] : [TX/RX]OUTCLK_DIV_G2                                                        
+    //    [ 5: 3] : [TX/RX]OUTCLK_DIV_G3                                                        
+    //    [ 2: 0] : [TX/RX]OUTCLK_DIV_G4                                                          
+    //----------------------------------------------------------------------------------------------                                                      
+    localparam [ 1:0] INT_DATAWIDTH_G4 = 2'd1;
+    localparam [ 3:0] DATA_WIDTH_G4    = 4'd4;
+    localparam [ 2:0] OUT_DIV_G2       = (PHY_MAX_SPEED  < 3) ? 3'd0 : 3'd1;                                                                                                                                                     
+    localparam [ 2:0] OUT_DIV_G3       = (PHY_MAX_SPEED == 4) ? 3'd1 : 3'd0;                                                                                                                                                                    
+    localparam [ 2:0] OUT_DIV_G4       = 3'd0;                                                              
+
+    localparam [15:0] PCIE_PMA_CFG = {1'd0,      
+                                     INT_DATAWIDTH_G4,                                    
+                                     DATA_WIDTH_G4,                                                             
+                                     OUT_DIV_G2,                                                 
+                                     OUT_DIV_G3,                                                                                              
+                                     OUT_DIV_G4};         
+    
+    
+    
+    //----------------------------------------------------------------------------------------------
+    //  PCIE_BUFG_DIV_CTRL - PCIe BUFG_GT Divider Control
+    //
+    //    [   15] : BUFG_GT_FSM_CLK
+    //    [14:12] : PCLK_DIV_G1
+    //    [11:10] : PCLK_DIV_G2  
+    //    [ 9: 8] : PCLK_DIV_G3 
+    //    [ 7: 6] : PCLK_DIV_G4
+    //    [ 5: 0] : Reserved
+    //----------------------------------------------------------------------------------------------  
+    localparam [ 0:0] BUFG_GT_FSM_CLK    = 1'd0;                                                    // 1'b0 = REFCLK : 1'b1 = PROGDIVCLK
+                                                              
+    localparam [ 2:0] PCLK_DIV_G1        = (PHY_MODE         == 1) ? 3'd0 :                         // 250 MHz (USB3)
+                                           (PHY_MAX_SPEED     < 3) ? 3'd1 :  
+                                           (PHY_MAX_SPEED    == 4) ? 3'd3 :                              
+                                           (PHY_CORECLK_FREQ == 1) ? 3'd1 : 3'd3;                   // 125 MHz (PCIe)
+    
+    localparam [ 1:0] PCLK_DIV_G2        = (PHY_MAX_SPEED     < 3) ? 2'd0 : 
+                                           (PHY_MAX_SPEED    == 4) ? 2'd1 : 
+                                           (PHY_CORECLK_FREQ == 1) ? 2'd0 : 2'd1;                   // 250 MHz
+    
+    localparam [ 1:0] PCLK_DIV_G3        = PCLK_DIV_G2;                                             // 250 MHz
+    
+    localparam [ 1:0] PCLK_DIV_G4        = 2'd0;                                                    // 500 MHz
+            
+    localparam [15:0] PCIE_BUFG_DIV_CTRL = {BUFG_GT_FSM_CLK,                    
+                                            PCLK_DIV_G1, 
+                                            PCLK_DIV_G2,  
+                                            PCLK_DIV_G3,                                                            
+                                            PCLK_DIV_G4,
+                                            6'd0};
+                    
+                    
+                    
+    //----------------------------------------------------------------------------------------------
+    //  PCIE_TXPCS_CFG_GEN3 - PCIe TX PCS Configuration
+    //                                             
+    //    [15:14] : Reserved                                                        
+    //    [13:12] : TX_DRIVE_MODE_G3                                                                    
+    //    [   11] : ASYNC_EN   
+    //    [   10] : TX_XCLK_SEL_G3                                                   
+    //    [    9] : TXBUF_EN_G3                                                          
+    //    [ 8: 7] : TX_INT_DATAWIDTH_G3
+    //    [ 6: 3] : TX_DATA_WIDTH_G3
+    //    [    2] : TX_SYNC_MODE
+    //    [    1] : DRP_EXT_CTRL                                                         
+    //    [    0] : Reserved                                                         
+    //----------------------------------------------------------------------------------------------                                                      
+    localparam [ 1:0] TX_DRIVE_MODE_G3    = 2'd2;                                      // "PIPEGEN3"
+    localparam [ 0:0] ASYNC_EN            = (PHY_REFCLK_MODE != 0) ? 1'd1 : 1'd0;      // 1'b0 = Async : 1'b1 = Sync
+    localparam [ 0:0] TX_XCLK_SEL_G3      = 1'd1;                                      // "TXUSER" when bypassing TX buffer                                                                                                                                                     
+    localparam [ 0:0] TXBUF_EN_G3         = 1'd0;                                      // "FALSE"                                                                                                                                        
+    localparam [ 1:0] TX_INT_DATAWIDTH_G3 = 2'd1;                                      //  4-byte
+    localparam [ 3:0] TX_DATA_WIDTH_G3    = 4'd4;                                      // 32-bit 
+    localparam [ 0:0] TX_SYNC_MODE        = 1'd1;                                      // Auto 
+    localparam [ 0:0] DRP_EXT_CTRL        = 1'd0;                                      // Disable (Advance feature) 
+    
+    localparam [15:0] PCIE_TXPCS_CFG_GEN3 = {2'd0,
+                                             TX_DRIVE_MODE_G3,
+                                             ASYNC_EN,
+                                             TX_XCLK_SEL_G3,
+                                             TXBUF_EN_G3,
+                                             TX_INT_DATAWIDTH_G3,
+                                             TX_DATA_WIDTH_G3,
+                                             TX_SYNC_MODE,
+                                             DRP_EXT_CTRL,
+                                             1'd0};
+    
+    
+    
+    //----------------------------------------------------------------------------------------------
+    //  PCIE_RXPCS_CFG_GEN3 - PCIe RX PCS Configuration  
+    //                                                                                                  
+    //    [   15] : RX_DFE_LPM_HOLD_DURING_EIDLE_G3                                                                 
+    //    [   14] : RXCDR_PH_RESET_ON_EIDLE_G3  
+    //    [   13] : RXCDR_FR_RESET_ON_EIDLE_G3                                             
+    //    [   12] : RXCDR_HOLD_DURING_EIDLE_G3                                                      
+    //    [   11] : CLK_CORRECT_USE_G3
+    //    [   10] : RX_XCLK_SEL_G3
+    //    [    9] : RXBUF_EN_G3
+    //    [ 8: 7] : RX_INT_DATA_WIDTH_G3
+    //    [ 6: 3] : RX_DATA_WIDTH_G3
+    //    [    2] : RX_SYNC_MODE                                                        
+    //    [    1] : RATE_FSM_CLK  
+    //    [    0] : RXVALID_GATE_G3                                                
+    //----------------------------------------------------------------------------------------------                                                      
+    localparam [ 0:0] RX_DFE_LPM_HOLD_DURING_EIDLE_G3 = 1'd0;                          // 
+    localparam [ 0:0] RXCDR_PH_RESET_ON_EIDLE_G3      = 1'd0;                          // 
+    localparam [ 0:0] RXCDR_FR_RESET_ON_EIDLE_G3      = 1'd0;                          //                                                                                                                                          
+    localparam [ 0:0] RXCDR_HOLD_DURING_EIDLE_G3      = 1'd0;                          //             
+    localparam [ 0:0] CLK_CORRECT_USE_G3              = 1'd1;                          // "TRUE"       
+    localparam [ 0:0] RX_XCLK_SEL_G3                  = 1'd0;                          // "RXDES" when using RX buffer                                                                              
+    localparam [ 0:0] RXBUF_EN_G3                     = 1'd1;                          // "TRUE"
+    localparam [ 1:0] RX_INT_DATA_WIDTH_G3            = 2'd1;                          //  4-byte  
+    localparam [ 3:0] RX_DATA_WIDTH_G3                = 4'd4;                          // 32-bit  
+    localparam [ 0:0] RX_SYNC_MODE                    = 1'd1;                          // Auto
+    localparam [ 0:0] RATE_FSM_CLK                    = 1'd0;                          // 1'b0 = REFCLK : 1'b1 = PCLK
+    localparam [ 0:0] RXVALID_GATE_G3                 = 1'd1;
+    
+    localparam [15:0] PCIE_RXPCS_CFG_GEN3 = {RX_DFE_LPM_HOLD_DURING_EIDLE_G3,
+                                             RXCDR_PH_RESET_ON_EIDLE_G3,
+                                             RXCDR_FR_RESET_ON_EIDLE_G3,
+                                             RXCDR_HOLD_DURING_EIDLE_G3,
+                                             CLK_CORRECT_USE_G3,
+                                             RX_XCLK_SEL_G3,
+                                             RXBUF_EN_G3,
+                                             RX_INT_DATA_WIDTH_G3,
+                                             RX_DATA_WIDTH_G3,
+                                             RX_SYNC_MODE,
+                                             RATE_FSM_CLK,
+                                             RXVALID_GATE_G3};
+    
+    //----------------------------------------------------------------------------------------------
+    //  PCIe CDR for Gen1/Gen2
+    //  USB CDR for Gen1 (5G) uses same setting
+    //----------------------------------------------------------------------------------------------   
+    localparam [15:0] RXCDR_CFG0      = 16'b0000_0000_0000_0010;
+    localparam [15:0] RXCDR_CFG1      = 16'b0000_0000_0000_0000;
+    localparam [15:0] RXCDR_CFG2      = (PHY_REFCLK_MODE == 2) ? 16'b0000_0001_1110_0100 : 16'b0000001001011001;
+    localparam [15:0] RXCDR_CFG3      = 16'b0000_0000_0001_0010; 
+    localparam [15:0] RXCDR_CFG4      = 16'b0101_1100_1111_0110;
+    localparam [15:0] RXCDR_CFG5      = 16'b1011_0100_0110_1011;
+    
+    //----------------------------------------------------------------------------------------------
+    //  PCIe CDR for Gen3
+    //---------------------------------------------------------------------------------------------- 
+    localparam [15:0] RXCDR_CFG0_GEN3 = RXCDR_CFG0;
+    localparam [15:0] RXCDR_CFG1_GEN3 = RXCDR_CFG1;
+    localparam [15:0] RXCDR_CFG2_GEN3 = (PHY_REFCLK_MODE == 2) ? 16'b0000_0000_0011_0110 : 16'b0000_0000_0011_0100;
+    localparam [15:0] RXCDR_CFG3_GEN3 = RXCDR_CFG3; 
+    localparam [15:0] RXCDR_CFG4_GEN3 = RXCDR_CFG4;
+    localparam [15:0] RXCDR_CFG5_GEN3 = 16'b0001_0100_0110_1011;
+    
+    //----------------------------------------------------------------------------------------------
+    //  PCIe CDR for Gen4
+    //---------------------------------------------------------------------------------------------- 
+    localparam [15:0] RXCDR_CFG2_GEN4 = (PHY_REFCLK_MODE == 2) ? 16'b0000_0000_0100_0110 : 16'b0000_0000_0011_0100;          
+    localparam [15:0] RXCDR_CFG3_GEN4 = RXCDR_CFG4_GEN3;
+
+    //----------------------------------------------------------------------------------------------
+    //  PCIe RX Buffer for Gen1/Gen2
+    //----------------------------------------------------------------------------------------------  
+    localparam [5:0] PCIE_CLK_COR_MAX_LAT     = (PHY_REFCLK_MODE == 2) ? 6'd28 : (PHY_REFCLK_MODE == 1) ? 6'd20 : 6'd20;
+    localparam [5:0] PCIE_CLK_COR_MIN_LAT     = (PHY_REFCLK_MODE == 2) ? 6'd22 : (PHY_REFCLK_MODE == 1) ? 6'd17 : 6'd4;
+    localparam [5:0] PCIE_RXBUF_THRESH_OVFLW  = (PHY_REFCLK_MODE == 2) ? 6'd63 : (PHY_REFCLK_MODE == 1) ? 6'd31 : 6'd31;
+    localparam [5:0] PCIE_RXBUF_THRESH_UNDFLW = (PHY_REFCLK_MODE == 2) ? 6'd8  : (PHY_REFCLK_MODE == 1) ? 6'd8  : 6'd1;
+    
+    //----------------------------------------------------------------------------------------------
+    //  PCIe RX Buffer for Gen3/Gen4
+    //----------------------------------------------------------------------------------------------  
+    localparam [4:0] PCIE3_CLK_COR_EMPTY_THRSH = 5'd0;
+    localparam [5:0] PCIE3_CLK_COR_FULL_THRSH  = (PHY_REFCLK_MODE == 2) ? 6'd32 : (PHY_REFCLK_MODE == 1) ? 6'd16 : 6'd16;
+    localparam [4:0] PCIE3_CLK_COR_MAX_LAT     = (PHY_REFCLK_MODE == 2) ? 5'd16 : (PHY_REFCLK_MODE == 1) ? 5'd8  : 5'd4;
+    localparam [4:0] PCIE3_CLK_COR_MIN_LAT     = (PHY_REFCLK_MODE == 2) ? 5'd12 : (PHY_REFCLK_MODE == 1) ? 5'd4  : 5'd0;
+    localparam [5:0] PCIE3_CLK_COR_THRSH_TIMER = (PHY_REFCLK_MODE == 2) ? 6'd4  : (PHY_REFCLK_MODE == 1) ? 6'd8  : 6'd8;
+    
+    //----------------------------------------------------------------------------------------------
+    //  TX Electrical Idle Attributes for USB3 and PCIe
+    //---------------------------------------------------------------------------------------------- 
+    localparam [ 2:0]  TX_EIDLE_ASSERT_DELAY   = (PHY_MODE == 1)      ? 3'd0 :
+                                                 (PHY_MAX_SPEED == 4) ? 3'd6 :   // For PCIe Gen4 EIOS TX
+                                                                        3'd5 ;   // For PCIe Gen3 EIOS TX    
+    localparam [ 2:0]  TX_EIDLE_DEASSERT_DELAY = (PHY_MODE == 1) ? 3'd1 : 3'd3;
+    
+    //----------------------------------------------------------------------------------------------
+    //  Comma Align and Detect Attributres for USB3 and PCIe                                                                  
+    //----------------------------------------------------------------------------------------------     
+    localparam         ALIGN_COMMA_DOUBLE  = (PHY_MODE == 1) ? "TRUE" : "FALSE";                      
+    localparam         SHOW_REALIGN_COMMA  = (PHY_MODE == 1) ? "TRUE" : "FALSE";  
+    
+    //----------------------------------------------------------------------------------------------
+    //  Clock Correction Attributes for USB3 and PCIe
+    //----------------------------------------------------------------------------------------------
+    localparam [ 5:0]  CLK_COR_MAX_LAT      = (PHY_MODE == 1) ?  6'd16        : PCIE_CLK_COR_MAX_LAT;
+    localparam [ 5:0]  CLK_COR_MIN_LAT      = (PHY_MODE == 1) ?  6'd13        : PCIE_CLK_COR_MIN_LAT;
+    localparam         CLK_COR_KEEP_IDLE    = (PHY_MODE == 1) ? "FALSE"       : "TRUE";
+    localparam [ 9:0]  CLK_COR_SEQ_1_1      = (PHY_MODE == 1) ? 10'b100111100 : 10'b0100011100;
+    localparam [ 9:0]  CLK_COR_SEQ_1_2      = (PHY_MODE == 1) ? 10'b100111100 : 10'b0000000000;
+    localparam [ 3:0]  CLK_COR_SEQ_2_ENABLE = (PHY_MODE == 1) ?  4'b0000      :  4'b1111;
+    localparam [ 1:0]  CLK_COR_SEQ_LEN      = (PHY_MODE == 1) ? 2             : 1;
+
+    //----------------------------------------------------------------------------------------------
+    //  RX Buffer Attributes for USB3 and PCIe                                                                  
+    //----------------------------------------------------------------------------------------------
+    localparam [ 5:0]  RXBUF_THRESH_OVFLW  = (PHY_MODE == 1) ? 32 : PCIE_RXBUF_THRESH_OVFLW;                                                            
+    localparam [ 5:0]  RXBUF_THRESH_UNDFLW = (PHY_MODE == 1) ?  6 : PCIE_RXBUF_THRESH_UNDFLW;                                    
+    
+    //----------------------------------------------------------------------------------------------
+    //  RX Common Mode Select for USB3 and PCIe        
+    //
+    //    0 = AVTT
+    //    1 = GND
+    //    2 = Floating
+    //    3 = Programmable                                                         
+    //----------------------------------------------------------------------------------------------
+    localparam integer RX_CM_SEL = (PHY_MODE == 1) ?  1 : 3;   
+   
+    //----------------------------------------------------------------------------------------------
+    //  GT Attributes for USB3 and PCIe                                                                  
+    //----------------------------------------------------------------------------------------------  
+    localparam         SIM_TX_EIDLE_DRIVE_LEVEL = (PHY_MODE == 1) ? "Z"   : "LOW";    
+    localparam         RXSLIDE_MODE             = (PHY_MODE == 1) ? "OFF" : "PMA";   
+
+    //----------------------------------------------------------------------------------------------
+    //  Reserved Attributes for USB3 and PCIe                                                                  
+    //----------------------------------------------------------------------------------------------      
+    localparam [ 8:0]  USB_LFPS_DET      = (PHY_REFCLK_FREQ == 0) ? 9'b011001001 : 9'b011001010; 
+    localparam         RXTERMINATION_DRP = 1'd1;
+    localparam [ 1:0]  RX_CM_SEL_USB     = 2'd3;
+    
+    localparam [15:0]  PCS_RSVD0         = {USB_LFPS_DET, 4'd0, RXTERMINATION_DRP, RX_CM_SEL_USB};
+        
+    //----------------------------------------------------------------------------------------------
+    //  Other Attributes based on latest 2015.3 rules                                                                 
+    //----------------------------------------------------------------------------------------------   
+    localparam [3:0]   RX_SUM_VCMTUNE    = (PHY_MODE         == 1) ? 4'b0110 : 
+                                           (PHY_MAX_SPEED     < 3) ? 4'b0110 : 4'b1010; 
+                                           
+    localparam [3:0]   RX_SUM_IREF_TUNE  = (PHY_MODE         == 1) ? 4'b0100 : 
+                                           (PHY_MAX_SPEED     < 3) ? 4'b0100 : 4'b1001; 
+                                           
+    localparam         RXDFE_PWR_SAVING  = (PHY_MODE         == 1) ? 1'b0 :
+                                           (PHY_MAX_SPEED    == 4) ? 1'b1 : 1'b0;
+                                           
+    localparam         TX_PI_BIASSET     = (PHY_MODE         == 1) ? 0 :
+                                           (PHY_MAX_SPEED     < 3) ? 0 :
+                                           (PHY_MAX_SPEED    == 3) ? 1 : 3;
+    
+    localparam  [15:0] RXPI_CFG0         = (PHY_MODE         == 1) ? 16'h1200 :
+                                           (PHY_MAX_SPEED     < 3) ? 16'h1200 :
+                                           (PHY_MAX_SPEED    == 3) ? 16'h2202 : 16'b0000000100000100;
+//--------------------------------------------------------------------------------------------------
+//  GT Channel
+//--------------------------------------------------------------------------------------------------
+generate
+  if (PHY_GT_XCVR == "GTY" || PHY_GT_XCVR == "GTY64") begin: GTY_CHANNEL
+//--------------------------------------------------------------------------------------------------
+//  GTY Channel
+//--------------------------------------------------------------------------------------------------
+GTYE4_CHANNEL #
+(  
+    //----------------------------------------------------------------------------------------------
+    //  Simulation Attributes
+    //----------------------------------------------------------------------------------------------
+    .SIM_MODE                           ("FAST"),                                    
+    .SIM_RECEIVER_DETECT_PASS           ("TRUE"),
+    .SIM_RESET_SPEEDUP                  ("TRUE"),
+    .SIM_TX_EIDLE_DRIVE_LEVEL           (SIM_TX_EIDLE_DRIVE_LEVEL),
+    //.SIM_VERSION                        (1),                             
+   
+    //----------------------------------------------------------------------------------------------     
+    //  Clock Attributes
+    //----------------------------------------------------------------------------------------------                       
+    .TXREFCLKDIV2_SEL                   ( 1'b0),                              
+    .RXREFCLKDIV2_SEL                   ( 1'b0),                                
+    .TX_CLK25_DIV                       (CLK25_DIV),                                                    
+    .RX_CLK25_DIV                       (CLK25_DIV),                                                    
+    .TX_CLKMUX_EN                       ( 1'b1),                                                
+    .RX_CLKMUX_EN                       ( 1'b1),                                                
+    .TX_XCLK_SEL                        ("TXUSR"),                                              
+    .RX_XCLK_SEL                        ("RXDES"),   
+    .TXOUT_DIV                          (OUT_DIV), 
+    .RXOUT_DIV                          (OUT_DIV), 
+    .LOCAL_MASTER                       (LOCAL_MASTER),   
+    .RX_CLK_SLIP_OVRD                   ( 5'b00000),  
+    .RXPMACLK_SEL                       ("DATA"),                                                                                                                           
+    .USE_PCS_CLK_PHASE_SEL              ( 1'b0),           
+   
+    //----------------------------------------------------------------------------------------------     
+    //  Programmable Divider Attributes
+    //----------------------------------------------------------------------------------------------                                                                                                                       
+    .TX_PROGCLK_SEL                     ("CPLL"),                               
+    .TX_PROGDIV_CFG                     (PROGDIV_CFG),                      
+    .RX_PROGDIV_CFG                     (PROGDIV_CFG),   
+    .TX_PROGDIV_RATE                    (16'h0001),                          
+    .RX_PROGDIV_RATE                    (16'h0001),                                   
+               
+    //----------------------------------------------------------------------------------------------
+    //  CPLL Attributes
+    //----------------------------------------------------------------------------------------------                 
+    .CPLL_CFG0                          (16'h0000), //(16'h20FA),                             // Optimize for PCIe PLL compliance   [Changed for extracted model]
+    .CPLL_CFG1                          (16'h81E4), //(16'h24AA),               [Changed for extracted model]
+    .CPLL_CFG2                          (16'hF007),                             
+    .CPLL_CFG3                          ( 6'h00),  
+    .CPLL_FBDIV                         (CPLL_FBDIV),  
+    .CPLL_FBDIV_45                      (CPLL_FBDIV_45),    
+    .CPLL_INIT_CFG0                     (16'h001E),                
+    .CPLL_LOCK_CFG                      (16'h01EC), //(16'h01E8),                             // Bit[0] must be LOW   [Changed for extracted model]
+    .CPLL_REFCLK_DIV                    ( 1),     
+             
+    //----------------------------------------------------------------------------------------------
+    //  Reset Attributes
+    //----------------------------------------------------------------------------------------------                
+    //.RESET_POWERSAVE_DISABLE            ( 1'b0),   
+                                                                              
+    //----------------------------------------------------------------------------------------------
+    //  Reset Time Attributes
+    //----------------------------------------------------------------------------------------------    
+    .TX_DIVRESET_TIME                   ( 5'b00001),
+    .TXPCSRESET_TIME	                ( 5'b00001),
+    .TXPMARESET_TIME	                ( 5'b00001),
+    .RX_DIVRESET_TIME                   ( 5'b00001),
+    .RXBUFRESET_TIME                    ( 5'b00001),
+    .RXCDRFREQRESET_TIME                ( 5'b10000), //( 5'b00001),  [Changed for extracted model]
+    .RXCDRPHRESET_TIME                  ( 5'b00001),    
+    .RXDFELPMRESET_TIME                 ( 7'b0001111),    
+    .RXISCANRESET_TIME	                ( 5'b00001), 
+    .RXOSCALRESET_TIME	                ( 5'b00011), 
+    .RXPCSRESET_TIME	                  ( 5'b00001),   
+    .RXPMARESET_TIME	                  ( 5'b00001),   
+               
+    //----------------------------------------------------------------------------------------------
+    //  PCIe Attributes
+    //----------------------------------------------------------------------------------------------
+    .PCIE_GEN4_64BIT_INT_EN             (PHY_GEN4_64BIT_EN),  // THIS ATTRIBUTE IS NEW AND MAY NOT BE AVAILABLE IN EARLY GT MODELS
+    .PCIE_BUFG_DIV_CTRL                 (PCIE_BUFG_DIV_CTRL),                  
+    .PCIE_RXPCS_CFG_GEN3                (PCIE_RXPCS_CFG_GEN3),                 
+    .PCIE_RXPMA_CFG                     (PCIE_PMA_CFG),                        
+    .PCIE_TXPCS_CFG_GEN3                (PCIE_TXPCS_CFG_GEN3),                 
+    .PCIE_TXPMA_CFG                     (PCIE_PMA_CFG),                        
+    .PCS_PCIE_EN                        (PCS_PCIE_EN),  
+    .PCIE_PLL_SEL_MODE_GEN12            (PCIE_PLL_SEL_MODE_GEN12),                  
+    .PCIE_PLL_SEL_MODE_GEN3             (PCIE_PLL_SEL_MODE_GEN3),  
+    .PCIE_PLL_SEL_MODE_GEN4             (PCIE_PLL_SEL_MODE_GEN4),
+
+    //---------------------------------------------------------------------------------------------- 
+    //  Data Width Attributes
+    //----------------------------------------------------------------------------------------------                          
+    .TX_DATA_WIDTH                      (20),                                                                                                                                         
+    .RX_DATA_WIDTH                      (20),  
+    .TX_INT_DATAWIDTH                   ( 0),                                                                
+    .RX_INT_DATAWIDTH                   ( 0),   
+    .TX_FABINT_USRCLK_FLOP              ( 1'b0), 
+    .RX_FABINT_USRCLK_FLOP              ( 1'b0),                                                    
+              
+    //----------------------------------------------------------------------------------------------
+    //  Analog Front End Attributes
+    //----------------------------------------------------------------------------------------------
+    .LPBK_BIAS_CTRL	                    ( 3'b000),                           
+    .LPBK_EN_RCAL_B	                    ( 1'b0),                             
+    .LPBK_EXT_RCAL	                    ( 4'b0000),                          
+    .LPBK_RG_CTRL	                      ( 4'b0000),                             
+    .RX_AFE_CM_EN                       ( 1'b0),
+    .RX_BIAS_CFG0                       (16'h1534),
+    .RX_CM_BUF_CFG                      ( 4'b1010),
+    .RX_CM_BUF_PD                       ( 1'b0),                                           
+    .RX_CM_SEL                          (RX_CM_SEL),                                                        
+    .RX_CM_TRIM                         (10),    
+    .RX_TUNE_AFE_OS                     ( 2'b00),
+    .TERM_RCAL_CFG                      (15'b100001000010000),                                     
+    .TERM_RCAL_OVRD                     ( 3'b000),             
+                                                                                                    
+    //----------------------------------------------------------------------------------------------  
+    //  Receiver Detection Attributes
+    //----------------------------------------------------------------------------------------------                                      
+    .TX_RXDETECT_CFG                    (14'h0032),                                                      
+    .TX_RXDETECT_REF                    (3),                                  
+    
+    //----------------------------------------------------------------------------------------------  
+    //  TX Electrical Idle Attributes
+    //----------------------------------------------------------------------------------------------   
+    .TX_EIDLE_ASSERT_DELAY              (TX_EIDLE_ASSERT_DELAY),                            
+    .TX_EIDLE_DEASSERT_DELAY            (TX_EIDLE_DEASSERT_DELAY),             
+    .TX_IDLE_DATA_ZERO                  ( 1'b0),                                // Optimized for PCIe      
+ 
+    //----------------------------------------------------------------------------------------------  
+    //  RX OOB Attributes
+    //----------------------------------------------------------------------------------------------   
+    .OOB_PWRUP                          ( 1'b1),                                
+    .OOBDIVCTL                          (OOBDIVCTL),                                            
+    .RX_SIG_VALID_DLY                   ( 4),                                   // Optimized for PCIe
+    .RXOOB_CFG                          ( 9'b000000110),                          
+    .RXOOB_CLK_CFG                      ("PMA"),      
+    
+    //----------------------------------------------------------------------------------------------  
+    //  RX Electrical Idle Attributes
+    //----------------------------------------------------------------------------------------------                                                   
+    .RX_DFE_LPM_HOLD_DURING_EIDLE       ( 1'b0),                                
+    .RXBUF_EIDLE_HI_CNT                 ( 4'b0100),                             // Optimized for PCIe
+    .RXBUF_EIDLE_LO_CNT                 ( 4'b0000),
+    .RXBUF_RESET_ON_EIDLE               ("TRUE"),
+    .RXCDR_FR_RESET_ON_EIDLE            ( 1'b0),
+    .RXCDR_PH_RESET_ON_EIDLE            ( 1'b0),
+    .RXCDR_HOLD_DURING_EIDLE            ( 1'b0),                                // Optimized for PCIe
+    .RXELECIDLE_CFG                     ("SIGCFG_1"),                           // Optimized for PCIe
+ 
+    //----------------------------------------------------------------------------------------------  
+    //  Power Down Attributes
+    //----------------------------------------------------------------------------------------------   
+    .PD_TRANS_TIME_FROM_P2              (12'h03C),                                                     
+    .PD_TRANS_TIME_NONE_P2              ( 8'h19),                                                      
+    .PD_TRANS_TIME_TO_P2                ( 8'h64),   
+    .TX_PMA_POWER_SAVE                  ( 1'b0),   
+    .RX_PMA_POWER_SAVE                  ( 1'b0),                               
+  
+    //----------------------------------------------------------------------------------------------  
+    //  Rate Change Attributes
+    //---------------------------------------------------------------------------------------------- 
+    .RATE_SW_USE_DRP                    ( 1'b0),                                // Advance PCIe feature
+    .TRANS_TIME_RATE                    ( 8'h0E),             
+    .TXBUF_RESET_ON_RATE_CHANGE         ("TRUE"),                              
+    .RXBUF_RESET_ON_RATE_CHANGE         ("TRUE"),                              
+
+    //----------------------------------------------------------------------------------------------
+    //  TX Driver Attributes
+    //----------------------------------------------------------------------------------------------                                   
+    .TX_DEEMPH0                         ( 6'b010100),                           // -6.0 dB 
+    .TX_DEEMPH1                         ( 6'b001101),                           // -3.5 dB
+    .TX_DEEMPH2                         ( 6'b000000),                           //  0.0 dB 
+    .TX_DEEMPH3                         ( 6'b000000),                           //  0.0 dB  
+    .TX_DRIVE_MODE                      ("PIPE"),                                
+    .TX_LOOPBACK_DRIVE_HIZ              ("FALSE"),                   
+    .TX_MAINCURSOR_SEL                  ( 1'b0),   
+    .TX_MARGIN_FULL_0                   ( 7'b1001111),                          // 1200 mV
+    .TX_MARGIN_FULL_1                   ( 7'b1001110),                          // 1100 mV
+    .TX_MARGIN_FULL_2                   ( 7'b1001100),                          // 1000 mV 
+    .TX_MARGIN_FULL_3                   ( 7'b1001010),                          //  900 mV
+    .TX_MARGIN_FULL_4                   ( 7'b1001000),                          //  800 mV
+    .TX_MARGIN_LOW_0                    ( 7'b1000110),                          //  700 mV            
+    .TX_MARGIN_LOW_1                    ( 7'b1000101),                          //  600 mV           
+    .TX_MARGIN_LOW_2                    ( 7'b1000011),                          //  500 mV          
+    .TX_MARGIN_LOW_3                    ( 7'b1000010),                          //  400 mV           
+    .TX_MARGIN_LOW_4                    ( 7'b1000000),                          //  300 mV                               
+   
+    //----------------------------------------------------------------------------------------------    
+    //  Comma Align & Detect Attributes
+    //----------------------------------------------------------------------------------------------       
+    .ALIGN_COMMA_DOUBLE                 (ALIGN_COMMA_DOUBLE),                                                  
+    .ALIGN_COMMA_ENABLE                 (10'b1111111111),                                           
+    .ALIGN_COMMA_WORD                   ( 1),                                                       
+    .ALIGN_MCOMMA_DET                   ("TRUE"),                                                   
+    .ALIGN_MCOMMA_VALUE                 (10'b1010000011),                                           
+    .ALIGN_PCOMMA_DET                   ("TRUE"),                                                   
+    .ALIGN_PCOMMA_VALUE                 (10'b0101111100),                                           
+    .DEC_MCOMMA_DETECT                  ("TRUE"),                                                      
+    .DEC_PCOMMA_DETECT                  ("TRUE"),                                                      
+    .DEC_VALID_COMMA_ONLY               ("FALSE"),                                                     
+    .SHOW_REALIGN_COMMA                 (SHOW_REALIGN_COMMA),       
+   
+    //----------------------------------------------------------------------------------------------   
+    //  8B/10B Attributes                                                                             
+    //----------------------------------------------------------------------------------------------                   
+    .RX_DISPERR_SEQ_MATCH               ("TRUE"),        
+   
+    //----------------------------------------------------------------------------------------------  
+    //  TX Buffer Attributes
+    //----------------------------------------------------------------------------------------------                      
+    .TX_FIFO_BYP_EN                     ( 1'b1),                                
+    .TXBUF_EN                           ("FALSE"),        
+    .TXFIFO_ADDR_CFG                    ("LOW"),                                                                                      
+ 
+    //----------------------------------------------------------------------------------------------
+    //  RX Buffer Attributes                                                                        
+    //----------------------------------------------------------------------------------------------     
+    .RXBUF_ADDR_MODE                    ("FULL"),                               
+    .RXBUF_EN                           ("TRUE"),
+    .RXBUF_RESET_ON_CB_CHANGE           ("TRUE"),
+    .RXBUF_RESET_ON_COMMAALIGN          ("FALSE"),
+    .RXBUF_THRESH_OVFLW                 (RXBUF_THRESH_OVFLW),                                                      
+    .RXBUF_THRESH_OVRD                  ("TRUE"),                             
+    .RXBUF_THRESH_UNDFLW                (RXBUF_THRESH_UNDFLW),                                    
+    .RX_BUFFER_CFG                      ( 6'b000000),
+    .RX_DEFER_RESET_BUF_EN              ("TRUE"), 
+   
+    //----------------------------------------------------------------------------------------------   
+    //  PCIe Gen3 RX Buffer Attributes                                                                                   
+    //----------------------------------------------------------------------------------------------   
+    .PCI3_AUTO_REALIGN                  ("OVR_1K_BLK"),                           
+    .PCI3_PIPE_RX_ELECIDLE              ( 1'b0),                                
+    .PCI3_RX_ASYNC_EBUF_BYPASS          ( 2'b00),                               
+    .PCI3_RX_ELECIDLE_EI2_ENABLE        ( 1'b0),                                
+    .PCI3_RX_ELECIDLE_H2L_COUNT         ( 6'b000000),                           
+    .PCI3_RX_ELECIDLE_H2L_DISABLE       ( 3'b000),                              
+    .PCI3_RX_ELECIDLE_HI_COUNT          ( 6'b000000),                           
+    .PCI3_RX_ELECIDLE_LP4_DISABLE       ( 1'b0),                                
+    .PCI3_RX_FIFO_DISABLE               ( 1'b0),                                
+       
+    //----------------------------------------------------------------------------------------------   
+    //  PCIe Gen3 Clock Correction Attributes                                                                                   
+    //----------------------------------------------------------------------------------------------          
+    .PCIE3_CLK_COR_EMPTY_THRSH             (PCIE3_CLK_COR_EMPTY_THRSH),                           
+    .PCIE3_CLK_COR_FULL_THRSH              (PCIE3_CLK_COR_FULL_THRSH),                          
+    .PCIE3_CLK_COR_MAX_LAT                 (PCIE3_CLK_COR_MAX_LAT),                          
+    .PCIE3_CLK_COR_MIN_LAT                 (PCIE3_CLK_COR_MIN_LAT),                          
+    .PCIE3_CLK_COR_THRSH_TIMER             (PCIE3_CLK_COR_THRSH_TIMER),                      
+       
+    //---------------------------------------------------------------------------------------------- 
+    //  Clock Correction Attributes
+    //----------------------------------------------------------------------------------------------             
+    .CBCC_DATA_SOURCE_SEL               ("DECODED"),  
+    .CLK_COR_KEEP_IDLE                  (CLK_COR_KEEP_IDLE),
+    .CLK_COR_MAX_LAT                    (CLK_COR_MAX_LAT),                                   
+    .CLK_COR_MIN_LAT                    (CLK_COR_MIN_LAT),                                  
+    .CLK_COR_PRECEDENCE                 ("TRUE"),
+    .CLK_COR_REPEAT_WAIT                (0),
+    .CLK_COR_SEQ_1_1                    (CLK_COR_SEQ_1_1),
+    .CLK_COR_SEQ_1_2                    (CLK_COR_SEQ_1_2),
+    .CLK_COR_SEQ_1_3                    (10'b0000000000),
+    .CLK_COR_SEQ_1_4                    (10'b0000000000),
+    .CLK_COR_SEQ_1_ENABLE               (4'b1111),
+    .CLK_COR_SEQ_2_1                    (10'b0000000000),
+    .CLK_COR_SEQ_2_2                    (10'b0000000000),
+    .CLK_COR_SEQ_2_3                    (10'b0000000000),
+    .CLK_COR_SEQ_2_4                    (10'b0000000000),
+    .CLK_COR_SEQ_2_ENABLE               (CLK_COR_SEQ_2_ENABLE),
+    .CLK_COR_SEQ_2_USE                  ("FALSE"),
+    .CLK_COR_SEQ_LEN                    (CLK_COR_SEQ_LEN),
+    .CLK_CORRECT_USE                    ("TRUE"),                
+       
+    //---------------------------------------------------------------------------------------------- 
+    //  FTS Deskew Attributes                                                                            
+    //----------------------------------------------------------------------------------------------                                         
+    .FTS_DESKEW_SEQ_ENABLE              ( 4'b1111),                                        
+    .FTS_LANE_DESKEW_CFG                ( 4'b1111),                                          
+    .FTS_LANE_DESKEW_EN                 ("FALSE"),           
+       
+    //---------------------------------------------------------------------------------------------- 
+    //  Channel Bonding Attributes (Disabled)
+    //----------------------------------------------------------------------------------------------          
+    .CHAN_BOND_KEEP_ALIGN               ("FALSE"),
+    .CHAN_BOND_MAX_SKEW                 ( 1),
+    .CHAN_BOND_SEQ_1_1                  (10'b0000000000),
+    .CHAN_BOND_SEQ_1_2                  (10'b0000000000),
+    .CHAN_BOND_SEQ_1_3                  (10'b0000000000),
+    .CHAN_BOND_SEQ_1_4                  (10'b0000000000),
+    .CHAN_BOND_SEQ_1_ENABLE             ( 4'b1111),
+    .CHAN_BOND_SEQ_2_1                  (10'b0000000000),
+    .CHAN_BOND_SEQ_2_2                  (10'b0000000000),
+    .CHAN_BOND_SEQ_2_3                  (10'b0000000000),
+    .CHAN_BOND_SEQ_2_4                  (10'b0000000000),  
+    .CHAN_BOND_SEQ_2_ENABLE             ( 4'b1111),
+    .CHAN_BOND_SEQ_2_USE                ("FALSE"), 
+    .CHAN_BOND_SEQ_LEN                  ( 1),                                                           
+  
+    //----------------------------------------------------------------------------------------------            
+    //  TX Sync Alignment Attributes                                                                              
+    //----------------------------------------------------------------------------------------------     
+    .TXDLY_CFG                          (16'b0000000000011111),    
+    .TXDLY_LCFG                         (16'b0000000001010000),                
+    .TXPH_CFG                           (16'b0000000100000011),
+    .TXPH_CFG2                          (16'b0000000000000000),                 
+    .TXPH_MONITOR_SEL                   ( 5'b00000),
+    .TXPHDLY_CFG0                       (16'b0110000000100000),                 
+    .TXPHDLY_CFG1                       (16'b0000000000000010),              
+                                                                                    
+    //----------------------------------------------------------------------------------------------            
+    //  TX Auto Sync Alignment Attributes                                                                               
+    //----------------------------------------------------------------------------------------------                
+    .TXSYNC_MULTILANE                   (MULTI_LANE),                                                                                                              
+    .TXSYNC_OVRD                        (1'b0),                                 // Select auto TXSYNC mode                                                                                 
+    .TXSYNC_SKIP_DA                     (1'b0),                     
+                                                                                                    
+    //----------------------------------------------------------------------------------------------            
+    //  RX Sync Alignment Attributes (Not used)                                                                             
+    //----------------------------------------------------------------------------------------------    
+  //.RXDLY_CFG                          (16'h001F),   
+  //.RXDLY_LCFG                         (16'h0030),   
+  //.RXPH_MONITOR_SEL                   (5'b00000),
+  //.RXPHBEACON_CFG                     (16'h0000),
+  //.RXPHDLY_CFG                        (16'h2020),
+  //.RXPHSAMP_CFG                       (16'h2100),
+  //.RXPHSLIP_CFG                       (16'h9933),                             
+     
+    //----------------------------------------------------------------------------------------------            
+    //  RX Auto Sync Alignment Attributes (Not used)                                                                                
+    //----------------------------------------------------------------------------------------------                
+  //.RXSYNC_MULTILANE                   (1'b0),                                                                                                              
+  //.RXSYNC_OVRD                        (1'b0),                                                                                         
+  //.RXSYNC_SKIP_DA                     (1'b0),                   
+  
+    //----------------------------------------------------------------------------------------------  
+    //  Gearbox Attributes (Not used)                                                                
+    //---------------------------------------------------------------------------------------------- 
+  //.GEARBOX_MODE                       ( 5'b00000), 
+  //.TX_SAMPLE_PERIOD                   ( 3'b101),
+  //.RX_SAMPLE_PERIOD                   ( 3'b101),
+  //.TXGEARBOX_EN                       ("FALSE"),
+  //.RXGEARBOX_EN                       ("FALSE"),    
+  //.TXGBOX_FIFO_INIT_RD_ADDR           ( 4),
+  //.RXGBOX_FIFO_INIT_RD_ADDR           ( 4),
+  //.RXSLIDE_AUTO_WAIT                  ( 7),                                                         
+    .RXSLIDE_MODE                       (RXSLIDE_MODE),                          
+
+    //----------------------------------------------------------------------------------------------
+    //  PCS Reserved Attributes
+    //----------------------------------------------------------------------------------------------
+    .PCS_RSVD0                          (PCS_RSVD0),
+  
+    //----------------------------------------------------------------------------------------------  
+    //  PMA Reserved Attributes
+    //----------------------------------------------------------------------------------------------      
+    .TX_PMA_RSV0                        (16'h000A),                             
+    .RX_PMA_RSV0                        (16'h00E0),                                        
+      
+    //----------------------------------------------------------------------------------------------
+    //  CFOK Attributes                                                                 
+    //----------------------------------------------------------------------------------------------              
+    .RXCFOK_CFG0                        (16'b0011_1110_0000_0000),
+    .RXCFOK_CFG1                        (16'b0000_0000_0100_0010),
+    .RXCFOK_CFG2                        (16'b0000_0000_0010_1101),
+
+    //----------------------------------------------------------------------------------------------
+    //  RX CTLE
+    //----------------------------------------------------------------------------------------------  
+    .CTLE3_OCAP_EXT_CTRL	              ( 3'b000),                           
+    .CTLE3_OCAP_EXT_EN	                ( 1'b0),                                
+    .RX_EN_CTLE_RCAL_B                  ( 1'b0),                              
+
+    //----------------------------------------------------------------------------------------------    
+    //  RX LPM Attributes
+    //----------------------------------------------------------------------------------------------        
+    .RXLPM_CFG                          (16'b0000_0000_0000_0000),    
+    .RXLPM_GC_CFG                       (16'b0000_0010_0000_0000),
+    .RXLPM_KH_CFG0                      (16'b0000_0000_0000_0000),
+    .RXLPM_KH_CFG1                      (16'b0000_0000_0000_0010),
+    .RXLPM_OS_CFG0                      (16'b0000_0100_0000_0000),
+    .RXLPM_OS_CFG1                      (16'b0000_0000_0000_0000),
+ 
+    //----------------------------------------------------------------------------------------------    
+    //  RX DFE Attributes
+    //----------------------------------------------------------------------------------------------       
+    .RXDFE_CFG0                         (16'b0100_1100_0000_0000), //(16'b0000110000000000),    [Changed for extracted model]
+    .RXDFE_CFG1                         (16'b0000_0000_0000_0000),
+    .RXDFE_GC_CFG0                      (16'b0001_1110_0000_0000), 
+    .RXDFE_GC_CFG1                      (16'b0001_1001_0000_0000),  // different from GTH 
+    .RXDFE_GC_CFG2                      (16'b0000_0000_0000_0000),  // different from GTH
+    .RXDFE_H2_CFG0                      (16'b0000_0000_0000_0000),
+    .RXDFE_H2_CFG1                      (16'b0000_0000_0000_0010),
+    .RXDFE_H3_CFG0                      (16'b0000_0000_0000_0000),
+    .RXDFE_H3_CFG1                      (16'b0000_0000_0000_0010),
+    .RXDFE_H4_CFG0                      (16'b0000_0000_0000_0000),
+    .RXDFE_H4_CFG1                      (16'b0000_0000_0000_0011),
+    .RXDFE_H5_CFG0                      (16'b0000_0000_0000_0000),
+    .RXDFE_H5_CFG1                      (16'b0000_0000_0000_0010),
+    .RXDFE_H6_CFG0                      (16'b0000_0000_0000_0000),
+    .RXDFE_H6_CFG1                      (16'b0000_0000_0000_0010),
+    .RXDFE_H7_CFG0                      (16'b0000_0000_0000_0000),
+    .RXDFE_H7_CFG1                      (16'b0000_0000_0000_0010), 
+    .RXDFE_H8_CFG0                      (16'b0000_0000_0000_0000),
+    .RXDFE_H8_CFG1                      (16'b0000_0000_0000_0010),
+    .RXDFE_H9_CFG0                      (16'b0000_0000_0000_0000),
+    .RXDFE_H9_CFG1                      (16'b0000_0000_0000_0010), 
+    .RXDFE_HA_CFG0                      (16'b0000_0000_0000_0000),
+    .RXDFE_HA_CFG1                      (16'b0000_0000_0000_0010),
+    .RXDFE_HB_CFG0                      (16'b0000_0000_0000_0000), //(16'b0010000000000000),    [Changed for extracted model]
+    .RXDFE_HB_CFG1                      (16'b0000_0000_0000_0010),
+    .RXDFE_HC_CFG0                      (16'b0000_0000_0000_0000),
+    .RXDFE_HC_CFG1                      (16'b0000_0000_0000_0010),
+    .RXDFE_HD_CFG0                      (16'b0000_0000_0000_0000),
+    .RXDFE_HD_CFG1                      (16'b0000_0000_0000_0010),
+    .RXDFE_HE_CFG0                      (16'b0000_0000_0000_0000),
+    .RXDFE_HE_CFG1                      (16'b0000_0000_0000_0010),
+    .RXDFE_HF_CFG0                      (16'b0000_0000_0000_0000),
+    .RXDFE_HF_CFG1                      (16'b0000_0000_0000_0010),
+    .RXDFE_OS_CFG0                      (16'b0000_0000_0000_0000),
+    .RXDFE_OS_CFG1                      (16'b0000_0000_0000_0010), //(16'b0000001000000000),    [Changed for extracted model]
+    //.RXDFE_PWR_SAVING                   (16'b0),
+    .RXDFE_UT_CFG0                      (16'b0000_0000_0000_0000),
+    .RXDFE_UT_CFG1                      (16'b0000_0000_0000_0010),
+    .RXDFE_VP_CFG0                      (16'b0000_0000_0000_0000),
+    .RXDFE_VP_CFG1                      (16'b0000_0000_0010_0010),
+    .RXDFELPM_KL_CFG0                   (16'h0000),                  
+    .RXDFELPM_KL_CFG1                   (16'h0022),             
+    .RXDFELPM_KL_CFG2                   (16'h0100),                        
+    //.RX_DFE_AGC_CFG0                    ( 2'b00),                               
+    .RX_DFE_AGC_CFG1                    ( 2),  
+    .RX_DFE_KL_LPM_KH_CFG0              ( 1),
+    .RX_DFE_KL_LPM_KH_CFG1              ( 2),
+    .RX_DFE_KL_LPM_KL_CFG0              ( 2'b01),
+    .RX_DFE_KL_LPM_KL_CFG1              ( 3'b010),   
+    .RX_DFELPM_CFG0                     ( 0),                                                            
+    .RX_DFELPM_CFG1                     ( 1'b1),                                                               
+    .RX_DFELPM_KLKH_AGC_STUP_EN         ( 1'b1),   
+          
+    //----------------------------------------------------------------------------------------------  
+    //  TX PI attributes
+    //----------------------------------------------------------------------------------------------
+    .TX_PHICAL_CFG0	                    (16'h0000),                           
+    .TX_PHICAL_CFG1	                    (16'h7e00),
+    //.TX_PHICAL_CFG2	                    (16'h0000),
+    .TX_PI_BIASSET	                    ( 0),                                  
+    .TXPI_CFG0                          ( 2'b00),
+    .TXPI_CFG1                          ( 2'b00),
+    //.TXPI_CFG2                          ( 2'b00),
+    //.TXPI_CFG3                          ( 1'b0),
+    //.TXPI_CFG4                          ( 1'b1),
+    //.TXPI_CFG5                          ( 3'b000),
+    .TXPI_GRAY_SEL                      ( 1'b0),
+    .TXPI_INVSTROBE_SEL                 ( 1'b0),
+    //.TXPI_LPM                           ( 1'b0),
+    .TXPI_PPM_CFG                       ( 8'b00000000),
+    //.TXPI_PPMCLK_SEL                    ("TXUSRCLK2"),
+    .TXPI_SYNFREQ_PPM                   ( 3'b000),
+    //.TXPI_VREFSEL                       ( 1'b0),    
+    
+    //----------------------------------------------------------------------------------------------  
+    //  RX PI Attributes
+    //----------------------------------------------------------------------------------------------    
+    //.RXPI_AUTO_BW_SEL_BYPASS            ( 1'b0),
+    .RXPI_CFG0                          (16'h0100),
+    .RXPI_CFG1                          (16'h0100),
+    //.RXPI_LPM                           ( 1'b0),
+    //.RXPI_SEL_LC                        ( 2'b00),
+    //.RXPI_STARTCODE                     ( 2'b00),
+    //.RXPI_VREFSEL                       ( 1'b0),              
+
+    //----------------------------------------------------------------------------------------------
+    //  RX CDR Attributes
+    //----------------------------------------------------------------------------------------------    
+    .CDR_SWAP_MODE_EN                   ( 1'b0),                 
+    .RX_WIDEMODE_CDR                    ( 2'b01),                                      
+    .RXCDR_CFG0                         (RXCDR_CFG0), 
+    .RXCDR_CFG0_GEN3                    (RXCDR_CFG0_GEN3), 
+    .RXCDR_CFG1                         (RXCDR_CFG1), 
+    .RXCDR_CFG1_GEN3                    (RXCDR_CFG1_GEN3), 
+    .RXCDR_CFG2                         (RXCDR_CFG2), 
+    .RXCDR_CFG2_GEN3                    (RXCDR_CFG2_GEN3), 
+    .RXCDR_CFG2_GEN4                    (RXCDR_CFG2_GEN4), 
+    .RXCDR_CFG3                         (RXCDR_CFG3), 
+    .RXCDR_CFG3_GEN3                    (RXCDR_CFG3_GEN3), 
+    .RXCDR_CFG3_GEN4                    (RXCDR_CFG3_GEN4),
+    .RXCDR_CFG4                         (RXCDR_CFG4), 
+    .RXCDR_CFG4_GEN3                    (RXCDR_CFG4_GEN3), 
+    .RXCDR_CFG5                         (RXCDR_CFG5), 
+    .RXCDR_CFG5_GEN3                    (RXCDR_CFG5_GEN3), 
+    .RXCDR_LOCK_CFG0                    (16'b1001_0000_1000_0001), 
+    .RXCDR_LOCK_CFG1                    (16'b1001_0111_1110_0000), 
+    .RXCDR_LOCK_CFG2                    (16'b0110_0100_0100_0001), 
+    .RXCDR_LOCK_CFG3                    (16'b0000_0111_1110_0000), 
+
+    //---------------------------------------------------------------------------------------------- 
+    //  Eye Scan Attributes
+    //----------------------------------------------------------------------------------------------
+    .ES_CLK_PHASE_SEL                   ( 1'b0),                           
+    .ES_CONTROL                         ( 6'b000000),                      
+    .ES_ERRDET_EN                       ("FALSE"),                        
+    .ES_EYE_SCAN_EN                     ("FALSE"),                        
+    .ES_HORZ_OFFSET                     (12'b000000000000),                       
+    .ES_PRESCALE                        ( 5'b00000),                                
+    .ES_QUAL_MASK0                      (16'b0000000000000000),           
+    .ES_QUAL_MASK1                      (16'b0000000000000000),           
+    .ES_QUAL_MASK2                      (16'b0000000000000000),           
+    .ES_QUAL_MASK3                      (16'b0000000000000000),           
+    .ES_QUAL_MASK4                      (16'b0000000000000000),       
+    .ES_QUAL_MASK5                      (16'b0000000000000000),           
+    .ES_QUAL_MASK6                      (16'b0000000000000000),           
+    .ES_QUAL_MASK7                      (16'b0000000000000000),           
+    .ES_QUAL_MASK8                      (16'b0000000000000000),           
+    .ES_QUAL_MASK9                      (16'b0000000000000000),         
+    .ES_QUALIFIER0                      (16'b0000000000000000),           
+    .ES_QUALIFIER1                      (16'b0000000000000000),           
+    .ES_QUALIFIER2                      (16'b0000000000000000),           
+    .ES_QUALIFIER3                      (16'b0000000000000000),           
+    .ES_QUALIFIER4                      (16'b0000000000000000), 
+    .ES_QUALIFIER5                      (16'b0000000000000000),           
+    .ES_QUALIFIER6                      (16'b0000000000000000),           
+    .ES_QUALIFIER7                      (16'b0000000000000000),           
+    .ES_QUALIFIER8                      (16'b0000000000000000),           
+    .ES_QUALIFIER9                      (16'b0000000000000000),   
+    .ES_SDATA_MASK0                     (16'b0000000000000000),           
+    .ES_SDATA_MASK1                     (16'b0000000000000000),           
+    .ES_SDATA_MASK2                     (16'b0000000000000000),           
+    .ES_SDATA_MASK3                     (16'b0000000000000000),           
+    .ES_SDATA_MASK4                     (16'b0000000000000000), 
+    .ES_SDATA_MASK5                     (16'b0000000000000000),           
+    .ES_SDATA_MASK6                     (16'b0000000000000000),           
+    .ES_SDATA_MASK7                     (16'b0000000000000000),           
+    .ES_SDATA_MASK8                     (16'b0000000000000000),   
+    .ES_SDATA_MASK9                     (16'b0000000000000000),          
+    .EYE_SCAN_SWAP_EN                   ( 1'b0),
+    .RX_EYESCAN_VS_CODE                 ( 7'b0000000),
+    .RX_EYESCAN_VS_NEG_DIR              ( 1'b0),
+    .RX_EYESCAN_VS_RANGE                ( 2'b00),
+    .RX_EYESCAN_VS_UT_SIGN              ( 1'b0),                        
+  
+    //----------------------------------------------------------------------------------------------
+    //  Loopback & PRBS Attributes
+    //----------------------------------------------------------------------------------------------
+    .RXPRBS_ERR_LOOPBACK                ( 1'b0),     
+    .RXPRBS_LINKACQ_CNT                 (15),                                                   
+                                                                                                    
+    //----------------------------------------------------------------------------------------------   
+    //  Digital Monitor Attribute
+    //----------------------------------------------------------------------------------------------                     
+    .DMONITOR_CFG0                      (10'b0000000000),                                                  
+    .DMONITOR_CFG1                      ( 8'b00000000),                                                   
+                                                      
+    //----------------------------------------------------------------------------------------------   
+    //  AC JTAG Attributes
+    //----------------------------------------------------------------------------------------------                     
+    .ACJTAG_DEBUG_MODE                  ( 1'b0),                                                        
+    .ACJTAG_MODE                        ( 1'b0),                                                        
+    .ACJTAG_RESET                       ( 1'b0),      
+    
+    //----------------------------------------------------------------------------------------------
+    //  USB Attributes
+    //----------------------------------------------------------------------------------------------                 
+    .USB_BOTH_BURST_IDLE                ( 1'b0),
+    .USB_BURSTMAX_U3WAKE	              ( 7'b1111111),
+    .USB_BURSTMIN_U3WAKE	              ( 7'b1100011),
+    .USB_CLK_COR_EQ_EN                  ( 1'b1),                              
+    .USB_EXT_CNTL                       ( 1'b1),
+    .USB_IDLEMAX_POLLING                (10'b1010111011),
+    .USB_IDLEMIN_POLLING                (10'b0100101011),
+    .USB_LFPS_TPERIOD	                  ( 4'b0011),
+    .USB_LFPS_TPERIOD_ACCURATE	        ( 1'b1),
+    .USB_LFPSPING_BURST	                ( 9'b000000101),
+    .USB_LFPSPOLLING_BURST	            ( 9'b000110001),
+    .USB_LFPSPOLLING_IDLE_MS	          ( 9'b000000100),
+    .USB_LFPSU1EXIT_BURST	              ( 9'b000011101),
+    .USB_LFPSU2LPEXIT_BURST_MS	        ( 9'b001100011),
+    .USB_LFPSU3WAKE_BURST_MS	          ( 9'b111110011),
+    .USB_MODE                           (USB_MODE), 
+    .USB_PCIE_ERR_REP_DIS               ( 1'b0),                                // For Debug
+    .USB_PING_SATA_MAX_INIT             (21),
+    .USB_PING_SATA_MIN_INIT             (12),
+    .USB_POLL_SATA_MAX_BURST            ( 8),
+    .USB_POLL_SATA_MIN_BURST            ( 4),
+    .USB_RAW_ELEC                       ( 1'b1),                               
+    .USB_RXIDLE_P0_CTRL                 ( 1'b1),
+    .USB_TXIDLE_TUNE_ENABLE             ( 1'b1),
+    .USB_U1_SATA_MAX_WAKE               ( 7),
+    .USB_U1_SATA_MIN_WAKE               ( 4),
+    .USB_U2_SAS_MAX_COM                 (64),   
+    .USB_U2_SAS_MIN_COM                 (36),
+    
+    //---------------------------------------------------------------------------------------------- 
+    //  SAS & SATA Attributes (Not used)
+    //---------------------------------------------------------------------------------------------- 
+  //.SAS12G_MODE                        ( 1'b0),
+  //.SATA_BURST_SEQ_LEN                 ( 4'b1111),
+  //.SATA_BURST_VAL                     ( 3'b100),
+  //.SATA_CPLL_CFG                      ("VCO_3000MHZ"),
+  //.SATA_EIDLE_VAL                     ( 3'b100), 
+            
+    //---------------------------------------------------------------------------------------------- 
+    //  CKCAL Attributes
+    //---------------------------------------------------------------------------------------------- 
+    .CKCAL1_CFG_0	                      (16'hC0C0), //(16'b0000000000000000), [Changed for extracted model]
+    .CKCAL1_CFG_1	                      (16'h00C0), //(16'b0000000000000000), [Changed for extracted model] 
+    .CKCAL1_CFG_2	                      (16'b0000000000000000),
+    .CKCAL1_CFG_3	                      (16'b0000000000000000),
+    .CKCAL2_CFG_0	                      (16'h8181), //(16'b0000000000000000), [Changed for extracted model]
+    .CKCAL2_CFG_1	                      (16'h8081), //(16'b0000000000000000), [Changed for extracted model]
+    .CKCAL2_CFG_2	                      (16'b0000000000000000),
+    .CKCAL2_CFG_3	                      (16'b0000000000000000),
+    .CKCAL2_CFG_4	                      (16'b0000000000000000),
+    //.CKCAL_RSVD0	                      (16'h4000),
+    //.CKCAL_RSVD1	                      (16'h0000),
+    .RXCKCAL1_I_LOOP_RST_CFG	          (16'h0000),
+    .RXCKCAL1_IQ_LOOP_RST_CFG	          (16'h0000),
+    .RXCKCAL1_Q_LOOP_RST_CFG	          (16'h0000),
+    .RXCKCAL2_D_LOOP_RST_CFG	          (16'h0000),
+    .RXCKCAL2_DX_LOOP_RST_CFG	          (16'h0000),
+    .RXCKCAL2_S_LOOP_RST_CFG	          (16'h0000),
+    .RXCKCAL2_X_LOOP_RST_CFG	          (16'h0000),
+  
+    //----------------------------------------------------------------------------------------------
+    //  Summer Attributes
+    //----------------------------------------------------------------------------------------------
+    .RX_SUM_DFETAPREP_EN                ( 1'b0),
+    .RX_SUM_IREF_TUNE                   ( 4'b0000),
+    .RX_SUM_VCM_OVWR                    ( 1'b0),
+    .RX_SUM_VCMTUNE                     ( 4'b1000),
+    .RX_SUM_VREF_TUNE                   ( 3'b100),
+
+    //----------------------------------------------------------------------------------------------
+    //  Attributes
+    //----------------------------------------------------------------------------------------------                 
+    .A_RXOSCALRESET                     ( 1'b0),   
+    .A_RXPROGDIVRESET                   ( 1'b0),
+    .A_RXTERMINATION                    ( 1'b1),
+    .A_TXDIFFCTRL                       ( 5'b11111),
+    .A_TXPROGDIVRESET                   ( 1'b0),
+    .ADAPT_CFG0                         ( 16'b1001001000000000),
+    .ADAPT_CFG1                         ( 16'b1000000000011100),
+    .ADAPT_CFG2                         ( 16'b0000000000000000), 
+    //.CAPBYPASS_FORCE                    ( 1'b0),                                
+    .CH_HSPMUX                          ( 16'h0000),
+    .DDI_CTRL                           ( 2'b00),
+    .DDI_REALIGN_WAIT                   (15),
+    .DELAY_ELEC                         ( 1'b0),                              
+    .ISCAN_CK_PH_SEL2                   ( 1'b0),                                
+    .PREIQ_FREQ_BST                     ( 0),                                   
+    //.PROCESS_PAR                        ( 3'b010), 
+    .RX_CAPFF_SARC_ENB                  ( 1'b0),    
+    .RX_DDI_SEL                         ( 6'b000000),  
+    .RX_DEGEN_CTRL                      ( 3'b011),                              
+    //.RX_DIV2_MODE_B                     ( 1'b0),                                
+    //.RX_EN_HI_LR                        ( 1'b0),
+    //.RX_EXT_RL_CTRL                     ( 9'b000000000),                        
+    .RX_RESLOAD_CTRL	                  ( 4'b0000),                             
+    .RX_RESLOAD_OVRD	                  ( 1'b0),                                
+    .RX_VREG_CTRL	                      ( 3'b101),                              
+    .RX_VREG_PDB	                      ( 1'b1),                                
+    .RX_XMODE_SEL	                      ( 1'b0),                                
+    .TAPDLY_SET_TX                      ( 2'b00),
+    //.TEMPERATURE_PAR                    ( 4'b0010),
+    .TST_RSV0                           ( 8'b00000000),                                     
+    .TST_RSV1                           ( 8'b00000000),
+    .TX_DCC_LOOP_RST_CFG                (16'h0000),                             
+    //.TX_DRVMUX_CTRL                     ( 2),                                   
+    //.TX_PREDRV_CTRL                     ( 2),                                   
+    .TX_PMADATA_OPT                     ( 1'b0)    
+)                                                                                                   
+gtye4_channel_smsw_i                                                                                     
+(                                                                                                                                                                                                   
+    //----------------------------------------------------------------------------------------------
+    //  Clock Ports
+    //----------------------------------------------------------------------------------------------
+    .GTGREFCLK                          ( 1'd0),                                                     
+    .GTREFCLK0                          (GT_GTREFCLK0),                                            
+    .GTREFCLK1                          ( 1'd0),                                                    
+    .GTNORTHREFCLK0                     ( 1'd0),                                                    
+    .GTNORTHREFCLK1                     ( 1'd0),                                                    
+    .GTSOUTHREFCLK0                     ( 1'd0),                                                    
+    .GTSOUTHREFCLK1                     ( 1'd0),                                             
+    .TXUSRCLK                           (GT_TXUSRCLK),                                              
+    .RXUSRCLK                           (GT_RXUSRCLK),                                              
+    .TXUSRCLK2                          (GT_TXUSRCLK2),                                             
+    .RXUSRCLK2                          (GT_RXUSRCLK2),  
+    .TXPLLCLKSEL                        (PLLCLKSEL),            
+    .RXPLLCLKSEL                        (PLLCLKSEL),                                                    
+    .TXSYSCLKSEL                        (SYSCLKSEL),                                             
+    .RXSYSCLKSEL                        (SYSCLKSEL),                             
+    .TXOUTCLKSEL                        (GT_TXOUTCLKSEL), //( 3'd5),            // Select TXPROGDIVCLK
+    .RXOUTCLKSEL                        ( 3'd2),                                // Select RXOUTCLKPMA
+    .CLKRSVD0                           ( 1'd0),          
+    .CLKRSVD1                           ( 1'd0),            
+                                                                                                   
+    .TXOUTCLK                           (GT_TXOUTCLK),                                             
+    .RXOUTCLK                           (GT_RXOUTCLK),                                                        
+    .TXOUTCLKFABRIC                     (GT_TXOUTCLKFABRIC),                                                        
+    .RXOUTCLKFABRIC                     (GT_RXOUTCLKFABRIC),                                                        
+    .TXOUTCLKPCS                        (GT_TXOUTCLKPCS),                                                        
+    .RXOUTCLKPCS                        (GT_RXOUTCLKPCS),  
+    .RXRECCLKOUT                        (GT_RXRECCLKOUT),                                                    
+    .GTREFCLKMONITOR                    (),                                 
+    
+    //----------------------------------------------------------------------------------------------
+    //  BUFG_GT Controller Ports
+    //----------------------------------------------------------------------------------------------
+    .BUFGTCE                            (GT_BUFGTCE),      
+    .BUFGTCEMASK                        (GT_BUFGTCEMASK), 
+    .BUFGTDIV                           (GT_BUFGTDIV), 
+    .BUFGTRESET                         (GT_BUFGTRESET), 
+    .BUFGTRSTMASK                       (GT_BUFGTRSTMASK),       
+    
+    //----------------------------------------------------------------------------------------------
+    //  CPLL Ports
+    //----------------------------------------------------------------------------------------------
+    .CPLLFREQLOCK                       (GT_MASTER_CPLLLOCK),                 
+    .CPLLLOCKDETCLK                     ( 1'd0),                              
+    .CPLLLOCKEN                         ( 1'd1),    
+    .CPLLPD                             (GT_CPLLPD),    
+    .CPLLREFCLKSEL                      ( 3'd1),                               
+    .CPLLRESET                          (GT_CPLLRESET),                               
+  
+    .CPLLFBCLKLOST                      (),     
+    .CPLLLOCK                           (GT_CPLLLOCK),                                            
+    .CPLLREFCLKLOST                     (),                    
+             
+    //----------------------------------------------------------------------------------------------
+    //  QPLL Ports                                                                                   
+    //----------------------------------------------------------------------------------------------
+    .QPLL0CLK                           (GT_QPLL0CLK),                           
+    .QPLL0REFCLK                        (GT_QPLL0REFCLK),                        
+    .QPLL0FREQLOCK                      (GT_QPLL0LOCK),                         
+    .QPLL1CLK                           (GT_QPLL1CLK),  
+    .QPLL1REFCLK                        (GT_QPLL1REFCLK),           
+    .QPLL1FREQLOCK                      (GT_QPLL1LOCK),                         
+    
+    //----------------------------------------------------------------------------------------------
+    //  Reset Ports
+    //----------------------------------------------------------------------------------------------                                                                                                                             
+    .GTTXRESET                          (GT_GTTXRESET),                                             
+    .GTRXRESET                          (GT_GTRXRESET),  
+    .GTRXRESETSEL                       ( 1'd0),                                
+    .GTTXRESETSEL                       ( 1'd0),                                
+    .TXPROGDIVRESET                     (GT_TXPROGDIVRESET),                       
+    .RXPROGDIVRESET                     ( 1'd0),                                                                            
+    .TXPMARESET                         (GT_TXPMARESET),                                            
+    .RXPMARESET                         (GT_RXPMARESET),                                            
+    .TXPCSRESET                         (GT_TXPCSRESET),   
+    .RXPCSRESET                         (GT_RXPCSRESET),   
+    .TXUSERRDY                          (GT_TXUSERRDY),                                             
+    .RXUSERRDY                          (GT_RXUSERRDY),   
+    .CFGRESET                           ( 1'd0),                                                    
+    .RESETOVRD                          ( GT_RESETOVRD),  
+    .RXOOBRESET                         ( 1'd0),                                              
+                                           
+    .GTPOWERGOOD                        (GT_GTPOWERGOOD), 
+    .TXPRGDIVRESETDONE                  (GT_TXPROGDIVRESETDONE),
+    .RXPRGDIVRESETDONE                  (),        
+    .TXPMARESETDONE                     (GT_TXPMARESETDONE),    
+    .RXPMARESETDONE                     (GT_RXPMARESETDONE),                                                                                                      
+    .TXRESETDONE                        (GT_TXRESETDONE),                                           
+    .RXRESETDONE                        (GT_RXRESETDONE),  
+    .RESETEXCEPTION                     (),
+
+    //----------------------------------------------------------------------------------------------
+    //  PCIe Ports
+    //----------------------------------------------------------------------------------------------
+    .PCIERSTIDLE                        (GT_PCIERSTIDLE),        
+    .PCIERSTTXSYNCSTART                 (GT_PCIERSTTXSYNCSTART), 
+    .PCIEEQRXEQADAPTDONE                (GT_PCIEEQRXEQADAPTDONE),
+    .PCIEUSERRATEDONE                   (GT_PCIEUSERRATEDONE),
+             
+    .PCIEUSERPHYSTATUSRST               (GT_PCIEUSERPHYSTATUSRST),    
+    .PCIERATEQPLLPD                     (GT_PCIERATEQPLLPD),                    
+    .PCIERATEQPLLRESET                  (GT_PCIERATEQPLLRESET),                 
+    .PCIERATEIDLE                       (GT_PCIERATEIDLE),            
+    .PCIESYNCTXSYNCDONE                 (GT_PCIESYNCTXSYNCDONE),                          
+    .PCIERATEGEN3                       (pcierategen3),    
+    .PCIEUSERGEN3RDY                    (GT_PCIEUSERGEN3RDY),   
+    .PCIEUSERRATESTART                  (GT_PCIEUSERRATESTART),    
+           
+    //----------------------------------------------------------------------------------------------
+    //  Serial Line Ports
+    //----------------------------------------------------------------------------------------------
+    .GTYRXP                             (GT_RXP),                                                   
+    .GTYRXN                             (GT_RXN),   
+   
+    .GTYTXP                             (GT_TXP),                                                 
+    .GTYTXN                             (GT_TXN),   
+
+    //----------------------------------------------------------------------------------------------
+    //  TX Data Ports
+    //----------------------------------------------------------------------------------------------
+    .TXDATA                             (txdata),                                     
+    .TXCTRL0                            (txctrl0),
+    .TXCTRL1                            (txctrl1),  
+    .TXCTRL2                            (txctrl2),
+    .TXDATAEXTENDRSVD                   ( 8'd0),                                
+
+    //----------------------------------------------------------------------------------------------
+    //  RX Data Ports
+    //----------------------------------------------------------------------------------------------
+    .RXDATA                             (rxdata),                                                    
+    .RXCTRL0                            (rxctrl0),   
+    .RXCTRL1                            (), 
+    .RXCTRL2                            (),
+    .RXCTRL3                            (), 
+    .RXDATAEXTENDRSVD                   (),                                     
+ 
+    //----------------------------------------------------------------------------------------------
+    //  PHY Command Ports
+    //----------------------------------------------------------------------------------------------
+    .TXDETECTRX                         (GT_TXDETECTRX),                                            
+    .TXELECIDLE                         (GT_TXELECIDLE),                                      
+    .TXPDELECIDLEMODE                   ( 1'd0),                                                                                 
+    .RXELECIDLEMODE                     ( 2'd0),                                
+    .SIGVALIDCLK                        ( 1'd0),                                                                                    
+    .TXPOLARITY                         ( 1'd0),                                              
+    .RXPOLARITY                         (GT_RXPOLARITY),                                
+    .TXPD                               (GT_POWERDOWN),                                           
+    .RXPD                               (GT_POWERDOWN),                                           
+    .TXRATE                             ({1'd0, GT_RATE}),                                                
+    .RXRATE                             ({1'd0, GT_RATE}),                                                
+    .TXRATEMODE                         ( 1'd0),                                                    
+    .RXRATEMODE                         ( 1'd0),                                                    
+ 
+    //----------------------------------------------------------------------------------------------
+    //  PHY Status Ports
+    //----------------------------------------------------------------------------------------------
+    .RXVALID                            (GT_RXVALID),                                              
+    .PHYSTATUS                          (GT_PHYSTATUS),                                            
+    .RXELECIDLE                         (rxelecidle_int),                                           
+    .RXSTATUS                           (GT_RXSTATUS),                                             
+    .TXRATEDONE                         (),                                           
+    .RXRATEDONE                         (GT_RXRATEDONE),                  
+ 
+    //----------------------------------------------------------------------------------------------
+    //  TX Driver Ports
+    //----------------------------------------------------------------------------------------------
+    .TXMARGIN                           (GT_TXMARGIN),                                           
+    .TXSWING                            (GT_TXSWING),                                            
+    .TXDEEMPH                           (GT_TXDEEMPH),                                                                     
+    .TXDIFFCTRL                         ( 5'b11111),
+    .TXINHIBIT                          ( 1'd0),                                                  
+
+    //----------------------------------------------------------------------------------------------
+    //  TX Driver Ports (Gen3)
+    //----------------------------------------------------------------------------------------------
+    .TXPRECURSOR                        (GT_TXPRECURSOR),                                          
+    .TXMAINCURSOR                       (GT_TXMAINCURSOR),                                         
+    .TXPOSTCURSOR                       (GT_TXPOSTCURSOR),                                                                                     
+
+    //----------------------------------------------------------------------------------------------
+    //  PCS Reserved Ports
+    //---------------------------------------------------------------------------------------------- 
+    .PCSRSVDIN                          (16'h0001),                             // CHECK                                                                               
+    .PCSRSVDOUT                         (pcsrsvdout),     
+    
+    //----------------------------------------------------------------------------------------------
+    //  RX Monitor Ports
+    //----------------------------------------------------------------------------------------------
+    .RXMONITORSEL                       ( 2'd0), 
+    .RXMONITOROUT                       (),                                                                                                                                                                                                            
+                                                                 
+    //----------------------------------------------------------------------------------------------
+    //  Comma Detect & Align Ports
+    //----------------------------------------------------------------------------------------------
+    .RXCOMMADETEN                       ( 1'd1),                  
+    .RXMCOMMAALIGNEN                    (!pcierategen3),          
+    .RXPCOMMAALIGNEN                    (!pcierategen3),          
+                                                                                 
+    .RXCOMMADET                         (),                                            
+    .RXBYTEISALIGNED                    (),                                        
+    .RXBYTEREALIGN                      (),                                                                                                                 
+                                                                                                    
+    //----------------------------------------------------------------------------------------------
+    // 8B10B Ports
+    //----------------------------------------------------------------------------------------------
+    .TX8B10BBYPASS                      ( 8'd0),                                                  
+    .TX8B10BEN                          (!pcierategen3),                            
+    .RX8B10BEN                          (!pcierategen3),                            
+           
+    //----------------------------------------------------------------------------------------------
+    //  TX Buffer Ports
+    //----------------------------------------------------------------------------------------------
+    .TXBUFSTATUS                        (),                                                        
+                                                                                                    
+    //----------------------------------------------------------------------------------------------
+    //  RX Buffer Ports
+    //----------------------------------------------------------------------------------------------
+    .RXBUFRESET                         (GT_RXBUFRESET),                                          
+    .RXBUFSTATUS                        (),                
+                      
+    //----------------------------------------------------------------------------------------------
+    //  Clock Correction Ports
+    //----------------------------------------------------------------------------------------------
+    .RXCLKCORCNT                        (),                            
+                    
+    //----------------------------------------------------------------------------------------------
+    //  Channel Bonding Ports (disable)
+    //----------------------------------------------------------------------------------------------
+    .RXCHBONDEN                         ( 1'd0),                                         
+    .RXCHBONDI                          ( 5'd0),                                         
+    .RXCHBONDLEVEL                      ( 3'd0),                                         
+    .RXCHBONDMASTER                     ( 1'd0),                                         
+    .RXCHBONDSLAVE                      ( 1'd0),                                         
+                                                                                    
+    .RXCHANBONDSEQ                      (),                                         
+    .RXCHANISALIGNED                    (),                                         
+    .RXCHANREALIGN                      (),                                         
+    .RXCHBONDO                          (),                                                                                                                                                                       
+ 
+    //----------------------------------------------------------------------------------------------
+    //  TX Phase Alignment Ports
+    //----------------------------------------------------------------------------------------------
+    .TXPHALIGN                          ( 1'd0),
+    .TXPHALIGNEN                        ( 1'd0),
+    .TXPHDLYPD                          ( 1'd0),
+    .TXPHDLYRESET                       ( 1'd0),
+    .TXPHDLYTSTCLK                      ( 1'd0),
+    .TXPHINIT                           ( 1'd0),
+    .TXPHOVRDEN                         ( 1'd0),
+   
+    .TXPHALIGNDONE                      (GT_TXPHALIGNDONE),
+    .TXPHINITDONE                       (),
+   
+    //----------------------------------------------------------------------------------------------
+    //  TX Delay Alignment Ports
+    //----------------------------------------------------------------------------------------------
+    .TXDLYBYPASS                        ( 1'd0),
+    .TXDLYEN                            ( 1'd0),
+    .TXDLYHOLD                          ( 1'd0),
+    .TXDLYOVRDEN                        ( 1'd0),
+    .TXDLYSRESET                        ( 1'd0),
+    .TXDLYUPDOWN                        ( 1'd0),
+       
+    .TXDLYSRESETDONE                    (),       
+          
+    //----------------------------------------------------------------------------------------------
+    //  TX Auto Sync Alignment Ports 
+    //----------------------------------------------------------------------------------------------
+    .TXSYNCALLIN                        (GT_TXSYNCALLIN),
+    .TXSYNCIN                           (GT_TXSYNCIN),
+    .TXSYNCMODE                         (MASTER_LANE),                                         
+                
+    .TXSYNCDONE                         (),
+    .TXSYNCOUT                          (GT_TXSYNCOUT),
+
+    //----------------------------------------------------------------------------------------------
+    //  RX Phase Alignment Ports (disable)
+    //----------------------------------------------------------------------------------------------
+    .RXPHALIGN                          ( 1'd0),
+    .RXPHALIGNEN                        ( 1'd0),
+    .RXPHDLYPD                          ( 1'd0),
+    .RXPHDLYRESET                       ( 1'd0),
+  //.RXPHOVRDEN                         ( 1'd0),
+   
+    .RXPHALIGNDONE                      (),
+    .RXPHALIGNERR                       (),
+       
+    //----------------------------------------------------------------------------------------------
+    //  RX Delay Alignment Ports (disable)
+    //----------------------------------------------------------------------------------------------
+    .RXDLYBYPASS                        ( 1'd1),
+    .RXDLYEN                            ( 1'd0),
+    .RXDLYOVRDEN                        ( 1'd0),
+    .RXDLYSRESET                        ( 1'd0),
+   
+    .RXDLYSRESETDONE                    (),                                           
+        
+    //----------------------------------------------------------------------------------------------
+    //  RX Auto Sync Alignment Ports (disable)
+    //----------------------------------------------------------------------------------------------
+    .RXSYNCALLIN                        ( 1'd0),
+    .RXSYNCIN                           ( 1'd0),
+    .RXSYNCMODE                         ( 1'd0),                                                    
+                                                                                                    
+    .RXSYNCDONE                         (),                                                
+    .RXSYNCOUT                          (),    
+       
+    //----------------------------------------------------------------------------------------------
+    //  Gearbox Ports 
+    //----------------------------------------------------------------------------------------------
+    .TXHEADER                           ( 6'd0), 
+    .TXLATCLK                           ( 1'd0),                                                    
+    .TXSEQUENCE                         ( 7'd0),                                                    
+    .RXGEARBOXSLIP                      ( 1'd0),  
+    .RXLATCLK                           ( 1'd0),  
+    .RXSLIDE                            ( 1'd0),                                                    
+                                                                                                    
+    .RXDATAVALID                        (),                 
+    .RXHEADER                           (),                                                         
+    .RXHEADERVALID                      (), 
+    .RXSLIDERDY                         (),                                                         
+    .RXSTARTOFSEQ                       (),                             
+                   
+    //----------------------------------------------------------------------------------------------
+    //  RX Slip Ports 
+    //----------------------------------------------------------------------------------------------
+    .RXSLIPOUTCLK                       ( 1'd0),
+    .RXSLIPPMA                          ( 1'd0),   
+                                                                   
+    .RXSLIPDONE                         (),     
+    .RXSLIPOUTCLKRDY                    (),
+    .RXSLIPPMARDY                       (),             
+       
+    //----------------------------------------------------------------------------------------------
+    //  RX LPM Ports 
+    //----------------------------------------------------------------------------------------------
+    .RXLPMEN                            (!pcierategen3),    
+    .RXLPMGCHOLD                        ( 1'b0),            
+    .RXLPMGCOVRDEN                      ( 1'b0),
+    .RXLPMHFHOLD                        ( 1'b0),            
+    .RXLPMHFOVRDEN                      ( 1'b0),
+    .RXLPMLFHOLD                        ( 1'b0),         
+    .RXLPMLFKLOVRDEN                    ( 1'b0), 
+    .RXLPMOSHOLD                        ( 1'b0),            
+    .RXLPMOSOVRDEN                      ( 1'b0),
+                                                                                                    
+    //----------------------------------------------------------------------------------------------
+    //  RX DFE Ports
+    //----------------------------------------------------------------------------------------------
+    ////.RXDFEAGCCTRL                       ( 2'h1), //( 2'b00),     [Changed for extracted model]
+    .RXDFEAGCHOLD                       ( 1'b0),            
+    .RXDFEAGCOVRDEN                     ( 1'b0),
+    .RXDFECFOKFCNUM                     ( 4'b0000),                             
+    .RXDFECFOKFEN                       ( 1'b0),                                
+    .RXDFECFOKFPULSE                    ( 1'b0),                                
+    .RXDFECFOKHOLD                      ( 1'b0),                                
+    .RXDFECFOKOVREN                     ( 1'b0),                                
+    .RXDFEKHHOLD                        ( 1'b0),
+    .RXDFEKHOVRDEN                      ( 1'b0),
+    .RXDFELFHOLD                        ( 1'b0),          
+    .RXDFELFOVRDEN                      ( 1'b0),
+    .RXDFELPMRESET                      (GT_RXDFELPMRESET),
+    .RXDFETAP2HOLD                      ( 1'b0),
+    .RXDFETAP2OVRDEN                    ( 1'b0),
+    .RXDFETAP3HOLD                      ( 1'b0),
+    .RXDFETAP3OVRDEN                    ( 1'b0),
+    .RXDFETAP4HOLD                      ( 1'b0),
+    .RXDFETAP4OVRDEN                    ( 1'b0),
+    .RXDFETAP5HOLD                      ( 1'b0),
+    .RXDFETAP5OVRDEN                    ( 1'b0),
+    .RXDFETAP6HOLD                      ( 1'b0),
+    .RXDFETAP6OVRDEN                    ( 1'b0),
+    .RXDFETAP7HOLD                      ( 1'b0),
+    .RXDFETAP7OVRDEN                    ( 1'b0),
+    .RXDFETAP8HOLD                      ( 1'b0),
+    .RXDFETAP8OVRDEN                    ( 1'b0),
+    .RXDFETAP9HOLD                      ( 1'b0),
+    .RXDFETAP9OVRDEN                    ( 1'b0),
+    .RXDFETAP10HOLD                     ( 1'b0),
+    .RXDFETAP10OVRDEN                   ( 1'b0),
+    .RXDFETAP11HOLD                     ( 1'b0),
+    .RXDFETAP11OVRDEN                   ( 1'b0),
+    .RXDFETAP12HOLD                     ( 1'b0),
+    .RXDFETAP12OVRDEN                   ( 1'b0),
+    .RXDFETAP13HOLD                     ( 1'b0),
+    .RXDFETAP13OVRDEN                   ( 1'b0),
+    .RXDFETAP14HOLD                     ( 1'b0),
+    .RXDFETAP14OVRDEN                   ( 1'b0),
+    .RXDFETAP15HOLD                     ( 1'b0),
+    .RXDFETAP15OVRDEN                   ( 1'b0),
+    .RXDFEUTHOLD                        ( 1'b0),
+    .RXDFEUTOVRDEN                      ( 1'b0),
+    .RXDFEVPHOLD                        ( 1'b0),
+    .RXDFEVPOVRDEN                      ( 1'b0),
+    .RXDFEXYDEN                         ( 1'b1),                                                                                                    
+    
+    //----------------------------------------------------------------------------------------------
+    //  TX PI Ports
+    //----------------------------------------------------------------------------------------------
+    .TXPIPPMEN                          ( 1'd0),
+    .TXPIPPMOVRDEN                      ( 1'd0),
+    .TXPIPPMPD                          ( 1'd0),
+    .TXPIPPMSEL                         ( 1'd0),
+    .TXPIPPMSTEPSIZE                    ( 5'd0),
+    .TXPISOPD                           ( 1'd0),   
+    
+    //----------------------------------------------------------------------------------------------
+    //  RX CDR Ports
+    //----------------------------------------------------------------------------------------------
+    .CDRSTEPDIR                         ( 1'b0),                                 
+    .CDRSTEPSQ                          ( 1'b0),                                
+    .CDRSTEPSX                          ( 1'b0),                               
+    .RXCDRFREQRESET                     (GT_RXCDRFREQRESET),
+    .RXCDRHOLD                          (GT_RXCDRHOLD),
+    .RXCDROVRDEN                        ( 1'd0),
+    .RXCDRRESET                         (rxcdrreset_int),
+    
+    .RXCDRLOCK                          (GT_RXCDRLOCK),    
+    .RXCDRPHDONE                        (), 
+       
+    //----------------------------------------------------------------------------------------------
+    //  Eye Scan Ports
+    //----------------------------------------------------------------------------------------------                                          
+    .EYESCANRESET                       ( 1'd0),                                             
+    .EYESCANTRIGGER                     ( 1'd0),                                             
+                                                                                            
+    .EYESCANDATAERROR                   (),           
+       
+    //----------------------------------------------------------------------------------------------
+    //  RX OS Ports
+    //----------------------------------------------------------------------------------------------
+    .RXOSCALRESET                       ( 1'b0),
+    .RXOSHOLD                           ( 1'b0),
+    .RXOSOVRDEN                         ( 1'b0),    
+ 
+    .RXOSINTDONE                        (),                                                         
+    .RXOSINTSTARTED                     (),                                                         
+    .RXOSINTSTROBEDONE                  (),                                                         
+    .RXOSINTSTROBESTARTED               (),         
+           
+    //----------------------------------------------------------------------------------------------
+    //  DRP Ports
+    //----------------------------------------------------------------------------------------------
+    .DRPCLK                             (GT_DRPCLK), 
+    .DRPRST                             ( 1'd0),                                                                                
+    .DRPADDR                            (GT_DRPADDR),                                                    
+    .DRPEN                              (GT_DRPEN),                                                    
+    .DRPWE                              (GT_DRPWE), 
+    .DRPDI                              (GT_DRPDI),                                                    
+        
+    .DRPRDY                             (GT_DRPRDY),                                                         
+    .DRPDO                              (GT_DRPDO),
+
+    //----------------------------------------------------------------------------------------------
+    //  Loopback & PRBS Ports
+    //----------------------------------------------------------------------------------------------
+    .LOOPBACK                           (GT_LOOPBACK),      
+    .TXPRBSSEL                          (GT_PRBSSEL),                                                    
+    .RXPRBSSEL                          (GT_PRBSSEL),  
+    .TXPRBSFORCEERR                     (GT_TXPRBSFORCEERR),  
+    .RXPRBSCNTRESET                     (GT_RXPRBSCNTRESET),  
+                   
+    .RXPRBSERR                          (GT_RXPRBSERR),                                                
+    .RXPRBSLOCKED                       (GT_RXPRBSLOCKED),       
+
+    //----------------------------------------------------------------------------------------------
+    //  Digital Monitor Ports                                                                             
+    //----------------------------------------------------------------------------------------------
+    .DMONFIFORESET                      ( 1'd0),                                                    
+    .DMONITORCLK                        ( 1'd0),                                                    
+    
+    .DMONITOROUT                        (),    
+    .DMONITOROUTCLK                     (),                                             
+      
+    //----------------------------------------------------------------------------------------------
+    //  USB Ports
+    //----------------------------------------------------------------------------------------------
+    .TXONESZEROS                        (GT_TXONESZEROS),
+    .RXEQTRAINING                       (GT_RXEQTRAINING),
+    .RXTERMINATION                      (GT_RXTERMINATION),    
+    
+    .POWERPRESENT                       (GT_POWERPRESENT),           
+        
+    //----------------------------------------------------------------------------------------------
+    //  USB LFPS Ports
+    //----------------------------------------------------------------------------------------------
+    .TXLFPSTRESET                       ( 1'b0),      
+    .TXLFPSU2LPEXIT                     ( 1'b0),
+    .TXLFPSU3WAKE                       ( 1'b0),
+    
+    .RXLFPSTRESETDET                    (),             
+    .RXLFPSU2LPEXITDET                  (),             
+    .RXLFPSU3WAKEDET                    (),            
+      
+    //----------------------------------------------------------------------------------------------
+    //  SATA Ports 
+    //----------------------------------------------------------------------------------------------
+    .TXCOMINIT                          ( 1'd0),                                                    
+    .TXCOMSAS                           ( 1'd0),                                                    
+    .TXCOMWAKE                          ( 1'd0),                                                    
+
+    .TXCOMFINISH                        (),                                                         
+    .RXCOMINITDET                       (),                                                         
+    .RXCOMSASDET                        (),                                                         
+    .RXCOMWAKEDET                       (),                                                    
+
+    //----------------------------------------------------------------------------------------------
+    //  QPI
+    //----------------------------------------------------------------------------------------------
+    ////.RXQPIEN                            ( 1'd0),
+    ////.TXQPIBIASEN                        ( 1'b0),                                
+    ////.TXQPIWEAKPUP                       ( 1'b0),                              
+    
+    ////.RXQPISENN                          (),
+    ////.RXQPISENP                          (),
+    ////.TXQPISENN                          (),
+    ////.TXQPISENP                          (),
+
+    //----------------------------------------------------------------------------------------------
+    //  GT Ports
+    //----------------------------------------------------------------------------------------------
+    .FREQOS                             ( 1'd0),    
+    .GTRSVD                             (16'd0),
+    .INCPCTRL                           ( 1'd0),
+    .RXAFECFOKEN                        ( 1'd0),                                
+    .RXCKCALRESET                       ( 1'b0),                                
+    .RXCKCALSTART                       ( 7'd0),                                
+    .TSTIN                              (20'h00000),                                                
+    .TXDCCFORCESTART                    ( 1'b0),                                
+    .TXDCCRESET                         ( 1'b0),                                
+    .TXMUXDCDEXHOLD                     ( 1'b0),                                
+    .TXMUXDCDORWREN                     ( 1'b0),                                
+                                                                                   
+    .PINRSRVDAS                         (),                                     
+    .RXCKCALDONE                        (),                                     
+    .TXDCCDONE                          ()                                      
+);
+
+end else begin: GTH_CHANNEL
+//--------------------------------------------------------------------------------------------------
+//  GTH Channel
+//--------------------------------------------------------------------------------------------------
+GTHE4_CHANNEL #
+(  
+    //----------------------------------------------------------------------------------------------
+    //  Simulation Attributes
+    //----------------------------------------------------------------------------------------------
+    .SIM_MODE                           ("FAST"),                                    
+    .SIM_RECEIVER_DETECT_PASS           ("TRUE"),
+    .SIM_RESET_SPEEDUP                  ("TRUE"),
+    .SIM_TX_EIDLE_DRIVE_LEVEL           (SIM_TX_EIDLE_DRIVE_LEVEL),
+  //.SIM_VERSION                        (1),                             
+   
+    //----------------------------------------------------------------------------------------------     
+    //  Clock Attributes
+    //----------------------------------------------------------------------------------------------                       
+    .TXREFCLKDIV2_SEL                   ( 1'b0),                              
+    .RXREFCLKDIV2_SEL                   ( 1'b0),                                
+    .TX_CLK25_DIV                       (CLK25_DIV),                                                    
+    .RX_CLK25_DIV                       (CLK25_DIV),                                                    
+    .TX_CLKMUX_EN                       ( 1'b1),                                                
+    .RX_CLKMUX_EN                       ( 1'b1),                                                
+    .TX_XCLK_SEL                        ("TXUSR"),                                              
+    .RX_XCLK_SEL                        ("RXDES"),   
+    .TXOUT_DIV                          (OUT_DIV), 
+    .RXOUT_DIV                          (OUT_DIV), 
+    .LOCAL_MASTER                       (LOCAL_MASTER),   
+    .RX_CLK_SLIP_OVRD                   ( 5'b00000),  
+    .RXPMACLK_SEL                       ("DATA"),                                                                                                                           
+    .USE_PCS_CLK_PHASE_SEL              ( 1'b0),           
+   
+    //----------------------------------------------------------------------------------------------     
+    //  Programmable Divider Attributes
+    //----------------------------------------------------------------------------------------------                                                                                                                       
+    .TX_PROGCLK_SEL                     ("CPLL"),                               
+    .TX_PROGDIV_CFG                     (PROGDIV_CFG),                      
+    .RX_PROGDIV_CFG                     (PROGDIV_CFG),   
+    .TX_PROGDIV_RATE                    (16'h0001),                          
+    .RX_PROGDIV_RATE                    (16'h0001),                                   
+               
+    //----------------------------------------------------------------------------------------------
+    //  CPLL Attributes
+    //----------------------------------------------------------------------------------------------                 
+    .CPLL_CFG0                          (16'h00FA), //(16'h20FA),               // Optimize for PCIe PLL compliance  
+    .CPLL_CFG1                          (16'h0023), //(16'h24AA),          
+    .CPLL_CFG2                          (16'h0002),                             
+    .CPLL_CFG3                          ( 6'h00),  
+    .CPLL_FBDIV                         (CPLL_FBDIV),  
+    .CPLL_FBDIV_45                      (CPLL_FBDIV_45),    
+    .CPLL_INIT_CFG0                     (16'h02B2),                
+    .CPLL_LOCK_CFG                      (16'h01E8), //(16'h01E8),                             
+    .CPLL_REFCLK_DIV                    ( 1),     
+             
+    //----------------------------------------------------------------------------------------------
+    //  Reset Attributes
+    //----------------------------------------------------------------------------------------------                
+    .RESET_POWERSAVE_DISABLE            ( 1'b0),   
+                                                                              
+    //----------------------------------------------------------------------------------------------
+    //  Reset Time Attributes
+    //----------------------------------------------------------------------------------------------    
+    .TX_DIVRESET_TIME                   ( 5'b00010), //( 5'b00001),  
+    .TXPCSRESET_TIME	                  ( 5'b00011),
+    .TXPMARESET_TIME	                  ( 5'b00011),
+    .RX_DIVRESET_TIME                   ( 5'b00010), //( 5'b00001),  
+    .RXBUFRESET_TIME                    ( 5'b00011),
+    .RXCDRFREQRESET_TIME                ( 5'b10000), //( 5'b00001),  
+    .RXCDRPHRESET_TIME                  ( 5'b00001),    
+    .RXDFELPMRESET_TIME                 ( 7'b0001111),    
+    .RXISCANRESET_TIME	                ( 5'b00001), 
+    .RXOSCALRESET_TIME	                ( 5'b00011), 
+    .RXPCSRESET_TIME	                  ( 5'b00011),   
+    .RXPMARESET_TIME	                  ( 5'b00011),   
+               
+    //----------------------------------------------------------------------------------------------
+    //  PCIe Attributes
+    //----------------------------------------------------------------------------------------------
+    .PCIE_BUFG_DIV_CTRL                 (PCIE_BUFG_DIV_CTRL),                  
+    .PCIE_RXPCS_CFG_GEN3                (PCIE_RXPCS_CFG_GEN3),                 
+    .PCIE_RXPMA_CFG                     (PCIE_PMA_CFG),                        
+    .PCIE_TXPCS_CFG_GEN3                (PCIE_TXPCS_CFG_GEN3),                 
+    .PCIE_TXPMA_CFG                     (PCIE_PMA_CFG),                        
+    .PCS_PCIE_EN                        (PCS_PCIE_EN),  
+    .PCIE_PLL_SEL_MODE_GEN12            (PCIE_PLL_SEL_MODE_GEN12),                  
+    .PCIE_PLL_SEL_MODE_GEN3             (PCIE_PLL_SEL_MODE_GEN3),  
+    .PCIE_PLL_SEL_MODE_GEN4             (PCIE_PLL_SEL_MODE_GEN4),                     
+           
+    //---------------------------------------------------------------------------------------------- 
+    //  Data Width Attributes
+    //----------------------------------------------------------------------------------------------                          
+    .TX_DATA_WIDTH                      (20),                                                                                                                                         
+    .RX_DATA_WIDTH                      (20),  
+    .TX_INT_DATAWIDTH                   ( 0),                                                                
+    .RX_INT_DATAWIDTH                   ( 0),   
+    .TX_FABINT_USRCLK_FLOP              ( 1'b0), 
+    .RX_FABINT_USRCLK_FLOP              ( 1'b0),                                                    
+              
+    //----------------------------------------------------------------------------------------------
+    //  Analog Front End Attributes
+    //----------------------------------------------------------------------------------------------
+    .LPBK_BIAS_CTRL	                    ( 3'b100),                           
+    .LPBK_EN_RCAL_B	                    ( 1'b0),                             
+    .LPBK_EXT_RCAL	                    ( 4'b1000),                          
+    .LPBK_RG_CTRL	                      ( 4'b1110),                             
+    .RX_AFE_CM_EN                       ( 1'b0),
+    .RX_BIAS_CFG0                       (16'h1554),
+    .RX_CM_BUF_CFG                      ( 4'b1010),
+    .RX_CM_BUF_PD                       ( 1'b0),                                           
+    .RX_CM_SEL                          (RX_CM_SEL),                                                        
+    .RX_CM_TRIM                         (10),    
+    .RX_TUNE_AFE_OS                     ( 2'b00),
+    .TERM_RCAL_CFG                      (15'b100001000010001),                                     
+    .TERM_RCAL_OVRD                     ( 3'b000),             
+                                                                                                    
+    //----------------------------------------------------------------------------------------------  
+    //  Receiver Detection Attributes
+    //----------------------------------------------------------------------------------------------                                      
+    .TX_RXDETECT_CFG                    (14'h0032),                                                      
+    .TX_RXDETECT_REF                    (3),                                  
+    
+    //----------------------------------------------------------------------------------------------  
+    //  TX Electrical Idle Attributes
+    //----------------------------------------------------------------------------------------------   
+    .TX_EIDLE_ASSERT_DELAY              (TX_EIDLE_ASSERT_DELAY),                            
+    .TX_EIDLE_DEASSERT_DELAY            (TX_EIDLE_DEASSERT_DELAY),             
+    .TX_IDLE_DATA_ZERO                  ( 1'b0),                                // Optimized for PCIe      
+ 
+    //----------------------------------------------------------------------------------------------  
+    //  RX OOB Attributes
+    //----------------------------------------------------------------------------------------------   
+    .OOB_PWRUP                          ( 1'b1),                                
+    .OOBDIVCTL                          (OOBDIVCTL),                                            
+    .RX_SIG_VALID_DLY                   ( 4),                                   // Optimized for PCIe
+    .RXOOB_CFG                          ( 9'b000000110),                          
+    .RXOOB_CLK_CFG                      ("PMA"),      
+    
+    //----------------------------------------------------------------------------------------------  
+    //  RX Electrical Idle Attributes
+    //----------------------------------------------------------------------------------------------                                                   
+    .RX_DFE_LPM_HOLD_DURING_EIDLE       ( 1'b0),                                
+    .RXBUF_EIDLE_HI_CNT                 ( 4'b0100),                             // Optimized for PCIe
+    .RXBUF_EIDLE_LO_CNT                 ( 4'b0000),
+    .RXBUF_RESET_ON_EIDLE               ("TRUE"),
+    .RXCDR_FR_RESET_ON_EIDLE            ( 1'b0),
+    .RXCDR_PH_RESET_ON_EIDLE            ( 1'b0),
+    .RXCDR_HOLD_DURING_EIDLE            ( 1'b0),                                // Optimized for PCIe
+    .RXELECIDLE_CFG                     ("SIGCFG_1"),                           // Optimized for PCIe
+ 
+    //----------------------------------------------------------------------------------------------  
+    //  Power Down Attributes
+    //----------------------------------------------------------------------------------------------   
+    .PD_TRANS_TIME_FROM_P2              (12'h03C),                                                     
+    .PD_TRANS_TIME_NONE_P2              ( 8'h19),                                                      
+    .PD_TRANS_TIME_TO_P2                ( 8'h64),   
+    .TX_PMA_POWER_SAVE                  ( 1'b0),   
+    .RX_PMA_POWER_SAVE                  ( 1'b0),                               
+  
+    //----------------------------------------------------------------------------------------------  
+    //  Rate Change Attributes
+    //---------------------------------------------------------------------------------------------- 
+    .RATE_SW_USE_DRP                    ( 1'b0),                                // Advance PCIe feature
+    .TRANS_TIME_RATE                    ( 8'h0E),             
+    .TXBUF_RESET_ON_RATE_CHANGE         ("TRUE"),                              
+    .RXBUF_RESET_ON_RATE_CHANGE         ("TRUE"),                              
+
+    //----------------------------------------------------------------------------------------------
+    //  TX Driver Attributes
+    //----------------------------------------------------------------------------------------------                                   
+    .TX_DEEMPH0                         ( 6'b010100),                           // -6.0 dB 
+    .TX_DEEMPH1                         ( 6'b001101),                           // -3.5 dB
+    .TX_DEEMPH2                         ( 6'b000000),                           //  0.0 dB 
+    .TX_DEEMPH3                         ( 6'b000000),                           //  0.0 dB  
+    .TX_DRIVE_MODE                      ("PIPE"),                                
+    .TX_LOOPBACK_DRIVE_HIZ              ("FALSE"),                   
+    .TX_MAINCURSOR_SEL                  ( 1'b0),   
+    .TX_MARGIN_FULL_0                   ( 7'b1001111),                          // 1200 mV
+    .TX_MARGIN_FULL_1                   ( 7'b1001110),                          // 1100 mV
+    .TX_MARGIN_FULL_2                   ( 7'b1001100),                          // 1000 mV 
+    .TX_MARGIN_FULL_3                   ( 7'b1001010),                          //  900 mV
+    .TX_MARGIN_FULL_4                   ( 7'b1001000),                          //  800 mV
+    .TX_MARGIN_LOW_0                    ( 7'b1000110),                          //  700 mV            
+    .TX_MARGIN_LOW_1                    ( 7'b1000101),                          //  600 mV           
+    .TX_MARGIN_LOW_2                    ( 7'b1000011),                          //  500 mV          
+    .TX_MARGIN_LOW_3                    ( 7'b1000010),                          //  400 mV           
+    .TX_MARGIN_LOW_4                    ( 7'b1000000),                          //  300 mV                               
+   
+    //----------------------------------------------------------------------------------------------    
+    //  Comma Align & Detect Attributes
+    //----------------------------------------------------------------------------------------------       
+    .ALIGN_COMMA_DOUBLE                 (ALIGN_COMMA_DOUBLE),                                                  
+    .ALIGN_COMMA_ENABLE                 (10'b1111111111),                                           
+    .ALIGN_COMMA_WORD                   ( 1),                                                       
+    .ALIGN_MCOMMA_DET                   ("TRUE"),                                                   
+    .ALIGN_MCOMMA_VALUE                 (10'b1010000011),                                           
+    .ALIGN_PCOMMA_DET                   ("TRUE"),                                                   
+    .ALIGN_PCOMMA_VALUE                 (10'b0101111100),                                           
+    .DEC_MCOMMA_DETECT                  ("TRUE"),                                                      
+    .DEC_PCOMMA_DETECT                  ("TRUE"),                                                      
+    .DEC_VALID_COMMA_ONLY               ("FALSE"),                                                     
+    .SHOW_REALIGN_COMMA                 (SHOW_REALIGN_COMMA),       
+   
+    //----------------------------------------------------------------------------------------------   
+    //  8B/10B Attributes                                                                             
+    //----------------------------------------------------------------------------------------------                   
+    .RX_DISPERR_SEQ_MATCH               ("TRUE"),        
+   
+    //----------------------------------------------------------------------------------------------  
+    //  TX Buffer Attributes
+    //----------------------------------------------------------------------------------------------                      
+    .TX_FIFO_BYP_EN                     ( 1'b1),                                
+    .TXBUF_EN                           ("FALSE"),        
+    .TXFIFO_ADDR_CFG                    ("LOW"),                                                                                      
+ 
+    //----------------------------------------------------------------------------------------------
+    //  RX Buffer Attributes                                                                        
+    //----------------------------------------------------------------------------------------------     
+    .RXBUF_ADDR_MODE                    ("FULL"),                               
+    .RXBUF_EN                           ("TRUE"),
+    .RXBUF_RESET_ON_CB_CHANGE           ("TRUE"),
+    .RXBUF_RESET_ON_COMMAALIGN          ("FALSE"),
+    .RXBUF_THRESH_OVFLW                 (RXBUF_THRESH_OVFLW),                                                      
+    .RXBUF_THRESH_OVRD                  ("TRUE"),                             
+    .RXBUF_THRESH_UNDFLW                (RXBUF_THRESH_UNDFLW),                                    
+    .RX_BUFFER_CFG                      ( 6'b000000),
+    .RX_DEFER_RESET_BUF_EN              ("TRUE"), 
+   
+    //----------------------------------------------------------------------------------------------   
+    //  PCIe Gen3 RX Buffer Attributes                                                                                   
+    //----------------------------------------------------------------------------------------------   
+    .PCI3_AUTO_REALIGN                  ("OVR_1K_BLK"),                           
+    .PCI3_PIPE_RX_ELECIDLE              ( 1'b0),                                
+    .PCI3_RX_ASYNC_EBUF_BYPASS          ( 2'b00),                               
+    .PCI3_RX_ELECIDLE_EI2_ENABLE        ( 1'b0),                                
+    .PCI3_RX_ELECIDLE_H2L_COUNT         ( 6'b000000),                           
+    .PCI3_RX_ELECIDLE_H2L_DISABLE       ( 3'b000),                              
+    .PCI3_RX_ELECIDLE_HI_COUNT          ( 6'b000000),                           
+    .PCI3_RX_ELECIDLE_LP4_DISABLE       ( 1'b0),                                
+    .PCI3_RX_FIFO_DISABLE               ( 1'b0),                                
+       
+    //----------------------------------------------------------------------------------------------   
+    //  PCIe Gen3 Clock Correction Attributes                                                                                   
+    //----------------------------------------------------------------------------------------------          
+    .PCIE3_CLK_COR_EMPTY_THRSH          (PCIE3_CLK_COR_EMPTY_THRSH),                           
+    .PCIE3_CLK_COR_FULL_THRSH           (PCIE3_CLK_COR_FULL_THRSH),                          
+    .PCIE3_CLK_COR_MAX_LAT              (PCIE3_CLK_COR_MAX_LAT),                          
+    .PCIE3_CLK_COR_MIN_LAT              (PCIE3_CLK_COR_MIN_LAT),                          
+    .PCIE3_CLK_COR_THRSH_TIMER          (PCIE3_CLK_COR_THRSH_TIMER),                      
+       
+    //---------------------------------------------------------------------------------------------- 
+    //  Clock Correction Attributes
+    //----------------------------------------------------------------------------------------------             
+    .CBCC_DATA_SOURCE_SEL               ("DECODED"),  
+    .CLK_COR_KEEP_IDLE                  (CLK_COR_KEEP_IDLE),
+    .CLK_COR_MAX_LAT                    (CLK_COR_MAX_LAT),                                   
+    .CLK_COR_MIN_LAT                    (CLK_COR_MIN_LAT),                                  
+    .CLK_COR_PRECEDENCE                 ("TRUE"),
+    .CLK_COR_REPEAT_WAIT                (0),
+    .CLK_COR_SEQ_1_1                    (CLK_COR_SEQ_1_1),
+    .CLK_COR_SEQ_1_2                    (CLK_COR_SEQ_1_2),
+    .CLK_COR_SEQ_1_3                    (10'b0000000000),
+    .CLK_COR_SEQ_1_4                    (10'b0000000000),
+    .CLK_COR_SEQ_1_ENABLE               (4'b1111),
+    .CLK_COR_SEQ_2_1                    (10'b0000000000),
+    .CLK_COR_SEQ_2_2                    (10'b0000000000),
+    .CLK_COR_SEQ_2_3                    (10'b0000000000),
+    .CLK_COR_SEQ_2_4                    (10'b0000000000),
+    .CLK_COR_SEQ_2_ENABLE               (CLK_COR_SEQ_2_ENABLE),
+    .CLK_COR_SEQ_2_USE                  ("FALSE"),
+    .CLK_COR_SEQ_LEN                    (CLK_COR_SEQ_LEN),
+    .CLK_CORRECT_USE                    ("TRUE"),                
+       
+    //---------------------------------------------------------------------------------------------- 
+    //  FTS Deskew Attributes                                                                            
+    //----------------------------------------------------------------------------------------------                                         
+    .FTS_DESKEW_SEQ_ENABLE              ( 4'b1111),                                        
+    .FTS_LANE_DESKEW_CFG                ( 4'b1111),                                          
+    .FTS_LANE_DESKEW_EN                 ("FALSE"),           
+       
+    //---------------------------------------------------------------------------------------------- 
+    //  Channel Bonding Attributes (Disabled)
+    //----------------------------------------------------------------------------------------------          
+    .CHAN_BOND_KEEP_ALIGN               ("FALSE"),
+    .CHAN_BOND_MAX_SKEW                 ( 1),
+    .CHAN_BOND_SEQ_1_1                  (10'b0000000000),
+    .CHAN_BOND_SEQ_1_2                  (10'b0000000000),
+    .CHAN_BOND_SEQ_1_3                  (10'b0000000000),
+    .CHAN_BOND_SEQ_1_4                  (10'b0000000000),
+    .CHAN_BOND_SEQ_1_ENABLE             ( 4'b1111),
+    .CHAN_BOND_SEQ_2_1                  (10'b0000000000),
+    .CHAN_BOND_SEQ_2_2                  (10'b0000000000),
+    .CHAN_BOND_SEQ_2_3                  (10'b0000000000),
+    .CHAN_BOND_SEQ_2_4                  (10'b0000000000),  
+    .CHAN_BOND_SEQ_2_ENABLE             ( 4'b1111),
+    .CHAN_BOND_SEQ_2_USE                ("FALSE"), 
+    .CHAN_BOND_SEQ_LEN                  ( 1),                                                           
+  
+    //----------------------------------------------------------------------------------------------            
+    //  TX Sync Alignment Attributes                                                                              
+    //----------------------------------------------------------------------------------------------     
+    .TXDLY_CFG                          (16'b1000000000010000),    
+    .TXDLY_LCFG                         (16'b0000000000110000),                
+    .TXPH_CFG                           (16'b0000000100100011), //(16'b0000000100000011),               
+    .TXPH_CFG2                          (16'b0000000000000000),                 
+    .TXPH_MONITOR_SEL                   ( 5'b00000),
+    .TXPHDLY_CFG0                       (16'b0110000000100000),                 
+    .TXPHDLY_CFG1                       (16'b0000000000000010),              
+                                                                                    
+    //----------------------------------------------------------------------------------------------            
+    //  TX Auto Sync Alignment Attributes                                                                               
+    //----------------------------------------------------------------------------------------------                
+    .TXSYNC_MULTILANE                   (MULTI_LANE),                                                                                                              
+    .TXSYNC_OVRD                        (1'b0),                                 // Select auto TXSYNC mode                                                                                 
+    .TXSYNC_SKIP_DA                     (1'b0),                     
+                                                                                                    
+    //----------------------------------------------------------------------------------------------            
+    //  RX Sync Alignment Attributes (Not used)                                                                             
+    //----------------------------------------------------------------------------------------------    
+  //.RXDLY_CFG                          (16'h001F),   
+  //.RXDLY_LCFG                         (16'h0030),   
+  //.RXPH_MONITOR_SEL                   (5'b00000),
+  //.RXPHBEACON_CFG                     (16'h0000),
+  //.RXPHDLY_CFG                        (16'h2020),
+  //.RXPHSAMP_CFG                       (16'h2100),
+  //.RXPHSLIP_CFG                       (16'h9933),                             
+     
+    //----------------------------------------------------------------------------------------------            
+    //  RX Auto Sync Alignment Attributes (Not used)                                                                                
+    //----------------------------------------------------------------------------------------------                
+  //.RXSYNC_MULTILANE                   (1'b0),                                                                                                              
+  //.RXSYNC_OVRD                        (1'b0),                                                                                         
+  //.RXSYNC_SKIP_DA                     (1'b0),                   
+  
+    //----------------------------------------------------------------------------------------------  
+    //  Gearbox Attributes (Not used)                                                                
+    //---------------------------------------------------------------------------------------------- 
+  //.GEARBOX_MODE                       ( 5'b00000), 
+  //.TX_SAMPLE_PERIOD                   ( 3'b101),
+  //.RX_SAMPLE_PERIOD                   ( 3'b101),
+  //.TXGEARBOX_EN                       ("FALSE"),
+  //.RXGEARBOX_EN                       ("FALSE"),    
+  //.TXGBOX_FIFO_INIT_RD_ADDR           ( 4),
+  //.RXGBOX_FIFO_INIT_RD_ADDR           ( 4),
+  //.RXSLIDE_AUTO_WAIT                  ( 7),                                                         
+    .RXSLIDE_MODE                       (RXSLIDE_MODE),                          
+
+    //----------------------------------------------------------------------------------------------
+    //  PCS Reserved Attributes
+    //----------------------------------------------------------------------------------------------
+    .PCS_RSVD0                          (PCS_RSVD0),
+  
+    //----------------------------------------------------------------------------------------------  
+    //  PMA Reserved Attributes
+    //----------------------------------------------------------------------------------------------      
+    .TX_PMA_RSV0                        (16'b0000000000001000),                             
+    .RX_PMA_RSV0                        (16'b0000000000000000),                                        
+      
+    //----------------------------------------------------------------------------------------------
+    //  CFOK Attributes                                                                 
+    //----------------------------------------------------------------------------------------------              
+    .RXCFOK_CFG0                        (16'b0000000000000000), //(16'b0011111000000000),   
+    .RXCFOK_CFG1                        (16'b1000000000010101), //(16'b0000000001000010),    
+    .RXCFOK_CFG2                        (16'b0000001010101110), //(16'b0000000000101101),  
+
+    //----------------------------------------------------------------------------------------------
+    //  RX CTLE
+    //----------------------------------------------------------------------------------------------  
+    .CTLE3_OCAP_EXT_CTRL	              ( 3'b000),                           
+    .CTLE3_OCAP_EXT_EN	                ( 1'b0),                                
+    .RX_EN_CTLE_RCAL_B                  ( 1'b0),                              
+
+    //----------------------------------------------------------------------------------------------    
+    //  RX LPM Attributes
+    //----------------------------------------------------------------------------------------------        
+    .RXLPM_CFG                          (16'b0000_0000_0000_0000),    
+    .RXLPM_GC_CFG                       (16'b1000_0000_0000_0000),
+    .RXLPM_KH_CFG0                      (16'b0000_0000_0000_0000), //(16'b0000000000000000),    
+    .RXLPM_KH_CFG1                      (16'b0000_0000_0000_0010), //(16'b0000000000000010),    
+    .RXLPM_OS_CFG0                      (16'b0000_0000_0000_0000),
+    .RXLPM_OS_CFG1                      (16'b1000_0000_0000_0010), //(16'b0000000000000000), 
+ 
+    //----------------------------------------------------------------------------------------------    
+    //  RX DFE Attributes
+    //----------------------------------------------------------------------------------------------       
+    .RXDFE_CFG0                         (16'b0000101000000000), //(16'b0000110000000000),    
+    .RXDFE_CFG1                         (16'b0000001010000000),
+    .RXDFE_GC_CFG0                      (16'b0000000000000000), //(16'b0001111000000000),    
+    .RXDFE_GC_CFG1                      (16'b1000000000000000), //(16'h1900),   different from GTY             
+    .RXDFE_GC_CFG2                      (16'b1111111111100000), //(16'h0000),   different from GTY             
+    .RXDFE_H2_CFG0                      (16'b0000000000000000), //(16'b0000000000000000),    
+    .RXDFE_H2_CFG1                      (16'b0000000000000010), //(16'b0000000000000010),    
+    .RXDFE_H3_CFG0                      (16'b0000000000000000), //(16'b0000000000000000),    
+    .RXDFE_H3_CFG1                      (16'b1000000000000010), //(16'b0000000000000010),    
+    .RXDFE_H4_CFG0                      (16'b0000000000000000), //(16'b0000000000000000),    
+    .RXDFE_H4_CFG1                      (16'b1000000000000010), //(16'b0000000000000011),    
+    .RXDFE_H5_CFG0                      (16'b0000000000000000), //(16'b0000000000000000),    
+    .RXDFE_H5_CFG1                      (16'b1000000000000010), //(16'b0000000000000010),    
+    .RXDFE_H6_CFG0                      (16'b0000000000000000), //(16'b0000000000000000),    
+    .RXDFE_H6_CFG1                      (16'b1000000000000010), //(16'b0000000000000010),    
+    .RXDFE_H7_CFG0                      (16'b0000000000000000), //(16'b0000000000000000),    
+    .RXDFE_H7_CFG1                      (16'b1000000000000010), //(16'b0000000000000010),    
+    .RXDFE_H8_CFG0                      (16'b0000000000000000), //(16'b0000000000000000),    
+    .RXDFE_H8_CFG1                      (16'b1000000000000010), //(16'b0000000000000010),    
+    .RXDFE_H9_CFG0                      (16'b0000000000000000), //(16'b0000000000000000),    
+    .RXDFE_H9_CFG1                      (16'b1000000000000010), //(16'b0000000000000010),    
+    .RXDFE_HA_CFG0                      (16'b0000000000000000), //(16'b0000000000000000),    
+    .RXDFE_HA_CFG1                      (16'b1000000000000010), //(16'b0000000000000010),    
+    .RXDFE_HB_CFG0                      (16'b0000000000000000), //(16'b0010000000000000),    
+    .RXDFE_HB_CFG1                      (16'b1000000000000010), //(16'b0000000000000010),    
+    .RXDFE_HC_CFG0                      (16'b0000000000000000), //(16'b0000000000000000),    
+    .RXDFE_HC_CFG1                      (16'b1000000000000010), //(16'b0000000000000010),    
+    .RXDFE_HD_CFG0                      (16'b0000000000000000), //(16'b0000000000000000),    
+    .RXDFE_HD_CFG1                      (16'b1000000000000010), //(16'b0000000000000010),    
+    .RXDFE_HE_CFG0                      (16'b0000000000000000), //(16'b0000000000000000),    
+    .RXDFE_HE_CFG1                      (16'b1000000000000010), //(16'b0000000000000010),    
+    .RXDFE_HF_CFG0                      (16'b0000000000000000), //(16'b0000000000000000),    
+    .RXDFE_HF_CFG1                      (16'b1000000000000010), //(16'b0000000000000010),    
+    .RXDFE_OS_CFG0                      (16'b0000000000000000), //(16'b0000000000000000),    
+    .RXDFE_OS_CFG1                      (16'b1000000000000010), //(16'b0000001000000000),    
+    .RXDFE_PWR_SAVING                   (RXDFE_PWR_SAVING),
+    .RXDFE_UT_CFG0                      (16'b0000000000000000), //(16'b0000000000000000),    
+    .RXDFE_UT_CFG1                      (16'b0000000000000011), //(16'b0000000000000010),    
+    .RXDFE_UT_CFG2                      (16'b0000000000000000),
+    .RXDFE_VP_CFG0                      (16'b0000000000000000), //(16'b0000000000000000),    
+    .RXDFE_VP_CFG1                      (16'b1000000000110011), //(16'b0000000000100010),    
+    .RXDFELPM_KL_CFG0                   (16'b0000000000000000),                  
+    .RXDFELPM_KL_CFG1                   (16'b1010000011100010),             
+    .RXDFELPM_KL_CFG2                   (16'b0000000100000000),                        
+    .RX_DFE_AGC_CFG0                    ( 2'b10),                               
+    .RX_DFE_AGC_CFG1                    ( 4),  
+    .RX_DFE_KL_LPM_KH_CFG0              ( 1),
+    .RX_DFE_KL_LPM_KH_CFG1              ( 4),
+    .RX_DFE_KL_LPM_KL_CFG0              ( 2'b01),
+    .RX_DFE_KL_LPM_KL_CFG1              ( 4),   
+    .RX_DFELPM_CFG0                     ( 6),                                                            
+    .RX_DFELPM_CFG1                     ( 1'b1),                                                               
+    .RX_DFELPM_KLKH_AGC_STUP_EN         ( 1'b1),   
+          
+    //----------------------------------------------------------------------------------------------  
+    //  TX PI attributes
+    //----------------------------------------------------------------------------------------------
+    .TX_PHICAL_CFG0	                    (16'h0000),                           
+    .TX_PHICAL_CFG1	                    (16'h7e00),
+    .TX_PHICAL_CFG2	                    (16'h0200), //(16'h0000),  
+    .TX_PI_BIASSET	                    (TX_PI_BIASSET),                                  
+    .TXPI_CFG0                          ( 2'b00),
+    .TXPI_CFG1                          ( 2'b00),
+    .TXPI_CFG2                          ( 2'b00),
+    .TXPI_CFG3                          ( 1'b0),
+    .TXPI_CFG4                          ( 1'b0),
+    .TXPI_CFG5                          ( 3'b000),
+    .TXPI_GRAY_SEL                      ( 1'b0),
+    .TXPI_INVSTROBE_SEL                 ( 1'b0),
+    .TXPI_LPM                           ( 1'b0),
+    .TXPI_PPM_CFG                       ( 8'b00000000),
+    .TXPI_PPMCLK_SEL                    ("TXUSRCLK2"),
+    .TXPI_SYNFREQ_PPM                   ( 3'b001),
+    .TXPI_VREFSEL                       ( 1'b0),
+    
+    //----------------------------------------------------------------------------------------------  
+    //  RX PI Attributes
+    //----------------------------------------------------------------------------------------------    
+    .RXPI_AUTO_BW_SEL_BYPASS            ( 1'b0),
+    .RXPI_CFG0                          (RXPI_CFG0),
+    .RXPI_CFG1                          (16'h0000),
+    .RXPI_LPM                           ( 1'b0),
+    .RXPI_SEL_LC                        ( 2'b00),
+    .RXPI_STARTCODE                     ( 2'b00),
+    .RXPI_VREFSEL                       ( 1'b0),              
+
+    //----------------------------------------------------------------------------------------------
+    //  RX CDR Attributes
+    //----------------------------------------------------------------------------------------------    
+    .CDR_SWAP_MODE_EN                   ( 1'b0),                 
+    .RX_WIDEMODE_CDR                    ( 2'b00),                               //Gen1/2 wide mode    
+    .RX_WIDEMODE_CDR_GEN3               ( 2'b00), 
+    .RX_WIDEMODE_CDR_GEN4               ( 2'b01),
+    .RXCDR_CFG0                         (RXCDR_CFG0), 
+    .RXCDR_CFG0_GEN3                    (RXCDR_CFG0_GEN3), 
+    .RXCDR_CFG1                         (RXCDR_CFG1), 
+    .RXCDR_CFG1_GEN3                    (RXCDR_CFG1_GEN3), 
+    .RXCDR_CFG2                         (RXCDR_CFG2), 
+    .RXCDR_CFG2_GEN3                    (RXCDR_CFG2_GEN3), 
+    .RXCDR_CFG2_GEN4                    (RXCDR_CFG2_GEN4), 
+    .RXCDR_CFG3                         (RXCDR_CFG3), 
+    .RXCDR_CFG3_GEN3                    (RXCDR_CFG3_GEN3), 
+    .RXCDR_CFG3_GEN4                    (RXCDR_CFG3_GEN4),
+    .RXCDR_CFG4                         (RXCDR_CFG4), 
+    .RXCDR_CFG4_GEN3                    (RXCDR_CFG4_GEN3), 
+    .RXCDR_CFG5                         (RXCDR_CFG5), 
+    .RXCDR_CFG5_GEN3                    (RXCDR_CFG5_GEN3), 
+    .RXCDR_LOCK_CFG0                    (16'b0001_0010_0000_0001), //(16'h0001),  
+    .RXCDR_LOCK_CFG1                    (16'b1001_1111_1111_1111), //(16'h0000),  
+    .RXCDR_LOCK_CFG2                    (16'b0111_0111_1100_0011), //(16'b0000),  
+    .RXCDR_LOCK_CFG3                    (16'b0000_0000_0000_0001), //(16'h0000),  
+
+    //---------------------------------------------------------------------------------------------- 
+    //  Eye Scan Attributes
+    //----------------------------------------------------------------------------------------------
+    .ES_CLK_PHASE_SEL                   ( 1'b0),                           
+    .ES_CONTROL                         ( 6'b000000),                      
+    .ES_ERRDET_EN                       ("FALSE"),                        
+    .ES_EYE_SCAN_EN                     ("FALSE"),                        
+    .ES_HORZ_OFFSET                     (12'b000000000000),                       
+    .ES_PRESCALE                        ( 5'b00000),                                
+    .ES_QUAL_MASK0                      (16'b0000000000000000),           
+    .ES_QUAL_MASK1                      (16'b0000000000000000),           
+    .ES_QUAL_MASK2                      (16'b0000000000000000),           
+    .ES_QUAL_MASK3                      (16'b0000000000000000),           
+    .ES_QUAL_MASK4                      (16'b0000000000000000),       
+    .ES_QUAL_MASK5                      (16'b0000000000000000),           
+    .ES_QUAL_MASK6                      (16'b0000000000000000),           
+    .ES_QUAL_MASK7                      (16'b0000000000000000),           
+    .ES_QUAL_MASK8                      (16'b0000000000000000),           
+    .ES_QUAL_MASK9                      (16'b0000000000000000),         
+    .ES_QUALIFIER0                      (16'b0000000000000000),           
+    .ES_QUALIFIER1                      (16'b0000000000000000),           
+    .ES_QUALIFIER2                      (16'b0000000000000000),           
+    .ES_QUALIFIER3                      (16'b0000000000000000),           
+    .ES_QUALIFIER4                      (16'b0000000000000000), 
+    .ES_QUALIFIER5                      (16'b0000000000000000),           
+    .ES_QUALIFIER6                      (16'b0000000000000000),           
+    .ES_QUALIFIER7                      (16'b0000000000000000),           
+    .ES_QUALIFIER8                      (16'b0000000000000000),           
+    .ES_QUALIFIER9                      (16'b0000000000000000),   
+    .ES_SDATA_MASK0                     (16'b0000000000000000),           
+    .ES_SDATA_MASK1                     (16'b0000000000000000),           
+    .ES_SDATA_MASK2                     (16'b0000000000000000),           
+    .ES_SDATA_MASK3                     (16'b0000000000000000),           
+    .ES_SDATA_MASK4                     (16'b0000000000000000), 
+    .ES_SDATA_MASK5                     (16'b0000000000000000),           
+    .ES_SDATA_MASK6                     (16'b0000000000000000),           
+    .ES_SDATA_MASK7                     (16'b0000000000000000),           
+    .ES_SDATA_MASK8                     (16'b0000000000000000),   
+    .ES_SDATA_MASK9                     (16'b0000000000000000),          
+    .EYE_SCAN_SWAP_EN                   ( 1'b0),
+    .RX_EYESCAN_VS_CODE                 ( 7'b0000000),
+    .RX_EYESCAN_VS_NEG_DIR              ( 1'b0),
+    .RX_EYESCAN_VS_RANGE                ( 2'b00),
+    .RX_EYESCAN_VS_UT_SIGN              ( 1'b0),                        
+  
+    //----------------------------------------------------------------------------------------------
+    //  Loopback & PRBS Attributes
+    //----------------------------------------------------------------------------------------------
+    .RXPRBS_ERR_LOOPBACK                ( 1'b0),     
+    .RXPRBS_LINKACQ_CNT                 (15),                                                   
+
+    //----------------------------------------------------------------------------------------------   
+    //  Digital Monitor Attribute
+    //----------------------------------------------------------------------------------------------                     
+    .DMONITOR_CFG0                      (10'b0000000000),                                                  
+    .DMONITOR_CFG1                      ( 8'b00000000),                                                   
+
+    //----------------------------------------------------------------------------------------------   
+    //  AC JTAG Attributes
+    //----------------------------------------------------------------------------------------------                     
+    .ACJTAG_DEBUG_MODE                  ( 1'b0),                                                        
+    .ACJTAG_MODE                        ( 1'b0),                                                        
+    .ACJTAG_RESET                       ( 1'b0),      
+    
+    //----------------------------------------------------------------------------------------------
+    //  USB Attributes
+    //----------------------------------------------------------------------------------------------                 
+    .USB_BOTH_BURST_IDLE                ( 1'b0),
+    .USB_BURSTMAX_U3WAKE	              ( 7'b1111111),
+    .USB_BURSTMIN_U3WAKE	              ( 7'b1100011),
+    .USB_CLK_COR_EQ_EN                  ( 1'b1),                              
+    .USB_EXT_CNTL                       ( 1'b1),
+    .USB_IDLEMAX_POLLING                (10'b1010111011),
+    .USB_IDLEMIN_POLLING                (10'b0100101011),
+    .USB_LFPS_TPERIOD	                  ( 4'b0011),
+    .USB_LFPS_TPERIOD_ACCURATE	        ( 1'b1),
+    .USB_LFPSPING_BURST	                ( 9'b000000101),
+    .USB_LFPSPOLLING_BURST	            ( 9'b000110001),
+    .USB_LFPSPOLLING_IDLE_MS	          ( 9'b000000100),
+    .USB_LFPSU1EXIT_BURST	              ( 9'b000011101),
+    .USB_LFPSU2LPEXIT_BURST_MS	        ( 9'b001100011),
+    .USB_LFPSU3WAKE_BURST_MS	          ( 9'b111110011),
+    .USB_MODE                           (USB_MODE), 
+    .USB_PCIE_ERR_REP_DIS               ( 1'b0),                                // For PCIe Debug
+    .USB_PING_SATA_MAX_INIT             (21),
+    .USB_PING_SATA_MIN_INIT             (12),
+    .USB_POLL_SATA_MAX_BURST            ( 8),
+    .USB_POLL_SATA_MIN_BURST            ( 4),
+    .USB_RAW_ELEC                       ( 1'b1),                               
+    .USB_RXIDLE_P0_CTRL                 ( 1'b1),
+    .USB_TXIDLE_TUNE_ENABLE             ( 1'b1),
+    .USB_U1_SATA_MAX_WAKE               ( 7),
+    .USB_U1_SATA_MIN_WAKE               ( 4),
+    .USB_U2_SAS_MAX_COM                 (64),   
+    .USB_U2_SAS_MIN_COM                 (36),
+    
+    //---------------------------------------------------------------------------------------------- 
+    //  SAS & SATA Attributes (Not used)
+    //---------------------------------------------------------------------------------------------- 
+  //.SAS12G_MODE                        ( 1'b0),
+  //.SATA_BURST_SEQ_LEN                 ( 4'b1111),
+  //.SATA_BURST_VAL                     ( 3'b100),
+  //.SATA_CPLL_CFG                      ("VCO_3000MHZ"),
+  //.SATA_EIDLE_VAL                     ( 3'b100), 
+            
+    //---------------------------------------------------------------------------------------------- 
+    //  CKCAL Attributes
+    //---------------------------------------------------------------------------------------------- 
+    .CKCAL1_CFG_0	                      (16'hC0C0), //(16'b0000000000000000), 
+    .CKCAL1_CFG_1	                      (16'h50C0), //(16'b0000000000000000), 
+    .CKCAL1_CFG_2	                      (16'b0000000000001010),
+    .CKCAL1_CFG_3	                      (16'b0000000000000000),
+    .CKCAL2_CFG_0	                      (16'hC0C0), //(16'b0000000000000000), 
+    .CKCAL2_CFG_1	                      (16'h80C0), //(16'b0000000000000000), 
+    .CKCAL2_CFG_2	                      (16'b0000000000000000),
+    .CKCAL2_CFG_3	                      (16'b0000000000000000),
+    .CKCAL2_CFG_4	                      (16'b0000000000000000),
+    .CKCAL_RSVD0	                      (16'h0000),
+    .CKCAL_RSVD1	                      (16'b0000010000000000), //(16'h0000),
+    .RXCKCAL1_I_LOOP_RST_CFG	          (16'h0004),
+    .RXCKCAL1_IQ_LOOP_RST_CFG	          (16'h0004),
+    .RXCKCAL1_Q_LOOP_RST_CFG	          (16'h0004),
+    .RXCKCAL2_D_LOOP_RST_CFG	          (16'h0004),
+    .RXCKCAL2_DX_LOOP_RST_CFG	          (16'h0004),
+    .RXCKCAL2_S_LOOP_RST_CFG	          (16'h0004),
+    .RXCKCAL2_X_LOOP_RST_CFG	          (16'h0004),
+  
+    //----------------------------------------------------------------------------------------------
+    //  Summer Attributes
+    //----------------------------------------------------------------------------------------------
+    .RX_SUM_DFETAPREP_EN                ( 1'b0),
+    .RX_SUM_IREF_TUNE                   (RX_SUM_IREF_TUNE),
+    .RX_SUM_VCM_OVWR                    ( 1'b0),
+    .RX_SUM_VCMTUNE                     (RX_SUM_VCMTUNE),
+    .RX_SUM_VREF_TUNE                   ( 3'b100),
+
+    //----------------------------------------------------------------------------------------------
+    //  Attributes
+    //----------------------------------------------------------------------------------------------                 
+    .A_RXOSCALRESET                     ( 1'b0),   
+    .A_RXPROGDIVRESET                   ( 1'b0),
+    .A_RXTERMINATION                    ( 1'b1),
+    .A_TXDIFFCTRL                       ( 5'b11111),
+    .A_TXPROGDIVRESET                   ( 1'b0),
+    .ADAPT_CFG0                         (16'b0001000000000000), //(16'b1001001000000000),   
+    .ADAPT_CFG1                         (16'b1100101100000000), //(16'b1000000000011100),   
+    .ADAPT_CFG2                         (16'b0000000000000000),   
+    .CAPBYPASS_FORCE                    ( 1'b0),                                
+    .CH_HSPMUX                          (16'b0110_1101_0110_1101), //(16'h0000),   
+    .DDI_CTRL                           ( 2'b00),
+    .DDI_REALIGN_WAIT                   (15),
+    .DELAY_ELEC                         ( 1'b0),                                
+    .ISCAN_CK_PH_SEL2                   ( 1'b0),                                
+    .PREIQ_FREQ_BST                     ( 1),                                   
+    .PROCESS_PAR                        ( 3'b010), 
+    .RX_CAPFF_SARC_ENB                  ( 1'b0),    
+    .RX_DDI_SEL                         ( 6'b000000),  
+    .RX_DEGEN_CTRL                      ( 3'b011),                              
+    .RX_DIV2_MODE_B                     ( 1'b0),                                
+    .RX_EN_HI_LR                        ( 1'b1),
+    .RX_EXT_RL_CTRL                     ( 9'b000000000),                        
+    .RX_RESLOAD_CTRL	                  ( 4'b0000),                             
+    .RX_RESLOAD_OVRD	                  ( 1'b0),                                
+    .RX_VREG_CTRL	                      ( 3'b101),                              
+    .RX_VREG_PDB	                      ( 1'b1),                                
+    .RX_XMODE_SEL	                      ( 1'b0),                                
+    .TAPDLY_SET_TX                      ( 2'b00),
+    .TEMPERATURE_PAR                    ( 4'b0010),
+    .TST_RSV0                           ( 8'b00000000),                                     
+    .TST_RSV1                           ( 8'b00000000),
+    .TX_DCC_LOOP_RST_CFG                (16'h0004),                             
+    .TX_DRVMUX_CTRL                     ( 2),                                   
+    .TX_PREDRV_CTRL                     ( 2),                                   
+    .TX_PMADATA_OPT                     ( 1'b0)    
+)                                                                                                   
+gthe4_channel_smsw_i                                                                                     
+(                                                                                                                                                                                                   
+    //----------------------------------------------------------------------------------------------
+    //  Clock Ports
+    //----------------------------------------------------------------------------------------------
+    .GTGREFCLK                          ( 1'd0),                                                     
+    .GTREFCLK0                          (GT_GTREFCLK0),                                            
+    .GTREFCLK1                          ( 1'd0),                                                    
+    .GTNORTHREFCLK0                     ( 1'd0),                                                    
+    .GTNORTHREFCLK1                     ( 1'd0),                                                    
+    .GTSOUTHREFCLK0                     ( 1'd0),                                                    
+    .GTSOUTHREFCLK1                     ( 1'd0),                                             
+    .TXUSRCLK                           (GT_TXUSRCLK),                                              
+    .RXUSRCLK                           (GT_RXUSRCLK),                                              
+    .TXUSRCLK2                          (GT_TXUSRCLK2),                                             
+    .RXUSRCLK2                          (GT_RXUSRCLK2),  
+    .TXPLLCLKSEL                        (PLLCLKSEL),            
+    .RXPLLCLKSEL                        (PLLCLKSEL),                                                    
+    .TXSYSCLKSEL                        (SYSCLKSEL),                                             
+    .RXSYSCLKSEL                        (SYSCLKSEL),                             
+    .TXOUTCLKSEL                        (GT_TXOUTCLKSEL),                                // Select TXPROGDIVCLK
+    .RXOUTCLKSEL                        ( 3'd2),                                // Select RXOUTCLKPMA
+    .CLKRSVD0                           ( 1'd0),          
+    .CLKRSVD1                           ( 1'd0),            
+                                                                                                   
+    .TXOUTCLK                           (GT_TXOUTCLK),                                             
+    .RXOUTCLK                           (GT_RXOUTCLK),                                                        
+    .TXOUTCLKFABRIC                     (GT_TXOUTCLKFABRIC),                                                        
+    .RXOUTCLKFABRIC                     (GT_RXOUTCLKFABRIC),                                                        
+    .TXOUTCLKPCS                        (GT_TXOUTCLKPCS),                                                        
+    .RXOUTCLKPCS                        (GT_RXOUTCLKPCS),  
+    .RXRECCLKOUT                        (GT_RXRECCLKOUT),                                                    
+    .GTREFCLKMONITOR                    (),                                 
+    
+    //----------------------------------------------------------------------------------------------
+    //  BUFG_GT Controller Ports
+    //----------------------------------------------------------------------------------------------
+    .BUFGTCE                            (GT_BUFGTCE),      
+    .BUFGTCEMASK                        (GT_BUFGTCEMASK), 
+    .BUFGTDIV                           (GT_BUFGTDIV), 
+    .BUFGTRESET                         (GT_BUFGTRESET), 
+    .BUFGTRSTMASK                       (GT_BUFGTRSTMASK),       
+    
+    //----------------------------------------------------------------------------------------------
+    //  CPLL Ports
+    //----------------------------------------------------------------------------------------------
+    .CPLLFREQLOCK                       (GT_MASTER_CPLLLOCK),                 
+    .CPLLLOCKDETCLK                     ( 1'd0),                              
+    .CPLLLOCKEN                         ( 1'd1),    
+    .CPLLPD                             (GT_CPLLPD),    
+    .CPLLREFCLKSEL                      ( 3'd1),                               
+    .CPLLRESET                          (GT_CPLLRESET),                               
+  
+    .CPLLFBCLKLOST                      (),     
+    .CPLLLOCK                           (GT_CPLLLOCK),                                            
+    .CPLLREFCLKLOST                     (),                    
+             
+    //----------------------------------------------------------------------------------------------
+    //  QPLL Ports                                                                                   
+    //----------------------------------------------------------------------------------------------
+    .QPLL0CLK                           (GT_QPLL0CLK),                           
+    .QPLL0REFCLK                        (GT_QPLL0REFCLK),                        
+    .QPLL0FREQLOCK                      (GT_QPLL0LOCK),                         
+    .QPLL1CLK                           (GT_QPLL1CLK),  
+    .QPLL1REFCLK                        (GT_QPLL1REFCLK),           
+    .QPLL1FREQLOCK                      (GT_QPLL1LOCK),                         
+    
+    //----------------------------------------------------------------------------------------------
+    //  Reset Ports
+    //----------------------------------------------------------------------------------------------                                                                                                                             
+    .GTTXRESET                          (GT_GTTXRESET),                                             
+    .GTRXRESET                          (GT_GTRXRESET),  
+    .GTRXRESETSEL                       ( 1'd0),                                
+    .GTTXRESETSEL                       ( 1'd0),                                
+    .TXPROGDIVRESET                     (GT_TXPROGDIVRESET),                       
+    .RXPROGDIVRESET                     ( 1'd0),                                                                            
+    .TXPMARESET                         (GT_TXPMARESET),                                            
+    .RXPMARESET                         (GT_RXPMARESET),                                            
+    .TXPCSRESET                         (GT_TXPCSRESET),   
+    .RXPCSRESET                         (GT_RXPCSRESET),   
+    .TXUSERRDY                          (GT_TXUSERRDY),                                             
+    .RXUSERRDY                          (GT_RXUSERRDY),   
+    .CFGRESET                           ( 1'd0),                                                    
+    .RESETOVRD                          (GT_RESETOVRD),  
+    .RXOOBRESET                         ( 1'd0),                                              
+                                           
+    .GTPOWERGOOD                        (GT_GTPOWERGOOD), 
+    .TXPRGDIVRESETDONE                  (GT_TXPROGDIVRESETDONE),
+    .RXPRGDIVRESETDONE                  (),        
+    .TXPMARESETDONE                     (GT_TXPMARESETDONE),    
+    .RXPMARESETDONE                     (GT_RXPMARESETDONE),                                                                                                      
+    .TXRESETDONE                        (GT_TXRESETDONE),                                           
+    .RXRESETDONE                        (GT_RXRESETDONE),  
+    .RESETEXCEPTION                     (),
+
+    //----------------------------------------------------------------------------------------------
+    //  PCIe Ports
+    //----------------------------------------------------------------------------------------------
+    .PCIERSTIDLE                        (GT_PCIERSTIDLE),        
+    .PCIERSTTXSYNCSTART                 (GT_PCIERSTTXSYNCSTART), 
+    .PCIEEQRXEQADAPTDONE                (GT_PCIEEQRXEQADAPTDONE),
+    .PCIEUSERRATEDONE                   (GT_PCIEUSERRATEDONE),
+             
+    .PCIEUSERPHYSTATUSRST               (GT_PCIEUSERPHYSTATUSRST),    
+    .PCIERATEQPLLPD                     (GT_PCIERATEQPLLPD),                    
+    .PCIERATEQPLLRESET                  (GT_PCIERATEQPLLRESET),                 
+    .PCIERATEIDLE                       (GT_PCIERATEIDLE),            
+    .PCIESYNCTXSYNCDONE                 (GT_PCIESYNCTXSYNCDONE),                          
+    .PCIERATEGEN3                       (pcierategen3),    
+    .PCIEUSERGEN3RDY                    (GT_PCIEUSERGEN3RDY),   
+    .PCIEUSERRATESTART                  (GT_PCIEUSERRATESTART),    
+           
+    //----------------------------------------------------------------------------------------------
+    //  Serial Line Ports
+    //----------------------------------------------------------------------------------------------
+    .GTHRXP                             (GT_RXP),                                                   
+    .GTHRXN                             (GT_RXN),   
+   
+    .GTHTXP                             (GT_TXP),                                                 
+    .GTHTXN                             (GT_TXN),   
+
+    //----------------------------------------------------------------------------------------------
+    //  TX Data Ports
+    //----------------------------------------------------------------------------------------------
+    .TXDATA                             (txdata),                                     
+    .TXCTRL0                            (txctrl0),
+    .TXCTRL1                            (txctrl1),  
+    .TXCTRL2                            (txctrl2),
+    .TXDATAEXTENDRSVD                   ( 8'd0),                                
+
+    //----------------------------------------------------------------------------------------------
+    //  RX Data Ports
+    //----------------------------------------------------------------------------------------------
+    .RXDATA                             (rxdata),                                                    
+    .RXCTRL0                            (rxctrl0),   
+    .RXCTRL1                            (), 
+    .RXCTRL2                            (),
+    .RXCTRL3                            (), 
+    .RXDATAEXTENDRSVD                   (),                                     
+ 
+    //----------------------------------------------------------------------------------------------
+    //  PHY Command Ports
+    //----------------------------------------------------------------------------------------------
+    .TXDETECTRX                         (GT_TXDETECTRX),                                            
+    .TXELECIDLE                         (GT_TXELECIDLE),                                      
+    .TXPDELECIDLEMODE                   ( 1'd0),                                                                                 
+    .RXELECIDLEMODE                     ( 2'd0),                                
+    .SIGVALIDCLK                        ( 1'd0),                                                                                    
+    .TXPOLARITY                         ( 1'd0),                                              
+    .RXPOLARITY                         (GT_RXPOLARITY),                                
+    .TXPD                               (GT_POWERDOWN),                                           
+    .RXPD                               (GT_POWERDOWN),                                           
+    .TXRATE                             ({1'd0, GT_RATE}),                                                
+    .RXRATE                             ({1'd0, GT_RATE}),                                                
+    .TXRATEMODE                         ( 1'd0),                                                    
+    .RXRATEMODE                         ( 1'd0),                                                    
+ 
+    //----------------------------------------------------------------------------------------------
+    //  PHY Status Ports
+    //----------------------------------------------------------------------------------------------
+    .RXVALID                            (GT_RXVALID),                                              
+    .PHYSTATUS                          (GT_PHYSTATUS),                                            
+    .RXELECIDLE                         (rxelecidle_int),                                           
+    .RXSTATUS                           (GT_RXSTATUS),                                             
+    .TXRATEDONE                         (),                                           
+    .RXRATEDONE                         (GT_RXRATEDONE),                  
+ 
+    //----------------------------------------------------------------------------------------------
+    //  TX Driver Ports
+    //----------------------------------------------------------------------------------------------
+    .TXMARGIN                           (GT_TXMARGIN),                                           
+    .TXSWING                            (GT_TXSWING),                                            
+    .TXDEEMPH                           (GT_TXDEEMPH),                                                                     
+    .TXDIFFCTRL                         (5'h14), //( 5'b11111), 
+    .TXINHIBIT                          ( 1'd0),                                                  
+
+    //----------------------------------------------------------------------------------------------
+    //  TX Driver Ports (Gen3)
+    //----------------------------------------------------------------------------------------------
+    .TXPRECURSOR                        (GT_TXPRECURSOR),                                          
+    .TXMAINCURSOR                       (GT_TXMAINCURSOR),                                         
+    .TXPOSTCURSOR                       (GT_TXPOSTCURSOR),                                                                                     
+
+    //----------------------------------------------------------------------------------------------
+    //  PCS Reserved Ports
+    //---------------------------------------------------------------------------------------------- 
+    .PCSRSVDIN                          (16'h0001),                             // CHECK                                                                               
+    .PCSRSVDOUT                         (pcsrsvdout),     
+    
+    //----------------------------------------------------------------------------------------------
+    //  RX Monitor Ports
+    //----------------------------------------------------------------------------------------------
+    .RXMONITORSEL                       ( 2'd0), 
+    .RXMONITOROUT                       (),                                                                                                                                                                                                            
+                                                                 
+    //----------------------------------------------------------------------------------------------
+    //  Comma Detect & Align Ports
+    //----------------------------------------------------------------------------------------------
+    .RXCOMMADETEN                       ( 1'd1),                  
+    .RXMCOMMAALIGNEN                    (!pcierategen3),          
+    .RXPCOMMAALIGNEN                    (!pcierategen3),          
+                                                                                 
+    .RXCOMMADET                         (),                                            
+    .RXBYTEISALIGNED                    (),                                        
+    .RXBYTEREALIGN                      (),                                                                                                                 
+                                                                                                    
+    //----------------------------------------------------------------------------------------------
+    // 8B10B Ports
+    //----------------------------------------------------------------------------------------------
+    .TX8B10BBYPASS                      ( 8'd0),                                                  
+    .TX8B10BEN                          (!pcierategen3),                            
+    .RX8B10BEN                          (!pcierategen3),                            
+           
+    //----------------------------------------------------------------------------------------------
+    //  TX Buffer Ports
+    //----------------------------------------------------------------------------------------------
+    .TXBUFSTATUS                        (),                                                        
+                                                                                                    
+    //----------------------------------------------------------------------------------------------
+    //  RX Buffer Ports
+    //----------------------------------------------------------------------------------------------
+    .RXBUFRESET                         (GT_RXBUFRESET),                                          
+    .RXBUFSTATUS                        (),                
+                      
+    //----------------------------------------------------------------------------------------------
+    //  Clock Correction Ports
+    //----------------------------------------------------------------------------------------------
+    .RXCLKCORCNT                        (),                            
+                    
+    //----------------------------------------------------------------------------------------------
+    //  Channel Bonding Ports (disable)
+    //----------------------------------------------------------------------------------------------
+    .RXCHBONDEN                         ( 1'd0),                                         
+    .RXCHBONDI                          ( 5'd0),                                         
+    .RXCHBONDLEVEL                      ( 3'd0),                                         
+    .RXCHBONDMASTER                     ( 1'd0),                                         
+    .RXCHBONDSLAVE                      ( 1'd0),                                         
+                                                                                    
+    .RXCHANBONDSEQ                      (),                                         
+    .RXCHANISALIGNED                    (),                                         
+    .RXCHANREALIGN                      (),                                         
+    .RXCHBONDO                          (),                                                                                                                                                                       
+ 
+    //----------------------------------------------------------------------------------------------
+    //  TX Phase Alignment Ports
+    //----------------------------------------------------------------------------------------------
+    .TXPHALIGN                          ( 1'd0),
+    .TXPHALIGNEN                        ( 1'd0),
+    .TXPHDLYPD                          ( 1'd0),
+    .TXPHDLYRESET                       ( 1'd0),
+    .TXPHDLYTSTCLK                      ( 1'd0),
+    .TXPHINIT                           ( 1'd0),
+    .TXPHOVRDEN                         ( 1'd0),
+   
+    .TXPHALIGNDONE                      (GT_TXPHALIGNDONE),
+    .TXPHINITDONE                       (),
+   
+    //----------------------------------------------------------------------------------------------
+    //  TX Delay Alignment Ports
+    //----------------------------------------------------------------------------------------------
+    .TXDLYBYPASS                        ( 1'd0),
+    .TXDLYEN                            ( 1'd0),
+    .TXDLYHOLD                          ( 1'd0),
+    .TXDLYOVRDEN                        ( 1'd0),
+    .TXDLYSRESET                        ( 1'd0),
+    .TXDLYUPDOWN                        ( 1'd0),
+       
+    .TXDLYSRESETDONE                    (),       
+          
+    //----------------------------------------------------------------------------------------------
+    //  TX Auto Sync Alignment Ports 
+    //----------------------------------------------------------------------------------------------
+    .TXSYNCALLIN                        (GT_TXSYNCALLIN),
+    .TXSYNCIN                           (GT_TXSYNCIN),
+    .TXSYNCMODE                         (MASTER_LANE),                                         
+                
+    .TXSYNCDONE                         (),
+    .TXSYNCOUT                          (GT_TXSYNCOUT),
+
+    //----------------------------------------------------------------------------------------------
+    //  RX Phase Alignment Ports (disable)
+    //----------------------------------------------------------------------------------------------
+    .RXPHALIGN                          ( 1'd0),
+    .RXPHALIGNEN                        ( 1'd0),
+    .RXPHDLYPD                          ( 1'd0),
+    .RXPHDLYRESET                       ( 1'd0),
+    .RXPHOVRDEN                         ( 1'd0),
+   
+    .RXPHALIGNDONE                      (),
+    .RXPHALIGNERR                       (),
+       
+    //----------------------------------------------------------------------------------------------
+    //  RX Delay Alignment Ports (disable)
+    //----------------------------------------------------------------------------------------------
+    .RXDLYBYPASS                        ( 1'd1),
+    .RXDLYEN                            ( 1'd0),
+    .RXDLYOVRDEN                        ( 1'd0),
+    .RXDLYSRESET                        ( 1'd0),
+   
+    .RXDLYSRESETDONE                    (),                                           
+        
+    //----------------------------------------------------------------------------------------------
+    //  RX Auto Sync Alignment Ports (disable)
+    //----------------------------------------------------------------------------------------------
+    .RXSYNCALLIN                        ( 1'd0),
+    .RXSYNCIN                           ( 1'd0),
+    .RXSYNCMODE                         ( 1'd0),                                                    
+                                                                                                    
+    .RXSYNCDONE                         (),                                                
+    .RXSYNCOUT                          (),    
+       
+    //----------------------------------------------------------------------------------------------
+    //  Gearbox Ports 
+    //----------------------------------------------------------------------------------------------
+    .TXHEADER                           ( 6'd0), 
+    .TXLATCLK                           ( 1'd0),                                                    
+    .TXSEQUENCE                         ( 7'd0),                                                    
+    .RXGEARBOXSLIP                      ( 1'd0),  
+    .RXLATCLK                           ( 1'd0),  
+    .RXSLIDE                            ( 1'd0),                                                    
+                                                                                                    
+    .RXDATAVALID                        (),                 
+    .RXHEADER                           (),                                                         
+    .RXHEADERVALID                      (), 
+    .RXSLIDERDY                         (),                                                         
+    .RXSTARTOFSEQ                       (),                             
+                   
+    //----------------------------------------------------------------------------------------------
+    //  RX Slip Ports 
+    //----------------------------------------------------------------------------------------------
+    .RXSLIPOUTCLK                       ( 1'd0),
+    .RXSLIPPMA                          ( 1'd0),   
+                                                                   
+    .RXSLIPDONE                         (),     
+    .RXSLIPOUTCLKRDY                    (),
+    .RXSLIPPMARDY                       (),             
+       
+    //----------------------------------------------------------------------------------------------
+    //  RX LPM Ports 
+    //----------------------------------------------------------------------------------------------
+    .RXLPMEN                            (!pcierategen3),    
+    .RXLPMGCHOLD                        ( 1'b0),            
+    .RXLPMGCOVRDEN                      ( 1'b0),
+    .RXLPMHFHOLD                        ( 1'b0),            
+    .RXLPMHFOVRDEN                      ( 1'b0),
+    .RXLPMLFHOLD                        ( 1'b0),         
+    .RXLPMLFKLOVRDEN                    ( 1'b0), 
+    .RXLPMOSHOLD                        ( 1'b0),            
+    .RXLPMOSOVRDEN                      ( 1'b0),
+                                                                                                    
+    //----------------------------------------------------------------------------------------------
+    //  RX DFE Ports
+    //----------------------------------------------------------------------------------------------
+    .RXDFEAGCCTRL                       ( 2'h1), //( 2'b00),   
+    .RXDFEAGCHOLD                       ( 1'b0),            
+    .RXDFEAGCOVRDEN                     ( 1'b0),
+    .RXDFECFOKFCNUM                     ( 4'b0000),                             
+    .RXDFECFOKFEN                       ( 1'b0),                                
+    .RXDFECFOKFPULSE                    ( 1'b0),                                
+    .RXDFECFOKHOLD                      ( 1'b0),                                
+    .RXDFECFOKOVREN                     ( 1'b0),                                
+    .RXDFEKHHOLD                        ( 1'b0),
+    .RXDFEKHOVRDEN                      ( 1'b0),
+    .RXDFELFHOLD                        ( 1'b0),          
+    .RXDFELFOVRDEN                      ( 1'b0),
+    .RXDFELPMRESET                      (GT_RXDFELPMRESET),
+    .RXDFETAP2HOLD                      ( 1'b0),
+    .RXDFETAP2OVRDEN                    ( 1'b0),
+    .RXDFETAP3HOLD                      ( 1'b0),
+    .RXDFETAP3OVRDEN                    ( 1'b0),
+    .RXDFETAP4HOLD                      ( 1'b0),
+    .RXDFETAP4OVRDEN                    ( 1'b0),
+    .RXDFETAP5HOLD                      ( 1'b0),
+    .RXDFETAP5OVRDEN                    ( 1'b0),
+    .RXDFETAP6HOLD                      ( 1'b0),
+    .RXDFETAP6OVRDEN                    ( 1'b0),
+    .RXDFETAP7HOLD                      ( 1'b0),
+    .RXDFETAP7OVRDEN                    ( 1'b0),
+    .RXDFETAP8HOLD                      ( 1'b0),
+    .RXDFETAP8OVRDEN                    ( 1'b0),
+    .RXDFETAP9HOLD                      ( 1'b0),
+    .RXDFETAP9OVRDEN                    ( 1'b0),
+    .RXDFETAP10HOLD                     ( 1'b0),
+    .RXDFETAP10OVRDEN                   ( 1'b0),
+    .RXDFETAP11HOLD                     ( 1'b0),
+    .RXDFETAP11OVRDEN                   ( 1'b0),
+    .RXDFETAP12HOLD                     ( 1'b0),
+    .RXDFETAP12OVRDEN                   ( 1'b0),
+    .RXDFETAP13HOLD                     ( 1'b0),
+    .RXDFETAP13OVRDEN                   ( 1'b0),
+    .RXDFETAP14HOLD                     ( 1'b0),
+    .RXDFETAP14OVRDEN                   ( 1'b0),
+    .RXDFETAP15HOLD                     ( 1'b0),
+    .RXDFETAP15OVRDEN                   ( 1'b0),
+    .RXDFEUTHOLD                        ( 1'b0),
+    .RXDFEUTOVRDEN                      ( 1'b0),
+    .RXDFEVPHOLD                        ( 1'b0),
+    .RXDFEVPOVRDEN                      ( 1'b0),
+    .RXDFEXYDEN                         ( 1'b1),                                                                                                    
+    
+    //----------------------------------------------------------------------------------------------
+    //  TX PI Ports
+    //----------------------------------------------------------------------------------------------
+    .TXPIPPMEN                          ( 1'd0),
+    .TXPIPPMOVRDEN                      ( 1'd0),
+    .TXPIPPMPD                          ( 1'd0),
+    .TXPIPPMSEL                         ( 1'd0),
+    .TXPIPPMSTEPSIZE                    ( 5'd0),
+    .TXPISOPD                           ( 1'd0),   
+    
+    //----------------------------------------------------------------------------------------------
+    //  RX CDR Ports
+    //----------------------------------------------------------------------------------------------
+    .CDRSTEPDIR                         ( 1'b0),                                 
+    .CDRSTEPSQ                          ( 1'b0),                                
+    .CDRSTEPSX                          ( 1'b0),                               
+    .RXCDRFREQRESET                     (GT_RXCDRFREQRESET),   //*****
+    .RXCDRHOLD                          (GT_RXCDRHOLD),
+    .RXCDROVRDEN                        ( 1'd0),
+    .RXCDRRESET                         (rxcdrreset_int),
+    
+    .RXCDRLOCK                          (GT_RXCDRLOCK),    
+    .RXCDRPHDONE                        (), 
+       
+    //----------------------------------------------------------------------------------------------
+    //  Eye Scan Ports
+    //----------------------------------------------------------------------------------------------                                          
+    .EYESCANRESET                       ( 1'd0),                                             
+    .EYESCANTRIGGER                     ( 1'd0),                                             
+                                                                                            
+    .EYESCANDATAERROR                   (),           
+       
+    //----------------------------------------------------------------------------------------------
+    //  RX OS Ports
+    //----------------------------------------------------------------------------------------------
+    .RXOSCALRESET                       ( 1'b0),
+    .RXOSHOLD                           ( 1'b0),
+    .RXOSOVRDEN                         ( 1'b0),    
+ 
+    .RXOSINTDONE                        (),                                                         
+    .RXOSINTSTARTED                     (),                                                         
+    .RXOSINTSTROBEDONE                  (),                                                         
+    .RXOSINTSTROBESTARTED               (),         
+           
+    //----------------------------------------------------------------------------------------------
+    //  DRP Ports
+    //----------------------------------------------------------------------------------------------
+    .DRPCLK                             (GT_DRPCLK), 
+    .DRPRST                             ( 1'd0),                                                                                
+    .DRPADDR                            (GT_DRPADDR),                                                    
+    .DRPEN                              (GT_DRPEN),                                                    
+    .DRPWE                              (GT_DRPWE), 
+    .DRPDI                              (GT_DRPDI),                                                    
+        
+    .DRPRDY                             (GT_DRPRDY),                                                         
+    .DRPDO                              (GT_DRPDO),                      
+ 
+    //----------------------------------------------------------------------------------------------
+    //  Loopback & PRBS Ports
+    //----------------------------------------------------------------------------------------------
+    .LOOPBACK                           (GT_LOOPBACK),      
+    .TXPRBSSEL                          (GT_PRBSSEL),                                                    
+    .RXPRBSSEL                          (GT_PRBSSEL),  
+    .TXPRBSFORCEERR                     (GT_TXPRBSFORCEERR),  
+    .RXPRBSCNTRESET                     (GT_RXPRBSCNTRESET),  
+                   
+    .RXPRBSERR                          (GT_RXPRBSERR),                                                
+    .RXPRBSLOCKED                       (GT_RXPRBSLOCKED),       
+
+    //----------------------------------------------------------------------------------------------
+    //  Digital Monitor Ports                                                                             
+    //----------------------------------------------------------------------------------------------
+    .DMONFIFORESET                      ( 1'd0),                                                    
+    .DMONITORCLK                        ( 1'd0),                                                    
+    
+    .DMONITOROUT                        (),    
+    .DMONITOROUTCLK                     (),                                             
+      
+    //----------------------------------------------------------------------------------------------
+    //  USB Ports
+    //----------------------------------------------------------------------------------------------
+    .TXONESZEROS                        (GT_TXONESZEROS),
+    .RXEQTRAINING                       (GT_RXEQTRAINING),
+    .RXTERMINATION                      (GT_RXTERMINATION),    
+    
+    .POWERPRESENT                       (GT_POWERPRESENT),           
+        
+    //----------------------------------------------------------------------------------------------
+    //  USB LFPS Ports
+    //----------------------------------------------------------------------------------------------
+    .TXLFPSTRESET                       ( 1'b0),      
+    .TXLFPSU2LPEXIT                     ( 1'b0),
+    .TXLFPSU3WAKE                       ( 1'b0),
+    
+    .RXLFPSTRESETDET                    (),             
+    .RXLFPSU2LPEXITDET                  (),             
+    .RXLFPSU3WAKEDET                    (),            
+      
+    //----------------------------------------------------------------------------------------------
+    //  SATA Ports 
+    //----------------------------------------------------------------------------------------------
+    .TXCOMINIT                          ( 1'd0),                                                    
+    .TXCOMSAS                           ( 1'd0),                                                    
+    .TXCOMWAKE                          ( 1'd0),                                                    
+
+    .TXCOMFINISH                        (),                                                         
+    .RXCOMINITDET                       (),                                                         
+    .RXCOMSASDET                        (),                                                         
+    .RXCOMWAKEDET                       (),                                                    
+
+    //----------------------------------------------------------------------------------------------
+    //  QPI
+    //----------------------------------------------------------------------------------------------
+    .RXQPIEN                            ( 1'd0),
+    .TXQPIBIASEN                        ( 1'b0),                                
+    .TXQPIWEAKPUP                       ( 1'b0),                              
+    
+    .RXQPISENN                          (),
+    .RXQPISENP                          (),
+    .TXQPISENN                          (),
+    .TXQPISENP                          (),
+
+    //----------------------------------------------------------------------------------------------
+    //  GT Ports
+    //----------------------------------------------------------------------------------------------
+    .FREQOS                             ( 1'd0),    
+    .GTRSVD                             (16'd0),
+    .INCPCTRL                           ( 1'd0),
+    .RXAFECFOKEN                        ( 1'd0),                                
+    .RXCKCALRESET                       ( 1'b0),                                
+    .RXCKCALSTART                       ( 7'd0),                                
+    .TSTIN                              (20'h00000),                                                
+    .TXDCCFORCESTART                    ( 1'b0),                                
+    .TXDCCRESET                         ( 1'b0),                                
+    .TXMUXDCDEXHOLD                     ( 1'b0),                                
+    .TXMUXDCDORWREN                     ( 1'b0),                                
+                                                                                   
+    .PINRSRVDAS                         (),                                     
+    .RXCKCALDONE                        (),                                     
+    .TXDCCDONE                          ()                                      
+);
+
+end
+endgenerate
+
+
+//--------------------------------------------------------------------------------------------------
+//  Input Port Remapping
+//--------------------------------------------------------------------------------------------------    
+assign txdata[ 63: 0] = GT_TXDATA;
+assign txdata[127:64] = 64'd0;
+
+assign txctrl0[ 1:0] = 2'd0;
+assign txctrl0[   2] = GT_TXDATA_VALID;
+assign txctrl0[   3] = GT_TXSTART_BLOCK;
+assign txctrl0[ 5:4] = GT_TXSYNC_HEADER;
+assign txctrl0[15:6] = 10'd0;
+
+assign txctrl1[   0] = GT_TXCOMPLIANCE;
+assign txctrl1[15:1] = 15'd0;
+
+assign txctrl2[ 1:0] = GT_TXDATAK;
+assign txctrl2[ 7:2] = 6'd0;
+
+
+
+//--------------------------------------------------------------------------------------------------
+//  GT Channel Outputs
+//--------------------------------------------------------------------------------------------------
+assign GT_RXDATA         = rxdata[63:0];
+
+assign GT_RXDATAK        = rxctrl0[1:0];
+assign GT_RXDATA_VALID   = rxctrl0[2];
+assign GT_RXSTART_BLOCK  = {rxctrl0[6], rxctrl0[3]};
+assign GT_RXSYNC_HEADER  = rxctrl0[5:4];
+assign GT_GEN34_EIOS_DET = rxctrl0[7]; 
+
+assign GT_PCIERATEGEN3   = pcierategen3;
+assign GT_QPLLRATE       = pcsrsvdout[2:0];
+
+assign GT_RXELECIDLE = rxelecidle_int;
+
+
+endmodule
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2023 AMD, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD, Inc. and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : UltraScale+ FPGA PCI Express v4.0 Integrated Block
+// File       : xp4_usp_smsw_gt_gt_common.v
+// Version    : 1.1 
+//-----------------------------------------------------------------------------
+//--------------------------------------------------------------------------------------------------
+//  Design :  PHY Wrapper
+//  Module :  GT Common
+//--------------------------------------------------------------------------------------------------
+
+`timescale 1ps / 1ps
+
+//--------------------------------------------------------------------------------------------------
+//  GT Common Module
+//--------------------------------------------------------------------------------------------------
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_gt_gt_common #
+(
+    parameter         PHY_SIM_EN      = "FALSE",
+    parameter         PHY_GT_XCVR     = "GTY",
+    parameter integer PHY_MAX_SPEED   = 4,
+    parameter integer PHY_REFCLK_FREQ = 0    
+)
+(    
+    //----------------------------------------------------------------------------------------------
+    //  Clock Ports
+    //----------------------------------------------------------------------------------------------
+    input                               GTCOM_REFCLK,
+    
+    output                              GTCOM_QPLL0OUTCLK,
+    output                              GTCOM_QPLL0OUTREFCLK,
+    output                              GTCOM_QPLL0LOCK,
+    
+    output                              GTCOM_QPLL1OUTCLK,
+    output                              GTCOM_QPLL1OUTREFCLK,
+    output                              GTCOM_QPLL1LOCK,
+    
+    //----------------------------------------------------------------------------------------------
+    //  Reset Ports
+    //----------------------------------------------------------------------------------------------
+    input                               GTCOM_QPLL0PD,
+    input                               GTCOM_QPLL0RESET, 
+ 
+    input                               GTCOM_QPLL1PD,
+    input                               GTCOM_QPLL1RESET,
+            
+    //----------------------------------------------------------------------------------------------
+    //  PCIe Ports
+    //----------------------------------------------------------------------------------------------
+    input       [ 2:0]                  GTCOM_QPLLRATE,
+    
+    //----------------------------------------------------------------------------------------------
+    //  DRP Ports
+    //----------------------------------------------------------------------------------------------
+    input                               GTCOM_DRPCLK,                                        
+    input       [15:0]                  GTCOM_DRPADDR,                                       
+    input                               GTCOM_DRPEN,                                             
+    input                               GTCOM_DRPWE,     
+    input       [15:0]                  GTCOM_DRPDI,                                      
+                                                                
+    output                              GTCOM_DRPRDY,    
+    output      [15:0]                  GTCOM_DRPDO
+);                                                      
+    
+    //----------------------------------------------------------------------------------------------
+    //  QPLL[0/1]_FBDIV - QPLL Feedback (N) Divider (Gen1/Gen2)
+    //----------------------------------------------------------------------------------------------
+    localparam [ 7:0] QPLL_FBDIV = (PHY_REFCLK_FREQ == 2) ? 8'd40 : 
+                                   (PHY_REFCLK_FREQ == 1) ? 8'd80 : 8'd100;
+    
+    
+    
+    //----------------------------------------------------------------------------------------------
+    //  QPLL[1/0]_FBDIV_G34 - QPLL Feedback (N) Divider (Gen3/Gen4)
+    //----------------------------------------------------------------------------------------------    
+    localparam [ 7:0] QPLL_FBDIV_G3 = (PHY_REFCLK_FREQ == 2) ? 8'd32  : 
+                                      (PHY_REFCLK_FREQ == 1) ? 8'd64  : 8'd80;
+    
+    localparam [ 7:0] QPLL_FBDIV_G4 = (PHY_REFCLK_FREQ == 2) ? 8'd64  : 
+                                      (PHY_REFCLK_FREQ == 1) ? 8'd128 : 8'd160;
+    
+    localparam [ 7:0] QPLL_FBDIV_G34 = (PHY_MAX_SPEED == 4) ? QPLL_FBDIV_G4 : QPLL_FBDIV_G3;
+
+
+
+    //----------------------------------------------------------------------------------------------
+    //  QPLL[1/0]_CFG2_G3 - QPLL Configuration (Gen3 and Gen4)
+    //    [6] : 1'b0 = Select upper band VCO
+    //        : 1'b1 = Select lower band VCO
+    //----------------------------------------------------------------------------------------------  
+    localparam [15:0] QPLL_CFG2_G3 = (PHY_MAX_SPEED == 4) ? 16'h0000 : 16'h0040;
+
+
+
+//--------------------------------------------------------------------------------------------------
+//  GTY Common
+//--------------------------------------------------------------------------------------------------    
+
+generate
+  if (PHY_GT_XCVR == "GTY" || PHY_GT_XCVR == "GTY64") begin: GTY_CHANNEL
+//--------------------------------------------------------------------------------------------------
+//  GTY Common
+//--------------------------------------------------------------------------------------------------
+GTYE4_COMMON #
+(   
+    //---------------------------------------------------------------------------------------------- 
+    //  Simulation Attributes
+    //----------------------------------------------------------------------------------------------      
+    .SIM_MODE                           ("FAST"),                                                                                                                                                                                      
+    .SIM_RESET_SPEEDUP                  ("TRUE"),                                                                                              
+    //.SIM_VERSION                        (1),                                                                          
+
+    //----------------------------------------------------------------------------------------------               
+    //  Clock Attributes
+    //----------------------------------------------------------------------------------------------    
+    .RXRECCLKOUT0_SEL                   ( 2'b00),
+    .RXRECCLKOUT1_SEL                   ( 2'b00),                    
+
+    //----------------------------------------------------------------------------------------------
+    //  QPLL0 Attributes 
+    //----------------------------------------------------------------------------------------------    
+    .AEN_QPLL0_FBDIV                    (1'b1),                                 
+    .QPLL0CLKOUT_RATE                   ("HALF"),                              
+    .QPLL0_CFG0                         (16'h001D),                             
+    .QPLL0_CFG1                         (16'h0000),                             
+    .QPLL0_CFG1_G3                      (16'h0000),                             
+    .QPLL0_CFG2                         (16'h0040),                             
+    .QPLL0_CFG2_G3                      (QPLL_CFG2_G3),                        
+    .QPLL0_CFG3                         (16'h0120),                  
+    .QPLL0_CFG4                         (16'h0000),
+    .QPLL0_CP                           (10'b0000011111),                       // Optimized for PCIe PLL compliance
+    .QPLL0_CP_G3                        (10'b0000011111),                       // Optimized for PCIe PLL compliance
+    .QPLL0_FBDIV                        (QPLL_FBDIV),
+    .QPLL0_FBDIV_G3                     (QPLL_FBDIV_G34),
+    .QPLL0_INIT_CFG0                    (16'b0000000000000000),
+    .QPLL0_INIT_CFG1                    ( 8'b00000000),
+    .QPLL0_LOCK_CFG                     (16'h05FC),                             // [10] : 1'b1 = Auto VCO
+    .QPLL0_LOCK_CFG_G3                  (16'h05FC),                             // [10] : 1'b1 = Auto VCO
+    .QPLL0_LPF                          (10'b0000010101),                       // Optimized for PCIe PLL compliance
+    .QPLL0_LPF_G3                       (10'b0000010101),                       // Optimized for PCIe PLL compliance
+    .QPLL0_PCI_EN                       ( 1'b1),                                
+    .QPLL0_RATE_SW_USE_DRP              ( 1'b0),                                // Advance PCIe feature
+    .QPLL0_REFCLK_DIV                   (1),
+    .QPLL0_SDM_CFG0                     (16'b0000000011000000),                
+    .QPLL0_SDM_CFG1                     (16'b0000000000000000),
+    .QPLL0_SDM_CFG2                     (16'b0000000000000000),
+                     
+    //---------------------------------------------------------------------------------------------- 
+    //  QPLL1 Attributes               
+    //----------------------------------------------------------------------------------------------    
+    .AEN_QPLL1_FBDIV                    (1'b1),                                 
+    .QPLL1CLKOUT_RATE                   ("HALF"),                              
+    .QPLL1_CFG0                         (16'h001D),                             
+    .QPLL1_CFG1                         (16'h0000),                             
+    .QPLL1_CFG1_G3                      (16'h0000),                             
+    .QPLL1_CFG2                         (16'h0040),                             
+    .QPLL1_CFG2_G3                      (QPLL_CFG2_G3),                         
+    .QPLL1_CFG3                         (16'h0120),                  
+    .QPLL1_CFG4                         (16'h0000),
+    .QPLL1_CP                           (10'b0000011111),                       // Optimized for PCIe PLL compliance
+    .QPLL1_CP_G3                        (10'b0000011111),                       // Optimized for PCIe PLL compliance
+    .QPLL1_FBDIV                        (QPLL_FBDIV),
+    .QPLL1_FBDIV_G3                     (QPLL_FBDIV_G34),
+    .QPLL1_INIT_CFG0                    (16'b0000000000000000),
+    .QPLL1_INIT_CFG1                    ( 8'b00000000),
+    .QPLL1_LOCK_CFG                     (16'h05FC),                             // [10] : 1'b1 = Auto VCO
+    .QPLL1_LOCK_CFG_G3                  (16'h05FC),                             // [10] : 1'b1 = Auto VCO
+    .QPLL1_LPF                          (10'b0000010101),                       // Optimized for PCIe PLL compliance
+    .QPLL1_LPF_G3                       (10'b0000010101),                       // Optimized for PCIe PLL compliance
+    .QPLL1_PCI_EN                       ( 1'b1),                               
+    .QPLL1_RATE_SW_USE_DRP              ( 1'b0),                                // Advance PCIe feature
+    .QPLL1_REFCLK_DIV                   (1),
+    .QPLL1_SDM_CFG0                     (16'b0000000011000000),                 
+    .QPLL1_SDM_CFG1                     (16'b0000000000000000),
+    .QPLL1_SDM_CFG2                     (16'b0000000000000000),
+ 
+    //----------------------------------------------------------------------------------------------
+    //  PPF Attributes                                                         
+    //----------------------------------------------------------------------------------------------      
+    .PPF0_CFG                           (16'h0FFF),                            
+    .PPF1_CFG                           (16'h0FFF),                           
+    
+    //----------------------------------------------------------------------------------------------
+    //  Bias Attributes                                                          
+    //----------------------------------------------------------------------------------------------
+    .BIAS_CFG0                          (16'b0000000000000000),
+    .BIAS_CFG1                          (16'b0000000000000000),
+    .BIAS_CFG2                          (16'b0011000000000000),                 // Optimized for PCIe PLL compliance
+    .BIAS_CFG3                          (16'b0000000001000000),                 
+    .BIAS_CFG4                          (16'b0000000000000000),    
+    .BIAS_CFG_RSVD                      (10'b0000000000),  
+       
+    //---------------------------------------------------------------------------------------------- 
+    //  SDM0 Attributes                                                          
+    //----------------------------------------------------------------------------------------------
+    .A_SDM0TOGGLE                       ( 1'b0),
+    .AEN_SDM0TOGGLE                     ( 1'b0),
+    .SDM0INITSEED0_0                    (16'b0000000000000000),
+    .SDM0INITSEED0_1                    ( 9'b000000000),
+    
+    //---------------------------------------------------------------------------------------------- 
+    //  SDM1 Attributes                                                          
+    //----------------------------------------------------------------------------------------------     
+    .A_SDM1DATA_HIGH                    ( 9'b000000000),
+    .A_SDM1DATA_LOW                     (16'b0000000000000000),
+    .A_SDM1TOGGLE                       ( 1'b0),
+    .AEN_SDM1TOGGLE                     ( 1'b0),
+    .SDM1INITSEED0_0                    (16'b0000000000000000),
+    .SDM1INITSEED0_1                    ( 9'b000000000),     
+          
+    //----------------------------------------------------------------------------------------------
+    //  Reserved & MISC Attributes                                                         
+    //----------------------------------------------------------------------------------------------            
+    .COMMON_CFG0                        (16'b0000000000000000),
+    .COMMON_CFG1                        (16'b0000000000000000),
+    .POR_CFG                            (16'b0000000000001011),                 // CHECK      
+    .RSVD_ATTR0                         (16'b0000000000000001),                 // CHECK
+    .RSVD_ATTR1                         (16'b0000000000000000),    
+    .RSVD_ATTR2                         (16'b0000000000000001),                 // CHECK                
+    .RSVD_ATTR3                         (16'b0000000000000000),
+    .SARC_ENB                           ( 1'b0),
+    .SARC_SEL                           ( 1'b0),
+
+    //----------------------------------------------------------------------------------------------
+    //  MicroBlaze Attributes                                                         
+    //----------------------------------------------------------------------------------------------
+    .UB_CFG0                            (16'h0),
+    .UB_CFG1                            (16'h0),
+    .UB_CFG2                            (16'h0),
+    .UB_CFG3                            (16'h0),
+    .UB_CFG4                            (16'h0),
+    .UB_CFG5                            (16'h0),
+    .UB_CFG6                            (16'h0)
+)
+gtye4_common_smsw_i 
+(       
+    //----------------------------------------------------------------------------------------------
+    //  QPLL0 Clock Ports
+    //----------------------------------------------------------------------------------------------
+    .GTGREFCLK0                         ( 1'd0), 
+    .GTREFCLK00                         (GTCOM_REFCLK),                         
+    .GTREFCLK10                         ( 1'd0),
+    .GTNORTHREFCLK00                    ( 1'd0),
+    .GTNORTHREFCLK10                    ( 1'd0),
+    .GTSOUTHREFCLK00                    ( 1'd0),
+    .GTSOUTHREFCLK10                    ( 1'd0),
+   
+    .REFCLKOUTMONITOR0                  (),
+    .RXRECCLK0SEL                       (),
+    
+    //----------------------------------------------------------------------------------------------
+    //  QPLL1 Clock Ports
+    //----------------------------------------------------------------------------------------------
+    .GTGREFCLK1                         ( 1'd0),
+    .GTREFCLK01                         (GTCOM_REFCLK),
+    .GTREFCLK11                         ( 1'd0),
+    .GTNORTHREFCLK01                    ( 1'd0),    
+    .GTNORTHREFCLK11                    ( 1'd0),
+    .GTSOUTHREFCLK01                    ( 1'd0),
+    .GTSOUTHREFCLK11                    ( 1'd0),        
+        
+    .REFCLKOUTMONITOR1                  (),  
+    .RXRECCLK1SEL	                      (), 
+        
+    //----------------------------------------------------------------------------------------------
+    //  QPLL0 Ports
+    //----------------------------------------------------------------------------------------------
+    .QPLL0CLKRSVD0                      ( 1'd0),
+    .QPLL0CLKRSVD1                      ( 1'd0),                              
+    .QPLL0FBDIV                         ( 8'd0),                                // CHECK
+    .QPLL0LOCKDETCLK                    ( 1'd0),
+    .QPLL0LOCKEN                        ( 1'd1),
+    .QPLL0PD                            (GTCOM_QPLL0PD),                        
+    .QPLL0REFCLKSEL                     ( 3'd1),                                                          
+    .QPLL0RESET                         (GTCOM_QPLL0RESET),                     
+       
+    .QPLL0FBCLKLOST                     (),
+    .QPLL0LOCK                          (GTCOM_QPLL0LOCK),
+    .QPLL0OUTCLK                        (GTCOM_QPLL0OUTCLK),
+    .QPLL0OUTREFCLK                     (GTCOM_QPLL0OUTREFCLK),
+    .QPLL0REFCLKLOST                    (),     
+    .QPLLDMONITOR0                      (),                                                                      
+                                               
+    //----------------------------------------------------------------------------------------------
+    //  QPLL1 Ports
+    //----------------------------------------------------------------------------------------------
+    .QPLL1CLKRSVD0                      ( 1'd0),
+    .QPLL1CLKRSVD1                      ( 1'd0),                                
+    .QPLL1FBDIV                         ( 8'd0),                                // CHECK
+    .QPLL1LOCKDETCLK                    ( 1'd0),
+    .QPLL1LOCKEN                        ( 1'd1),
+    .QPLL1PD                            (GTCOM_QPLL1PD),
+    .QPLL1REFCLKSEL                     ( 3'd1),                        
+    .QPLL1RESET                         (GTCOM_QPLL1RESET),      
+     
+    .QPLL1FBCLKLOST                     (),  
+    .QPLL1LOCK                          (GTCOM_QPLL1LOCK),       
+    .QPLL1OUTCLK                        (GTCOM_QPLL1OUTCLK),     
+    .QPLL1OUTREFCLK                     (GTCOM_QPLL1OUTREFCLK),                       
+    .QPLL1REFCLKLOST                    (),  
+    .QPLLDMONITOR1                      (),            
+         
+    //----------------------------------------------------------------------------------------------
+    //  PCIe Ports
+    //----------------------------------------------------------------------------------------------
+    .PCIERATEQPLL0                      (GTCOM_QPLLRATE),           
+    .PCIERATEQPLL1                      (GTCOM_QPLLRATE),       
+                                                                                                       
+    //----------------------------------------------------------------------------------------------
+    //  DRP Ports
+    //----------------------------------------------------------------------------------------------
+    .DRPCLK                             (GTCOM_DRPCLK),                                        
+    .DRPADDR                            (GTCOM_DRPADDR),                                       
+    .DRPEN                              (GTCOM_DRPEN),                                             
+    .DRPWE                              (GTCOM_DRPWE),     
+    .DRPDI                              (GTCOM_DRPDI),                                      
+                                                                         
+    .DRPRDY                             (GTCOM_DRPRDY),    
+    .DRPDO                              (GTCOM_DRPDO),                                      
+        
+    //----------------------------------------------------------------------------------------------
+    //  rCal Ports
+    //----------------------------------------------------------------------------------------------        
+    .RCALENB                            ( 1'd1),          
+                                                                                                        
+    //----------------------------------------------------------------------------------------------
+    //  Band Gap Ports
+    //----------------------------------------------------------------------------------------------
+    .BGBYPASSB                          ( 1'b1),                                
+    .BGMONITORENB                       ( 1'b1),                                
+    .BGPDB                              ( 1'b1),  
+    .BGRCALOVRD                         ( 5'b11111),                                 
+    .BGRCALOVRDENB                      ( 1'b1),                                                            
+        
+    //----------------------------------------------------------------------------------------------
+    //  SDM0 Ports
+    //----------------------------------------------------------------------------------------------
+    .SDM0DATA                           (25'd0),
+    .SDM0RESET                          ( 1'd0),
+    .SDM0TOGGLE                         ( 1'd0), 
+    .SDM0WIDTH                          ( 2'd0),
+    
+    .SDM0FINALOUT                       (),
+    .SDM0TESTDATA                       (),
+
+    //----------------------------------------------------------------------------------------------
+    //  SDM1 Ports
+    //----------------------------------------------------------------------------------------------
+    .SDM1DATA                           (25'd0),
+    .SDM1RESET                          ( 1'd0),
+    .SDM1TOGGLE                         ( 1'd0), 
+    .SDM1WIDTH                          ( 2'd0),
+    
+    .SDM1FINALOUT                       (),
+    .SDM1TESTDATA                       (),
+
+    //----------------------------------------------------------------------------------------------
+    //  TCON Ports
+    //----------------------------------------------------------------------------------------------
+    //.TCONGPI                            (10'd0),
+    //.TCONPOWERUP                        ( 1'd0),
+    //.TCONRESET                          ( 2'd0),
+    //.TCONRSVDIN1                        ( 2'd0),
+    
+    //.TCONGPO                            (),
+    //.TCONRSVDOUT0                       (),
+
+    //----------------------------------------------------------------------------------------------
+    //  Reserved & MISC Ports
+    //----------------------------------------------------------------------------------------------
+    .PMARSVD0                           ( 8'd0),            
+    .PMARSVD1                           ( 8'd0),  
+    .QPLLRSVD1                          ( 8'd0),
+    .QPLLRSVD2                          ( 5'd0),               
+    .QPLLRSVD3                          ( 5'd0),          
+    .QPLLRSVD4                          ( 8'd0),                   
+
+    .PMARSVDOUT0                        (),
+    .PMARSVDOUT1                        (),
+
+    //----------------------------------------------------------------------------------------------
+    //  MicroBlaze Ports
+    //----------------------------------------------------------------------------------------------
+    .UBCFGSTREAMEN                      ( 1'b0),
+    .UBDO                               ( 16'h0),
+    .UBDRDY                             ( 1'b0),
+    .UBENABLE                           ( 1'b0),
+    .UBGPI                              ( 2'b0),
+    .UBINTR                             ( 2'b0),
+    .UBIOLMBRST                         ( 1'b0),
+    .UBMBRST                            ( 1'b0),
+    .UBMDMCAPTURE                       ( 1'b0),
+    .UBMDMDBGRST                        ( 1'b0),
+    .UBMDMDBGUPDATE                     ( 1'b0),
+    .UBMDMREGEN                         ( 4'b0),
+    .UBMDMSHIFT                         ( 1'b0),
+    .UBMDMSYSRST                        ( 1'b0),
+    .UBMDMTCK                           ( 1'b0),
+    .UBMDMTDI                           ( 1'b0),
+
+    .UBDADDR                            (),
+    .UBDEN                              (),
+    .UBDI                               (),
+    .UBDWE                              (),
+    .UBMDMTDO                           (),
+    .UBRSVDOUT                          (),
+    .UBTXUART                           ()
+
+);
+
+end else begin: GTH_COMMON
+GTHE4_COMMON #
+(   
+    //---------------------------------------------------------------------------------------------- 
+    //  Simulation Attributes
+    //----------------------------------------------------------------------------------------------      
+    .SIM_MODE                           ("FAST"),                                                                                                                                                                                      
+    .SIM_RESET_SPEEDUP                  ("TRUE"),                                                                                              
+    //.SIM_VERSION                        (1),                                                                          
+
+    //----------------------------------------------------------------------------------------------               
+    //  Clock Attributes
+    //----------------------------------------------------------------------------------------------    
+    .RXRECCLKOUT0_SEL                   ( 2'b00),
+    .RXRECCLKOUT1_SEL                   ( 2'b00),                    
+
+    //----------------------------------------------------------------------------------------------
+    //  QPLL0 Attributes 
+    //----------------------------------------------------------------------------------------------    
+    .AEN_QPLL0_FBDIV                    (1'b1),                                 
+    .QPLL0CLKOUT_RATE                   ("HALF"),                              
+    .QPLL0_CFG0                         (16'b0011001100011100),                            
+    .QPLL0_CFG1                         (16'b1101000000111000),                             
+    .QPLL0_CFG1_G3                      (16'b1101000000111000),                             
+    .QPLL0_CFG2                         (16'b0000111111000000),                             
+    .QPLL0_CFG2_G3                      (16'b0000111111000000),                        
+    .QPLL0_CFG3                         (16'b0000000100100000),                  
+    .QPLL0_CFG4                         (16'b0000000011100111),
+    .QPLL0_CP                           (10'b1111111111),                       // Optimized for PCIe PLL compliance
+    .QPLL0_CP_G3                        (10'b0000011111),                       // Optimized for PCIe PLL compliance
+    .QPLL0_FBDIV                        (QPLL_FBDIV),
+    .QPLL0_FBDIV_G3                     (QPLL_FBDIV_G34),
+    .QPLL0_INIT_CFG0                    (16'h02B2),
+    .QPLL0_INIT_CFG1                    ( 8'b00000000),
+    .QPLL0_LOCK_CFG                     (16'b0010010111101000),                             // [10] : 1'b1 = Auto VCO
+    .QPLL0_LOCK_CFG_G3                  (16'b0010010111101000),                             // [10] : 1'b1 = Auto VCO
+    .QPLL0_LPF                          (10'b0100110101),                       // Optimized for PCIe PLL compliance
+    .QPLL0_LPF_G3                       (10'b1111111111),                       // Optimized for PCIe PLL compliance
+    .QPLL0_PCI_EN                       ( 1'b1),                                
+    .QPLL0_RATE_SW_USE_DRP              ( 1'b0),                                // Advance PCIe feature
+    .QPLL0_REFCLK_DIV                   (1),
+    .QPLL0_SDM_CFG0                     (16'b0000000011000000),                
+    .QPLL0_SDM_CFG1                     (16'b0000000000000000),
+    .QPLL0_SDM_CFG2                     (16'b0000000000000000),
+                     
+    //---------------------------------------------------------------------------------------------- 
+    //  QPLL1 Attributes               
+    //----------------------------------------------------------------------------------------------    
+    .AEN_QPLL1_FBDIV                    (1'b1),                                 
+    .QPLL1CLKOUT_RATE                   ("HALF"),                              
+    .QPLL1_CFG0                         (16'b0011001100011100),                             
+    .QPLL1_CFG1                         (16'b0001000000101000),                             
+    .QPLL1_CFG1_G3                      (16'b0001000000101000),                             
+    .QPLL1_CFG2                         (16'b0000111111000011),                             
+    .QPLL1_CFG2_G3                      (16'b0000000100100000),                         
+    .QPLL1_CFG3                         (16'b0000000100100000),                  
+    .QPLL1_CFG4                         (16'b0000000001100011),
+    .QPLL1_CP                           (10'b0100010101),                       // Optimized for PCIe PLL compliance
+    .QPLL1_CP_G3                        (10'b0100010101),                       // Optimized for PCIe PLL compliance
+    .QPLL1_FBDIV                        (QPLL_FBDIV),
+    .QPLL1_FBDIV_G3                     (QPLL_FBDIV_G34),
+    .QPLL1_INIT_CFG0                    (16'h02B2),
+    .QPLL1_INIT_CFG1                    ( 8'b00000000),
+    .QPLL1_LOCK_CFG                     (16'b0010010111101000),                             // [10] : 1'b1 = Auto VCO
+    .QPLL1_LOCK_CFG_G3                  (16'b0010010111101000),                             // [10] : 1'b1 = Auto VCO
+    .QPLL1_LPF                          (10'b0000010101),                       // Optimized for PCIe PLL compliance
+    .QPLL1_LPF_G3                       (10'b0000010101),                       // Optimized for PCIe PLL compliance
+    .QPLL1_PCI_EN                       ( 1'b1),                               
+    .QPLL1_RATE_SW_USE_DRP              ( 1'b0),                                // Advance PCIe feature
+    .QPLL1_REFCLK_DIV                   (1),
+    .QPLL1_SDM_CFG0                     (16'b0000000011000000),                 
+    .QPLL1_SDM_CFG1                     (16'b0000000000000000),
+    .QPLL1_SDM_CFG2                     (16'b0000000000000000),
+ 
+    //----------------------------------------------------------------------------------------------
+    //  PPF Attributes                                                         
+    //----------------------------------------------------------------------------------------------      
+    .PPF0_CFG                           (16'h0FFF),                            
+    .PPF1_CFG                           (16'h0FFF),                           
+    
+    //----------------------------------------------------------------------------------------------
+    //  Bias Attributes                                                          
+    //----------------------------------------------------------------------------------------------
+    .BIAS_CFG0                          (16'b0000000000000000),
+    .BIAS_CFG1                          (16'b0000000000000000),
+    .BIAS_CFG2                          (16'b0000000100100100),                 // Optimized for PCIe PLL compliance
+    .BIAS_CFG3                          (16'b0000000001000001),                 
+    .BIAS_CFG4                          (16'b0000000000010000),    
+    .BIAS_CFG_RSVD                      (10'b0000000000),  
+       
+    //---------------------------------------------------------------------------------------------- 
+    //  SDM0 Attributes                                                          
+    //----------------------------------------------------------------------------------------------
+    .A_SDM0TOGGLE                       ( 1'b0),
+    .AEN_SDM0TOGGLE                     ( 1'b0),
+    .SDM0INITSEED0_0                    (16'b0000000000000000),
+    .SDM0INITSEED0_1                    ( 9'b000000000),
+    
+    //---------------------------------------------------------------------------------------------- 
+    //  SDM1 Attributes                                                          
+    //----------------------------------------------------------------------------------------------     
+    .A_SDM1DATA_HIGH                    ( 9'b000000000),
+    .A_SDM1DATA_LOW                     (16'b0000000000000000),
+    .A_SDM1TOGGLE                       ( 1'b0),
+    .AEN_SDM1TOGGLE                     ( 1'b0),
+    .SDM1INITSEED0_0                    (16'b0000000000000000),
+    .SDM1INITSEED0_1                    ( 9'b000000000),     
+          
+    //----------------------------------------------------------------------------------------------
+    //  Reserved & MISC Attributes                                                         
+    //----------------------------------------------------------------------------------------------            
+    .COMMON_CFG0                        (16'b0000000000000000),
+    .COMMON_CFG1                        (16'b0000000000000000),
+    .POR_CFG                            (16'b0000000000000000),                 // CHECK      
+    .RSVD_ATTR0                         (16'b0000000000000000),                 // CHECK
+    .RSVD_ATTR1                         (16'b0000000000000000),    
+    .RSVD_ATTR2                         (16'b0000000000000000),                 // CHECK                
+    .RSVD_ATTR3                         (16'b0000000000000000),
+    .SARC_ENB                           ( 1'b0),
+    .SARC_SEL                           ( 1'b0)
+)
+gthe4_common_smsw_i 
+(       
+    //----------------------------------------------------------------------------------------------
+    //  QPLL0 Clock Ports
+    //----------------------------------------------------------------------------------------------
+    .GTGREFCLK0                         ( 1'd0), 
+    .GTREFCLK00                         (GTCOM_REFCLK),                         
+    .GTREFCLK10                         ( 1'd0),
+    .GTNORTHREFCLK00                    ( 1'd0),
+    .GTNORTHREFCLK10                    ( 1'd0),
+    .GTSOUTHREFCLK00                    ( 1'd0),
+    .GTSOUTHREFCLK10                    ( 1'd0),
+   
+    .REFCLKOUTMONITOR0                  (),
+    .RXRECCLK0SEL                       (),
+    
+    //----------------------------------------------------------------------------------------------
+    //  QPLL1 Clock Ports
+    //----------------------------------------------------------------------------------------------
+    .GTGREFCLK1                         ( 1'd0),
+    .GTREFCLK01                         (GTCOM_REFCLK),
+    .GTREFCLK11                         ( 1'd0),
+    .GTNORTHREFCLK01                    ( 1'd0),    
+    .GTNORTHREFCLK11                    ( 1'd0),
+    .GTSOUTHREFCLK01                    ( 1'd0),
+    .GTSOUTHREFCLK11                    ( 1'd0),        
+        
+    .REFCLKOUTMONITOR1                  (),  
+    .RXRECCLK1SEL	                      (), 
+        
+    //----------------------------------------------------------------------------------------------
+    //  QPLL0 Ports
+    //----------------------------------------------------------------------------------------------
+    .QPLL0CLKRSVD0                      ( 1'd0),
+    .QPLL0CLKRSVD1                      ( 1'd0),                              
+    .QPLL0FBDIV                         ( 8'd0),                                // CHECK
+    .QPLL0LOCKDETCLK                    ( 1'd0),
+    .QPLL0LOCKEN                        ( 1'd1),
+    .QPLL0PD                            (GTCOM_QPLL0PD),                        
+    .QPLL0REFCLKSEL                     ( 3'd1),                                                          
+    .QPLL0RESET                         (GTCOM_QPLL0RESET),                     
+       
+    .QPLL0FBCLKLOST                     (),
+    .QPLL0LOCK                          (GTCOM_QPLL0LOCK),
+    .QPLL0OUTCLK                        (GTCOM_QPLL0OUTCLK),
+    .QPLL0OUTREFCLK                     (GTCOM_QPLL0OUTREFCLK),
+    .QPLL0REFCLKLOST                    (),     
+    .QPLLDMONITOR0                      (),                                                                      
+                                               
+    //----------------------------------------------------------------------------------------------
+    //  QPLL1 Ports
+    //----------------------------------------------------------------------------------------------
+    .QPLL1CLKRSVD0                      ( 1'd0),
+    .QPLL1CLKRSVD1                      ( 1'd0),                                
+    .QPLL1FBDIV                         ( 8'd0),                                // CHECK
+    .QPLL1LOCKDETCLK                    ( 1'd0),
+    .QPLL1LOCKEN                        ( 1'd1),
+    .QPLL1PD                            (GTCOM_QPLL1PD),
+    .QPLL1REFCLKSEL                     ( 3'd1),                        
+    .QPLL1RESET                         (GTCOM_QPLL1RESET),      
+     
+    .QPLL1FBCLKLOST                     (),  
+    .QPLL1LOCK                          (GTCOM_QPLL1LOCK),       
+    .QPLL1OUTCLK                        (GTCOM_QPLL1OUTCLK),     
+    .QPLL1OUTREFCLK                     (GTCOM_QPLL1OUTREFCLK),                       
+    .QPLL1REFCLKLOST                    (),  
+    .QPLLDMONITOR1                      (),            
+         
+    //----------------------------------------------------------------------------------------------
+    //  PCIe Ports
+    //----------------------------------------------------------------------------------------------
+    .PCIERATEQPLL0                      (GTCOM_QPLLRATE),           
+    .PCIERATEQPLL1                      (GTCOM_QPLLRATE),       
+                                                                                                       
+    //----------------------------------------------------------------------------------------------
+    //  DRP Ports
+    //----------------------------------------------------------------------------------------------
+    .DRPCLK                             (GTCOM_DRPCLK),                                        
+    .DRPADDR                            (GTCOM_DRPADDR),                                       
+    .DRPEN                              (GTCOM_DRPEN),                                             
+    .DRPWE                              (GTCOM_DRPWE),     
+    .DRPDI                              (GTCOM_DRPDI),                                      
+                                                                         
+    .DRPRDY                             (GTCOM_DRPRDY),    
+    .DRPDO                              (GTCOM_DRPDO),                                      
+        
+    //----------------------------------------------------------------------------------------------
+    //  rCal Ports
+    //----------------------------------------------------------------------------------------------        
+    .RCALENB                            ( 1'd1),          
+                                                                                                        
+    //----------------------------------------------------------------------------------------------
+    //  Band Gap Ports
+    //----------------------------------------------------------------------------------------------
+    .BGBYPASSB                          ( 1'b1),                                
+    .BGMONITORENB                       ( 1'b1),                                
+    .BGPDB                              ( 1'b1),  
+    .BGRCALOVRD                         ( 5'b11111),                                 
+    .BGRCALOVRDENB                      ( 1'b1),                                                            
+        
+    //----------------------------------------------------------------------------------------------
+    //  SDM0 Ports
+    //----------------------------------------------------------------------------------------------
+    .SDM0DATA                           (25'd0),
+    .SDM0RESET                          ( 1'd0),
+    .SDM0TOGGLE                         ( 1'd0), 
+    .SDM0WIDTH                          ( 2'd0),
+    
+    .SDM0FINALOUT                       (),
+    .SDM0TESTDATA                       (),
+
+    //----------------------------------------------------------------------------------------------
+    //  SDM1 Ports
+    //----------------------------------------------------------------------------------------------
+    .SDM1DATA                           (25'd0),
+    .SDM1RESET                          ( 1'd0),
+    .SDM1TOGGLE                         ( 1'd0), 
+    .SDM1WIDTH                          ( 2'd0),
+    
+    .SDM1FINALOUT                       (),
+    .SDM1TESTDATA                       (),
+
+    //----------------------------------------------------------------------------------------------
+    //  TCON Ports
+    //----------------------------------------------------------------------------------------------
+    .TCONGPI                            (10'd0),
+    .TCONPOWERUP                        ( 1'd0),
+    .TCONRESET                          ( 2'd0),
+    .TCONRSVDIN1                        ( 2'd0),
+    
+    .TCONGPO                            (),
+    .TCONRSVDOUT0                       (),
+
+    //----------------------------------------------------------------------------------------------
+    //  Reserved & MISC Ports
+    //----------------------------------------------------------------------------------------------
+    .PMARSVD0                           ( 8'd0),            
+    .PMARSVD1                           ( 8'd0),  
+    .QPLLRSVD1                          ( 8'd0),
+    .QPLLRSVD2                          ( 5'd0),               
+    .QPLLRSVD3                          ( 5'd0),          
+    .QPLLRSVD4                          ( 8'd0),                   
+
+    .PMARSVDOUT0                        (),
+    .PMARSVDOUT1                        ()
+);
+end
+endgenerate
+
+endmodule
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2023 AMD, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD, Inc. and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : UltraScale+ FPGA PCI Express v4.0 Integrated Block
+// File       : xp4_usp_smsw_gt_phy_clk.v
+// Version    : 1.1 
+//-----------------------------------------------------------------------------
+//--------------------------------------------------------------------------------------------------
+//  Design :  PHY Wrapper 
+//  Module :  PHY Clock
+//--------------------------------------------------------------------------------------------------
+
+`timescale 1ps / 1ps
+
+//--------------------------------------------------------------------------------------------------
+//  PHY Clock Module
+//--------------------------------------------------------------------------------------------------
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_gt_phy_clk #
+(
+    parameter integer PHY_MAX_SPEED     = 4, 
+    parameter         PHY_GEN4_64BIT_EN = "FALSE",
+    parameter integer PHY_CORECLK_FREQ  = 2,  
+    parameter integer PHY_USERCLK_FREQ  = 4, 
+    parameter integer PHY_MCAPCLK_FREQ  = 4          
+)
+(
+    //--------------------------------------------------------------------------
+    //  CLK Port
+    //--------------------------------------------------------------------------
+    input                               CLK_TXOUTCLK,
+    output                              CLK_PCLK2_GT,
+
+    //--------------------------------------------------------------------------
+    //  PCLK Ports
+    //--------------------------------------------------------------------------
+    input                               CLK_PCLK_CE,
+    input                               CLK_PCLK_CEMASK,
+    input                               CLK_PCLK_CLR,
+    input                               CLK_PCLK_CLRMASK,
+    input       [ 2:0]                  CLK_PCLK_DIV,
+    output                              CLK_PCLK,
+    
+    //--------------------------------------------------------------------------
+    //  PCLK2 Ports
+    //--------------------------------------------------------------------------
+    input                               CLK_PCLK2_CE,
+    input                               CLK_PCLK2_CEMASK,
+    input                               CLK_PCLK2_CLR,
+    input                               CLK_PCLK2_CLRMASK,
+    input       [ 2:0]                  CLK_PCLK2_DIV,
+    output                              CLK_PCLK2,
+    
+    //--------------------------------------------------------------------------
+    //  CORECLK Ports
+    //--------------------------------------------------------------------------
+    input                               CLK_CORECLK_CE,
+    input                               CLK_CORECLK_CEMASK,
+    input                               CLK_CORECLK_CLR,
+    input                               CLK_CORECLK_CLRMASK,
+    output                              CLK_CORECLK,      
+    
+    //--------------------------------------------------------------------------
+    //  USERCLK Ports
+    //--------------------------------------------------------------------------
+    input                               CLK_USERCLK_CE,
+    input                               CLK_USERCLK_CEMASK,
+    input                               CLK_USERCLK_CLR,
+    input                               CLK_USERCLK_CLRMASK,
+    output                              CLK_USERCLK,    
+    
+    //--------------------------------------------------------------------------
+    //  MCAPCLK Ports
+    //--------------------------------------------------------------------------
+    input                               CLK_MCAPCLK_CE,
+    input                               CLK_MCAPCLK_CEMASK,
+    input                               CLK_MCAPCLK_CLR,
+    input                               CLK_MCAPCLK_CLRMASK,
+    output                              CLK_MCAPCLK    
+);
+    //--------------------------------------------------------------------------
+    //  Internal Signals
+    //--------------------------------------------------------------------------                                     
+    wire                                pclk;                                                                 
+    wire                                pclk2;
+
+
+
+    //----------------------------------------------------------------------------------------------
+    //  Divider for CORECLK
+    //----------------------------------------------------------------------------------------------     
+    localparam [ 2:0] CORECLK_DIV_250MHZ = 3'd0;                                                    // 250.0 MHz
+    localparam [ 2:0] CORECLK_DIV_500MHZ = (PHY_CORECLK_FREQ == 1) ? 3'd1 : 3'd0;                   // 250.0 MHZ : Default = 500.0 MHz                                
+    
+    localparam [ 2:0] CORECLK_DIV        = (PHY_MAX_SPEED     < 3) ? CORECLK_DIV_250MHZ : 
+                                           (PHY_MAX_SPEED    == 4) ? CORECLK_DIV_500MHZ : 
+                                           (PHY_CORECLK_FREQ == 1) ? CORECLK_DIV_250MHZ : CORECLK_DIV_500MHZ;
+
+
+
+    //----------------------------------------------------------------------------------------------
+    //  Divider for USERCLK
+    //---------------------------------------------------------------------------------------------- 
+    localparam [ 2:0] USERCLK_DIV_250MHZ = (PHY_USERCLK_FREQ == 3) ? 3'd0 :                         // 250.0 MHz
+                                           (PHY_USERCLK_FREQ == 2) ? 3'd1 :                         // 125.0 MHz
+                                           (PHY_USERCLK_FREQ == 1) ? 3'd3 : 3'd0;                   //  62.5 MHz : Default = 250.0 MHz
+   
+    localparam [ 2:0] USERCLK_DIV_500MHZ = (PHY_USERCLK_FREQ == 4) ? 3'd0 :                         // 500.0 MHz
+                                           (PHY_USERCLK_FREQ == 3) ? 3'd1 :                         // 250.0 MHz
+                                           (PHY_USERCLK_FREQ == 2) ? 3'd3 :                         // 125.0 MHz
+                                           (PHY_USERCLK_FREQ == 1) ? 3'd7 : 3'd0;                   //  62.5 MHz : Default = 500.0 MHz
+    
+    localparam [ 2:0] USERCLK_DIV        = (PHY_MAX_SPEED     < 3) ? USERCLK_DIV_250MHZ :
+                                           (PHY_MAX_SPEED    == 4) ? USERCLK_DIV_500MHZ : 
+                                           (PHY_CORECLK_FREQ == 1) ? USERCLK_DIV_250MHZ : USERCLK_DIV_500MHZ;
+
+
+                                           
+    //----------------------------------------------------------------------------------------------
+    //  Divider for MCAPCLK
+    //---------------------------------------------------------------------------------------------- 
+    localparam [ 2:0] MCAPCLK_DIV_250MHZ = (PHY_MCAPCLK_FREQ == 3) ? 3'd0 :                         // 250.0 MHz
+                                           (PHY_MCAPCLK_FREQ == 2) ? 3'd1 :                         // 125.0 MHz
+                                           (PHY_MCAPCLK_FREQ == 1) ? 3'd3 : 3'd0;                   //  62.5 MHz : Default = 250.0 MHz
+   
+    localparam [ 2:0] MCAPCLK_DIV_500MHZ = (PHY_MCAPCLK_FREQ == 4) ? 3'd0 :                         // 500.0 MHz
+                                           (PHY_MCAPCLK_FREQ == 3) ? 3'd1 :                         // 250.0 MHz
+                                           (PHY_MCAPCLK_FREQ == 2) ? 3'd3 :                         // 125.0 MHz
+                                           (PHY_MCAPCLK_FREQ == 1) ? 3'd7 : 3'd0;                   //  62.5 MHz : Default = 500.0 MHz
+    
+    localparam [ 2:0] MCAPCLK_DIV        = (PHY_MAX_SPEED     < 3) ? MCAPCLK_DIV_250MHZ :
+                                           (PHY_MAX_SPEED    == 4) ? MCAPCLK_DIV_500MHZ : 
+                                           (PHY_CORECLK_FREQ == 1) ? MCAPCLK_DIV_250MHZ : MCAPCLK_DIV_500MHZ;
+
+                                           
+
+//--------------------------------------------------------------------------------------------------
+//  BUFG_GT for PCLK
+//--------------------------------------------------------------------------------------------------
+BUFG_GT bufg_gt_pclk 
+(
+     //-------------------------------------------------------------------------
+     //  Input Ports
+     //-------------------------------------------------------------------------
+    .CE                                 (CLK_PCLK_CE),
+    .CEMASK                             (CLK_PCLK_CEMASK),
+    .CLR                                (CLK_PCLK_CLR),
+    .CLRMASK                            (CLK_PCLK_CLRMASK),
+    .DIV                                (CLK_PCLK_DIV),
+    .I                                  (CLK_TXOUTCLK),
+    
+     //-------------------------------------------------------------------------
+     //  Output Ports
+     //-------------------------------------------------------------------------
+    .O                                  (pclk)
+);
+
+
+
+ assign pclk2 = pclk;
+
+
+//--------------------------------------------------------------------------------------------------
+//  BUFG_GT for CORECLK
+//--------------------------------------------------------------------------------------------------
+BUFG_GT bufg_gt_coreclk 
+(
+     //-------------------------------------------------------------------------
+     //  Input Ports
+     //-------------------------------------------------------------------------
+    .CE                                 (CLK_CORECLK_CE),
+    .CEMASK                             (CLK_CORECLK_CEMASK),
+    .CLR                                (CLK_CORECLK_CLR),
+    .CLRMASK                            (CLK_CORECLK_CLRMASK),
+    .DIV                                (    CORECLK_DIV),
+    .I                                  (CLK_TXOUTCLK),
+
+     //-------------------------------------------------------------------------
+     //  Output Ports
+     //-------------------------------------------------------------------------
+    .O                                  (CLK_CORECLK)
+);
+
+
+
+//--------------------------------------------------------------------------------------------------
+//  BUFG_GT for USERCLK
+//--------------------------------------------------------------------------------------------------
+BUFG_GT bufg_gt_userclk 
+(
+     //-------------------------------------------------------------------------
+     //  Input Ports
+     //-------------------------------------------------------------------------
+    .CE                                 (CLK_USERCLK_CE),
+    .CEMASK                             (CLK_USERCLK_CEMASK),
+    .CLR                                (CLK_USERCLK_CLR),
+    .CLRMASK                            (CLK_USERCLK_CLRMASK),
+    .DIV                                (    USERCLK_DIV),
+    .I                                  (CLK_TXOUTCLK),
+    
+     //-------------------------------------------------------------------------
+     //  Output Ports
+     //-------------------------------------------------------------------------
+    .O                                  (CLK_USERCLK)
+);
+
+
+
+//--------------------------------------------------------------------------------------------------
+//  BUFG_GT for MCAPCLK
+//--------------------------------------------------------------------------------------------------
+BUFG_GT bufg_gt_mcapclk
+(
+     //-------------------------------------------------------------------------
+     //  Input Ports
+     //-------------------------------------------------------------------------
+    .CE                                 (CLK_MCAPCLK_CE),
+    .CEMASK                             (CLK_MCAPCLK_CEMASK),
+    .CLR                                (CLK_MCAPCLK_CLR),
+    .CLRMASK                            (CLK_MCAPCLK_CLRMASK),
+    .DIV                                (    MCAPCLK_DIV),
+    .I                                  (CLK_TXOUTCLK),
+
+     //-------------------------------------------------------------------------
+     //  Output Ports
+     //-------------------------------------------------------------------------
+    .O                                  (CLK_MCAPCLK)
+);
+
+
+//--------------------------------------------------------------------------------------------------
+//  PHY Clock Output
+//--------------------------------------------------------------------------------------------------
+assign CLK_PCLK     = pclk;
+assign CLK_PCLK2    = pclk2;
+assign CLK_PCLK2_GT = (PHY_GEN4_64BIT_EN == "TRUE") ? pclk2 : pclk;
+
+
+
+endmodule
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2023 AMD, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD, Inc. and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : UltraScale+ FPGA PCI Express v4.0 Integrated Block
+// File       : xp4_usp_smsw_gt_phy_rst.v
+// Version    : 1.1 
+//-----------------------------------------------------------------------------
+//--------------------------------------------------------------------------------------------------
+//  Design :  PHY Wrapper
+//  Module :  PHY Reset 
+//--------------------------------------------------------------------------------------------------
+
+`timescale 1ps / 1ps
+
+//--------------------------------------------------------------------------------------------------
+//  PHY Reset Module
+//--------------------------------------------------------------------------------------------------
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_gt_phy_rst #
+(
+    parameter integer PHY_LANE      = 16,   
+    parameter integer PHY_MAX_SPEED = 4,
+    parameter integer SYNC_STAGE    = 3
+)
+(
+    //-------------------------------------------------------------------------- 
+    //  Input Ports
+    //-------------------------------------------------------------------------- 
+    input                               RST_REFCLK,
+    input                               RST_PCLK,
+    input                               RST_N,
+    input       [PHY_LANE-1:0]          RST_GTPOWERGOOD,
+    input       [PHY_LANE-1:0]          RST_CPLLLOCK,
+    input       [(PHY_LANE-1)>>2:0]     RST_QPLL0LOCK,   
+    input       [(PHY_LANE-1)>>2:0]     RST_QPLL1LOCK,
+    input       [PHY_LANE-1:0]          RST_TXPROGDIVRESETDONE,
+    input       [PHY_LANE-1:0]          RST_TXRESETDONE,    
+    input       [PHY_LANE-1:0]          RST_RXRESETDONE, 
+    input       [PHY_LANE-1:0]          RST_TXSYNC_DONE,   
+    input       [PHY_LANE-1:0]          RST_PHYSTATUS,
+    
+    //-------------------------------------------------------------------------- 
+    //  Output Ports
+    //-------------------------------------------------------------------------- 
+    output                              RST_RRST_N,
+    output                              RST_PRST_N,
+    output                              RST_CPLLPD,
+    output                              RST_CPLLRESET,
+    output                              RST_QPLLPD,
+    output                              RST_QPLLRESET,
+    output                              RST_TXPROGDIVRESET,
+    output                              RST_GTRESET,
+    output                              RST_USERRDY,
+    output                              RST_TXSYNC_START,
+    output                              RST_IDLE
+);
+    //-------------------------------------------------------------------------- 
+    //  Reset Synchronized Signals
+    //-------------------------------------------------------------------------- 
+    (* ASYNC_REG = "TRUE", SHIFT_EXTRACT = "NO" *) reg [ 3:0] rrst_n_r;
+    (* ASYNC_REG = "TRUE", SHIFT_EXTRACT = "NO" *) reg [ 3:0] prst_n_r;
+
+    wire                                rrst_n;                                     
+    wire                                prst_n;  
+       
+    //--------------------------------------------------------------------------
+    //  Synchronized Signals
+    //--------------------------------------------------------------------------                                     
+    wire        [PHY_LANE-1:0]          gtpowergood_r;                                                                 
+    wire        [PHY_LANE-1:0]          cplllock_r;
+    wire        [(PHY_LANE-1)>>2:0]     qpll0lock_r;
+    wire        [(PHY_LANE-1)>>2:0]     qpll1lock_r;
+    wire        [PHY_LANE-1:0]          txprogdivresetdone_r;
+    wire        [PHY_LANE-1:0]          txresetdone_r;  
+    wire        [PHY_LANE-1:0]          rxresetdone_r;
+    wire        [PHY_LANE-1:0]          txsync_done_r;
+    wire        [PHY_LANE-1:0]          phystatus_r;
+    
+    //--------------------------------------------------------------------------
+    //  Internal Signals
+    //--------------------------------------------------------------------------
+    wire                                gtpowergood_a;
+    wire                                cplllock_a;
+    wire                                qplllock_a;
+    wire                                txprogdivresetdone_a;
+    wire                                resetdone_a;
+    wire                                txsync_done_a;
+    wire                                phystatus_a;
+    
+    reg         [ 1:0]                  txsync_start_cnt;
+    
+    //--------------------------------------------------------------------------
+    //  Output Delayed Signals
+    //--------------------------------------------------------------------------     
+    reg         [ 3:0]                  cpllpd_r;
+    reg         [ 3:0]                  cpllreset_r;                                  
+    reg         [ 3:0]                  qpllpd_r;
+    reg         [ 3:0]                  qpllreset_r;                                
+    reg         [ 3:0]                  txprogdivreset_r;
+    reg         [ 3:0]                  gtreset_r;
+    reg         [ 3:0]                  userrdy_r;
+                
+    wire                                cpllpd_dly;
+    wire                                cpllreset_dly;                                    
+    wire                                qpllpd_dly;
+    wire                                qpllreset_dly;                        
+    wire                                txprogdivreset_dly;
+    wire                                gtreset_dly;
+    wire                                userrdy_dly;
+     
+    //-------------------------------------------------------------------------- 
+    //  FSM Signals
+    //-------------------------------------------------------------------------- 
+    reg [ 2:0] fsm;
+    
+    reg                                 idle;     
+    reg                                 cpllpd;
+    reg                                 cpllreset;
+    reg                                 qpllpd;
+    reg                                 qpllreset;
+    reg                                 txprogdivreset;
+    reg                                 gtreset;
+    reg                                 userrdy; 
+    reg                                 txsync_start;         
+   
+    //--------------------------------------------------------------------------
+    //  FSM Encoding
+    //-------------------------------------------------------------------------- 
+    localparam FSM_IDLE               = 3'd0;
+    localparam FSM_GTPOWERGOOD        = 3'd1;
+    localparam FSM_PLLLOCK            = 3'd2;
+    localparam FSM_TXPROGDIVRESETDONE = 3'd3;
+    localparam FSM_RESETDONE          = 3'd4;
+    localparam FSM_TXSYNC_START       = 3'd5;
+    localparam FSM_TXSYNC_DONE        = 3'd6;
+    localparam FSM_PHYSTATUS          = 3'd7;
+
+
+
+//--------------------------------------------------------------------------------------------------
+//  Reset Synchronizer for REFCLK
+//--------------------------------------------------------------------------------------------------
+always @ (posedge RST_REFCLK or negedge RST_N)
+begin
+
+    if (!RST_N) 
+        rrst_n_r <= 4'd0;
+    else
+        rrst_n_r <= {rrst_n_r[2:0], 1'd1}; 
+          
+end   
+ 
+assign rrst_n = rrst_n_r[3];
+
+
+
+//--------------------------------------------------------------------------------------------------
+//  Reset Synchronizer for PCLK
+//--------------------------------------------------------------------------------------------------
+always @ (posedge RST_PCLK or negedge RST_N)
+begin
+
+    if (!RST_N) 
+        prst_n_r <= 4'd0;
+    else
+        prst_n_r <= {prst_n_r[2:0], 1'd1};
+          
+end   
+
+assign prst_n = prst_n_r[3];
+
+
+
+//--------------------------------------------------------------------------------------------------
+//  Input Synchronizer or Pipeline
+//--------------------------------------------------------------------------------------------------
+xp4_usp_smsw_sync #(.WIDTH (PHY_LANE),            .STAGE (SYNC_STAGE)) sync_gtpowergood        (.CLK (RST_REFCLK), .D (RST_GTPOWERGOOD),        .Q (gtpowergood_r));
+xp4_usp_smsw_sync #(.WIDTH (PHY_LANE),            .STAGE (SYNC_STAGE)) sync_cplllock           (.CLK (RST_REFCLK), .D (RST_CPLLLOCK),           .Q (cplllock_r));
+xp4_usp_smsw_sync #(.WIDTH (((PHY_LANE-1)>>2)+1), .STAGE (SYNC_STAGE)) sync_qpll0lock          (.CLK (RST_REFCLK), .D (RST_QPLL0LOCK),          .Q (qpll0lock_r));
+xp4_usp_smsw_sync #(.WIDTH (((PHY_LANE-1)>>2)+1), .STAGE (SYNC_STAGE)) sync_qpll1lock          (.CLK (RST_REFCLK), .D (RST_QPLL1LOCK),          .Q (qpll1lock_r));
+xp4_usp_smsw_sync #(.WIDTH (PHY_LANE),            .STAGE (SYNC_STAGE)) sync_txprogdivresetdone (.CLK (RST_REFCLK), .D (RST_TXPROGDIVRESETDONE), .Q (txprogdivresetdone_r));
+xp4_usp_smsw_sync #(.WIDTH (PHY_LANE),            .STAGE (SYNC_STAGE)) sync_txresetdone        (.CLK (RST_REFCLK), .D (RST_TXRESETDONE),        .Q (txresetdone_r));  
+xp4_usp_smsw_sync #(.WIDTH (PHY_LANE),            .STAGE (SYNC_STAGE)) sync_rxresetdone        (.CLK (RST_REFCLK), .D (RST_RXRESETDONE),        .Q (rxresetdone_r));
+xp4_usp_smsw_sync #(.WIDTH (PHY_LANE),            .STAGE (SYNC_STAGE)) sync_txsync_done        (.CLK (RST_REFCLK), .D (RST_TXSYNC_DONE),        .Q (txsync_done_r)); 
+xp4_usp_smsw_sync #(.WIDTH (PHY_LANE),            .STAGE (SYNC_STAGE)) sync_phystatus          (.CLK (RST_REFCLK), .D (RST_PHYSTATUS),          .Q (phystatus_r));
+
+
+
+//--------------------------------------------------------------------------------------------------
+//  Convert per-lane signals to per-design 
+//--------------------------------------------------------------------------------------------------
+assign gtpowergood_a        = &gtpowergood_r;
+assign cplllock_a           = (PHY_MAX_SPEED  < 3) ? (&cplllock_r)  : cplllock_r[0];
+assign qplllock_a           = (PHY_MAX_SPEED == 4) ? (&qpll0lock_r) : (&qpll1lock_r);
+assign txprogdivresetdone_a = &txprogdivresetdone_r;
+assign resetdone_a          = (&txresetdone_r) && (&rxresetdone_r);
+assign txsync_done_a        = &txsync_done_r;
+assign phystatus_a          = |phystatus_r;                 
+
+
+
+//--------------------------------------------------------------------------------------------------
+//  TX Sync Alignment Start Counter
+//--------------------------------------------------------------------------------------------------
+always @ (posedge RST_REFCLK)
+begin
+
+    if (!rrst_n)
+        txsync_start_cnt <= 2'd0;
+    else
+        if (fsm == FSM_TXSYNC_START)
+            txsync_start_cnt <= txsync_start_cnt + 2'd1; 
+        else
+            txsync_start_cnt <= 2'd0;
+            
+end
+
+
+
+//--------------------------------------------------------------------------------------------------
+//  Reset FSM
+//--------------------------------------------------------------------------------------------------
+always @ (posedge RST_REFCLK)
+begin
+
+    if (!rrst_n)
+        begin
+        fsm            <= FSM_GTPOWERGOOD;
+        idle           <= 1'd0;
+        cpllpd         <= 1'd1;                               
+        cpllreset      <= 1'd1;
+        qpllpd         <= 1'd1;
+        qpllreset      <= 1'd1;
+        txprogdivreset <= 1'd1;
+        gtreset        <= 1'd1;
+        userrdy        <= 1'd0;
+        txsync_start   <= 1'd0;
+        end
+    else
+        begin
+        
+        case (fsm)
+            
+        //------------------------------------------------------------------------------------------
+        //  Stay in IDLE state until system reset is released
+        //------------------------------------------------------------------------------------------
+        FSM_IDLE :
+        
+            begin
+            if (!rrst_n)
+                begin
+                fsm            <= FSM_GTPOWERGOOD;
+                idle           <= 1'd0;
+                cpllpd         <= 1'd1;
+                cpllreset      <= 1'd1;
+                qpllpd         <= 1'd1;
+                qpllreset      <= 1'd1;
+                txprogdivreset <= 1'd1;
+                gtreset        <= 1'd1;
+                userrdy        <= 1'd0;
+                txsync_start   <= 1'd0;
+                end
+            else
+                begin
+                fsm            <= FSM_IDLE;
+                idle           <= 1'd1;
+                cpllpd         <= cpllpd;
+                cpllreset      <= cpllreset;
+                qpllpd         <= qpllpd;
+                qpllreset      <= qpllreset;
+                txprogdivreset <= txprogdivreset;
+                gtreset        <= gtreset;
+                userrdy        <= userrdy;
+                txsync_start   <= txsync_start;
+                end
+            end   
+            
+        //------------------------------------------------------------------------------------------
+        //  Release [CPLL/QPLL]PD and wait for GTPOWERGOOD to assert HIGH
+        //------------------------------------------------------------------------------------------
+        FSM_GTPOWERGOOD :
+        
+            begin
+            fsm            <= (gtpowergood_a && (!cplllock_a) && (!qplllock_a || PHY_MAX_SPEED < 3)) ? FSM_PLLLOCK : FSM_GTPOWERGOOD;
+            idle           <= idle;
+            cpllpd         <= 1'd0;
+            cpllreset      <= cpllreset;
+            qpllpd         <= (PHY_MAX_SPEED < 3) ? 1'd1 : 1'd0;
+            qpllreset      <= qpllreset;
+            txprogdivreset <= txprogdivreset;
+            gtreset        <= gtreset;
+            userrdy        <= userrdy;
+            txsync_start   <= txsync_start;
+            end    
+            
+        //------------------------------------------------------------------------------------------
+        //  Release [CPLL/QPLL]RESET and wait for [CPLL/QPLL]LOCK to assert HIGH
+        //------------------------------------------------------------------------------------------
+        FSM_PLLLOCK :
+        
+            begin
+            fsm            <= (cplllock_a && (qplllock_a || PHY_MAX_SPEED < 3)) ? FSM_TXPROGDIVRESETDONE : FSM_PLLLOCK;
+            idle           <= idle;
+            cpllpd         <= cpllpd;
+            cpllreset      <= 1'd0;
+            qpllpd         <= qpllpd;
+            qpllreset      <= (PHY_MAX_SPEED < 3) ? 1'd1 : 1'd0;
+            txprogdivreset <= txprogdivreset;
+            gtreset        <= gtreset;
+            userrdy        <= userrdy;
+            txsync_start   <= txsync_start;
+            end
+
+        //------------------------------------------------------------------------------------------
+        //  Release TXPROGDIVRESET and wait for TXPROGDIVRESETDONE to assert HIGH
+        //------------------------------------------------------------------------------------------
+        FSM_TXPROGDIVRESETDONE :
+        
+            begin
+            fsm            <= txprogdivresetdone_a ? FSM_RESETDONE : FSM_TXPROGDIVRESETDONE;  
+            idle           <= idle;
+            cpllpd         <= cpllpd;
+            cpllreset      <= cpllreset;
+            qpllpd         <= qpllpd;
+            qpllreset      <= qpllreset;
+            txprogdivreset <= 1'd0;
+            gtreset        <= gtreset;
+            userrdy        <= userrdy;
+            txsync_start   <= txsync_start;
+            end
+            
+        //------------------------------------------------------------------------------------------
+        //  Release GT[TX/RX]RESET, assert [TX/RX]USERRDY, and wait for [TX/RX]RESETDONE to assert HIGH
+        //------------------------------------------------------------------------------------------
+        FSM_RESETDONE :
+        
+            begin
+            fsm            <= resetdone_a ? FSM_TXSYNC_START : FSM_RESETDONE;  
+            idle           <= idle;
+            cpllpd         <= cpllpd;
+            cpllreset      <= cpllreset;
+            qpllpd         <= qpllpd;
+            qpllreset      <= qpllreset;
+            txprogdivreset <= txprogdivreset;
+            gtreset        <= 1'd0;
+            userrdy        <= 1'd1;
+            txsync_start   <= txsync_start;
+            end
+        
+        //------------------------------------------------------------------------------------------
+        //  Start TX sync alignment.  Extend TXSYNC_START pulse by few REFCLK cycles
+        //------------------------------------------------------------------------------------------
+        FSM_TXSYNC_START :
+        
+            begin
+            fsm            <= (!txsync_done_a && (txsync_start_cnt == 2'd3)) ? FSM_TXSYNC_DONE : FSM_TXSYNC_START;
+            idle           <= idle;
+            cpllpd         <= cpllpd;
+            cpllreset      <= cpllreset;
+            qpllpd         <= qpllpd;   
+            qpllreset      <= qpllreset;
+            txprogdivreset <= txprogdivreset;
+            gtreset        <= gtreset;
+            userrdy        <= userrdy;
+            txsync_start   <= 1'd1;
+            end
+            
+        //------------------------------------------------------------------------------------------
+        //  Wait for TX sync alignment done
+        //------------------------------------------------------------------------------------------
+        FSM_TXSYNC_DONE :
+        
+            begin
+            fsm            <= txsync_done_a ? FSM_PHYSTATUS : FSM_TXSYNC_DONE;
+            idle           <= idle;
+            cpllpd         <= cpllpd;
+            cpllreset      <= cpllreset;
+            qpllpd         <= qpllpd;
+            qpllreset      <= qpllreset;
+            txprogdivreset <= txprogdivreset;
+            gtreset        <= gtreset;
+            userrdy        <= userrdy;
+            txsync_start   <= 1'd0;
+            end    
+            
+        //------------------------------------------------------------------------------------------
+        //  Wait for PHYSTATUS to de-assert LOW
+        //------------------------------------------------------------------------------------------
+        FSM_PHYSTATUS :
+        
+            begin
+            fsm            <= !phystatus_a ? FSM_IDLE : FSM_PHYSTATUS;  
+            idle           <= 1'd1;
+            cpllpd         <= cpllpd;
+            cpllreset      <= cpllreset;
+            qpllpd         <= qpllpd;
+            qpllreset      <= qpllreset;
+            txprogdivreset <= txprogdivreset;
+            gtreset        <= gtreset;
+            userrdy        <= userrdy;
+            txsync_start   <= txsync_start;
+            end 
+            
+        //------------------------------------------------------------------------------------------
+        //  Default State
+        //------------------------------------------------------------------------------------------
+        default :
+        
+            begin
+            fsm            <= FSM_IDLE;
+            idle           <= 1'd0;
+            cpllpd         <= 1'd1;
+            cpllreset      <= 1'd1;
+            qpllpd         <= 1'd1;
+            qpllreset      <= 1'd1;
+            txprogdivreset <= 1'd1;
+            gtreset        <= 1'd1;
+            userrdy        <= 1'd0;
+            txsync_start   <= 1'd0;
+            end
+
+        endcase
+        
+        end
+        
+end
+
+
+
+//--------------------------------------------------------------------------------------------------
+//  Delay Outputs
+//--------------------------------------------------------------------------------------------------
+always @ (posedge RST_REFCLK)
+begin
+
+    cpllpd_r         <= {cpllpd_r[2:0],         cpllpd}; 
+    cpllreset_r      <= {cpllreset_r[2:0],      cpllreset}; 
+    qpllpd_r         <= {qpllpd_r[2:0],         qpllpd}; 
+    qpllreset_r      <= {qpllreset_r[2:0],      qpllreset}; 
+    txprogdivreset_r <= {txprogdivreset_r[2:0], txprogdivreset}; 
+    gtreset_r        <= {gtreset_r[2:0],        gtreset};    
+    userrdy_r        <= {userrdy_r[2:0],        userrdy}; 
+            
+end
+
+assign cpllpd_dly         = cpllpd_r[3];
+assign cpllreset_dly      = cpllreset_r[3];
+assign qpllpd_dly         = qpllpd_r[3];
+assign qpllreset_dly      = qpllreset_r[3];
+assign txprogdivreset_dly = txprogdivreset_r[3];
+assign gtreset_dly        = gtreset_r[3];
+assign userrdy_dly        = userrdy_r[3];
+
+
+
+//--------------------------------------------------------------------------------------------------
+//  PHY Reset Outputs
+//--------------------------------------------------------------------------------------------------
+assign RST_RRST_N         = rrst_n;
+assign RST_PRST_N         = prst_n;
+
+assign RST_CPLLPD         = cpllpd_dly;
+assign RST_CPLLRESET      = cpllreset_dly; 
+assign RST_QPLLPD         = qpllpd_dly;
+assign RST_QPLLRESET      = qpllreset_dly;
+assign RST_TXPROGDIVRESET = txprogdivreset_dly;
+assign RST_GTRESET        = gtreset_dly;  
+assign RST_USERRDY        = userrdy_dly;
+assign RST_TXSYNC_START   = txsync_start;
+assign RST_IDLE           = idle;
+
+
+
+endmodule
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2023 AMD, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD, Inc. and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : UltraScale+ FPGA PCI Express v4.0 Integrated Block
+// File       : xp4_usp_smsw_gt_phy_rxeq.v
+// Version    : 1.1 
+//-----------------------------------------------------------------------------
+//--------------------------------------------------------------------------------------------------
+//  Design :  PHY Wrapper                                                             
+//  Module :  RX Equalization                                                                   
+//--------------------------------------------------------------------------------------------------
+
+`timescale 1ps / 1ps
+ 
+//--------------------------------------------------------------------------------------------------
+//  RX Equalization Module
+//--------------------------------------------------------------------------------------------------
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_gt_phy_rxeq #
+(
+    parameter         PHY_SIM_EN      = "FALSE",   
+    parameter integer PHY_LP_TXPRESET = 4,
+    parameter integer SYNC_STAGE      = 3                        
+)
+(
+    //-------------------------------------------------------------------------- 
+    //  Input Ports
+    //-------------------------------------------------------------------------- 
+    input                               RXEQ_CLK,                            
+    input                               RXEQ_RST_N,
+    
+    input       [ 1:0]                  RXEQ_CTRL,    
+    input       [ 2:0]                  RXEQ_PRESET,
+    input       [ 3:0]                  RXEQ_TXPRESET,
+    input       [ 5:0]                  RXEQ_TXCOEFF,
+    input       [ 5:0]                  RXEQ_LFFS,
+    
+    //-------------------------------------------------------------------------- 
+    //  Output Ports
+    //-------------------------------------------------------------------------- 
+    output                              RXEQ_LFFS_SEL, 
+    output      [17:0]                  RXEQ_NEW_TXCOEFF,
+    output                              RXEQ_ADAPT_DONE,
+    output                              RXEQ_DONE 
+);          
+    //--------------------------------------------------------------------------
+    //  Synchronized Signals
+    //--------------------------------------------------------------------------   
+    wire        [ 1:0]                  ctrl_r;
+    wire        [ 2:0]                  preset_r;
+    wire        [ 3:0]                  txpreset_r;
+    wire        [ 5:0]                  txcoeff_r;
+    wire        [ 5:0]                  lffs_r;
+
+    //--------------------------------------------------------------------------
+    //  Internal Signals
+    //--------------------------------------------------------------------------
+    reg         [ 21:0]                 adapt_cnt;
+
+    //--------------------------------------------------------------------------
+    //  FSM Signals                                                            
+    //--------------------------------------------------------------------------    
+    reg         [ 2:0]                  fsm;
+    reg         [ 3:0]                  txpreset;
+    reg         [17:0]                  txcoeff;
+    reg         [ 1:0]                  txcoeff_cnt;
+    reg                                 lffs_sel;
+    reg                                 adapt_done;
+    reg                                 adapt_2nd;
+    reg                                 done;
+   
+    //----------------------------------------------------------------------------------------------  
+    //  FSM Encoding                                                                                  
+    //----------------------------------------------------------------------------------------------                                            
+    localparam FSM_IDLE    = 3'd0; 
+    localparam FSM_PRESET  = 3'd1;                                     
+    localparam FSM_TXCOEFF = 3'd2;
+    localparam FSM_ADAPT   = 3'd3;
+    localparam FSM_DONE    = 3'd4;                                  
+
+    //--------------------------------------------------------------------------
+    //  New TX Coefficient
+    //--------------------------------------------------------------------------
+    localparam NEW_TXCOEFF = (PHY_LP_TXPRESET == 10) ? 18'd10 :
+                             (PHY_LP_TXPRESET ==  9) ? 18'd9  :
+                             (PHY_LP_TXPRESET ==  8) ? 18'd8  :
+                             (PHY_LP_TXPRESET ==  7) ? 18'd7  :
+                             (PHY_LP_TXPRESET ==  6) ? 18'd6  :                                                                     
+                             (PHY_LP_TXPRESET ==  5) ? 18'd5  :
+                             (PHY_LP_TXPRESET ==  4) ? 18'd4  :
+                             (PHY_LP_TXPRESET ==  3) ? 18'd3  :
+                             (PHY_LP_TXPRESET ==  2) ? 18'd2  :           
+                             (PHY_LP_TXPRESET ==  1) ? 18'd1  :
+                             (PHY_LP_TXPRESET ==  0) ? 18'd0  : 18'd0;   
+
+    //--------------------------------------------------------------------------
+    //  Counters (Simulation vs. Silicon)
+    //--------------------------------------------------------------------------
+    localparam ADAPT_MAX = (PHY_SIM_EN == "TRUE") ? 22'd1000 : 22'd2000000;
+  
+    
+    
+//--------------------------------------------------------------------------------------------------
+//  Input Synchronizer
+//--------------------------------------------------------------------------------------------------
+xp4_usp_smsw_sync #(.WIDTH (2), .STAGE (SYNC_STAGE)) sync_ctrl     (.CLK (RXEQ_CLK), .D (RXEQ_CTRL),     .Q (ctrl_r));
+xp4_usp_smsw_sync #(.WIDTH (3), .STAGE (SYNC_STAGE)) sync_preset   (.CLK (RXEQ_CLK), .D (RXEQ_PRESET),   .Q (preset_r));
+xp4_usp_smsw_sync #(.WIDTH (4), .STAGE (SYNC_STAGE)) sync_txpreset (.CLK (RXEQ_CLK), .D (RXEQ_TXPRESET), .Q (txpreset_r));    
+xp4_usp_smsw_sync #(.WIDTH (6), .STAGE (SYNC_STAGE)) sync_txcoeff  (.CLK (RXEQ_CLK), .D (RXEQ_TXCOEFF),  .Q (txcoeff_r));
+xp4_usp_smsw_sync #(.WIDTH (6), .STAGE (SYNC_STAGE)) sync_lffs     (.CLK (RXEQ_CLK), .D (RXEQ_LFFS),     .Q (lffs_r));            
+
+
+
+//--------------------------------------------------------------------------------------------------
+//  Adaptation Counter
+//--------------------------------------------------------------------------------------------------
+always @ (posedge RXEQ_CLK)
+begin
+
+    if (!RXEQ_RST_N)
+        begin
+        adapt_cnt <= 22'd0;
+        end
+    else
+        begin
+        
+        //----------------------------------------------------------------------
+        //  Increment Counter
+        //----------------------------------------------------------------------
+        if (fsm == FSM_ADAPT)
+            begin
+            adapt_cnt <= adapt_cnt + 22'd1;
+            end
+            
+        //----------------------------------------------------------------------
+        //  Reset Counter
+        //----------------------------------------------------------------------
+        else
+            begin
+            adapt_cnt <= 22'd0;
+            end
+
+        end
+        
+end
+
+
+
+//-------------------------------------------------------------------------------------------------- 
+//  RX Equalization FSM                                                                              
+//-------------------------------------------------------------------------------------------------- 
+always @ (posedge RXEQ_CLK)
+begin
+
+    if (!RXEQ_RST_N)
+        begin
+        fsm         <= FSM_IDLE; 
+        txpreset    <=  4'd0;
+        txcoeff     <= 18'd0;
+        txcoeff_cnt <=  2'd0;
+        lffs_sel    <=  1'd0;
+        adapt_done  <=  1'd0;
+        adapt_2nd   <=  1'd1;
+        done        <=  1'd0;
+        end                    
+    else
+        begin
+        
+        case (fsm)
+        
+        //------------------------------------------------------------------------------------------
+        //  Wait until RXEQ_CTRL != 2'b00
+        //------------------------------------------------------------------------------------------
+        FSM_IDLE :
+        
+            begin
+            
+            case (ctrl_r)
+                
+            //------------------------------------------------------------------
+            //  Idle
+            //------------------------------------------------------------------
+            2'd0 :
+            
+                begin
+                fsm         <= FSM_IDLE; 
+                txpreset    <=  4'd0;
+                txcoeff     <= 18'd0;
+                txcoeff_cnt <=  2'd0;
+                lffs_sel    <=  1'd0;
+                adapt_done  <=  1'd0;
+                adapt_2nd   <= adapt_2nd;
+                done        <=  1'd0;
+                end      
+                
+            //------------------------------------------------------------------
+            //  Preset
+            //------------------------------------------------------------------
+            2'd1 :
+            
+                begin
+                fsm         <= FSM_PRESET; 
+                txpreset    <=  4'd0;
+                txcoeff     <= 18'd0;
+                txcoeff_cnt <=  2'd0;
+                lffs_sel    <=  1'd0;
+                adapt_done  <=  1'd0;
+                adapt_2nd   <= adapt_2nd;
+                done        <=  1'd0;
+                end  
+                
+            //------------------------------------------------------------------
+            //  Coeff : Latch C(-1) and TXPRESET
+            //------------------------------------------------------------------
+            2'd2 :
+            
+                begin
+                fsm         <= FSM_TXCOEFF; 
+                txpreset    <= txpreset_r;
+                txcoeff     <= {txcoeff_r, txcoeff[17:6]};
+                txcoeff_cnt <= 2'd1;
+                lffs_sel    <= 1'd1;
+                adapt_done  <= 1'd0;
+                adapt_2nd   <= !adapt_2nd;                                      // Toggle adapt done
+                done        <= 1'd0;
+                end
+                
+            //------------------------------------------------------------------
+            //  Bypass : Latch C(-1) and TXPRESET
+            //------------------------------------------------------------------
+            2'd3 :
+            
+                begin
+                fsm         <= FSM_TXCOEFF; 
+                txpreset    <= txpreset_r;
+                txcoeff     <= {txcoeff_r, txcoeff[17:6]};
+                txcoeff_cnt <= 2'd1;
+                lffs_sel    <= 1'd1;
+                adapt_done  <= 1'd0;
+                adapt_2nd   <= 1'd1;
+                done        <= 1'd0;
+                end
+                
+            //------------------------------------------------------------------
+            //  Default
+            //------------------------------------------------------------------
+            default :
+            
+                begin
+                fsm         <= FSM_IDLE; 
+                txpreset    <=  4'd0;
+                txcoeff     <= 18'd0;
+                txcoeff_cnt <=  2'd0;
+                lffs_sel    <=  1'd0;
+                adapt_done  <=  1'd0;
+                adapt_2nd   <= adapt_2nd;
+                done        <=  1'd0;
+                end
+                
+            endcase
+            
+            end
+            
+        //------------------------------------------------------------------------------------------
+        //  Go to DONE state (RXEQ preset not supported)
+        //------------------------------------------------------------------------------------------
+        FSM_PRESET :
+        
+            begin
+            fsm         <= FSM_DONE;
+            txpreset    <=  4'd0;
+            txcoeff     <= 18'd0; 
+            txcoeff_cnt <=  2'd0;
+            lffs_sel    <=  1'd0;
+            adapt_done  <=  1'd0;
+            adapt_2nd   <= adapt_2nd;
+            done        <=  1'd0; 
+            end        
+            
+        //------------------------------------------------------------------------------------------
+        //  Latch C(0) and C(+1)
+        //------------------------------------------------------------------------------------------
+        FSM_TXCOEFF :
+        
+            begin
+            fsm         <= (txcoeff_cnt == 2'd2) ? FSM_ADAPT : FSM_TXCOEFF;
+            txpreset    <= txpreset;
+            txcoeff     <= {txcoeff_r, txcoeff[17:6]};
+            txcoeff_cnt <= txcoeff_cnt + 2'd1;
+            lffs_sel    <= 1'd0;
+            adapt_done  <= 1'd0;
+            adapt_2nd   <= adapt_2nd;
+            done        <= 1'd0; 
+            end
+   
+        //------------------------------------------------------------------------------------------
+        //  Wait for adaptation timer 
+        //------------------------------------------------------------------------------------------
+        FSM_ADAPT :
+        
+            begin            
+            fsm         <= (adapt_cnt == ADAPT_MAX) || (!adapt_2nd) ? FSM_DONE : FSM_ADAPT;
+            txpreset    <= txpreset;
+            txcoeff     <= txcoeff;
+            txcoeff_cnt <= 2'd0;
+            lffs_sel    <= 1'd0;
+            adapt_done  <= 1'd0;
+            adapt_2nd   <= adapt_2nd;
+            done        <= 1'd0;
+            end             
+             
+        //------------------------------------------------------------------------------------------
+        //  Assert RXEQ_DONE until RXEQ_CTRL == 2'd0
+        //------------------------------------------------------------------------------------------
+        FSM_DONE :
+        
+            begin
+            fsm         <= (ctrl_r == 2'd0) ? FSM_IDLE : FSM_DONE;
+            txpreset    <= txpreset;
+            txcoeff     <= txcoeff;
+            txcoeff_cnt <= 2'd0;
+            lffs_sel    <= ((ctrl_r == 2'd2) || (ctrl_r == 2'd3));
+            adapt_done  <= ((ctrl_r == 2'd2) || (ctrl_r == 2'd3)) ? adapt_2nd : 1'd0;
+            adapt_2nd   <= adapt_2nd;  
+            done        <= 1'd1;
+            end        
+                          
+        //------------------------------------------------------------------------------------------
+        //  Default State
+        //------------------------------------------------------------------------------------------
+        default : 
+        
+            begin
+            fsm         <= FSM_IDLE;
+            txpreset    <=  4'd0;
+            txcoeff     <= 18'd0;
+            txcoeff_cnt <=  2'd0;
+            lffs_sel    <=  1'd0;
+            adapt_done  <=  1'd0; 
+            adapt_2nd   <=  1'd1; 
+            done        <=  1'd0; 
+            end    
+                    
+        endcase
+        
+        end
+        
+end      
+
+
+
+//-------------------------------------------------------------------------------------------------- 
+//  RX Equalization Output                                                                           
+//-------------------------------------------------------------------------------------------------- 
+assign RXEQ_NEW_TXCOEFF = NEW_TXCOEFF;
+assign RXEQ_LFFS_SEL    = lffs_sel;
+assign RXEQ_ADAPT_DONE  = adapt_done;
+assign RXEQ_DONE        = done;
+
+
+
+endmodule
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2023 AMD, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD, Inc. and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : UltraScale+ FPGA PCI Express v4.0 Integrated Block
+// File       : xp4_usp_smsw_gt_phy_txeq.v
+// Version    : 1.1 
+//-----------------------------------------------------------------------------
+//--------------------------------------------------------------------------------------------------
+//  Design :  PCIe PHY Wrapper 
+//  Module :  TX Equalization 
+//--------------------------------------------------------------------------------------------------
+
+
+
+`timescale 1ps / 1ps
+
+
+
+//--------------------------------------------------------------------------------------------------
+//  TX Equalization Module
+//--------------------------------------------------------------------------------------------------
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_gt_phy_txeq #
+(
+    parameter integer PHY_GT_TXPRESET = 0,
+    parameter integer SYNC_STAGE    = 3
+)
+(
+    //-------------------------------------------------------------------------- 
+    //  Input Ports
+    //-------------------------------------------------------------------------- 
+    input                               TXEQ_CLK,                            
+    input                               TXEQ_RST_N,
+
+    input       [ 1:0]                  TXEQ_CTRL,    
+    input       [ 3:0]                  TXEQ_PRESET,
+    input       [ 5:0]                  TXEQ_COEFF,
+    
+    //-------------------------------------------------------------------------- 
+    //  Output Ports
+    //-------------------------------------------------------------------------- 
+    output  reg [ 4:0]                  TXEQ_PRECURSOR, 
+    output  reg [ 6:0]                  TXEQ_MAINCURSOR,
+    output  reg [ 4:0]                  TXEQ_POSTCURSOR,
+    output  reg [17:0]                  TXEQ_NEW_COEFF,
+    output  reg                         TXEQ_DONE
+);          
+    //--------------------------------------------------------------------------
+    //  Synchronized Signals
+    //-------------------------------------------------------------------------- 
+    wire        [ 1:0]                  ctrl_r; 
+    wire        [ 3:0]                  preset_r;
+    wire        [ 5:0]                  coeff_r;
+  
+    //--------------------------------------------------------------------------
+    //  Internal Signals
+    //--------------------------------------------------------------------------
+    reg         [18:0]                  preset;          
+    reg                                 preset_done;
+    
+    //--------------------------------------------------------------------------
+    //  FSM Signals                                                            
+    //--------------------------------------------------------------------------    
+    reg         [ 2:0]                  fsm;
+    reg         [18:0]                  coeff;
+    reg         [ 1:0]                  coeff_cnt;
+    reg                                 done;
+   
+    //----------------------------------------------------------------------------------------------                   
+    //  FSM Encoding                                                                               
+    //----------------------------------------------------------------------------------------------                   
+    localparam FSM_IDLE   = 3'd0; 
+    localparam FSM_PRESET = 3'd1;                                     
+    localparam FSM_COEFF  = 3'd2;
+    localparam FSM_REMAP  = 3'd3;
+    localparam FSM_QUERY  = 3'd4;                                     
+    localparam FSM_DONE   = 3'd5;
+
+    //----------------------------------------------------------------------------------------------
+    //  TX Equalization Preset 
+    //----------------------------------------------------------------------------------------------
+    //  Advertise FS = 40
+    //  Advertise LF = 12
+    //  Actual    FS = 80
+    //  Actual    LF = 24
+    //----------------------------------------------------------------------------------------------
+    //  Coefficient Rules:
+    //  * C(-1) < Floor(FS/4)
+    //  * C(-1) + C(0) + C(+1) = FS
+    //  * C(0) - C(-1) - C(+1) >= LF
+    //----------------------------------------------------------------------------------------------
+    //  TXPRECURSOR  or C(-1) should be 20 or less
+    //  TXMAINCURSOR or C( 0) should be 52 or more (automatically calcuated in GT)
+    //  TXPOSTCURSOR or C(+1) should be 28 or less
+    //----------------------------------------------------------------------------------------------                           
+    localparam TXPRECURSOR_00  = 6'd0;   // 0.0 dB
+    localparam TXMAINCURSOR_00 = 7'd58;                     
+    localparam TXPOSTCURSOR_00 = 6'd22;  // 6.0 dB
+                                         
+    localparam TXPRECURSOR_01  = 6'd0;   // 0.0 dB
+    localparam TXMAINCURSOR_01 = 7'd64;                               
+    localparam TXPOSTCURSOR_01 = 6'd16;  // 3.5 dB
+                                         
+    localparam TXPRECURSOR_02  = 6'd0;   // 0.0 dB
+    localparam TXMAINCURSOR_02 = 7'd62;                     
+    localparam TXPOSTCURSOR_02 = 6'd18;  // 4.5 dB
+                                         
+    localparam TXPRECURSOR_03  = 6'd0;   // 0.0 dB
+    localparam TXMAINCURSOR_03 = 7'd68;                     
+    localparam TXPOSTCURSOR_03 = 6'd12;  // 2.5 dB
+                                         
+    localparam TXPRECURSOR_04  = 6'd0;   // 0.0 dB
+    localparam TXMAINCURSOR_04 = 7'd80;                     
+    localparam TXPOSTCURSOR_04 = 6'd0;   // 0.0 dB
+                                         
+    localparam TXPRECURSOR_05  = 6'd8;   // 2.0 dB
+    localparam TXMAINCURSOR_05 = 7'd72;                     
+    localparam TXPOSTCURSOR_05 = 6'd0;   // 0.0 dB
+                                         
+    localparam TXPRECURSOR_06  = 6'd10;  // 2.5 dB
+    localparam TXMAINCURSOR_06 = 7'd70;                     
+    localparam TXPOSTCURSOR_06 = 6'd0;   // 0.0 dB
+                                         
+    localparam TXPRECURSOR_07  = 6'd10;  // 3.5 dB
+    localparam TXMAINCURSOR_07 = 7'd54;                     
+    localparam TXPOSTCURSOR_07 = 6'd16;  // 6.0 dB
+                                         
+    localparam TXPRECURSOR_08  = 6'd12;  // 3.5 dB
+    localparam TXMAINCURSOR_08 = 7'd56;                     
+    localparam TXPOSTCURSOR_08 = 6'd12;  // 3.5 dB
+                                         
+    localparam TXPRECURSOR_09  = 6'd14;  // 3.5 dB
+    localparam TXMAINCURSOR_09 = 7'd66;                    
+    localparam TXPOSTCURSOR_09 = 6'd0;   // 0.0 dB
+                                         
+    localparam TXPRECURSOR_10  = 6'd0;   // 0.0 dB
+    localparam TXMAINCURSOR_10 = 7'd54;                      
+    localparam TXPOSTCURSOR_10 = 6'd26;  // 9.5 dB
+    
+//--------------------------------------------------------------------------------------------------
+//  Input Synchronizer
+//--------------------------------------------------------------------------------------------------
+xp4_usp_smsw_sync #(.WIDTH (2), .STAGE (SYNC_STAGE)) sync_ctrl   (.CLK (TXEQ_CLK), .D (TXEQ_CTRL),   .Q (ctrl_r));
+xp4_usp_smsw_sync #(.WIDTH (4), .STAGE (SYNC_STAGE)) sync_preset (.CLK (TXEQ_CLK), .D (TXEQ_PRESET), .Q (preset_r));
+xp4_usp_smsw_sync #(.WIDTH (6), .STAGE (SYNC_STAGE)) sync_coeff  (.CLK (TXEQ_CLK), .D (TXEQ_COEFF),  .Q (coeff_r));
+
+
+
+//--------------------------------------------------------------------------------------------------
+//  TX Equalization Preset
+//--------------------------------------------------------------------------------------------------
+always @ (posedge TXEQ_CLK)
+begin
+
+    if (!TXEQ_RST_N)
+        begin
+        
+        //------------------------------------------------------------------
+        //  Default TX Equalization Preset                                 
+        //------------------------------------------------------------------
+        case (PHY_GT_TXPRESET)
+            4'd0    : preset <= {TXPOSTCURSOR_00, TXMAINCURSOR_00, TXPRECURSOR_00};
+            4'd1    : preset <= {TXPOSTCURSOR_01, TXMAINCURSOR_01, TXPRECURSOR_01};
+            4'd2    : preset <= {TXPOSTCURSOR_02, TXMAINCURSOR_02, TXPRECURSOR_02};
+            4'd3    : preset <= {TXPOSTCURSOR_03, TXMAINCURSOR_03, TXPRECURSOR_03};
+            4'd4    : preset <= {TXPOSTCURSOR_04, TXMAINCURSOR_04, TXPRECURSOR_04};
+            4'd5    : preset <= {TXPOSTCURSOR_05, TXMAINCURSOR_05, TXPRECURSOR_05};
+            4'd6    : preset <= {TXPOSTCURSOR_06, TXMAINCURSOR_06, TXPRECURSOR_06};
+            4'd7    : preset <= {TXPOSTCURSOR_07, TXMAINCURSOR_07, TXPRECURSOR_07};
+            4'd8    : preset <= {TXPOSTCURSOR_08, TXMAINCURSOR_08, TXPRECURSOR_08};      
+            4'd9    : preset <= {TXPOSTCURSOR_09, TXMAINCURSOR_09, TXPRECURSOR_09};   
+            4'd10   : preset <= {TXPOSTCURSOR_10, TXMAINCURSOR_10, TXPRECURSOR_10};                 
+            default : preset <= {TXPOSTCURSOR_00, TXMAINCURSOR_00, TXPRECURSOR_00};   
+        endcase	       
+        
+        preset_done <= 1'd0;
+        end                    
+    else
+        begin   
+        if (fsm == FSM_PRESET)
+            begin    
+                
+            //------------------------------------------------------------------
+            //  Update TX Equalization Preset
+            //------------------------------------------------------------------
+            case (preset_r)
+                4'd0    : preset <= {TXPOSTCURSOR_00, TXMAINCURSOR_00, TXPRECURSOR_00};
+                4'd1    : preset <= {TXPOSTCURSOR_01, TXMAINCURSOR_01, TXPRECURSOR_01};
+                4'd2    : preset <= {TXPOSTCURSOR_02, TXMAINCURSOR_02, TXPRECURSOR_02};
+                4'd3    : preset <= {TXPOSTCURSOR_03, TXMAINCURSOR_03, TXPRECURSOR_03};
+                4'd4    : preset <= {TXPOSTCURSOR_04, TXMAINCURSOR_04, TXPRECURSOR_04};
+                4'd5    : preset <= {TXPOSTCURSOR_05, TXMAINCURSOR_05, TXPRECURSOR_05};
+                4'd6    : preset <= {TXPOSTCURSOR_06, TXMAINCURSOR_06, TXPRECURSOR_06};
+                4'd7    : preset <= {TXPOSTCURSOR_07, TXMAINCURSOR_07, TXPRECURSOR_07};
+                4'd8    : preset <= {TXPOSTCURSOR_08, TXMAINCURSOR_08, TXPRECURSOR_08};      
+                4'd9    : preset <= {TXPOSTCURSOR_09, TXMAINCURSOR_09, TXPRECURSOR_09}; 
+                4'd10   : preset <= {TXPOSTCURSOR_10, TXMAINCURSOR_10, TXPRECURSOR_10};                   
+                default : preset <= {TXPOSTCURSOR_00, TXMAINCURSOR_00, TXPRECURSOR_00};    
+            endcase
+              
+            preset_done <= 1'd1;
+            end
+        else
+            begin
+            preset      <= preset;
+            preset_done <= 1'd0;
+            end
+        end
+        
+end     
+
+
+
+//--------------------------------------------------------------------------------------------------
+//  TX Equalization FSM
+//--------------------------------------------------------------------------------------------------
+always @ (posedge TXEQ_CLK)
+begin
+
+    if (!TXEQ_RST_N)
+        begin
+        fsm       <= FSM_IDLE; 
+        coeff     <= preset;
+        coeff_cnt <= 2'd0;
+        done      <= 1'd0;
+        end                    
+    else
+        begin
+        
+        case (fsm)
+        
+        //------------------------------------------------------------------------------------------
+        //  Wait until TXEQ_CTRL != 2'b00
+        //------------------------------------------------------------------------------------------
+        FSM_IDLE :
+        
+            begin
+            done <= 1'd0;
+            
+            case (ctrl_r)
+            
+            //------------------------------------------------------------------
+            //  Idle
+            //------------------------------------------------------------------
+            2'd0 :
+            
+                begin
+                fsm       <= FSM_IDLE; 
+                coeff     <= coeff;
+                coeff_cnt <= 2'd0;
+                end 
+                
+            //------------------------------------------------------------------
+            //  Preset
+            //------------------------------------------------------------------
+            2'd1 :
+            
+                begin
+                fsm       <= FSM_PRESET; 
+                coeff     <= coeff;
+                coeff_cnt <= 2'd0;
+                end  
+                
+            //------------------------------------------------------------------
+            //  Coeff : Latch C(-1) 
+            //------------------------------------------------------------------
+            2'd2 :
+            
+                begin
+                fsm       <= FSM_COEFF; 
+                coeff     <= {coeff_r, coeff[18:6]};
+                coeff_cnt <= 2'd1;
+                end
+                
+            //------------------------------------------------------------------
+            //  Query
+            //------------------------------------------------------------------
+            2'd3 :
+            
+                begin
+                fsm       <= FSM_QUERY; 
+                coeff     <= coeff;
+                coeff_cnt <= 2'd0;
+                end
+                
+            //------------------------------------------------------------------
+            //  Stay in IDLE state (Default)
+            //------------------------------------------------------------------
+            default :
+            
+                begin
+                fsm       <= FSM_IDLE; 
+                coeff     <= coeff;
+                coeff_cnt <= 2'd0;
+                end
+                
+            endcase
+            
+            end
+            
+        //------------------------------------------------------------------------------------------
+        //  Wait for TXEQ preset done
+        //------------------------------------------------------------------------------------------
+        FSM_PRESET :
+        
+            begin
+            fsm       <= preset_done ? FSM_DONE : FSM_PRESET;
+            coeff     <= preset;
+            coeff_cnt <= 2'd0;
+            done      <= 1'd0;
+            end    
+            
+        //------------------------------------------------------------------------------------------
+        //  Latch C(0) and C(+1)
+        //------------------------------------------------------------------------------------------
+        FSM_COEFF :
+        
+            begin
+            fsm <= (coeff_cnt == 2'd2) ? FSM_REMAP : FSM_COEFF;
+            
+            //------------------------------------------------------------------
+            //  Shift in one extra bit for TXMAINCURSOR
+            //------------------------------------------------------------------
+            if (coeff_cnt == 2'd1)
+                coeff <= {1'd0, coeff_r, coeff[18:7]};
+            else
+                coeff <= {coeff_r, coeff[18:6]};
+                
+            coeff_cnt <= coeff_cnt + 2'd1;
+            done      <= 1'd0; 
+            end
+            
+        //------------------------------------------------------------------------------------------
+        //  Multiply coefficient by 2x
+        //------------------------------------------------------------------------------------------
+        FSM_REMAP :
+        
+            begin
+            fsm       <= FSM_DONE;
+            coeff     <= coeff << 1;        
+            coeff_cnt <= 2'd0;
+            done      <= 1'd0; 
+            end
+            
+        //------------------------------------------------------------------------------------------
+        //  Query to display current TXEQ_NEW_COEFF
+        //------------------------------------------------------------------------------------------
+        FSM_QUERY:
+        
+            begin
+            fsm       <= FSM_DONE;
+            coeff     <= coeff; 
+            coeff_cnt <= 2'd0;
+            done      <= 1'd0;
+            end     
+                  
+        //------------------------------------------------------------------------------------------
+        //  Assert TXEQ_DONE until TXEQ_CTRL == 2'd0
+        //------------------------------------------------------------------------------------------
+        FSM_DONE :
+        
+            begin
+            fsm       <= (ctrl_r == 2'd0) ? FSM_IDLE : FSM_DONE;
+            coeff     <= coeff;          
+            coeff_cnt <= 2'd0;
+            done      <= 1'd1;
+            end        
+                          
+        //------------------------------------------------------------------------------------------
+        //  Default State
+        //------------------------------------------------------------------------------------------
+        default : 
+        
+            begin
+            fsm       <= FSM_IDLE;
+            coeff     <= 19'd0; 
+            coeff_cnt <=  2'd0;
+            done      <=  1'd0;
+            end    
+                    
+        endcase
+        
+        end
+        
+end  
+
+
+
+//-------------------------------------------------------------------------------------------------- 
+//  TX Equalization Output Register                                                                               
+//-------------------------------------------------------------------------------------------------- 
+always @ (posedge TXEQ_CLK)
+begin
+
+    if (!TXEQ_RST_N)
+        begin
+        TXEQ_PRECURSOR        <= coeff[ 4: 0];  
+        TXEQ_MAINCURSOR       <= coeff[12: 6]; 
+        TXEQ_POSTCURSOR       <= coeff[17:13];
+        TXEQ_NEW_COEFF[17:12] <= {1'd0, coeff[18:14]};
+        TXEQ_NEW_COEFF[11: 6] <= coeff[12:7]; 
+        TXEQ_NEW_COEFF[ 5: 0] <= {1'd0, coeff[5:1]}; 
+        TXEQ_DONE             <= 1'd0;
+        end
+    else           
+        begin
+        TXEQ_DONE <= done;
+        
+        //----------------------------------------------------------------------
+        //  Divide TXEQ_NEW_COEFF by 2x and update output
+        //----------------------------------------------------------------------
+        if (fsm == FSM_DONE)
+            begin
+            TXEQ_PRECURSOR        <= coeff[ 4: 0]; 
+            TXEQ_MAINCURSOR       <= coeff[12: 6]; 
+            TXEQ_POSTCURSOR       <= coeff[17:13];
+            TXEQ_NEW_COEFF[17:12] <= {1'd0, coeff[18:14]};
+            TXEQ_NEW_COEFF[11: 6] <= coeff[12:7]; 
+            TXEQ_NEW_COEFF[ 5: 0] <= {1'd0, coeff[5:1]}; 
+            end
+            
+        //----------------------------------------------------------------------
+        //  Hold output
+        //----------------------------------------------------------------------    
+        else
+            begin
+            TXEQ_PRECURSOR        <= TXEQ_PRECURSOR;  
+            TXEQ_MAINCURSOR       <= TXEQ_MAINCURSOR; 
+            TXEQ_POSTCURSOR       <= TXEQ_POSTCURSOR; 
+            TXEQ_NEW_COEFF[17:12] <= TXEQ_NEW_COEFF[17:12];
+            TXEQ_NEW_COEFF[11: 6] <= TXEQ_NEW_COEFF[11: 6];
+            TXEQ_NEW_COEFF[ 5: 0] <= TXEQ_NEW_COEFF[ 5: 0];
+            end
+            
+        end    
+        
+end
+
+
+
+endmodule
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2023 AMD, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD, Inc. and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : UltraScale+ FPGA PCI Express v4.0 Integrated Block
+// File       : xp4_usp_smsw_gt_receiver_detect_rxterm.v
+// Version    : 1.1 
+//-----------------------------------------------------------------------------
+//------------------------------------------------------------------------------
+//  Filename     :  diablo_gt_receiver_detect_rxterm.v
+//  Description  :  
+//  Version      :  
+//------------------------------------------------------------------------------
+
+
+
+`timescale 1ns / 1ps
+
+
+
+//-------------------------------------------------------------
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_gt_receiver_detect_rxterm #
+(
+    parameter SYNC_STAGE       = 3, 
+    parameter CONSECUTIVE_CYCLE_OF_RXELECIDLE = 64
+)
+(
+    
+    //---------- Input -------------------------------------
+    input               RXTERM_CLK, 
+    input               RXTERM_RST_N, 
+    input               RXTERM_RXELECIDLE, 
+    input               RXTERM_MAC_IN_DETECT,
+    
+    //---------- Output ------------------------------------
+    output              RXTERM_RXTERMINATION,
+    output      [ 6:0]  RXTERM_FSM
+);
+    
+    //---------- Internal Signals --------------------------
+    reg                 rxelecidle_deasserted = 1'b0;
+    
+    //---------- Output Registers --------------------------
+    reg         [ 2:0]  ctrl_fsm =  0;
+    reg                 rxelecidle_int = 0;
+    
+    reg        [6:0]    rxelecidle_cycle_count;
+    reg                 rxtermination = 0;
+
+    wire        ctrl_fsm_not_in_solid_deassert;
+    
+    //---------- Control FSM ------------------------------------
+    localparam          FSM_CTRL_IDLE                         = 0;
+    localparam          FSM_ASSERT_AVTT                       = 1;
+    localparam          FSM_CHECK_RXELECIDLE_ASSERTED         = 2; 
+    localparam          FSM_CHECK_RXELECIDLE_SOLID_DEASSERT   = 3;
+    localparam          FSM_ASSERT_PROG                       = 4;
+
+    //--------------------------------------------------------------------------
+    //  Synchronized Signals
+    //--------------------------------------------------------------------------                                  
+    wire                rxelecidle_a;
+    wire                mac_in_detect_a;
+    
+    reg   [1:0]         rxelecidle_r;
+    reg   [1:0]         mac_in_detect_r;
+
+  xp4_usp_smsw_sync #(.WIDTH (1), .STAGE (SYNC_STAGE)) sync_rxelecidle (.CLK (RXTERM_CLK), .D (RXTERM_RXELECIDLE), .Q (rxelecidle_a));
+  xp4_usp_smsw_sync #(.WIDTH (1), .STAGE (SYNC_STAGE)) sync_mac_in_detect (.CLK (RXTERM_CLK), .D (RXTERM_MAC_IN_DETECT), .Q (mac_in_detect_a));
+
+  always @ (posedge RXTERM_CLK) 
+  begin
+    if (!RXTERM_RST_N) begin
+      mac_in_detect_r <= 2'd3;
+      rxelecidle_r <= 2'd3;
+    end 
+    else begin 
+        rxelecidle_r <= {rxelecidle_r[0], rxelecidle_a}; 
+        mac_in_detect_r <= {mac_in_detect_r[0], mac_in_detect_a};
+    end
+  end 
+  
+  always @ (posedge RXTERM_CLK) 
+  begin 
+    if (ctrl_fsm_not_in_solid_deassert) begin
+      rxelecidle_cycle_count <= 7'd0;
+    end 
+    else begin
+      if (!rxelecidle_a)
+        rxelecidle_cycle_count <= rxelecidle_cycle_count + 7'd1;        
+      else 
+        rxelecidle_cycle_count <= 7'd0;
+    end
+  end
+  
+  always @(posedge RXTERM_CLK)
+  begin 
+    if (ctrl_fsm_not_in_solid_deassert) begin
+      rxelecidle_int <= 1'b0;
+    end 
+    else begin
+      if (rxelecidle_cycle_count > CONSECUTIVE_CYCLE_OF_RXELECIDLE)
+        rxelecidle_int <= 1'b1;
+      else 
+        rxelecidle_int <= rxelecidle_int;
+    end
+  end
+  
+  //---------- FSM to determine when to change RX termination  --------------------
+  // counter for rxelecidle. filter for consecutive #, x cycles (parameter) drive our own rxelecidle into state machine. 
+  // 
+  always @ (posedge RXTERM_CLK) 
+  begin 
+    if (!RXTERM_RST_N) begin
+      ctrl_fsm   <= FSM_ASSERT_AVTT;
+      rxtermination <= 1'b1;
+    end
+    else begin
+    
+      case (ctrl_fsm)
+      
+          //---------- Idle State ----------------------------
+          FSM_CTRL_IDLE :  
+            
+              begin
+              //----------------------------------------------
+              if (!mac_in_detect_r[1]&mac_in_detect_r[0])
+                  begin
+                    ctrl_fsm  <= FSM_ASSERT_AVTT;
+                    rxtermination <= 1'b1;
+                  end
+              //---------- Idle ------------------------------
+              else      
+                  begin
+                    ctrl_fsm   <= FSM_CTRL_IDLE;
+                    rxtermination <= 1'b0;
+                  end
+              end
+              
+          //---------- Assert AVTT TERMINATION ----------------
+          FSM_ASSERT_AVTT :
+          
+              begin
+                ctrl_fsm <= FSM_CHECK_RXELECIDLE_ASSERTED;
+                rxtermination <= 1'b1;
+              end
+          
+          //---------- Check RXELECIDLE is asserted --------------------
+          FSM_CHECK_RXELECIDLE_ASSERTED : 
+          
+            begin 
+              ctrl_fsm <= rxelecidle_a ? FSM_CHECK_RXELECIDLE_SOLID_DEASSERT : FSM_CHECK_RXELECIDLE_ASSERTED;
+              rxtermination <= rxtermination;
+            end
+          
+          //---------- Wait for RXELECIDELE SOLID DEASSERT and not in mac_in_detect --------------- 
+          
+          FSM_CHECK_RXELECIDLE_SOLID_DEASSERT:
+          
+              begin
+                ctrl_fsm <= (rxelecidle_int&!mac_in_detect_a) ? FSM_ASSERT_PROG : FSM_CHECK_RXELECIDLE_SOLID_DEASSERT;
+                rxtermination <= rxtermination;
+              end
+
+          //---------- ASSERT PROG TERMINATION -------------- 
+          
+          FSM_ASSERT_PROG:
+          
+              begin 
+                ctrl_fsm <= FSM_CTRL_IDLE;
+                rxtermination <= 1'b0;
+              end
+              
+          //---------- Default State -------------------------
+          default :
+          
+              begin      
+              ctrl_fsm   <= FSM_CTRL_IDLE;
+              rxtermination <= 1'b0;
+              end
+              
+          endcase
+        end
+  end
+  
+  assign ctrl_fsm_not_in_solid_deassert = (ctrl_fsm != FSM_CHECK_RXELECIDLE_SOLID_DEASSERT);
+  assign RXTERM_RXTERMINATION = rxtermination;
+
+
+endmodule
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2023 AMD, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD, Inc. and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : UltraScale+ FPGA PCI Express v4.0 Integrated Block
+// File       : xp4_usp_smsw_sync_cell.v
+// Version    : 1.1 
+//-----------------------------------------------------------------------------
+//--------------------------------------------------------------------------------------------------
+//  Design :  PHY Wrapper
+//  Module :  Synchronizer & Pipelining Cell
+//--------------------------------------------------------------------------------------------------
+
+`timescale 1ps / 1ps
+
+//--------------------------------------------------------------------------------------------------
+//  Synchronizer & Pipelining Cell 
+//--------------------------------------------------------------------------------------------------
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_sync_cell #
+(
+    parameter integer STAGE = 3
+)
+(
+    //-------------------------------------------------------------------------- 
+    //  Input Ports
+    //-------------------------------------------------------------------------- 
+    input                               CLK,
+    input                               D,
+    
+    //-------------------------------------------------------------------------- 
+    //  Output Ports
+    //-------------------------------------------------------------------------- 
+    output                              Q
+);
+    //-------------------------------------------------------------------------- 
+    //  Synchronized Signals
+    //--------------------------------------------------------------------------  
+    (* ASYNC_REG = "TRUE", SHIFT_EXTRACT = "NO" *) reg [STAGE:0] sync;                                                            
+
+
+
+//--------------------------------------------------------------------------------------------------
+//  Synchronizier
+//--------------------------------------------------------------------------------------------------
+always @ (posedge CLK)
+begin
+
+    sync <= {sync[(STAGE-1):0], D};
+            
+end   
+
+
+
+//--------------------------------------------------------------------------------------------------
+//  Generate Output
+//--------------------------------------------------------------------------------------------------
+assign Q = sync[STAGE];
+
+
+
+endmodule
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2023 AMD, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD, Inc. and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : UltraScale+ FPGA PCI Express v4.0 Integrated Block
+// File       : xp4_usp_smsw_sync.v
+// Version    : 1.1 
+//-----------------------------------------------------------------------------
+//--------------------------------------------------------------------------------------------------
+//  Design :  PHY Wrapper
+//  Module :  PHY Synchronizer & Pipelining 
+//--------------------------------------------------------------------------------------------------
+
+`timescale 1ps / 1ps
+
+//--------------------------------------------------------------------------------------------------
+//  PHY Synchronizer & Pipelining Module
+//--------------------------------------------------------------------------------------------------
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_sync #
+(
+    parameter integer WIDTH = 1, 
+    parameter integer STAGE = 3
+)
+(
+    //-------------------------------------------------------------------------- 
+    //  Input Ports
+    //-------------------------------------------------------------------------- 
+    input                               CLK,
+    input       [WIDTH-1:0]             D,
+    
+    //-------------------------------------------------------------------------- 
+    //  Output Ports
+    //-------------------------------------------------------------------------- 
+    output      [WIDTH-1:0]             Q
+);                                                        
+
+
+
+//--------------------------------------------------------------------------------------------------
+//  Generate Synchronizer - Begin
+//--------------------------------------------------------------------------------------------------
+genvar i;
+
+generate for (i=0; i<WIDTH; i=i+1) 
+
+    begin : sync_vec
+
+    //----------------------------------------------------------------------
+    //  Synchronizer
+    //----------------------------------------------------------------------
+    xp4_usp_smsw_sync_cell #
+    (
+        .STAGE                          (STAGE)
+    )    
+    sync_cell_i
+    (
+        //------------------------------------------------------------------
+        //  Input Ports
+        //------------------------------------------------------------------
+        .CLK                            (CLK),
+        .D                              (D[i]),
+
+        //------------------------------------------------------------------
+        //  Output Ports
+        //------------------------------------------------------------------
+        .Q                              (Q[i])
+    );
+ 
+    end   
+      
+endgenerate 
+//--------------------------------------------------------------------------------------------------
+//  Generate - End
+//--------------------------------------------------------------------------------------------------
+
+
+
+endmodule
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2023 AMD, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD, Inc. and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : UltraScale+ FPGA PCI Express v4.0 Integrated Block
+// File       : xp4_usp_smsw_sys_clk_gen_ps.v
+// Version    : 1.1 
+//-----------------------------------------------------------------------------
+//-----------------------------------------------------------------------------
+//
+// Project    : Ultrascale FPGA Gen4 Integrated Block for PCI Express
+// File       : sys_clk_gen_ps.v
+// Desc       : This file is same as sys_clk_gen.v            
+// Version    : 1.0 
+//-----------------------------------------------------------------------------
+
+`timescale 1ps/1ps
+
+module xp4_usp_smsw_sys_clk_gen_ps (sys_clk);
+
+output	sys_clk;
+
+reg		sys_clk;
+
+parameter        offset = 0;
+parameter        halfcycle = 500;
+
+initial begin
+
+	sys_clk = 0;
+	#(offset);
+
+	forever #(halfcycle) sys_clk = ~sys_clk;
+
+end
+
+endmodule // sys_clk_gen_ps
+
+
+
+
+//--------------------------------------------------------------------------------------------------
+`timescale 1ps/1ps
+
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_model_init_ctrl #(
+     parameter           TCQ = 100
+   , parameter           PL_UPSTREAM_FACING = "TRUE"
+   , parameter           IS_SWITCH_PORT = "FALSE"
+   , parameter           CRM_CORE_CLK_FREQ_500="TRUE"
+   , parameter [1:0]     CRM_USER_CLK_FREQ=2'b10
+)(
+  input  wire         core_clk_i,
+  input  wire         user_clk_i,
+  input  wire         phy_rdy_i,
+  input  wire         cfg_hot_reset_in_i,
+  input  wire         cfg_phy_link_down_i,
+  output reg          cfg_phy_link_down_user_clk_o,
+  output wire   [2:0] state_o,
+
+  (* keep = "true", max_fanout = 1000 *) output reg          reset_n_o,
+  (* keep = "true", max_fanout = 1000 *) output reg          core_reset_n_o,
+  output wire                                                pipe_reset_n_o,
+  (* keep = "true", max_fanout = 1000 *) output reg          mgmt_reset_n_o,
+  (* keep = "true", max_fanout = 1000 *) output reg          mgmt_sticky_reset_n_o,
+
+  output wire         user_clk_en_o,
+  output wire         user_clkgate_en_o
+  );
+
+   localparam STATE_RESET   = 3'b000;
+   localparam STATE_MGMT_RESET_DEASSERT = 3'b001;
+   localparam STATE_PHY_RDY = 3'b100;
+   localparam STATE_RESET_DEASSERT = 3'b101;
+   
+   localparam CLK_QUARTER0  = 3'b0_00; // core=250, user=62.5, user2 = 62.5 
+   localparam CLK_HALF0     = 3'b0_01; // core=250, user=125,  user2 = 125
+   localparam CLK_EQUAL0    = 3'b0_10; // core=250, user=250,  user2 = 250
+   localparam CLK_INVALID0  = 3'b0_11; // core=250, user=250,  user2 = 500
+   localparam CLK_INVALID1  = 3'b1_00; // core=500, user=62.5, user2 = 62.5
+   localparam CLK_QUARTER1  = 3'b1_01; // core=500, user=125,  user2 = 125
+   localparam CLK_HALF1     = 3'b1_10; // core=500, user=250,  user2 = 250
+   localparam CLK_HALF2     = 3'b1_11; // core=500, user=250,  user2 = 500
+
+   reg           [2:0] reg_state;
+   reg           [2:0] reg_next_state;
+(* ASYNC_REG = "TRUE", SHIFT_EXTRACT = "NO" *)    reg           [1:0] reg_phy_rdy = 2'b00; 
+   reg           [1:0] reg_cold_reset = 2'b11;
+   reg                 reg_reset_n_o;
+   reg                 reg_pipe_reset_n_o;
+   reg                 reg_mgmt_reset_n_o;
+   reg                 reg_mgmt_sticky_reset_n_o;
+   reg           [1:0] reg_reset_timer;
+   wire          [2:0] state_w;
+   wire          [2:0] next_state_w;
+   wire                phy_rdy;
+   wire                cold_reset_n;
+   wire          [1:0] reset_timer_w;
+   wire                attr_pl_upstream_facing;
+   wire                attr_is_switch_port;
+
+   wire 	       attr_crm_core_clk_freq_500;
+   wire [1:0] 	       attr_crm_user_clk_freq;
+   wire 	       user2_eq_core;
+   reg [1:0] 	       counter;
+   
+   (* keep = "true", max_fanout = 1000 *) reg 		       user_clk_en_int;
+   
+   reg 		       user_clkgate_en_int;
+   
+      
+   assign attr_crm_core_clk_freq_500 = (CRM_CORE_CLK_FREQ_500 == "TRUE") ? 1'b1 : 1'b0;
+   assign attr_crm_user_clk_freq = CRM_USER_CLK_FREQ[1:0];
+				       
+   wire [2:0]  coreuser_clk_ratio  = {attr_crm_core_clk_freq_500, attr_crm_user_clk_freq};
+
+  // common values for {attr_crm_core_clk_freq_500, attr_crm_user_clk_freq}
+  // attr_crm_core_clk_freq_500,
+  // 0 == 250, 1 == 500
+  // attr_crm_user_clk_freq,
+  // 0 = 62.5/62.5, 1 = 125/125, 2 = 250/250, 3 = 250/500
+  //---------------------------------------------------
+  // ratios: c:u(:u2)
+  // 0/0 250:62.5(62.5)  -> 1/4(/4) CLK_QUARTER0       // user2_eq_core == 0
+  // 0/1 250:125 (125)   -> 1/2(/2) CLK_HALF0          // user2_eq_core == 0
+  // 0/2 250:250 (250)   -> 1/1(/1) CLK_EQUAL0         // user2_eq_core == 0
+  // 0/3 250:250 (500)   -> 1/1(x2) CLK_INVALID0/EQUAL // user2_eq_core == 1
+  // 1/0 500:62.5(62.5)  -> 1/8(/8) CLK_INVALID1/EQUAL // user2_eq_core == 0
+  // 1/1 500:125 (125)   -> 1/4(/4) CLK_QUARTER1       // user2_eq_core == 0
+  // 1/2 500:250 (250)   -> 1/2(/2) CLK_HALF1          // user2_eq_core == 0
+  // 1/3 500:250 (500)   -> 1/2(/1) CLK_HALF2          // user2_eq_core == 1
+   
+   // user2_eq_core high when user_clk2 is equal to core_clk (and faster than user_clk) else equal to user_clk
+   //OBSOLETE// assign user2_eq_core = {attr_crm_user_clk_freq == 2'b11};
+      
+   // when user2_clk is same as core_clk assign coreuser2_clk_ratio to EQUAL, else
+   // user2_clk is same as user_clk so use the coreuser_clk_ratio
+   //OBSOLETE// wire [2:0]  coreuser2_clk_ratio = user2_eq_core ? CLK_EQUAL0 : coreuser_clk_ratio;
+
+
+  always @(posedge core_clk_i or negedge mgmt_reset_n_o) begin
+
+    // hold the count during power-on reset
+    if (!mgmt_reset_n_o) begin
+      user_clkgate_en_int  <= #TCQ 1'b0;
+      user_clk_en_int      <= #TCQ 1'b0;
+      counter              <= #TCQ 2'h0;
+    // normal free-running operation
+    end else begin
+      // counter always increments and rolls over, no matter the ratio
+      counter <= #TCQ counter + 1;
+
+      // Choose the valid based on the table above
+      case (coreuser_clk_ratio)
+        CLK_HALF0, CLK_HALF1, CLK_HALF2: begin
+	   // one core_clk cycle advanced for _e4 input
+          user_clkgate_en_int <= #TCQ counter[0];
+          user_clk_en_int     <= #TCQ !counter[0];
+        end
+        CLK_QUARTER0, CLK_QUARTER1: begin
+	   // one core_clk cycle advanced for _e4 input 
+          user_clkgate_en_int <= #TCQ (counter == 2'h1);
+          user_clk_en_int     <= #TCQ (counter == 2'h2);
+        end
+        default: begin  // and CLK_EQUAL* case which ties off to high
+          user_clkgate_en_int <= #TCQ 1'b1;
+          user_clk_en_int     <= #TCQ 1'b1;
+        end
+      endcase
+
+    end
+
+  end
+  //  user_clk_en generation
+ 
+  assign attr_pl_upstream_facing = (PL_UPSTREAM_FACING == "TRUE") ? 1'b1 : 1'b0 ;
+  assign attr_is_switch_port     = (IS_SWITCH_PORT == "TRUE") ? 1'b1 : 1'b0 ;
+
+  // Generate PHY Ready
+
+  always @(posedge user_clk_i)
+  begin
+    reg_phy_rdy[1:0] <= #TCQ {reg_phy_rdy[0], phy_rdy_i};
+  end
+
+  assign phy_rdy = reg_phy_rdy[1];
+  
+   // Generate Cold reset
+
+  always @(posedge user_clk_i)
+  begin
+    if (!phy_rdy && reg_cold_reset[1] )
+      reg_cold_reset[1:0] <= #TCQ 2'b11;
+    else
+      reg_cold_reset[1:0] <= #TCQ {reg_cold_reset[0], 1'b0};
+  end
+
+  assign cold_reset_n = !reg_cold_reset[1];
+  
+  // Reset Timer
+  
+  always @(posedge user_clk_i)
+  begin
+    if (!phy_rdy_i)
+        reg_reset_timer <= #TCQ 2'b00;
+    else if ((state_w == STATE_MGMT_RESET_DEASSERT) && (reset_timer_w != 2'b11))
+        reg_reset_timer <= #TCQ reset_timer_w + 1'b1;
+    else
+        reg_reset_timer <= #TCQ reset_timer_w;    
+  end
+  
+  
+  // Reset SM
+  
+  always @(posedge user_clk_i or negedge cold_reset_n)
+  begin
+    if (!cold_reset_n)
+      reg_state <= #TCQ STATE_RESET;
+    else
+      reg_state <= #TCQ reg_next_state;
+  end
+  
+  always @* begin
+
+    if (attr_pl_upstream_facing) begin // Design is a Upstream Port 
+
+      reg_next_state = STATE_RESET;
+      reg_mgmt_reset_n_o = 1'b1;
+      reg_mgmt_sticky_reset_n_o = 1'b1;
+      reg_reset_n_o = 1'b0;
+      reg_pipe_reset_n_o = 1'b0;
+      case (state_w)
+        STATE_RESET:
+        begin
+          reg_mgmt_reset_n_o = 1'b0;
+          reg_mgmt_sticky_reset_n_o = 1'b0;
+          if (phy_rdy)
+            reg_next_state = STATE_MGMT_RESET_DEASSERT;
+          else
+            reg_next_state = STATE_RESET;
+          end
+        STATE_MGMT_RESET_DEASSERT:
+        begin
+          if (reset_timer_w == 2'b11)
+          reg_next_state = STATE_RESET_DEASSERT;
+          else
+          reg_next_state = STATE_MGMT_RESET_DEASSERT;
+        end
+        STATE_RESET_DEASSERT:
+        begin
+          reg_reset_n_o = 1'b1;
+          reg_pipe_reset_n_o = 1'b1;
+          if (!phy_rdy)
+            reg_next_state = STATE_RESET;
+          else
+            reg_next_state = STATE_RESET_DEASSERT;
+            end
+      endcase
+
+    end else  begin // Design is a Downstream Port
+      
+      reg_next_state = STATE_RESET;
+      reg_mgmt_reset_n_o = 1'b1;
+      reg_mgmt_sticky_reset_n_o = 1'b1;
+      reg_reset_n_o = 1'b0;
+      reg_pipe_reset_n_o = 1'b0;
+      case (state_w)
+        STATE_RESET:
+        begin
+          reg_mgmt_reset_n_o = 1'b0;
+          reg_mgmt_sticky_reset_n_o = 1'b0;
+          if (phy_rdy)
+            reg_next_state = STATE_MGMT_RESET_DEASSERT;
+          else
+            reg_next_state = STATE_RESET;
+        end
+        STATE_MGMT_RESET_DEASSERT:
+        begin
+          if (reset_timer_w == 2'b11)
+            reg_next_state = STATE_PHY_RDY;
+          else
+            reg_next_state = STATE_MGMT_RESET_DEASSERT;
+          end
+        STATE_PHY_RDY:
+        begin
+          if (phy_rdy)
+            reg_next_state = STATE_RESET_DEASSERT;
+          else
+            reg_next_state = STATE_PHY_RDY;
+        end
+        STATE_RESET_DEASSERT:
+        begin
+          reg_reset_n_o = 1'b1;
+          reg_pipe_reset_n_o = 1'b1;
+          if (!phy_rdy)
+            reg_next_state = STATE_PHY_RDY;
+          else if (attr_is_switch_port && cfg_hot_reset_in_i) begin  // Downstream Port Only
+            reg_next_state = STATE_RESET_DEASSERT;
+            reg_mgmt_reset_n_o = 1'b0;  
+          end else
+            reg_next_state = STATE_RESET_DEASSERT;
+        end
+      endcase
+     
+    end
+
+  end // 
+
+  // Reset registers pipeline
+
+  (* keep = "true", max_fanout = 1000 *) reg reg_reset_n_2;
+  (* keep = "true", max_fanout = 1000 *) reg mgmt_reset_n_2;
+  (* keep = "true", max_fanout = 1000 *) reg mgmt_sticky_reset_n_2;
+  
+  always @(posedge user_clk_i or negedge phy_rdy)
+  begin
+    if (!phy_rdy)
+    begin
+      reg_reset_n_2         <= #TCQ 1'b0;
+      mgmt_reset_n_2        <= #TCQ 1'b0;
+      mgmt_sticky_reset_n_2 <= #TCQ 1'b0;
+      
+      reset_n_o             <= #TCQ 1'b0;
+      mgmt_reset_n_o        <= #TCQ 1'b0;
+      mgmt_sticky_reset_n_o <= #TCQ 1'b0;
+    end
+    else
+    begin
+      reg_reset_n_2         <= #TCQ reg_reset_n_o;
+      mgmt_reset_n_2        <= #TCQ reg_mgmt_reset_n_o;
+      mgmt_sticky_reset_n_2 <= #TCQ reg_mgmt_sticky_reset_n_o;
+      
+      reset_n_o             <= #TCQ reg_reset_n_2;
+      mgmt_reset_n_o        <= #TCQ mgmt_reset_n_2;
+      mgmt_sticky_reset_n_o <= #TCQ mgmt_sticky_reset_n_2;
+    end
+  end
+
+   // Time reset_n_o to the core_clk domain
+  (* keep = "true", max_fanout = 1000 *) (* ASYNC_REG = "true" *) reg reset_n_core_clk_ff;
+
+  always @(posedge core_clk_i) begin
+      reset_n_core_clk_ff  <= #TCQ reset_n_o;
+      core_reset_n_o       <= #TCQ reset_n_core_clk_ff;
+  end
+
+   assign state_w = reg_state;
+   assign next_state_w = reg_next_state;
+   assign pipe_reset_n_o = reg_pipe_reset_n_o;
+   assign state_o = reg_state;
+   assign reset_timer_w = reg_reset_timer;
+
+   assign user_clkgate_en_o  = user_clkgate_en_int;
+
+   assign user_clk_en_o  = user_clk_en_int;
+
+
+     // Retime cfg_phy_link_down to user clock
+
+  always @(posedge user_clk_i or negedge phy_rdy)
+  begin
+    if (!phy_rdy)
+      cfg_phy_link_down_user_clk_o <= #TCQ 1'b1;
+    else
+      cfg_phy_link_down_user_clk_o <= #TCQ cfg_phy_link_down_i;
+  end
+
+
+endmodule
+/////////////////////////////////////////////////////////////////////////////
+
+`timescale 1ps/1ps
+
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_model_pipe 
+#(
+     parameter           TCQ = 100
+   , parameter           IMPL_TARGET = "SOFT"
+   , parameter           SIM_DEVICE = "ULTRASCALE_PLUS"
+   , parameter           AXISTEN_IF_EXT_512_INTFC_RAM_STYLE = "BRAM"
+
+   , parameter           AXI4_DATA_WIDTH = 512
+   , parameter           AXI4_TKEEP_WIDTH = 16
+   , parameter           AXI4_CQ_TUSER_WIDTH = 183
+   , parameter           AXI4_CC_TUSER_WIDTH = 81
+   , parameter           AXI4_RQ_TUSER_WIDTH = 137
+   , parameter           AXI4_RC_TUSER_WIDTH = 161
+   , parameter           AXI4_CQ_TREADY_WIDTH = 1
+   , parameter           AXI4_CC_TREADY_WIDTH = 1
+   , parameter           AXI4_RQ_TREADY_WIDTH = 1
+   , parameter           AXI4_RC_TREADY_WIDTH = 1
+
+   , parameter           CRM_CORE_CLK_FREQ_500="TRUE"
+   , parameter [1:0]     CRM_USER_CLK_FREQ=2'b10
+   , parameter [1:0]     AXISTEN_IF_WIDTH=2'b10
+   , parameter           AXISTEN_IF_EXT_512="FALSE"
+   , parameter           AXISTEN_IF_EXT_512_CQ_STRADDLE="FALSE"
+   , parameter           AXISTEN_IF_EXT_512_CC_STRADDLE="FALSE"
+   , parameter           AXISTEN_IF_EXT_512_RQ_STRADDLE="FALSE"
+   , parameter           AXISTEN_IF_EXT_512_RC_STRADDLE="FALSE"
+   , parameter           AXISTEN_IF_EXT_512_RC_4TLP_STRADDLE="TRUE"
+   , parameter [1:0]     AXISTEN_IF_CQ_ALIGNMENT_MODE=2'b00
+   , parameter [1:0]     AXISTEN_IF_CC_ALIGNMENT_MODE=2'b00
+   , parameter [1:0]     AXISTEN_IF_RQ_ALIGNMENT_MODE=2'b00
+   , parameter [1:0]     AXISTEN_IF_RC_ALIGNMENT_MODE=2'b00
+   , parameter           AXISTEN_IF_RC_STRADDLE="FALSE"
+   , parameter           AXISTEN_IF_ENABLE_RX_MSG_INTFC="FALSE"
+   , parameter [17:0]    AXISTEN_IF_ENABLE_MSG_ROUTE=18'h0
+   , parameter           AXISTEN_IF_RX_PARITY_EN="TRUE"
+   , parameter           AXISTEN_IF_TX_PARITY_EN="TRUE"
+   , parameter           AXISTEN_IF_ENABLE_CLIENT_TAG="FALSE"
+   , parameter           AXISTEN_IF_ENABLE_256_TAGS="FALSE"
+   , parameter [23:0]    AXISTEN_IF_COMPL_TIMEOUT_REG0=24'hBEBC20
+   , parameter [27:0]    AXISTEN_IF_COMPL_TIMEOUT_REG1=28'h2FAF080
+   , parameter           AXISTEN_IF_LEGACY_MODE_ENABLE="FALSE"
+   , parameter           AXISTEN_IF_ENABLE_MESSAGE_RID_CHECK="TRUE"
+   , parameter           AXISTEN_IF_MSIX_TO_RAM_PIPELINE="FALSE"
+   , parameter           AXISTEN_IF_MSIX_FROM_RAM_PIPELINE="FALSE"
+   , parameter           AXISTEN_IF_MSIX_RX_PARITY_EN="TRUE"
+   , parameter           AXISTEN_IF_ENABLE_INTERNAL_MSIX_TABLE="FALSE"
+   , parameter           AXISTEN_IF_CQ_EN_POISONED_MEM_WR="FALSE"
+   , parameter           AXISTEN_IF_SIM_SHORT_CPL_TIMEOUT="FALSE"
+   , parameter           AXISTEN_IF_RQ_CC_REGISTERED_TREADY="TRUE"
+   , parameter [15:0]    PM_ASPML0S_TIMEOUT=16'h1500
+   , parameter [31:0]    PM_L1_REENTRY_DELAY=32'h0
+   , parameter [19:0]    PM_ASPML1_ENTRY_DELAY=20'h0
+   , parameter           PM_ENABLE_SLOT_POWER_CAPTURE="TRUE"
+   , parameter [19:0]    PM_PME_SERVICE_TIMEOUT_DELAY=20'h0
+   , parameter [15:0]    PM_PME_TURNOFF_ACK_DELAY=16'h100
+   , parameter           PL_UPSTREAM_FACING="TRUE"
+   , parameter [4:0]     PL_LINK_CAP_MAX_LINK_WIDTH=5'b01000
+   , parameter [3:0]     PL_LINK_CAP_MAX_LINK_SPEED=4'b100
+   , parameter           PL_DISABLE_DC_BALANCE="FALSE"
+   , parameter           PL_DISABLE_EI_INFER_IN_L0="FALSE"
+   , parameter integer   PL_N_FTS=255
+   , parameter           PL_DISABLE_UPCONFIG_CAPABLE="FALSE"
+   , parameter           PL_DISABLE_RETRAIN_ON_FRAMING_ERROR="FALSE"
+   , parameter           PL_DISABLE_RETRAIN_ON_EB_ERROR="FALSE"
+   , parameter [15:0]    PL_DISABLE_RETRAIN_ON_SPECIFIC_FRAMING_ERROR=16'b0000000000000000
+   , parameter [7:0]     PL_REPORT_ALL_PHY_ERRORS=8'b00000000
+   , parameter [1:0]     PL_DISABLE_LFSR_UPDATE_ON_SKP=2'b00
+   , parameter [31:0]    PL_LANE0_EQ_CONTROL=32'h3F00
+   , parameter [31:0]    PL_LANE1_EQ_CONTROL=32'h3F00
+   , parameter [31:0]    PL_LANE2_EQ_CONTROL=32'h3F00
+   , parameter [31:0]    PL_LANE3_EQ_CONTROL=32'h3F00
+   , parameter [31:0]    PL_LANE4_EQ_CONTROL=32'h3F00
+   , parameter [31:0]    PL_LANE5_EQ_CONTROL=32'h3F00
+   , parameter [31:0]    PL_LANE6_EQ_CONTROL=32'h3F00
+   , parameter [31:0]    PL_LANE7_EQ_CONTROL=32'h3F00
+   , parameter [31:0]    PL_LANE8_EQ_CONTROL=32'h3F00
+   , parameter [31:0]    PL_LANE9_EQ_CONTROL=32'h3F00
+   , parameter [31:0]    PL_LANE10_EQ_CONTROL=32'h3F00
+   , parameter [31:0]    PL_LANE11_EQ_CONTROL=32'h3F00
+   , parameter [31:0]    PL_LANE12_EQ_CONTROL=32'h3F00
+   , parameter [31:0]    PL_LANE13_EQ_CONTROL=32'h3F00
+   , parameter [31:0]    PL_LANE14_EQ_CONTROL=32'h3F00
+   , parameter [31:0]    PL_LANE15_EQ_CONTROL=32'h3F00
+   , parameter [1:0]     PL_EQ_BYPASS_PHASE23=2'b00
+   , parameter [4:0]     PL_EQ_ADAPT_ITER_COUNT=5'h2
+   , parameter [1:0]     PL_EQ_ADAPT_REJECT_RETRY_COUNT=2'h1
+   , parameter           PL_EQ_SHORT_ADAPT_PHASE="FALSE"
+   , parameter [1:0]     PL_EQ_ADAPT_DISABLE_COEFF_CHECK=2'b0
+   , parameter [1:0]     PL_EQ_ADAPT_DISABLE_PRESET_CHECK=2'b0
+   , parameter [7:0]     PL_EQ_DEFAULT_TX_PRESET=8'h44
+   , parameter [5:0]     PL_EQ_DEFAULT_RX_PRESET_HINT=6'h33
+   , parameter [1:0]     PL_EQ_RX_ADAPT_EQ_PHASE0=2'b00
+   , parameter [1:0]     PL_EQ_RX_ADAPT_EQ_PHASE1=2'b00
+   , parameter           PL_EQ_DISABLE_MISMATCH_CHECK="TRUE"
+   , parameter [1:0]     PL_RX_L0S_EXIT_TO_RECOVERY=2'b00
+   , parameter           PL_EQ_TX_8G_EQ_TS2_ENABLE="FALSE"
+   , parameter           PL_DISABLE_AUTO_EQ_SPEED_CHANGE_TO_GEN4="FALSE"
+   , parameter           PL_DISABLE_AUTO_EQ_SPEED_CHANGE_TO_GEN3="FALSE"
+   , parameter           PL_DISABLE_AUTO_SPEED_CHANGE_TO_GEN2="FALSE"
+   , parameter           PL_DESKEW_ON_SKIP_IN_GEN12="FALSE"
+   , parameter           PL_INFER_EI_DISABLE_REC_RC="FALSE"
+   , parameter           PL_INFER_EI_DISABLE_REC_SPD="FALSE"
+   , parameter           PL_INFER_EI_DISABLE_LPBK_ACTIVE="FALSE"
+   , parameter [3:0]     PL_RX_ADAPT_TIMER_RRL_GEN3=4'h0
+   , parameter [1:0]     PL_RX_ADAPT_TIMER_RRL_CLOBBER_TX_TS=2'b00
+   , parameter [3:0]     PL_RX_ADAPT_TIMER_RRL_GEN4=4'h0
+   , parameter [3:0]     PL_RX_ADAPT_TIMER_CLWS_GEN3=4'h0
+   , parameter [1:0]     PL_RX_ADAPT_TIMER_CLWS_CLOBBER_TX_TS=2'b00
+   , parameter [3:0]     PL_RX_ADAPT_TIMER_CLWS_GEN4=4'h0
+   , parameter           PL_DISABLE_LANE_REVERSAL="FALSE"
+   , parameter           PL_CFG_STATE_ROBUSTNESS_ENABLE="TRUE"
+   , parameter           PL_REDO_EQ_SOURCE_SELECT="TRUE"
+   , parameter           PL_DEEMPH_SOURCE_SELECT="TRUE"
+   , parameter           PL_EXIT_LOOPBACK_ON_EI_ENTRY="FALSE"
+   , parameter           PL_QUIESCE_GUARANTEE_DISABLE="FALSE"
+   , parameter           PL_SRIS_ENABLE="FALSE"
+   , parameter [6:0]     PL_SRIS_SKPOS_GEN_SPD_VEC=7'h0
+   , parameter [6:0]     PL_SRIS_SKPOS_REC_SPD_VEC=7'h0
+   , parameter [1:0]     PL_SIM_FAST_LINK_TRAINING=2'h0
+   , parameter [15:0]    PL_USER_SPARE=16'h0
+   , parameter           LL_ACK_TIMEOUT_EN="FALSE"
+   , parameter [8:0]     LL_ACK_TIMEOUT=9'h0
+   , parameter integer   LL_ACK_TIMEOUT_FUNC=0
+   , parameter           LL_REPLAY_TIMEOUT_EN="FALSE"
+   , parameter [8:0]     LL_REPLAY_TIMEOUT=9'h0
+   , parameter integer   LL_REPLAY_TIMEOUT_FUNC=0
+   , parameter           LL_REPLAY_TO_RAM_PIPELINE="FALSE"
+   , parameter           LL_REPLAY_FROM_RAM_PIPELINE="FALSE"
+   , parameter           LL_DISABLE_SCHED_TX_NAK="FALSE"
+   , parameter           LL_TX_TLP_PARITY_CHK="TRUE"
+   , parameter           LL_RX_TLP_PARITY_GEN="TRUE"
+   , parameter [15:0]    LL_USER_SPARE=16'h0
+   , parameter           IS_SWITCH_PORT="FALSE"
+   , parameter           CFG_BYPASS_MODE_ENABLE="FALSE"
+   , parameter [1:0]     TL_PF_ENABLE_REG=2'h0
+   , parameter [11:0]    TL_CREDITS_CD=12'h1C0
+   , parameter [7:0]     TL_CREDITS_CH=8'h20
+   , parameter [1:0]     TL_COMPLETION_RAM_SIZE=2'b10
+   , parameter [1:0]     TL_COMPLETION_RAM_NUM_TLPS=2'b00
+   , parameter [11:0]    TL_CREDITS_NPD=12'h4
+   , parameter [7:0]     TL_CREDITS_NPH=8'h20
+   , parameter [11:0]    TL_CREDITS_PD=12'h3e0
+   , parameter [7:0]     TL_CREDITS_PH=8'h20
+   , parameter           TL_RX_COMPLETION_TO_RAM_WRITE_PIPELINE="FALSE"
+   , parameter           TL_RX_COMPLETION_TO_RAM_READ_PIPELINE="FALSE"
+   , parameter           TL_RX_COMPLETION_FROM_RAM_READ_PIPELINE="FALSE"
+   , parameter           TL_POSTED_RAM_SIZE=1'b0
+   , parameter           TL_RX_POSTED_TO_RAM_WRITE_PIPELINE="FALSE"
+   , parameter           TL_RX_POSTED_TO_RAM_READ_PIPELINE="FALSE"
+   , parameter           TL_RX_POSTED_FROM_RAM_READ_PIPELINE="FALSE"
+   , parameter           TL_TX_MUX_STRICT_PRIORITY="TRUE"
+   , parameter           TL_TX_TLP_STRADDLE_ENABLE="FALSE"
+   , parameter           TL_TX_TLP_TERMINATE_PARITY="FALSE"
+   , parameter [4:0]     TL_FC_UPDATE_MIN_INTERVAL_TLP_COUNT=5'h8
+   , parameter [4:0]     TL_FC_UPDATE_MIN_INTERVAL_TIME=5'h2
+   , parameter [15:0]    TL_USER_SPARE=16'h0
+   , parameter [23:0]    PF0_CLASS_CODE=24'h000000
+   , parameter [23:0]    PF1_CLASS_CODE=24'h000000
+   , parameter [23:0]    PF2_CLASS_CODE=24'h000000
+   , parameter [23:0]    PF3_CLASS_CODE=24'h000000
+   , parameter [2:0]     PF0_INTERRUPT_PIN=3'h1
+   , parameter [2:0]     PF1_INTERRUPT_PIN=3'h1
+   , parameter [2:0]     PF2_INTERRUPT_PIN=3'h1
+   , parameter [2:0]     PF3_INTERRUPT_PIN=3'h1
+   , parameter [7:0]     PF0_CAPABILITY_POINTER=8'h80
+   , parameter [7:0]     PF1_CAPABILITY_POINTER=8'h80
+   , parameter [7:0]     PF2_CAPABILITY_POINTER=8'h80
+   , parameter [7:0]     PF3_CAPABILITY_POINTER=8'h80
+   , parameter [7:0]     VF0_CAPABILITY_POINTER=8'h80
+   , parameter           LEGACY_CFG_EXTEND_INTERFACE_ENABLE="FALSE"
+   , parameter           EXTENDED_CFG_EXTEND_INTERFACE_ENABLE="FALSE"
+   , parameter           TL2CFG_IF_PARITY_CHK="TRUE"
+   , parameter           HEADER_TYPE_OVERRIDE="FALSE"
+   , parameter [2:0]     PF0_BAR0_CONTROL=3'b100
+   , parameter [2:0]     PF1_BAR0_CONTROL=3'b100
+   , parameter [2:0]     PF2_BAR0_CONTROL=3'b100
+   , parameter [2:0]     PF3_BAR0_CONTROL=3'b100
+   , parameter [5:0]     PF0_BAR0_APERTURE_SIZE=6'b000011
+   , parameter [5:0]     PF1_BAR0_APERTURE_SIZE=6'b000011
+   , parameter [5:0]     PF2_BAR0_APERTURE_SIZE=6'b000011
+   , parameter [5:0]     PF3_BAR0_APERTURE_SIZE=6'b000011
+   , parameter [2:0]     PF0_BAR1_CONTROL=3'b0
+   , parameter [2:0]     PF1_BAR1_CONTROL=3'b0
+   , parameter [2:0]     PF2_BAR1_CONTROL=3'b0
+   , parameter [2:0]     PF3_BAR1_CONTROL=3'b0
+   , parameter [4:0]     PF0_BAR1_APERTURE_SIZE=5'b0
+   , parameter [4:0]     PF1_BAR1_APERTURE_SIZE=5'b0
+   , parameter [4:0]     PF2_BAR1_APERTURE_SIZE=5'b0
+   , parameter [4:0]     PF3_BAR1_APERTURE_SIZE=5'b0
+   , parameter [2:0]     PF0_BAR2_CONTROL=3'b100
+   , parameter [2:0]     PF1_BAR2_CONTROL=3'b100
+   , parameter [2:0]     PF2_BAR2_CONTROL=3'b100
+   , parameter [2:0]     PF3_BAR2_CONTROL=3'b100
+   , parameter [5:0]     PF0_BAR2_APERTURE_SIZE=6'b00011
+   , parameter [5:0]     PF1_BAR2_APERTURE_SIZE=6'b00011
+   , parameter [5:0]     PF2_BAR2_APERTURE_SIZE=6'b00011
+   , parameter [5:0]     PF3_BAR2_APERTURE_SIZE=6'b00011
+   , parameter [2:0]     PF0_BAR3_CONTROL=3'b0
+   , parameter [2:0]     PF1_BAR3_CONTROL=3'b0
+   , parameter [2:0]     PF2_BAR3_CONTROL=3'b0
+   , parameter [2:0]     PF3_BAR3_CONTROL=3'b0
+   , parameter [4:0]     PF0_BAR3_APERTURE_SIZE=5'b00011
+   , parameter [4:0]     PF1_BAR3_APERTURE_SIZE=5'b00011
+   , parameter [4:0]     PF2_BAR3_APERTURE_SIZE=5'b00011
+   , parameter [4:0]     PF3_BAR3_APERTURE_SIZE=5'b00011
+   , parameter [2:0]     PF0_BAR4_CONTROL=3'b100
+   , parameter [2:0]     PF1_BAR4_CONTROL=3'b100
+   , parameter [2:0]     PF2_BAR4_CONTROL=3'b100
+   , parameter [2:0]     PF3_BAR4_CONTROL=3'b100
+   , parameter [5:0]     PF0_BAR4_APERTURE_SIZE=6'b00011
+   , parameter [5:0]     PF1_BAR4_APERTURE_SIZE=6'b00011
+   , parameter [5:0]     PF2_BAR4_APERTURE_SIZE=6'b00011
+   , parameter [5:0]     PF3_BAR4_APERTURE_SIZE=6'b00011
+   , parameter [2:0]     PF0_BAR5_CONTROL=3'b0
+   , parameter [2:0]     PF1_BAR5_CONTROL=3'b0
+   , parameter [2:0]     PF2_BAR5_CONTROL=3'b0
+   , parameter [2:0]     PF3_BAR5_CONTROL=3'b0
+   , parameter [4:0]     PF0_BAR5_APERTURE_SIZE=5'b00011
+   , parameter [4:0]     PF1_BAR5_APERTURE_SIZE=5'b00011
+   , parameter [4:0]     PF2_BAR5_APERTURE_SIZE=5'b00011
+   , parameter [4:0]     PF3_BAR5_APERTURE_SIZE=5'b00011
+   , parameter           PF0_EXPANSION_ROM_ENABLE="FALSE"
+   , parameter           PF1_EXPANSION_ROM_ENABLE="FALSE"
+   , parameter           PF2_EXPANSION_ROM_ENABLE="FALSE"
+   , parameter           PF3_EXPANSION_ROM_ENABLE="FALSE"
+   , parameter [4:0]     PF0_EXPANSION_ROM_APERTURE_SIZE=5'b00011
+   , parameter [4:0]     PF1_EXPANSION_ROM_APERTURE_SIZE=5'b00011
+   , parameter [4:0]     PF2_EXPANSION_ROM_APERTURE_SIZE=5'b00011
+   , parameter [4:0]     PF3_EXPANSION_ROM_APERTURE_SIZE=5'b00011
+   , parameter [7:0]     PF0_PCIE_CAP_NEXTPTR=8'h0
+   , parameter [7:0]     PF1_PCIE_CAP_NEXTPTR=8'h0
+   , parameter [7:0]     PF2_PCIE_CAP_NEXTPTR=8'h0
+   , parameter [7:0]     PF3_PCIE_CAP_NEXTPTR=8'h0
+   , parameter [7:0]     VFG0_PCIE_CAP_NEXTPTR=8'h0
+   , parameter [7:0]     VFG1_PCIE_CAP_NEXTPTR=8'h0
+   , parameter [7:0]     VFG2_PCIE_CAP_NEXTPTR=8'h0
+   , parameter [7:0]     VFG3_PCIE_CAP_NEXTPTR=8'h0
+   , parameter [2:0]     PF0_DEV_CAP_MAX_PAYLOAD_SIZE=3'b011
+   , parameter [2:0]     PF1_DEV_CAP_MAX_PAYLOAD_SIZE=3'b011
+   , parameter [2:0]     PF2_DEV_CAP_MAX_PAYLOAD_SIZE=3'b011
+   , parameter [2:0]     PF3_DEV_CAP_MAX_PAYLOAD_SIZE=3'b011
+   , parameter           PF0_DEV_CAP_EXT_TAG_SUPPORTED="TRUE"
+   , parameter integer   PF0_DEV_CAP_ENDPOINT_L0S_LATENCY=0
+   , parameter integer   PF0_DEV_CAP_ENDPOINT_L1_LATENCY=0
+   , parameter           PF0_DEV_CAP_FUNCTION_LEVEL_RESET_CAPABLE="TRUE"
+   , parameter integer   PF0_LINK_CAP_ASPM_SUPPORT=0
+   , parameter [0:0]     PF0_LINK_CONTROL_RCB=1'b0
+   , parameter           PF0_LINK_STATUS_SLOT_CLOCK_CONFIG="TRUE"
+   , parameter integer   PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN1=7
+   , parameter integer   PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN2=7
+   , parameter integer   PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN3=7
+   , parameter integer   PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN4=7
+   , parameter integer   PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN1=7
+   , parameter integer   PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN2=7
+   , parameter integer   PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN3=7
+   , parameter integer   PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN4=7
+   , parameter integer   PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN1=7
+   , parameter integer   PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN2=7
+   , parameter integer   PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN3=7
+   , parameter integer   PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN4=7
+   , parameter integer   PF0_LINK_CAP_L1_EXIT_LATENCY_GEN1=7
+   , parameter integer   PF0_LINK_CAP_L1_EXIT_LATENCY_GEN2=7
+   , parameter integer   PF0_LINK_CAP_L1_EXIT_LATENCY_GEN3=7
+   , parameter integer   PF0_LINK_CAP_L1_EXIT_LATENCY_GEN4=7
+   , parameter           PF0_DEV_CAP2_CPL_TIMEOUT_DISABLE="TRUE"
+   , parameter           PF0_DEV_CAP2_32B_ATOMIC_COMPLETER_SUPPORT="TRUE"
+   , parameter           PF0_DEV_CAP2_64B_ATOMIC_COMPLETER_SUPPORT="TRUE"
+   , parameter           PF0_DEV_CAP2_128B_CAS_ATOMIC_COMPLETER_SUPPORT="TRUE"
+   , parameter           PF0_DEV_CAP2_LTR_SUPPORT="TRUE"
+   , parameter           PF0_DEV_CAP2_TPH_COMPLETER_SUPPORT="FALSE"
+   , parameter [1:0]     PF0_DEV_CAP2_OBFF_SUPPORT=2'b00
+   , parameter           PF0_DEV_CAP2_ARI_FORWARD_ENABLE="FALSE"
+   , parameter [7:0]     PF0_MSI_CAP_NEXTPTR=8'h0
+   , parameter [7:0]     PF1_MSI_CAP_NEXTPTR=8'h0
+   , parameter [7:0]     PF2_MSI_CAP_NEXTPTR=8'h0
+   , parameter [7:0]     PF3_MSI_CAP_NEXTPTR=8'h0
+   , parameter           PF0_MSI_CAP_PERVECMASKCAP="FALSE"
+   , parameter           PF1_MSI_CAP_PERVECMASKCAP="FALSE"
+   , parameter           PF2_MSI_CAP_PERVECMASKCAP="FALSE"
+   , parameter           PF3_MSI_CAP_PERVECMASKCAP="FALSE"
+   , parameter integer   PF0_MSI_CAP_MULTIMSGCAP=0
+   , parameter integer   PF1_MSI_CAP_MULTIMSGCAP=0
+   , parameter integer   PF2_MSI_CAP_MULTIMSGCAP=0
+   , parameter integer   PF3_MSI_CAP_MULTIMSGCAP=0
+   , parameter [7:0]     PF0_MSIX_CAP_NEXTPTR=8'h0
+   , parameter [7:0]     PF1_MSIX_CAP_NEXTPTR=8'h0
+   , parameter [7:0]     PF2_MSIX_CAP_NEXTPTR=8'h0
+   , parameter [7:0]     PF3_MSIX_CAP_NEXTPTR=8'h0
+   , parameter [7:0]     VFG0_MSIX_CAP_NEXTPTR=8'h0
+   , parameter [7:0]     VFG1_MSIX_CAP_NEXTPTR=8'h0
+   , parameter [7:0]     VFG2_MSIX_CAP_NEXTPTR=8'h0
+   , parameter [7:0]     VFG3_MSIX_CAP_NEXTPTR=8'h0
+   , parameter integer   PF0_MSIX_CAP_PBA_BIR=0
+   , parameter integer   PF1_MSIX_CAP_PBA_BIR=0
+   , parameter integer   PF2_MSIX_CAP_PBA_BIR=0
+   , parameter integer   PF3_MSIX_CAP_PBA_BIR=0
+   , parameter integer   VFG0_MSIX_CAP_PBA_BIR=0
+   , parameter integer   VFG1_MSIX_CAP_PBA_BIR=0
+   , parameter integer   VFG2_MSIX_CAP_PBA_BIR=0
+   , parameter integer   VFG3_MSIX_CAP_PBA_BIR=0
+   , parameter [28:0]    PF0_MSIX_CAP_PBA_OFFSET=29'h50
+   , parameter [28:0]    PF1_MSIX_CAP_PBA_OFFSET=29'h50
+   , parameter [28:0]    PF2_MSIX_CAP_PBA_OFFSET=29'h50
+   , parameter [28:0]    PF3_MSIX_CAP_PBA_OFFSET=29'h50
+   , parameter [28:0]    VFG0_MSIX_CAP_PBA_OFFSET=29'h50
+   , parameter [28:0]    VFG1_MSIX_CAP_PBA_OFFSET=29'h50
+   , parameter [28:0]    VFG2_MSIX_CAP_PBA_OFFSET=29'h50
+   , parameter [28:0]    VFG3_MSIX_CAP_PBA_OFFSET=29'h50
+   , parameter integer   PF0_MSIX_CAP_TABLE_BIR=0
+   , parameter integer   PF1_MSIX_CAP_TABLE_BIR=0
+   , parameter integer   PF2_MSIX_CAP_TABLE_BIR=0
+   , parameter integer   PF3_MSIX_CAP_TABLE_BIR=0
+   , parameter integer   VFG0_MSIX_CAP_TABLE_BIR=0
+   , parameter integer   VFG1_MSIX_CAP_TABLE_BIR=0
+   , parameter integer   VFG2_MSIX_CAP_TABLE_BIR=0
+   , parameter integer   VFG3_MSIX_CAP_TABLE_BIR=0
+   , parameter [28:0]    PF0_MSIX_CAP_TABLE_OFFSET=29'h40
+   , parameter [28:0]    PF1_MSIX_CAP_TABLE_OFFSET=29'h40
+   , parameter [28:0]    PF2_MSIX_CAP_TABLE_OFFSET=29'h40
+   , parameter [28:0]    PF3_MSIX_CAP_TABLE_OFFSET=29'h40
+   , parameter [28:0]    VFG0_MSIX_CAP_TABLE_OFFSET=29'h40
+   , parameter [28:0]    VFG1_MSIX_CAP_TABLE_OFFSET=29'h40
+   , parameter [28:0]    VFG2_MSIX_CAP_TABLE_OFFSET=29'h40
+   , parameter [28:0]    VFG3_MSIX_CAP_TABLE_OFFSET=29'h40
+   , parameter [10:0]    PF0_MSIX_CAP_TABLE_SIZE=11'h0
+   , parameter [10:0]    PF1_MSIX_CAP_TABLE_SIZE=11'h0
+   , parameter [10:0]    PF2_MSIX_CAP_TABLE_SIZE=11'h0
+   , parameter [10:0]    PF3_MSIX_CAP_TABLE_SIZE=11'h0
+   , parameter [10:0]    VFG0_MSIX_CAP_TABLE_SIZE=11'h0
+   , parameter [10:0]    VFG1_MSIX_CAP_TABLE_SIZE=11'h0
+   , parameter [10:0]    VFG2_MSIX_CAP_TABLE_SIZE=11'h0
+   , parameter [10:0]    VFG3_MSIX_CAP_TABLE_SIZE=11'h0
+   , parameter [5:0]     PF0_MSIX_VECTOR_COUNT=6'h4
+   , parameter [7:0]     PF0_PM_CAP_ID=8'h1
+   , parameter [7:0]     PF0_PM_CAP_NEXTPTR=8'h0
+   , parameter [7:0]     PF1_PM_CAP_NEXTPTR=8'h0
+   , parameter [7:0]     PF2_PM_CAP_NEXTPTR=8'h0
+   , parameter [7:0]     PF3_PM_CAP_NEXTPTR=8'h0
+   , parameter           PF0_PM_CAP_PMESUPPORT_D3HOT="TRUE"
+   , parameter           PF0_PM_CAP_PMESUPPORT_D1="TRUE"
+   , parameter           PF0_PM_CAP_PMESUPPORT_D0="TRUE"
+   , parameter           PF0_PM_CAP_SUPP_D1_STATE="TRUE"
+   , parameter [2:0]     PF0_PM_CAP_VER_ID=3'h3
+   , parameter           PF0_PM_CSR_NOSOFTRESET="TRUE"
+   , parameter           PM_ENABLE_L23_ENTRY="FALSE"
+   , parameter [7:0]     DNSTREAM_LINK_NUM=8'h0
+   , parameter           AUTO_FLR_RESPONSE="FALSE"
+   , parameter [11:0]    PF0_DSN_CAP_NEXTPTR=12'h10C
+   , parameter [11:0]    PF1_DSN_CAP_NEXTPTR=12'h10C
+   , parameter [11:0]    PF2_DSN_CAP_NEXTPTR=12'h10C
+   , parameter [11:0]    PF3_DSN_CAP_NEXTPTR=12'h10C
+   , parameter           DSN_CAP_ENABLE="FALSE"
+   , parameter [3:0]     PF0_VC_CAP_VER=4'h1
+   , parameter [11:0]    PF0_VC_CAP_NEXTPTR=12'h0
+   , parameter           PF0_VC_CAP_ENABLE="FALSE"
+   , parameter [11:0]    PF0_SECONDARY_PCIE_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    PF0_AER_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    PF1_AER_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    PF2_AER_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    PF3_AER_CAP_NEXTPTR=12'h0
+   , parameter           PF0_AER_CAP_ECRC_GEN_AND_CHECK_CAPABLE="FALSE"
+   , parameter           ARI_CAP_ENABLE="FALSE"
+   , parameter [11:0]    PF0_ARI_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    PF1_ARI_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    PF2_ARI_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    PF3_ARI_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    VFG0_ARI_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    VFG1_ARI_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    VFG2_ARI_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    VFG3_ARI_CAP_NEXTPTR=12'h0
+   , parameter [3:0]     PF0_ARI_CAP_VER=4'h1
+   , parameter [7:0]     PF0_ARI_CAP_NEXT_FUNC=8'h0
+   , parameter [7:0]     PF1_ARI_CAP_NEXT_FUNC=8'h0
+   , parameter [7:0]     PF2_ARI_CAP_NEXT_FUNC=8'h0
+   , parameter [7:0]     PF3_ARI_CAP_NEXT_FUNC=8'h0
+   , parameter [11:0]    PF0_LTR_CAP_NEXTPTR=12'h0
+   , parameter [3:0]     PF0_LTR_CAP_VER=4'h1
+   , parameter [9:0]     PF0_LTR_CAP_MAX_SNOOP_LAT=10'h0
+   , parameter [9:0]     PF0_LTR_CAP_MAX_NOSNOOP_LAT=10'h0
+   , parameter           LTR_TX_MESSAGE_ON_LTR_ENABLE="FALSE"
+   , parameter           LTR_TX_MESSAGE_ON_FUNC_POWER_STATE_CHANGE="FALSE"
+   , parameter [9:0]     LTR_TX_MESSAGE_MINIMUM_INTERVAL=10'h250
+   , parameter [3:0]     SRIOV_CAP_ENABLE=4'h0
+   , parameter [11:0]    PF0_SRIOV_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    PF1_SRIOV_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    PF2_SRIOV_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    PF3_SRIOV_CAP_NEXTPTR=12'h0
+   , parameter [3:0]     PF0_SRIOV_CAP_VER=4'h1
+   , parameter [3:0]     PF1_SRIOV_CAP_VER=4'h1
+   , parameter [3:0]     PF2_SRIOV_CAP_VER=4'h1
+   , parameter [3:0]     PF3_SRIOV_CAP_VER=4'h1
+   , parameter           PF0_SRIOV_ARI_CAPBL_HIER_PRESERVED="FALSE"
+   , parameter           PF1_SRIOV_ARI_CAPBL_HIER_PRESERVED="FALSE"
+   , parameter           PF2_SRIOV_ARI_CAPBL_HIER_PRESERVED="FALSE"
+   , parameter           PF3_SRIOV_ARI_CAPBL_HIER_PRESERVED="FALSE"
+   , parameter [15:0]    PF0_SRIOV_CAP_INITIAL_VF=16'h0
+   , parameter [15:0]    PF1_SRIOV_CAP_INITIAL_VF=16'h0
+   , parameter [15:0]    PF2_SRIOV_CAP_INITIAL_VF=16'h0
+   , parameter [15:0]    PF3_SRIOV_CAP_INITIAL_VF=16'h0
+   , parameter [15:0]    PF0_SRIOV_CAP_TOTAL_VF=16'h0
+   , parameter [15:0]    PF1_SRIOV_CAP_TOTAL_VF=16'h0
+   , parameter [15:0]    PF2_SRIOV_CAP_TOTAL_VF=16'h0
+   , parameter [15:0]    PF3_SRIOV_CAP_TOTAL_VF=16'h0
+   , parameter [15:0]    PF0_SRIOV_FUNC_DEP_LINK=16'h0
+   , parameter [15:0]    PF1_SRIOV_FUNC_DEP_LINK=16'h0
+   , parameter [15:0]    PF2_SRIOV_FUNC_DEP_LINK=16'h0
+   , parameter [15:0]    PF3_SRIOV_FUNC_DEP_LINK=16'h0
+   , parameter [15:0]    PF0_SRIOV_FIRST_VF_OFFSET=16'h0
+   , parameter [15:0]    PF1_SRIOV_FIRST_VF_OFFSET=16'h0
+   , parameter [15:0]    PF2_SRIOV_FIRST_VF_OFFSET=16'h0
+   , parameter [15:0]    PF3_SRIOV_FIRST_VF_OFFSET=16'h0
+   , parameter [15:0]    PF0_SRIOV_VF_DEVICE_ID=16'h0
+   , parameter [15:0]    PF1_SRIOV_VF_DEVICE_ID=16'h0
+   , parameter [15:0]    PF2_SRIOV_VF_DEVICE_ID=16'h0
+   , parameter [15:0]    PF3_SRIOV_VF_DEVICE_ID=16'h0
+   , parameter [31:0]    PF0_SRIOV_SUPPORTED_PAGE_SIZE=32'h0
+   , parameter [31:0]    PF1_SRIOV_SUPPORTED_PAGE_SIZE=32'h0
+   , parameter [31:0]    PF2_SRIOV_SUPPORTED_PAGE_SIZE=32'h0
+   , parameter [31:0]    PF3_SRIOV_SUPPORTED_PAGE_SIZE=32'h0
+   , parameter [2:0]     PF0_SRIOV_BAR0_CONTROL=3'b100
+   , parameter [2:0]     PF1_SRIOV_BAR0_CONTROL=3'b100
+   , parameter [2:0]     PF2_SRIOV_BAR0_CONTROL=3'b100
+   , parameter [2:0]     PF3_SRIOV_BAR0_CONTROL=3'b100
+   , parameter [5:0]     PF0_SRIOV_BAR0_APERTURE_SIZE=6'b000011
+   , parameter [5:0]     PF1_SRIOV_BAR0_APERTURE_SIZE=6'b000011
+   , parameter [5:0]     PF2_SRIOV_BAR0_APERTURE_SIZE=6'b000011
+   , parameter [5:0]     PF3_SRIOV_BAR0_APERTURE_SIZE=6'b000011
+   , parameter [2:0]     PF0_SRIOV_BAR1_CONTROL=3'b0
+   , parameter [2:0]     PF1_SRIOV_BAR1_CONTROL=3'b0
+   , parameter [2:0]     PF2_SRIOV_BAR1_CONTROL=3'b0
+   , parameter [2:0]     PF3_SRIOV_BAR1_CONTROL=3'b0
+   , parameter [4:0]     PF0_SRIOV_BAR1_APERTURE_SIZE=5'b0
+   , parameter [4:0]     PF1_SRIOV_BAR1_APERTURE_SIZE=5'b0
+   , parameter [4:0]     PF2_SRIOV_BAR1_APERTURE_SIZE=5'b0
+   , parameter [4:0]     PF3_SRIOV_BAR1_APERTURE_SIZE=5'b0
+   , parameter [2:0]     PF0_SRIOV_BAR2_CONTROL=3'b100
+   , parameter [2:0]     PF1_SRIOV_BAR2_CONTROL=3'b100
+   , parameter [2:0]     PF2_SRIOV_BAR2_CONTROL=3'b100
+   , parameter [2:0]     PF3_SRIOV_BAR2_CONTROL=3'b100
+   , parameter [5:0]     PF0_SRIOV_BAR2_APERTURE_SIZE=6'b000011
+   , parameter [5:0]     PF1_SRIOV_BAR2_APERTURE_SIZE=6'b000011
+   , parameter [5:0]     PF2_SRIOV_BAR2_APERTURE_SIZE=6'b000011
+   , parameter [5:0]     PF3_SRIOV_BAR2_APERTURE_SIZE=6'b000011
+   , parameter [2:0]     PF0_SRIOV_BAR3_CONTROL=3'b0
+   , parameter [2:0]     PF1_SRIOV_BAR3_CONTROL=3'b0
+   , parameter [2:0]     PF2_SRIOV_BAR3_CONTROL=3'b0
+   , parameter [2:0]     PF3_SRIOV_BAR3_CONTROL=3'b0
+   , parameter [4:0]     PF0_SRIOV_BAR3_APERTURE_SIZE=5'b00011
+   , parameter [4:0]     PF1_SRIOV_BAR3_APERTURE_SIZE=5'b00011
+   , parameter [4:0]     PF2_SRIOV_BAR3_APERTURE_SIZE=5'b00011
+   , parameter [4:0]     PF3_SRIOV_BAR3_APERTURE_SIZE=5'b00011
+   , parameter [2:0]     PF0_SRIOV_BAR4_CONTROL=3'b100
+   , parameter [2:0]     PF1_SRIOV_BAR4_CONTROL=3'b100
+   , parameter [2:0]     PF2_SRIOV_BAR4_CONTROL=3'b100
+   , parameter [2:0]     PF3_SRIOV_BAR4_CONTROL=3'b100
+   , parameter [5:0]     PF0_SRIOV_BAR4_APERTURE_SIZE=6'b000011
+   , parameter [5:0]     PF1_SRIOV_BAR4_APERTURE_SIZE=6'b000011
+   , parameter [5:0]     PF2_SRIOV_BAR4_APERTURE_SIZE=6'b000011
+   , parameter [5:0]     PF3_SRIOV_BAR4_APERTURE_SIZE=6'b000011
+   , parameter [2:0]     PF0_SRIOV_BAR5_CONTROL=3'b0
+   , parameter [2:0]     PF1_SRIOV_BAR5_CONTROL=3'b0
+   , parameter [2:0]     PF2_SRIOV_BAR5_CONTROL=3'b0
+   , parameter [2:0]     PF3_SRIOV_BAR5_CONTROL=3'b0
+   , parameter [4:0]     PF0_SRIOV_BAR5_APERTURE_SIZE=5'b00011
+   , parameter [4:0]     PF1_SRIOV_BAR5_APERTURE_SIZE=5'b00011
+   , parameter [4:0]     PF2_SRIOV_BAR5_APERTURE_SIZE=5'b00011
+   , parameter [4:0]     PF3_SRIOV_BAR5_APERTURE_SIZE=5'b00011
+   , parameter [11:0]    PF0_TPHR_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    PF1_TPHR_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    PF2_TPHR_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    PF3_TPHR_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    VFG0_TPHR_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    VFG1_TPHR_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    VFG2_TPHR_CAP_NEXTPTR=12'h0
+   , parameter [11:0]    VFG3_TPHR_CAP_NEXTPTR=12'h0
+   , parameter [3:0]     PF0_TPHR_CAP_VER=4'h1
+   , parameter           PF0_TPHR_CAP_INT_VEC_MODE="TRUE"
+   , parameter           PF0_TPHR_CAP_DEV_SPECIFIC_MODE="TRUE"
+   , parameter [1:0]     PF0_TPHR_CAP_ST_TABLE_LOC=2'h0
+   , parameter [10:0]    PF0_TPHR_CAP_ST_TABLE_SIZE=11'h0
+   , parameter [2:0]     PF0_TPHR_CAP_ST_MODE_SEL=3'h0
+   , parameter [2:0]     PF1_TPHR_CAP_ST_MODE_SEL=3'h0
+   , parameter [2:0]     PF2_TPHR_CAP_ST_MODE_SEL=3'h0
+   , parameter [2:0]     PF3_TPHR_CAP_ST_MODE_SEL=3'h0
+   , parameter [2:0]     VFG0_TPHR_CAP_ST_MODE_SEL=3'h0
+   , parameter [2:0]     VFG1_TPHR_CAP_ST_MODE_SEL=3'h0
+   , parameter [2:0]     VFG2_TPHR_CAP_ST_MODE_SEL=3'h0
+   , parameter [2:0]     VFG3_TPHR_CAP_ST_MODE_SEL=3'h0
+   , parameter           PF0_TPHR_CAP_ENABLE="FALSE"
+   , parameter           TPH_TO_RAM_PIPELINE="FALSE"
+   , parameter           TPH_FROM_RAM_PIPELINE="FALSE"
+   , parameter           MCAP_ENABLE="FALSE"
+   , parameter           MCAP_CONFIGURE_OVERRIDE="FALSE"
+   , parameter [11:0]    MCAP_CAP_NEXTPTR=12'h0
+   , parameter [15:0]    MCAP_VSEC_ID=16'h0
+   , parameter [3:0]     MCAP_VSEC_REV=4'h0
+   , parameter [11:0]    MCAP_VSEC_LEN=12'h2C
+   , parameter [31:0]    MCAP_FPGA_BITSTREAM_VERSION=32'h0
+   , parameter           MCAP_INTERRUPT_ON_MCAP_EOS="FALSE"
+   , parameter           MCAP_INTERRUPT_ON_MCAP_ERROR="FALSE"
+   , parameter           MCAP_INPUT_GATE_DESIGN_SWITCH="FALSE"
+   , parameter           MCAP_EOS_DESIGN_SWITCH="FALSE"
+   , parameter           MCAP_GATE_MEM_ENABLE_DESIGN_SWITCH="FALSE"
+   , parameter           MCAP_GATE_IO_ENABLE_DESIGN_SWITCH="FALSE"
+   , parameter [31:0]    SIM_JTAG_IDCODE=32'h0
+   , parameter [7:0]     DEBUG_AXIST_DISABLE_FEATURE_BIT=8'h0
+   , parameter           DEBUG_TL_DISABLE_RX_TLP_ORDER_CHECKS="FALSE"
+   , parameter           DEBUG_TL_DISABLE_FC_TIMEOUT="FALSE"
+   , parameter           DEBUG_PL_DISABLE_SCRAMBLING="FALSE"
+   , parameter           DEBUG_PL_DISABLE_REC_ENTRY_ON_DYNAMIC_DSKEW_FAIL ="FALSE"
+   , parameter           DEBUG_PL_DISABLE_REC_ENTRY_ON_RX_BUFFER_UNDER_OVER_FLOW ="FALSE"
+   , parameter           DEBUG_PL_DISABLE_LES_UPDATE_ON_SKP_ERROR="FALSE"
+   , parameter           DEBUG_PL_DISABLE_LES_UPDATE_ON_SKP_PARITY_ERROR="FALSE"
+   , parameter           DEBUG_PL_DISABLE_LES_UPDATE_ON_DEFRAMER_ERROR="FALSE"
+   , parameter           DEBUG_PL_SIM_RESET_LFSR="FALSE"
+   , parameter [15:0]    DEBUG_PL_SPARE=16'h0
+   , parameter [15:0]    DEBUG_LL_SPARE=16'h0
+   , parameter [15:0]    DEBUG_TL_SPARE=16'h0
+   , parameter [15:0]    DEBUG_AXI4ST_SPARE=16'h0
+   , parameter [15:0]    DEBUG_CFG_SPARE=16'h0
+   , parameter [3:0]     DEBUG_CAR_SPARE=4'h0
+   , parameter           TEST_MODE_PIN_CHAR="FALSE"
+   , parameter           SPARE_BIT0="FALSE"
+   , parameter           SPARE_BIT1=1'b0
+   , parameter           SPARE_BIT2=1'b0
+   , parameter           SPARE_BIT3="FALSE"
+   , parameter           SPARE_BIT4=1'b0
+   , parameter           SPARE_BIT5=1'b0
+   , parameter           SPARE_BIT6=1'b0
+   , parameter           SPARE_BIT7=1'b0
+   , parameter           SPARE_BIT8=1'b0
+   , parameter [7:0]     SPARE_BYTE0=8'h0
+   , parameter [7:0]     SPARE_BYTE1=8'h0
+   , parameter [7:0]     SPARE_BYTE2=8'h0
+   , parameter [7:0]     SPARE_BYTE3=8'h0
+   , parameter [31:0]    SPARE_WORD0=32'h0
+   , parameter [31:0]    SPARE_WORD1=32'h0
+   , parameter [31:0]    SPARE_WORD2=32'h0
+   , parameter [31:0]    SPARE_WORD3=32'h0
+
+   , parameter [7:0]     AXISTEN_IF_CCIX_RX_CREDIT_LIMIT	= 8'h08
+   , parameter [7:0]     AXISTEN_IF_CCIX_TX_CREDIT_LIMIT	= 8'h08
+   , parameter           AXISTEN_IF_CCIX_TX_REGISTERED_TREADY	= "FALSE"
+   , parameter           CCIX_DIRECT_ATTACH_MODE	= "FALSE"
+   , parameter           CCIX_ENABLE	= "FALSE"
+   , parameter [15:0]    CCIX_VENDOR_ID	= 16'h0000
+   , parameter [4:0]     PF0_ATS_CAP_INV_QUEUE_DEPTH	= 5'h00
+   , parameter [11:0]    PF0_ATS_CAP_NEXTPTR	= 12'h000
+   , parameter           PF0_ATS_CAP_ON	= "FALSE"
+   , parameter [11:0]    PF0_PRI_CAP_NEXTPTR	= 12'h000
+   , parameter           PF0_PRI_CAP_ON	= "FALSE"
+   , parameter [31:0]    PF0_PRI_OST_PR_CAPACITY	= 32'h00000000
+   , parameter [3:0]     PF0_VC_ARB_CAPABILITY	= 4'h0
+   , parameter [7:0]     PF0_VC_ARB_TBL_OFFSET	= 8'h00
+   , parameter           PF0_VC_EXTENDED_COUNT	= "FALSE"
+   , parameter           PF0_VC_LOW_PRIORITY_EXTENDED_COUNT	= "FALSE"
+   , parameter [4:0]     PF1_ATS_CAP_INV_QUEUE_DEPTH	= 5'h00
+   , parameter [11:0]    PF1_ATS_CAP_NEXTPTR	= 12'h000
+   , parameter           PF1_ATS_CAP_ON	= "FALSE"
+   , parameter [11:0]    PF1_PRI_CAP_NEXTPTR	= 12'h000
+   , parameter           PF1_PRI_CAP_ON	= "FALSE"
+   , parameter [31:0]    PF1_PRI_OST_PR_CAPACITY	= 32'h00000000
+   , parameter [4:0]     PF2_ATS_CAP_INV_QUEUE_DEPTH	= 5'h00
+   , parameter [11:0]    PF2_ATS_CAP_NEXTPTR	= 12'h000
+   , parameter           PF2_ATS_CAP_ON	= "FALSE"
+   , parameter [11:0]    PF2_PRI_CAP_NEXTPTR	= 12'h000
+   , parameter           PF2_PRI_CAP_ON	= "FALSE"
+   , parameter [31:0]    PF2_PRI_OST_PR_CAPACITY	= 32'h00000000
+   , parameter [4:0]     PF3_ATS_CAP_INV_QUEUE_DEPTH	= 5'h00
+   , parameter [11:0]    PF3_ATS_CAP_NEXTPTR	= 12'h000
+   , parameter           PF3_ATS_CAP_ON	= "FALSE"
+   , parameter [11:0]    PF3_PRI_CAP_NEXTPTR	= 12'h000
+   , parameter           PF3_PRI_CAP_ON	= "FALSE"
+   , parameter [31:0]    PF3_PRI_OST_PR_CAPACITY	= 32'h00000000
+   , parameter           PL_CTRL_SKP_GEN_ENABLE	= "FALSE"
+   , parameter           PL_CTRL_SKP_PARITY_AND_CRC_CHECK_DISABLE	= "TRUE"
+   , parameter [15:0]    PL_USER_SPARE2	= 16'h0000
+   , parameter [11:0]    TL_CREDITS_CD_VC1	= 12'h000
+   , parameter [7:0]     TL_CREDITS_CH_VC1	= 8'h00
+   , parameter [11:0]    TL_CREDITS_NPD_VC1	= 12'h000
+   , parameter [7:0]     TL_CREDITS_NPH_VC1	= 8'h01
+   , parameter [11:0]    TL_CREDITS_PD_VC1	= 12'h3e0
+   , parameter [7:0]     TL_CREDITS_PH_VC1	= 8'h20
+   , parameter [4:0]     TL_FC_UPDATE_MIN_INTERVAL_TIME_VC1	= 5'h02
+   , parameter [4:0]     TL_FC_UPDATE_MIN_INTERVAL_TLP_COUNT_VC1	= 5'h08
+   , parameter           TL_FEATURE_ENABLE_FC_SCALING	= "FALSE"
+   , parameter [4:0]     VFG0_ATS_CAP_INV_QUEUE_DEPTH	= 5'h00
+   , parameter [11:0]    VFG0_ATS_CAP_NEXTPTR	= 12'h000
+   , parameter           VFG0_ATS_CAP_ON	= "FALSE"
+   , parameter [4:0]     VFG1_ATS_CAP_INV_QUEUE_DEPTH	= 5'h00
+   , parameter [11:0]    VFG1_ATS_CAP_NEXTPTR	= 12'h000
+   , parameter           VFG1_ATS_CAP_ON	= "FALSE"
+   , parameter [4:0]     VFG2_ATS_CAP_INV_QUEUE_DEPTH	= 5'h00
+   , parameter [11:0]    VFG2_ATS_CAP_NEXTPTR	= 12'h000
+   , parameter           VFG2_ATS_CAP_ON	= "FALSE"
+   , parameter [4:0]     VFG3_ATS_CAP_INV_QUEUE_DEPTH	= 5'h00
+   , parameter [11:0]    VFG3_ATS_CAP_NEXTPTR	= 12'h000
+   , parameter           VFG3_ATS_CAP_ON	= "FALSE"
+
+  ) (
+    input  wire [1:0]     pipe_rx00_char_is_k
+   ,input  wire [1:0]     pipe_rx01_char_is_k
+   ,input  wire [1:0]     pipe_rx02_char_is_k
+   ,input  wire [1:0]     pipe_rx03_char_is_k
+   ,input  wire [1:0]     pipe_rx04_char_is_k
+   ,input  wire [1:0]     pipe_rx05_char_is_k
+   ,input  wire [1:0]     pipe_rx06_char_is_k
+   ,input  wire [1:0]     pipe_rx07_char_is_k
+   ,input  wire [1:0]     pipe_rx08_char_is_k
+   ,input  wire [1:0]     pipe_rx09_char_is_k
+   ,input  wire [1:0]     pipe_rx10_char_is_k
+   ,input  wire [1:0]     pipe_rx11_char_is_k
+   ,input  wire [1:0]     pipe_rx12_char_is_k
+   ,input  wire [1:0]     pipe_rx13_char_is_k
+   ,input  wire [1:0]     pipe_rx14_char_is_k
+   ,input  wire [1:0]     pipe_rx15_char_is_k
+   ,input  wire           pipe_rx00_valid
+   ,input  wire           pipe_rx01_valid
+   ,input  wire           pipe_rx02_valid
+   ,input  wire           pipe_rx03_valid
+   ,input  wire           pipe_rx04_valid
+   ,input  wire           pipe_rx05_valid
+   ,input  wire           pipe_rx06_valid
+   ,input  wire           pipe_rx07_valid
+   ,input  wire           pipe_rx08_valid
+   ,input  wire           pipe_rx09_valid
+   ,input  wire           pipe_rx10_valid
+   ,input  wire           pipe_rx11_valid
+   ,input  wire           pipe_rx12_valid
+   ,input  wire           pipe_rx13_valid
+   ,input  wire           pipe_rx14_valid
+   ,input  wire           pipe_rx15_valid
+   ,input  wire [31:0]    pipe_rx00_data
+   ,input  wire [31:0]    pipe_rx01_data
+   ,input  wire [31:0]    pipe_rx02_data
+   ,input  wire [31:0]    pipe_rx03_data
+   ,input  wire [31:0]    pipe_rx04_data
+   ,input  wire [31:0]    pipe_rx05_data
+   ,input  wire [31:0]    pipe_rx06_data
+   ,input  wire [31:0]    pipe_rx07_data
+   ,input  wire [31:0]    pipe_rx08_data
+   ,input  wire [31:0]    pipe_rx09_data
+   ,input  wire [31:0]    pipe_rx10_data
+   ,input  wire [31:0]    pipe_rx11_data
+   ,input  wire [31:0]    pipe_rx12_data
+   ,input  wire [31:0]    pipe_rx13_data
+   ,input  wire [31:0]    pipe_rx14_data
+   ,input  wire [31:0]    pipe_rx15_data
+   ,output wire           pipe_rx00_polarity
+   ,output wire           pipe_rx01_polarity
+   ,output wire           pipe_rx02_polarity
+   ,output wire           pipe_rx03_polarity
+   ,output wire           pipe_rx04_polarity
+   ,output wire           pipe_rx05_polarity
+   ,output wire           pipe_rx06_polarity
+   ,output wire           pipe_rx07_polarity
+   ,output wire           pipe_rx08_polarity
+   ,output wire           pipe_rx09_polarity
+   ,output wire           pipe_rx10_polarity
+   ,output wire           pipe_rx11_polarity
+   ,output wire           pipe_rx12_polarity
+   ,output wire           pipe_rx13_polarity
+   ,output wire           pipe_rx14_polarity
+   ,output wire           pipe_rx15_polarity
+   ,input  wire [2:0]     pipe_rx00_status
+   ,input  wire [2:0]     pipe_rx01_status
+   ,input  wire [2:0]     pipe_rx02_status
+   ,input  wire [2:0]     pipe_rx03_status
+   ,input  wire [2:0]     pipe_rx04_status
+   ,input  wire [2:0]     pipe_rx05_status
+   ,input  wire [2:0]     pipe_rx06_status
+   ,input  wire [2:0]     pipe_rx07_status
+   ,input  wire [2:0]     pipe_rx08_status
+   ,input  wire [2:0]     pipe_rx09_status
+   ,input  wire [2:0]     pipe_rx10_status
+   ,input  wire [2:0]     pipe_rx11_status
+   ,input  wire [2:0]     pipe_rx12_status
+   ,input  wire [2:0]     pipe_rx13_status
+   ,input  wire [2:0]     pipe_rx14_status
+   ,input  wire [2:0]     pipe_rx15_status
+   ,input  wire           pipe_rx00_phy_status
+   ,input  wire           pipe_rx01_phy_status
+   ,input  wire           pipe_rx02_phy_status
+   ,input  wire           pipe_rx03_phy_status
+   ,input  wire           pipe_rx04_phy_status
+   ,input  wire           pipe_rx05_phy_status
+   ,input  wire           pipe_rx06_phy_status
+   ,input  wire           pipe_rx07_phy_status
+   ,input  wire           pipe_rx08_phy_status
+   ,input  wire           pipe_rx09_phy_status
+   ,input  wire           pipe_rx10_phy_status
+   ,input  wire           pipe_rx11_phy_status
+   ,input  wire           pipe_rx12_phy_status
+   ,input  wire           pipe_rx13_phy_status
+   ,input  wire           pipe_rx14_phy_status
+   ,input  wire           pipe_rx15_phy_status
+   ,input  wire           pipe_rx00_elec_idle
+   ,input  wire           pipe_rx01_elec_idle
+   ,input  wire           pipe_rx02_elec_idle
+   ,input  wire           pipe_rx03_elec_idle
+   ,input  wire           pipe_rx04_elec_idle
+   ,input  wire           pipe_rx05_elec_idle
+   ,input  wire           pipe_rx06_elec_idle
+   ,input  wire           pipe_rx07_elec_idle
+   ,input  wire           pipe_rx08_elec_idle
+   ,input  wire           pipe_rx09_elec_idle
+   ,input  wire           pipe_rx10_elec_idle
+   ,input  wire           pipe_rx11_elec_idle
+   ,input  wire           pipe_rx12_elec_idle
+   ,input  wire           pipe_rx13_elec_idle
+   ,input  wire           pipe_rx14_elec_idle
+   ,input  wire           pipe_rx15_elec_idle
+   ,input  wire           pipe_rx00_data_valid
+   ,input  wire           pipe_rx01_data_valid
+   ,input  wire           pipe_rx02_data_valid
+   ,input  wire           pipe_rx03_data_valid
+   ,input  wire           pipe_rx04_data_valid
+   ,input  wire           pipe_rx05_data_valid
+   ,input  wire           pipe_rx06_data_valid
+   ,input  wire           pipe_rx07_data_valid
+   ,input  wire           pipe_rx08_data_valid
+   ,input  wire           pipe_rx09_data_valid
+   ,input  wire           pipe_rx10_data_valid
+   ,input  wire           pipe_rx11_data_valid
+   ,input  wire           pipe_rx12_data_valid
+   ,input  wire           pipe_rx13_data_valid
+   ,input  wire           pipe_rx14_data_valid
+   ,input  wire           pipe_rx15_data_valid
+   ,input  wire [1:0]     pipe_rx00_start_block
+   ,input  wire [1:0]     pipe_rx01_start_block
+   ,input  wire [1:0]     pipe_rx02_start_block
+   ,input  wire [1:0]     pipe_rx03_start_block
+   ,input  wire [1:0]     pipe_rx04_start_block
+   ,input  wire [1:0]     pipe_rx05_start_block
+   ,input  wire [1:0]     pipe_rx06_start_block
+   ,input  wire [1:0]     pipe_rx07_start_block
+   ,input  wire [1:0]     pipe_rx08_start_block
+   ,input  wire [1:0]     pipe_rx09_start_block
+   ,input  wire [1:0]     pipe_rx10_start_block
+   ,input  wire [1:0]     pipe_rx11_start_block
+   ,input  wire [1:0]     pipe_rx12_start_block
+   ,input  wire [1:0]     pipe_rx13_start_block
+   ,input  wire [1:0]     pipe_rx14_start_block
+   ,input  wire [1:0]     pipe_rx15_start_block
+   ,input  wire [1:0]     pipe_rx00_sync_header
+   ,input  wire [1:0]     pipe_rx01_sync_header
+   ,input  wire [1:0]     pipe_rx02_sync_header
+   ,input  wire [1:0]     pipe_rx03_sync_header
+   ,input  wire [1:0]     pipe_rx04_sync_header
+   ,input  wire [1:0]     pipe_rx05_sync_header
+   ,input  wire [1:0]     pipe_rx06_sync_header
+   ,input  wire [1:0]     pipe_rx07_sync_header
+   ,input  wire [1:0]     pipe_rx08_sync_header
+   ,input  wire [1:0]     pipe_rx09_sync_header
+   ,input  wire [1:0]     pipe_rx10_sync_header
+   ,input  wire [1:0]     pipe_rx11_sync_header
+   ,input  wire [1:0]     pipe_rx12_sync_header
+   ,input  wire [1:0]     pipe_rx13_sync_header
+   ,input  wire [1:0]     pipe_rx14_sync_header
+   ,input  wire [1:0]     pipe_rx15_sync_header
+   ,output wire           pipe_tx00_compliance
+   ,output wire           pipe_tx01_compliance
+   ,output wire           pipe_tx02_compliance
+   ,output wire           pipe_tx03_compliance
+   ,output wire           pipe_tx04_compliance
+   ,output wire           pipe_tx05_compliance
+   ,output wire           pipe_tx06_compliance
+   ,output wire           pipe_tx07_compliance
+   ,output wire           pipe_tx08_compliance
+   ,output wire           pipe_tx09_compliance
+   ,output wire           pipe_tx10_compliance
+   ,output wire           pipe_tx11_compliance
+   ,output wire           pipe_tx12_compliance
+   ,output wire           pipe_tx13_compliance
+   ,output wire           pipe_tx14_compliance
+   ,output wire           pipe_tx15_compliance
+   ,output wire [1:0]     pipe_tx00_char_is_k
+   ,output wire [1:0]     pipe_tx01_char_is_k
+   ,output wire [1:0]     pipe_tx02_char_is_k
+   ,output wire [1:0]     pipe_tx03_char_is_k
+   ,output wire [1:0]     pipe_tx04_char_is_k
+   ,output wire [1:0]     pipe_tx05_char_is_k
+   ,output wire [1:0]     pipe_tx06_char_is_k
+   ,output wire [1:0]     pipe_tx07_char_is_k
+   ,output wire [1:0]     pipe_tx08_char_is_k
+   ,output wire [1:0]     pipe_tx09_char_is_k
+   ,output wire [1:0]     pipe_tx10_char_is_k
+   ,output wire [1:0]     pipe_tx11_char_is_k
+   ,output wire [1:0]     pipe_tx12_char_is_k
+   ,output wire [1:0]     pipe_tx13_char_is_k
+   ,output wire [1:0]     pipe_tx14_char_is_k
+   ,output wire [1:0]     pipe_tx15_char_is_k
+   ,output wire [31:0]    pipe_tx00_data
+   ,output wire [31:0]    pipe_tx01_data
+   ,output wire [31:0]    pipe_tx02_data
+   ,output wire [31:0]    pipe_tx03_data
+   ,output wire [31:0]    pipe_tx04_data
+   ,output wire [31:0]    pipe_tx05_data
+   ,output wire [31:0]    pipe_tx06_data
+   ,output wire [31:0]    pipe_tx07_data
+   ,output wire [31:0]    pipe_tx08_data
+   ,output wire [31:0]    pipe_tx09_data
+   ,output wire [31:0]    pipe_tx10_data
+   ,output wire [31:0]    pipe_tx11_data
+   ,output wire [31:0]    pipe_tx12_data
+   ,output wire [31:0]    pipe_tx13_data
+   ,output wire [31:0]    pipe_tx14_data
+   ,output wire [31:0]    pipe_tx15_data
+   ,output wire           pipe_tx00_elec_idle
+   ,output wire           pipe_tx01_elec_idle
+   ,output wire           pipe_tx02_elec_idle
+   ,output wire           pipe_tx03_elec_idle
+   ,output wire           pipe_tx04_elec_idle
+   ,output wire           pipe_tx05_elec_idle
+   ,output wire           pipe_tx06_elec_idle
+   ,output wire           pipe_tx07_elec_idle
+   ,output wire           pipe_tx08_elec_idle
+   ,output wire           pipe_tx09_elec_idle
+   ,output wire           pipe_tx10_elec_idle
+   ,output wire           pipe_tx11_elec_idle
+   ,output wire           pipe_tx12_elec_idle
+   ,output wire           pipe_tx13_elec_idle
+   ,output wire           pipe_tx14_elec_idle
+   ,output wire           pipe_tx15_elec_idle
+   ,output wire [1:0]     pipe_tx00_powerdown
+   ,output wire [1:0]     pipe_tx01_powerdown
+   ,output wire [1:0]     pipe_tx02_powerdown
+   ,output wire [1:0]     pipe_tx03_powerdown
+   ,output wire [1:0]     pipe_tx04_powerdown
+   ,output wire [1:0]     pipe_tx05_powerdown
+   ,output wire [1:0]     pipe_tx06_powerdown
+   ,output wire [1:0]     pipe_tx07_powerdown
+   ,output wire [1:0]     pipe_tx08_powerdown
+   ,output wire [1:0]     pipe_tx09_powerdown
+   ,output wire [1:0]     pipe_tx10_powerdown
+   ,output wire [1:0]     pipe_tx11_powerdown
+   ,output wire [1:0]     pipe_tx12_powerdown
+   ,output wire [1:0]     pipe_tx13_powerdown
+   ,output wire [1:0]     pipe_tx14_powerdown
+   ,output wire [1:0]     pipe_tx15_powerdown
+   ,output wire           pipe_tx00_data_valid
+   ,output wire           pipe_tx01_data_valid
+   ,output wire           pipe_tx02_data_valid
+   ,output wire           pipe_tx03_data_valid
+   ,output wire           pipe_tx04_data_valid
+   ,output wire           pipe_tx05_data_valid
+   ,output wire           pipe_tx06_data_valid
+   ,output wire           pipe_tx07_data_valid
+   ,output wire           pipe_tx08_data_valid
+   ,output wire           pipe_tx09_data_valid
+   ,output wire           pipe_tx10_data_valid
+   ,output wire           pipe_tx11_data_valid
+   ,output wire           pipe_tx12_data_valid
+   ,output wire           pipe_tx13_data_valid
+   ,output wire           pipe_tx14_data_valid
+   ,output wire           pipe_tx15_data_valid
+   ,output wire           pipe_tx00_start_block
+   ,output wire           pipe_tx01_start_block
+   ,output wire           pipe_tx02_start_block
+   ,output wire           pipe_tx03_start_block
+   ,output wire           pipe_tx04_start_block
+   ,output wire           pipe_tx05_start_block
+   ,output wire           pipe_tx06_start_block
+   ,output wire           pipe_tx07_start_block
+   ,output wire           pipe_tx08_start_block
+   ,output wire           pipe_tx09_start_block
+   ,output wire           pipe_tx10_start_block
+   ,output wire           pipe_tx11_start_block
+   ,output wire           pipe_tx12_start_block
+   ,output wire           pipe_tx13_start_block
+   ,output wire           pipe_tx14_start_block
+   ,output wire           pipe_tx15_start_block
+   ,output wire [1:0]     pipe_tx00_sync_header
+   ,output wire [1:0]     pipe_tx01_sync_header
+   ,output wire [1:0]     pipe_tx02_sync_header
+   ,output wire [1:0]     pipe_tx03_sync_header
+   ,output wire [1:0]     pipe_tx04_sync_header
+   ,output wire [1:0]     pipe_tx05_sync_header
+   ,output wire [1:0]     pipe_tx06_sync_header
+   ,output wire [1:0]     pipe_tx07_sync_header
+   ,output wire [1:0]     pipe_tx08_sync_header
+   ,output wire [1:0]     pipe_tx09_sync_header
+   ,output wire [1:0]     pipe_tx10_sync_header
+   ,output wire [1:0]     pipe_tx11_sync_header
+   ,output wire [1:0]     pipe_tx12_sync_header
+   ,output wire [1:0]     pipe_tx13_sync_header
+   ,output wire [1:0]     pipe_tx14_sync_header
+   ,output wire [1:0]     pipe_tx15_sync_header
+   ,output wire [1:0]     pipe_rx00_eq_control
+   ,output wire [1:0]     pipe_rx01_eq_control
+   ,output wire [1:0]     pipe_rx02_eq_control
+   ,output wire [1:0]     pipe_rx03_eq_control
+   ,output wire [1:0]     pipe_rx04_eq_control
+   ,output wire [1:0]     pipe_rx05_eq_control
+   ,output wire [1:0]     pipe_rx06_eq_control
+   ,output wire [1:0]     pipe_rx07_eq_control
+   ,output wire [1:0]     pipe_rx08_eq_control
+   ,output wire [1:0]     pipe_rx09_eq_control
+   ,output wire [1:0]     pipe_rx10_eq_control
+   ,output wire [1:0]     pipe_rx11_eq_control
+   ,output wire [1:0]     pipe_rx12_eq_control
+   ,output wire [1:0]     pipe_rx13_eq_control
+   ,output wire [1:0]     pipe_rx14_eq_control
+   ,output wire [1:0]     pipe_rx15_eq_control
+   ,input  wire           pipe_rx00_eq_lp_lf_fs_sel
+   ,input  wire           pipe_rx01_eq_lp_lf_fs_sel
+   ,input  wire           pipe_rx02_eq_lp_lf_fs_sel
+   ,input  wire           pipe_rx03_eq_lp_lf_fs_sel
+   ,input  wire           pipe_rx04_eq_lp_lf_fs_sel
+   ,input  wire           pipe_rx05_eq_lp_lf_fs_sel
+   ,input  wire           pipe_rx06_eq_lp_lf_fs_sel
+   ,input  wire           pipe_rx07_eq_lp_lf_fs_sel
+   ,input  wire           pipe_rx08_eq_lp_lf_fs_sel
+   ,input  wire           pipe_rx09_eq_lp_lf_fs_sel
+   ,input  wire           pipe_rx10_eq_lp_lf_fs_sel
+   ,input  wire           pipe_rx11_eq_lp_lf_fs_sel
+   ,input  wire           pipe_rx12_eq_lp_lf_fs_sel
+   ,input  wire           pipe_rx13_eq_lp_lf_fs_sel
+   ,input  wire           pipe_rx14_eq_lp_lf_fs_sel
+   ,input  wire           pipe_rx15_eq_lp_lf_fs_sel
+   ,input  wire [17:0]    pipe_rx00_eq_lp_new_tx_coeff_or_preset
+   ,input  wire [17:0]    pipe_rx01_eq_lp_new_tx_coeff_or_preset
+   ,input  wire [17:0]    pipe_rx02_eq_lp_new_tx_coeff_or_preset
+   ,input  wire [17:0]    pipe_rx03_eq_lp_new_tx_coeff_or_preset
+   ,input  wire [17:0]    pipe_rx04_eq_lp_new_tx_coeff_or_preset
+   ,input  wire [17:0]    pipe_rx05_eq_lp_new_tx_coeff_or_preset
+   ,input  wire [17:0]    pipe_rx06_eq_lp_new_tx_coeff_or_preset
+   ,input  wire [17:0]    pipe_rx07_eq_lp_new_tx_coeff_or_preset
+   ,input  wire [17:0]    pipe_rx08_eq_lp_new_tx_coeff_or_preset
+   ,input  wire [17:0]    pipe_rx09_eq_lp_new_tx_coeff_or_preset
+   ,input  wire [17:0]    pipe_rx10_eq_lp_new_tx_coeff_or_preset
+   ,input  wire [17:0]    pipe_rx11_eq_lp_new_tx_coeff_or_preset
+   ,input  wire [17:0]    pipe_rx12_eq_lp_new_tx_coeff_or_preset
+   ,input  wire [17:0]    pipe_rx13_eq_lp_new_tx_coeff_or_preset
+   ,input  wire [17:0]    pipe_rx14_eq_lp_new_tx_coeff_or_preset
+   ,input  wire [17:0]    pipe_rx15_eq_lp_new_tx_coeff_or_preset
+   ,input  wire           pipe_rx00_eq_lp_adapt_done
+   ,input  wire           pipe_rx01_eq_lp_adapt_done
+   ,input  wire           pipe_rx02_eq_lp_adapt_done
+   ,input  wire           pipe_rx03_eq_lp_adapt_done
+   ,input  wire           pipe_rx04_eq_lp_adapt_done
+   ,input  wire           pipe_rx05_eq_lp_adapt_done
+   ,input  wire           pipe_rx06_eq_lp_adapt_done
+   ,input  wire           pipe_rx07_eq_lp_adapt_done
+   ,input  wire           pipe_rx08_eq_lp_adapt_done
+   ,input  wire           pipe_rx09_eq_lp_adapt_done
+   ,input  wire           pipe_rx10_eq_lp_adapt_done
+   ,input  wire           pipe_rx11_eq_lp_adapt_done
+   ,input  wire           pipe_rx12_eq_lp_adapt_done
+   ,input  wire           pipe_rx13_eq_lp_adapt_done
+   ,input  wire           pipe_rx14_eq_lp_adapt_done
+   ,input  wire           pipe_rx15_eq_lp_adapt_done
+   ,input  wire           pipe_rx00_eq_done
+   ,input  wire           pipe_rx01_eq_done
+   ,input  wire           pipe_rx02_eq_done
+   ,input  wire           pipe_rx03_eq_done
+   ,input  wire           pipe_rx04_eq_done
+   ,input  wire           pipe_rx05_eq_done
+   ,input  wire           pipe_rx06_eq_done
+   ,input  wire           pipe_rx07_eq_done
+   ,input  wire           pipe_rx08_eq_done
+   ,input  wire           pipe_rx09_eq_done
+   ,input  wire           pipe_rx10_eq_done
+   ,input  wire           pipe_rx11_eq_done
+   ,input  wire           pipe_rx12_eq_done
+   ,input  wire           pipe_rx13_eq_done
+   ,input  wire           pipe_rx14_eq_done
+   ,input  wire           pipe_rx15_eq_done
+   ,output wire [1:0]     pipe_tx00_eq_control
+   ,output wire [1:0]     pipe_tx01_eq_control
+   ,output wire [1:0]     pipe_tx02_eq_control
+   ,output wire [1:0]     pipe_tx03_eq_control
+   ,output wire [1:0]     pipe_tx04_eq_control
+   ,output wire [1:0]     pipe_tx05_eq_control
+   ,output wire [1:0]     pipe_tx06_eq_control
+   ,output wire [1:0]     pipe_tx07_eq_control
+   ,output wire [1:0]     pipe_tx08_eq_control
+   ,output wire [1:0]     pipe_tx09_eq_control
+   ,output wire [1:0]     pipe_tx10_eq_control
+   ,output wire [1:0]     pipe_tx11_eq_control
+   ,output wire [1:0]     pipe_tx12_eq_control
+   ,output wire [1:0]     pipe_tx13_eq_control
+   ,output wire [1:0]     pipe_tx14_eq_control
+   ,output wire [1:0]     pipe_tx15_eq_control
+   ,output wire [5:0]     pipe_tx00_eq_deemph
+   ,output wire [5:0]     pipe_tx01_eq_deemph
+   ,output wire [5:0]     pipe_tx02_eq_deemph
+   ,output wire [5:0]     pipe_tx03_eq_deemph
+   ,output wire [5:0]     pipe_tx04_eq_deemph
+   ,output wire [5:0]     pipe_tx05_eq_deemph
+   ,output wire [5:0]     pipe_tx06_eq_deemph
+   ,output wire [5:0]     pipe_tx07_eq_deemph
+   ,output wire [5:0]     pipe_tx08_eq_deemph
+   ,output wire [5:0]     pipe_tx09_eq_deemph
+   ,output wire [5:0]     pipe_tx10_eq_deemph
+   ,output wire [5:0]     pipe_tx11_eq_deemph
+   ,output wire [5:0]     pipe_tx12_eq_deemph
+   ,output wire [5:0]     pipe_tx13_eq_deemph
+   ,output wire [5:0]     pipe_tx14_eq_deemph
+   ,output wire [5:0]     pipe_tx15_eq_deemph
+   ,input  wire [17:0]    pipe_tx00_eq_coeff
+   ,input  wire [17:0]    pipe_tx01_eq_coeff
+   ,input  wire [17:0]    pipe_tx02_eq_coeff
+   ,input  wire [17:0]    pipe_tx03_eq_coeff
+   ,input  wire [17:0]    pipe_tx04_eq_coeff
+   ,input  wire [17:0]    pipe_tx05_eq_coeff
+   ,input  wire [17:0]    pipe_tx06_eq_coeff
+   ,input  wire [17:0]    pipe_tx07_eq_coeff
+   ,input  wire [17:0]    pipe_tx08_eq_coeff
+   ,input  wire [17:0]    pipe_tx09_eq_coeff
+   ,input  wire [17:0]    pipe_tx10_eq_coeff
+   ,input  wire [17:0]    pipe_tx11_eq_coeff
+   ,input  wire [17:0]    pipe_tx12_eq_coeff
+   ,input  wire [17:0]    pipe_tx13_eq_coeff
+   ,input  wire [17:0]    pipe_tx14_eq_coeff
+   ,input  wire [17:0]    pipe_tx15_eq_coeff
+   ,input  wire           pipe_tx00_eq_done
+   ,input  wire           pipe_tx01_eq_done
+   ,input  wire           pipe_tx02_eq_done
+   ,input  wire           pipe_tx03_eq_done
+   ,input  wire           pipe_tx04_eq_done
+   ,input  wire           pipe_tx05_eq_done
+   ,input  wire           pipe_tx06_eq_done
+   ,input  wire           pipe_tx07_eq_done
+   ,input  wire           pipe_tx08_eq_done
+   ,input  wire           pipe_tx09_eq_done
+   ,input  wire           pipe_tx10_eq_done
+   ,input  wire           pipe_tx11_eq_done
+   ,input  wire           pipe_tx12_eq_done
+   ,input  wire           pipe_tx13_eq_done
+   ,input  wire           pipe_tx14_eq_done
+   ,input  wire           pipe_tx15_eq_done
+   ,output wire [3:0]     pipe_rx_eq_lp_tx_preset
+   ,output wire [5:0]     pipe_rx_eq_lp_lf_fs
+   ,output wire           pipe_tx_rcvr_det
+   ,output wire [1:0]     pipe_tx_rate
+   ,output wire           pipe_tx_deemph
+   ,output wire [2:0]     pipe_tx_margin
+   ,output wire           pipe_tx_swing
+   ,output wire           pipe_tx_reset
+   ,input  wire [5:0]     pipe_eq_fs
+   ,input  wire [5:0]     pipe_eq_lf
+   ,input  wire           pl_gen2_upstream_prefer_deemph
+   ,output wire           pl_eq_in_progress
+   ,output wire [1:0]     pl_eq_phase
+   ,input  wire           pl_eq_reset_eieos_count
+   ,input  wire           pl_redo_eq
+   ,input  wire           pl_redo_eq_speed
+   ,output wire           pl_eq_mismatch
+   ,output wire           pl_redo_eq_pending
+   ,output wire [AXI4_DATA_WIDTH-1:0] m_axis_cq_tdata
+   ,input  wire [AXI4_DATA_WIDTH-1:0] s_axis_cc_tdata
+   ,input  wire [AXI4_DATA_WIDTH-1:0] s_axis_rq_tdata
+   ,output wire [AXI4_DATA_WIDTH-1:0] m_axis_rc_tdata
+   ,output wire [AXI4_CQ_TUSER_WIDTH-1:0] m_axis_cq_tuser
+   ,input  wire [AXI4_CC_TUSER_WIDTH-1:0] s_axis_cc_tuser
+   ,output wire           m_axis_cq_tlast
+   ,input  wire           s_axis_rq_tlast
+   ,output wire           m_axis_rc_tlast
+   ,input  wire           s_axis_cc_tlast
+   ,input  wire [1:0]     pcie_cq_np_req
+   ,output wire [5:0]     pcie_cq_np_req_count
+   ,input  wire [AXI4_RQ_TUSER_WIDTH-1:0] s_axis_rq_tuser
+   ,output wire [AXI4_RC_TUSER_WIDTH-1:0] m_axis_rc_tuser
+   ,output wire [AXI4_TKEEP_WIDTH-1:0] m_axis_cq_tkeep
+   ,input  wire [AXI4_TKEEP_WIDTH-1:0] s_axis_cc_tkeep
+   ,input  wire [AXI4_TKEEP_WIDTH-1:0] s_axis_rq_tkeep
+   ,output wire [AXI4_TKEEP_WIDTH-1:0] m_axis_rc_tkeep
+   ,output wire           m_axis_cq_tvalid
+   ,input  wire           s_axis_cc_tvalid
+   ,input  wire           s_axis_rq_tvalid
+   ,output wire           m_axis_rc_tvalid
+   ,input  wire [AXI4_CQ_TREADY_WIDTH-1:0] m_axis_cq_tready
+   ,output wire [AXI4_CC_TREADY_WIDTH-1:0] s_axis_cc_tready
+   ,output wire [AXI4_RQ_TREADY_WIDTH-1:0] s_axis_rq_tready
+   ,input  wire [AXI4_RC_TREADY_WIDTH-1:0] m_axis_rc_tready
+   ,output wire [5:0]     pcie_rq_seq_num0
+   ,output wire           pcie_rq_seq_num_vld0
+   ,output wire [5:0]     pcie_rq_seq_num1
+   ,output wire           pcie_rq_seq_num_vld1
+   ,output wire [7:0]     pcie_rq_tag0
+   ,output wire           pcie_rq_tag_vld0
+   ,output wire [7:0]     pcie_rq_tag1
+   ,output wire           pcie_rq_tag_vld1
+   ,output wire [3:0]     pcie_tfc_nph_av
+   ,output wire [3:0]     pcie_tfc_npd_av
+   ,output wire [3:0]     pcie_rq_tag_av
+   ,output wire [7:0]     axi_user_out
+   ,input  wire [7:0]     axi_user_in
+   ,input  wire [9:0]     cfg_mgmt_addr
+   ,input  wire [7:0]     cfg_mgmt_function_number
+   ,input  wire           cfg_mgmt_write
+   ,input  wire [31:0]    cfg_mgmt_write_data
+   ,input  wire [3:0]     cfg_mgmt_byte_enable
+   ,input  wire           cfg_mgmt_read
+   ,output wire [31:0]    cfg_mgmt_read_data
+   ,output wire           cfg_mgmt_read_write_done
+   ,input  wire           cfg_mgmt_debug_access
+   ,output wire           cfg_phy_link_down
+   ,output wire [1:0]     cfg_phy_link_status
+   ,output wire [2:0]     cfg_negotiated_width
+   ,output wire [1:0]     cfg_current_speed
+   ,output wire [1:0]     cfg_max_payload
+   ,output wire [2:0]     cfg_max_read_req
+   ,output wire [15:0]    cfg_function_status
+   ,output wire [11:0]    cfg_function_power_state
+   ,output wire [1:0]     cfg_link_power_state
+   ,output wire           cfg_err_cor_out
+   ,output wire           cfg_err_nonfatal_out
+   ,output wire           cfg_err_fatal_out
+   ,output wire           cfg_local_error_valid
+   ,output wire [4:0]     cfg_local_error_out
+   ,output wire           cfg_ltr_enable
+   ,output wire [5:0]     cfg_ltssm_state
+   ,output wire [1:0]     cfg_rx_pm_state
+   ,output wire [1:0]     cfg_tx_pm_state
+   ,output wire [3:0]     cfg_rcb_status
+   ,output wire [1:0]     cfg_obff_enable
+   ,output wire           cfg_pl_status_change
+   ,output wire [3:0]     cfg_tph_requester_enable
+   ,output wire [11:0]    cfg_tph_st_mode
+   ,output wire           cfg_msg_received
+   ,output wire [7:0]     cfg_msg_received_data
+   ,output wire [4:0]     cfg_msg_received_type
+   ,input  wire           cfg_msg_transmit
+   ,input  wire [2:0]     cfg_msg_transmit_type
+   ,input  wire [31:0]    cfg_msg_transmit_data
+   ,output wire           cfg_msg_transmit_done
+   ,output wire [7:0]     cfg_fc_ph
+   ,output wire [11:0]    cfg_fc_pd
+   ,output wire [7:0]     cfg_fc_nph
+   ,output wire [11:0]    cfg_fc_npd
+   ,output wire [7:0]     cfg_fc_cplh
+   ,output wire [11:0]    cfg_fc_cpld
+   ,input  wire [2:0]     cfg_fc_sel
+   ,input  wire           cfg_fc_vc_sel
+   ,input  wire           cfg_hot_reset_in
+   ,output wire           cfg_hot_reset_out
+   ,input  wire           cfg_config_space_enable
+   ,input  wire [63:0]    cfg_dsn
+   ,input  wire [15:0]    cfg_dev_id_pf0
+   ,input  wire [15:0]    cfg_dev_id_pf1
+   ,input  wire [15:0]    cfg_dev_id_pf2
+   ,input  wire [15:0]    cfg_dev_id_pf3
+   ,input  wire [15:0]    cfg_vend_id
+   ,input  wire [7:0]     cfg_rev_id_pf0
+   ,input  wire [7:0]     cfg_rev_id_pf1
+   ,input  wire [7:0]     cfg_rev_id_pf2
+   ,input  wire [7:0]     cfg_rev_id_pf3
+   ,input  wire [15:0]    cfg_subsys_id_pf0
+   ,input  wire [15:0]    cfg_subsys_id_pf1
+   ,input  wire [15:0]    cfg_subsys_id_pf2
+   ,input  wire [15:0]    cfg_subsys_id_pf3
+   ,input  wire [15:0]    cfg_subsys_vend_id
+   ,input  wire [7:0]     cfg_ds_port_number
+   ,input  wire [7:0]     cfg_ds_bus_number
+   ,input  wire [4:0]     cfg_ds_device_number
+   ,input  wire [2:0]     cfg_ds_function_number
+   ,output wire [7:0]     cfg_bus_number
+   ,input  wire           cfg_power_state_change_ack
+   ,output wire           cfg_power_state_change_interrupt
+   ,input  wire           cfg_err_cor_in
+   ,input  wire           cfg_err_uncor_in
+   ,input  wire [3:0]     cfg_flr_done
+   ,output wire [3:0]     cfg_flr_in_process
+   ,input  wire           cfg_req_pm_transition_l23_ready
+   ,input  wire           cfg_link_training_enable
+   ,input  wire [3:0]     cfg_interrupt_int
+   ,output wire           cfg_interrupt_sent
+   ,input  wire [3:0]     cfg_interrupt_pending
+   ,output wire [3:0]     cfg_interrupt_msi_enable
+   ,input  wire [31:0]    cfg_interrupt_msi_int
+   ,output wire           cfg_interrupt_msi_sent
+   ,output wire           cfg_interrupt_msi_fail
+   ,output wire [11:0]    cfg_interrupt_msi_mmenable
+   ,input  wire [31:0]    cfg_interrupt_msi_pending_status
+   ,input  wire [1:0]     cfg_interrupt_msi_pending_status_function_num
+   ,input  wire           cfg_interrupt_msi_pending_status_data_enable
+   ,output wire           cfg_interrupt_msi_mask_update
+   ,input  wire [1:0]     cfg_interrupt_msi_select
+   ,output wire [31:0]    cfg_interrupt_msi_data
+   ,output wire [3:0]     cfg_interrupt_msix_enable
+   ,output wire [3:0]     cfg_interrupt_msix_mask
+   ,input  wire [63:0]    cfg_interrupt_msix_address
+   ,input  wire [31:0]    cfg_interrupt_msix_data
+   ,input  wire           cfg_interrupt_msix_int
+   ,input  wire [1:0]     cfg_interrupt_msix_vec_pending
+   ,output wire           cfg_interrupt_msix_vec_pending_status
+   ,input  wire [2:0]     cfg_interrupt_msi_attr
+   ,input  wire           cfg_interrupt_msi_tph_present
+   ,input  wire [1:0]     cfg_interrupt_msi_tph_type
+   ,input  wire [7:0]     cfg_interrupt_msi_tph_st_tag
+   ,input  wire [7:0]     cfg_interrupt_msi_function_number
+   ,output wire           cfg_ext_read_received
+   ,output wire           cfg_ext_write_received
+   ,output wire [9:0]     cfg_ext_register_number
+   ,output wire [7:0]     cfg_ext_function_number
+   ,output wire [31:0]    cfg_ext_write_data
+   ,output wire [3:0]     cfg_ext_write_byte_enable
+   ,input  wire [31:0]    cfg_ext_read_data
+   ,input  wire           cfg_ext_read_data_valid
+   ,output wire [251:0]   cfg_vf_flr_in_process
+   ,input  wire [7:0]     cfg_vf_flr_func_num
+   ,input  wire           cfg_vf_flr_done
+   ,output wire [503:0]   cfg_vf_status
+   ,output wire [755:0]   cfg_vf_power_state
+   ,output wire [251:0]   cfg_vf_tph_requester_enable
+   ,output wire [755:0]   cfg_vf_tph_st_mode
+   ,output wire [251:0]   cfg_interrupt_msix_vf_enable
+   ,output wire [251:0]   cfg_interrupt_msix_vf_mask
+   ,input  wire           cfg_pm_aspm_l1_entry_reject
+   ,input  wire           cfg_pm_aspm_tx_l0s_entry_disable
+   ,input  wire [7:0]     user_tph_stt_func_num
+   ,input  wire [5:0]     user_tph_stt_index
+   ,input  wire           user_tph_stt_rd_en
+   ,output wire [7:0]     user_tph_stt_rd_data
+   ,input  wire [1:0]     conf_req_type
+   ,input  wire [3:0]     conf_req_reg_num
+   ,input  wire [31:0]    conf_req_data
+   ,input  wire           conf_req_valid
+   ,output wire           conf_req_ready
+   ,output wire [31:0]    conf_resp_rdata
+   ,output wire           conf_resp_valid
+   ,output wire           conf_mcap_design_switch
+   ,output wire           conf_mcap_eos
+   ,output wire           conf_mcap_in_use_by_pcie
+   ,input  wire           conf_mcap_request_by_conf
+   ,input  wire           drp_clk
+   ,input  wire           drp_en
+   ,input  wire           drp_we
+   ,input  wire [9:0]     drp_addr
+   ,input  wire [15:0]    drp_di
+   ,output wire           drp_rdy
+   ,output wire [15:0]    drp_do
+
+   ,input  wire           pipe_clk
+   ,input  wire           core_clk
+   ,input  wire           user_clk
+   ,input  wire           user_clk2
+   ,output wire           user_clk_en
+   ,input  wire           mcap_clk
+   ,input  wire           mcap_rst_b
+   ,output wire           pcie_perst0_b
+   ,output wire           pcie_perst1_b
+   ,input  wire           phy_rdy 
+     //-----------------------------------------------------------------------
+     // CCIX TX Interface
+     // Data from CCIX protocol processing block
+     //-----------------------------------------------------------------------
+   ,input wire [255:0]   s_axis_ccix_tx_tdata // 256-bit data
+   ,input wire           s_axis_ccix_tx_tvalid // Valid
+   ,input wire [45:0]    s_axis_ccix_tx_tuser // tuser bus
+                         // [0] = is_sop0, [1] = is_sop0_ptr,
+                         // [2] = is_sop1, [3] = is_sop1_ptr,
+                         // [4] = is_eop0, [7:5] = is_eop0_ptr,
+                         // [8] = is_eop1, [11:9] = is_eop1_ptr,
+                         // [13:12] = discontinue, [45:14] = odd parity
+   ,output wire          ccix_tx_credit // Flow control credits to CCIX protocol processing block
+     //-----------------------------------------------------------------------
+     // CCIX RX Interface
+     // Data to downstream CCIX protocol processing block
+     //-----------------------------------------------------------------------
+   ,output wire [255:0]  m_axis_ccix_rx_tdata // 256-bit data
+   ,output wire          m_axis_ccix_rx_tvalid // Valid
+   ,output wire [45:0]   m_axis_ccix_rx_tuser // tuser bus
+                         // [0] = is_sop0, [1] = is_sop0_ptr,
+                         // [2] = is_sop1, [3] = is_sop1_ptr,
+                         // [4] = is_eop0, [7:5] = is_eop0_ptr,
+                         // [8] = is_eop1, [11:9] = is_eop1_ptr,
+                         // [13:12] = discontinue, [45:14] = odd parity
+   ,input wire           ccix_rx_credit // Flow control credits from CCIX protocol processing block
+   ,output wire [7:0]    ccix_rx_credit_av // Current value of available credit maintained by the bridge
+   ,output wire          cfg_vc1_enable
+   ,output wire          cfg_vc1_negotiation_pending
+   ,input  wire          ccix_optimized_tlp_tx_and_rx_enable
+  );
+
+  // localparams
+  
+  localparam [10:0]      MSIX_CAP_TABLE_SIZE = PF0_MSIX_CAP_TABLE_SIZE +
+                                               PF1_MSIX_CAP_TABLE_SIZE +
+                                               PF2_MSIX_CAP_TABLE_SIZE +
+                                               PF3_MSIX_CAP_TABLE_SIZE +
+                                               VFG0_MSIX_CAP_TABLE_SIZE +
+                                               VFG1_MSIX_CAP_TABLE_SIZE +
+                                               VFG2_MSIX_CAP_TABLE_SIZE +
+                                               VFG3_MSIX_CAP_TABLE_SIZE;
+  localparam             MSIX_TABLE_RAM_ENABLE = AXISTEN_IF_ENABLE_INTERNAL_MSIX_TABLE;
+
+
+  // Resets
+  
+  wire                        reset_n;
+  wire                        core_reset_n;
+  wire                        mgmt_reset_n;
+  wire                        mgmt_sticky_reset_n;
+  wire                        pipe_reset_n;
+  wire                        user_clkgate_en;
+  wire                        pipe_clkgate_en;
+  wire                        user_clk_en_to_e4;
+  wire                        user_clk_to_e4;
+  wire                        user_clk2_to_e4;
+  wire                        pipe_clk_to_e4;
+  wire                        cfg_phy_link_down_wire;
+  wire                        cfg_phy_link_down_user_clk;
+
+  wire [31:0]                 pipe_tx00_data_out;
+  wire [31:0]                 pipe_tx01_data_out;
+  wire [31:0]                 pipe_tx02_data_out;
+  wire [31:0]                 pipe_tx03_data_out;
+  wire [31:0]                 pipe_tx04_data_out;
+  wire [31:0]                 pipe_tx05_data_out;
+  wire [31:0]                 pipe_tx06_data_out;
+  wire [31:0]                 pipe_tx07_data_out;
+  wire [31:0]                 pipe_tx08_data_out;
+  wire [31:0]                 pipe_tx09_data_out;
+  wire [31:0]                 pipe_tx10_data_out;
+  wire [31:0]                 pipe_tx11_data_out;
+  wire [31:0]                 pipe_tx12_data_out;
+  wire [31:0]                 pipe_tx13_data_out;
+  wire [31:0]                 pipe_tx14_data_out;
+  wire [31:0]                 pipe_tx15_data_out;
+
+  assign cfg_phy_link_down = cfg_phy_link_down_wire;
+
+generate if (IMPL_TARGET=="SOFT" || IMPL_TARGET=="PROTO") begin
+
+   // no clock gating case for soft or hard
+   assign user_clk_en_to_e4  = user_clk_en;
+   assign user_clk_to_e4     = user_clk;
+   assign user_clk2_to_e4    = user_clk2;
+   assign pipe_clk_to_e4     = pipe_clk;   
+
+end else begin
+
+   // clock gating case for soft or hard
+   assign user_clk_en_to_e4  = user_clkgate_en;
+   assign user_clk_to_e4     = 1'b0;
+   assign user_clk2_to_e4    = 1'b0;
+   assign pipe_clk_to_e4     = pipe_clk;   // pipe clock gating not yet included
+
+end
+endgenerate
+
+/*
+//
+// EIEOS Spec 0.7 Enable for Gen4 Mode
+//
+    assign pipe_tx00_data = ((cfg_current_speed == 2'b11) & (pipe_tx00_sync_header == 2'b01) &  (pipe_tx00_data_out == 32'hFF00FF00) & (PL_USER_SPARE[4])) ? 32'hFFFF0000 : pipe_tx00_data_out;
+    assign pipe_tx01_data = ((cfg_current_speed == 2'b11) & (pipe_tx01_sync_header == 2'b01) &  (pipe_tx01_data_out == 32'hFF00FF00) & (PL_USER_SPARE[4])) ? 32'hFFFF0000 : pipe_tx01_data_out;
+    assign pipe_tx02_data = ((cfg_current_speed == 2'b11) & (pipe_tx02_sync_header == 2'b01) &  (pipe_tx02_data_out == 32'hFF00FF00) & (PL_USER_SPARE[4])) ? 32'hFFFF0000 : pipe_tx02_data_out;
+    assign pipe_tx03_data = ((cfg_current_speed == 2'b11) & (pipe_tx03_sync_header == 2'b01) &  (pipe_tx03_data_out == 32'hFF00FF00) & (PL_USER_SPARE[4])) ? 32'hFFFF0000 : pipe_tx03_data_out;
+    assign pipe_tx04_data = ((cfg_current_speed == 2'b11) & (pipe_tx04_sync_header == 2'b01) &  (pipe_tx04_data_out == 32'hFF00FF00) & (PL_USER_SPARE[4])) ? 32'hFFFF0000 : pipe_tx04_data_out;
+    assign pipe_tx05_data = ((cfg_current_speed == 2'b11) & (pipe_tx05_sync_header == 2'b01) &  (pipe_tx05_data_out == 32'hFF00FF00) & (PL_USER_SPARE[4])) ? 32'hFFFF0000 : pipe_tx05_data_out;
+    assign pipe_tx06_data = ((cfg_current_speed == 2'b11) & (pipe_tx06_sync_header == 2'b01) &  (pipe_tx06_data_out == 32'hFF00FF00) & (PL_USER_SPARE[4])) ? 32'hFFFF0000 : pipe_tx06_data_out;
+    assign pipe_tx07_data = ((cfg_current_speed == 2'b11) & (pipe_tx07_sync_header == 2'b01) &  (pipe_tx07_data_out == 32'hFF00FF00) & (PL_USER_SPARE[4])) ? 32'hFFFF0000 : pipe_tx07_data_out;
+    assign pipe_tx08_data = ((cfg_current_speed == 2'b11) & (pipe_tx00_sync_header == 2'b01) & ((pipe_tx00_data_out == 32'hFF00FF00) | (pipe_tx08_data_out == 32'hFF00FF00)) & (PL_USER_SPARE[4])) ? 32'hFFFF0000 : pipe_tx08_data_out;
+    assign pipe_tx09_data = ((cfg_current_speed == 2'b11) & (pipe_tx01_sync_header == 2'b01) & ((pipe_tx01_data_out == 32'hFF00FF00) | (pipe_tx09_data_out == 32'hFF00FF00)) & (PL_USER_SPARE[4])) ? 32'hFFFF0000 : pipe_tx09_data_out;
+    assign pipe_tx10_data = ((cfg_current_speed == 2'b11) & (pipe_tx02_sync_header == 2'b01) & ((pipe_tx02_data_out == 32'hFF00FF00) | (pipe_tx10_data_out == 32'hFF00FF00)) & (PL_USER_SPARE[4])) ? 32'hFFFF0000 : pipe_tx10_data_out;
+    assign pipe_tx11_data = ((cfg_current_speed == 2'b11) & (pipe_tx03_sync_header == 2'b01) & ((pipe_tx03_data_out == 32'hFF00FF00) | (pipe_tx11_data_out == 32'hFF00FF00)) & (PL_USER_SPARE[4])) ? 32'hFFFF0000 : pipe_tx11_data_out;
+    assign pipe_tx12_data = ((cfg_current_speed == 2'b11) & (pipe_tx04_sync_header == 2'b01) & ((pipe_tx04_data_out == 32'hFF00FF00) | (pipe_tx12_data_out == 32'hFF00FF00)) & (PL_USER_SPARE[4])) ? 32'hFFFF0000 : pipe_tx12_data_out;
+    assign pipe_tx13_data = ((cfg_current_speed == 2'b11) & (pipe_tx05_sync_header == 2'b01) & ((pipe_tx05_data_out == 32'hFF00FF00) | (pipe_tx13_data_out == 32'hFF00FF00)) & (PL_USER_SPARE[4])) ? 32'hFFFF0000 : pipe_tx13_data_out;
+    assign pipe_tx14_data = ((cfg_current_speed == 2'b11) & (pipe_tx06_sync_header == 2'b01) & ((pipe_tx06_data_out == 32'hFF00FF00) | (pipe_tx14_data_out == 32'hFF00FF00)) & (PL_USER_SPARE[4])) ? 32'hFFFF0000 : pipe_tx14_data_out;
+    assign pipe_tx15_data = ((cfg_current_speed == 2'b11) & (pipe_tx07_sync_header == 2'b01) & ((pipe_tx07_data_out == 32'hFF00FF00) | (pipe_tx15_data_out == 32'hFF00FF00)) & (PL_USER_SPARE[4])) ? 32'hFFFF0000 : pipe_tx15_data_out;
+*/
+    assign pipe_tx00_data = pipe_tx00_data_out; 
+    assign pipe_tx01_data = pipe_tx01_data_out;
+    assign pipe_tx02_data = pipe_tx02_data_out;
+    assign pipe_tx03_data = pipe_tx03_data_out;
+    assign pipe_tx04_data = pipe_tx04_data_out;
+    assign pipe_tx05_data = pipe_tx05_data_out;
+    assign pipe_tx06_data = pipe_tx06_data_out;
+    assign pipe_tx07_data = pipe_tx07_data_out;
+    assign pipe_tx08_data = pipe_tx08_data_out;
+    assign pipe_tx09_data = pipe_tx09_data_out;
+    assign pipe_tx10_data = pipe_tx10_data_out;
+    assign pipe_tx11_data = pipe_tx11_data_out;
+    assign pipe_tx12_data = pipe_tx12_data_out;
+    assign pipe_tx13_data = pipe_tx13_data_out;
+    assign pipe_tx14_data = pipe_tx14_data_out;
+    assign pipe_tx15_data = pipe_tx15_data_out;
+     
+ 
+  // Memory Interfaces
+
+  wire [8:0]                  mi_replay_ram_address0;
+  wire [8:0]                  mi_replay_ram_address1;
+  wire [127:0]                mi_replay_ram_write_data0;
+  wire                        mi_replay_ram_write_enable0;
+  wire [127:0]                mi_replay_ram_write_data1;
+  wire                        mi_replay_ram_write_enable1;
+  wire [127:0]                mi_replay_ram_read_data0;
+  wire                        mi_replay_ram_read_enable0;
+  wire [127:0]                mi_replay_ram_read_data1;
+  wire                        mi_replay_ram_read_enable1;
+  wire [5:0]                  mi_replay_ram_err_cor;
+  wire [5:0]                  mi_replay_ram_err_uncor;
+  wire [8:0]                  mi_rx_posted_request_ram_write_address0;
+  wire [143:0]                mi_rx_posted_request_ram_write_data0;
+  wire                        mi_rx_posted_request_ram_write_enable0;
+  wire [8:0]                  mi_rx_posted_request_ram_write_address1;
+  wire [143:0]                mi_rx_posted_request_ram_write_data1;
+  wire                        mi_rx_posted_request_ram_write_enable1;
+  wire [8:0]                  mi_rx_posted_request_ram_read_address0;
+  wire [143:0]                mi_rx_posted_request_ram_read_data0;
+  wire                        mi_rx_posted_request_ram_read_enable0;
+  wire [8:0]                  mi_rx_posted_request_ram_read_address1;
+  wire [143:0]                mi_rx_posted_request_ram_read_data1;
+  wire                        mi_rx_posted_request_ram_read_enable1;
+  wire [5:0]                  mi_rx_posted_request_ram_err_cor;
+  wire [5:0]                  mi_rx_posted_request_ram_err_uncor;
+  wire [8:0]                  mi_rx_completion_ram_write_address0;
+  wire [143:0]                mi_rx_completion_ram_write_data0;
+  wire [1:0]                  mi_rx_completion_ram_write_enable0;
+  wire [8:0]                  mi_rx_completion_ram_write_address1;
+  wire [143:0]                mi_rx_completion_ram_write_data1;
+  wire [1:0]                  mi_rx_completion_ram_write_enable1;
+  wire [8:0]                  mi_rx_completion_ram_read_address0;
+  wire [143:0]                mi_rx_completion_ram_read_data0;
+  wire [1:0]                  mi_rx_completion_ram_read_enable0;
+  wire [8:0]                  mi_rx_completion_ram_read_address1;
+  wire [143:0]                mi_rx_completion_ram_read_data1;
+  wire [1:0]                  mi_rx_completion_ram_read_enable1;
+  wire [11:0]                 mi_rx_completion_ram_err_cor;
+  wire [11:0]                 mi_rx_completion_ram_err_uncor;
+  wire [11:0]                 cfg_tph_ram_address;
+  wire [35:0]                 cfg_tph_ram_write_data;
+  wire [3:0]                  cfg_tph_ram_write_byte_enable;
+  wire [35:0]                 cfg_tph_ram_read_data;
+  wire                        cfg_tph_ram_read_enable;
+  wire [12:0]                 cfg_msix_ram_address;
+  wire [35:0]                 cfg_msix_ram_write_data;
+  wire [3:0]                  cfg_msix_ram_write_byte_enable;
+  wire [35:0]                 cfg_msix_ram_read_data;
+  wire                        cfg_msix_ram_read_enable;
+ 
+  // Driven by soft logic
+  wire                        pcie_posted_req_delivered;
+  wire                        pcie_cq_pipeline_empty;
+  wire                        pcie_cq_np_user_credit_rcvd;
+  wire [1:0]                  pcie_compl_delivered;
+  wire [7:0]                  pcie_compl_delivered_tag0;
+  wire [7:0]                  pcie_compl_delivered_tag1;
+
+  // Wires from Hard Block AXI Stream Interface to Soft Bridge
+  wire [255:0]                m_axis_cq_tdata_int;
+  wire [87:0]                 m_axis_cq_tuser_int;
+  wire                        m_axis_cq_tlast_int;
+  wire [7:0]                  m_axis_cq_tkeep_int;
+  wire                        m_axis_cq_tvalid_int;
+        
+  wire [255:0]                s_axis_cc_tdata_int;
+  wire [32:0]                 s_axis_cc_tuser_int;
+  wire                        s_axis_cc_tlast_int;
+  wire [7:0]                  s_axis_cc_tkeep_int;
+  wire                        s_axis_cc_tvalid_int;
+
+  wire [255:0]                s_axis_rq_tdata_int;
+  wire [61:0]                 s_axis_rq_tuser_int;
+  wire                        s_axis_rq_tlast_int;
+  wire [7:0]                  s_axis_rq_tkeep_int;
+  wire                        s_axis_rq_tvalid_int;
+
+  wire [255:0]                m_axis_rc_tdata_int;
+  wire [74:0]                 m_axis_rc_tuser_int;
+  wire                        m_axis_rc_tlast_int;
+  wire [7:0]                  m_axis_rc_tkeep_int;
+  wire                        m_axis_rc_tvalid_int;
+
+  wire [255:0]                s_axis_cc_tdata_axi512;
+  wire [32:0]                 s_axis_cc_tuser_axi512;
+  wire                        s_axis_cc_tlast_axi512;
+  wire [7:0]                  s_axis_cc_tkeep_axi512;
+  wire                        s_axis_cc_tvalid_axi512;
+
+  wire [255:0]                s_axis_rq_tdata_axi512;
+  wire [61:0]                 s_axis_rq_tuser_axi512;
+  wire                        s_axis_rq_tlast_axi512;
+  wire [7:0]                  s_axis_rq_tkeep_axi512;
+  wire                        s_axis_rq_tvalid_axi512;
+
+  wire [21:0]                 m_axis_cq_tready_int;
+  wire [21:0]                 m_axis_rc_tready_int;
+  wire [21:0]                 m_axis_cq_tready_axi512;
+  wire [21:0]                 m_axis_rc_tready_axi512;
+  wire [3:0]                  s_axis_cc_tready_int;
+  wire                        s_axis_cc_tready_axi512;
+  wire [3:0]                  s_axis_rq_tready_int;
+  wire                        s_axis_rq_tready_axi512;
+
+  wire [5:0]                  pcie_cq_np_req_count_int;
+  wire [5:0]                  pcie_cq_np_req_count_axi512;
+
+  wire                        pl_gen34_redo_equalization;
+  wire                        pl_gen34_redo_eq_speed;
+  wire                        pl_gen34_eq_mismatch;
+
+  wire [5:0]     pcie_rq_seq_num0_cc;
+  wire           pcie_rq_seq_num_vld0_cc;
+
+  // Wires between TL CCIX RX interface and soft FIFO
+  wire [255:0] 	 m_axis_ccix_rx_tdata_int;
+  wire 		 m_axis_ccix_rx_tvalid_int;
+  wire [45:0]	 m_axis_ccix_rx_tuser_int;
+  wire 		 ccix_rx_tlp_forwarded0_int;
+  wire [5:0] 	 ccix_rx_tlp_forwarded_length0_int;
+  wire 		 ccix_rx_tlp_forwarded1_int;
+  wire [5:0]	 ccix_rx_tlp_forwarded_length1_int;
+  wire 		 ccix_rx_fifo_overflow_int;
+  wire 		 ccix_rx_correctable_error_detected_int;
+  wire 		 ccix_rx_uncorrectable_error_detected_int;
+  wire [8:0] 	 mi_rx_ccix_fifo_ram_write_address0;
+  wire [143:0] 	 mi_rx_ccix_fifo_ram_write_data0;
+  wire           mi_rx_ccix_fifo_ram_write_enable0;
+  wire [8:0] 	 mi_rx_ccix_fifo_ram_write_address1;
+  wire [143:0] 	 mi_rx_ccix_fifo_ram_write_data1;
+  wire           mi_rx_ccix_fifo_ram_write_enable1;
+  wire [8:0] 	 mi_rx_ccix_fifo_ram_read_address0;
+  wire [143:0] 	 mi_rx_ccix_fifo_ram_read_data0;
+  wire 		 mi_rx_ccix_fifo_ram_read_enable0;
+  wire [8:0] 	 mi_rx_ccix_fifo_ram_read_address1;
+  wire [143:0] 	 mi_rx_ccix_fifo_ram_read_data1;
+  wire 		 mi_rx_ccix_fifo_ram_read_enable1;
+  wire [5:0] 	 mi_rx_ccix_fifo_ram_err_cor;
+  wire [5:0] 	 mi_rx_ccix_fifo_ram_err_uncor;
+
+  wire [255:0]   dbg_data1_out;
+  wire [129:0]   dbg_ccix_out; // WIP new outputs
+
+  assign ccix_rx_tlp_forwarded_length1_int[5:1] = 5'h00; // WIP unused
+
+  PCIE4CE4 #(
+
+    .CRM_CORE_CLK_FREQ_500(CRM_CORE_CLK_FREQ_500)
+   ,.CRM_USER_CLK_FREQ(CRM_USER_CLK_FREQ)
+   ,.SIM_DEVICE(SIM_DEVICE)
+   ,.AXISTEN_IF_WIDTH(AXISTEN_IF_WIDTH)
+   ,.AXISTEN_IF_EXT_512(AXISTEN_IF_EXT_512)
+   ,.AXISTEN_IF_EXT_512_CQ_STRADDLE(AXISTEN_IF_EXT_512_CQ_STRADDLE)
+   ,.AXISTEN_IF_EXT_512_CC_STRADDLE(AXISTEN_IF_EXT_512_CC_STRADDLE)
+   ,.AXISTEN_IF_EXT_512_RQ_STRADDLE(AXISTEN_IF_EXT_512_RQ_STRADDLE)
+   ,.AXISTEN_IF_EXT_512_RC_STRADDLE(AXISTEN_IF_EXT_512_RC_STRADDLE)
+   ,.AXISTEN_IF_CQ_ALIGNMENT_MODE(AXISTEN_IF_CQ_ALIGNMENT_MODE)
+   ,.AXISTEN_IF_CC_ALIGNMENT_MODE(AXISTEN_IF_CC_ALIGNMENT_MODE)
+   ,.AXISTEN_IF_RQ_ALIGNMENT_MODE(AXISTEN_IF_RQ_ALIGNMENT_MODE)
+   ,.AXISTEN_IF_RC_ALIGNMENT_MODE(AXISTEN_IF_RC_ALIGNMENT_MODE)
+   ,.AXISTEN_IF_RC_STRADDLE(AXISTEN_IF_RC_STRADDLE)
+   ,.AXISTEN_IF_ENABLE_RX_MSG_INTFC(AXISTEN_IF_ENABLE_RX_MSG_INTFC)
+   ,.AXISTEN_IF_ENABLE_MSG_ROUTE(AXISTEN_IF_ENABLE_MSG_ROUTE)
+   ,.AXISTEN_IF_RX_PARITY_EN(AXISTEN_IF_RX_PARITY_EN)
+   ,.AXISTEN_IF_TX_PARITY_EN(AXISTEN_IF_TX_PARITY_EN)
+   ,.AXISTEN_IF_ENABLE_CLIENT_TAG(AXISTEN_IF_ENABLE_CLIENT_TAG)
+   ,.AXISTEN_IF_ENABLE_256_TAGS(AXISTEN_IF_ENABLE_256_TAGS)
+   ,.AXISTEN_IF_COMPL_TIMEOUT_REG0(AXISTEN_IF_COMPL_TIMEOUT_REG0)
+   ,.AXISTEN_IF_COMPL_TIMEOUT_REG1(AXISTEN_IF_COMPL_TIMEOUT_REG1)
+   ,.AXISTEN_IF_LEGACY_MODE_ENABLE(AXISTEN_IF_LEGACY_MODE_ENABLE)
+   ,.AXISTEN_IF_ENABLE_MESSAGE_RID_CHECK(AXISTEN_IF_ENABLE_MESSAGE_RID_CHECK)
+   ,.AXISTEN_IF_MSIX_TO_RAM_PIPELINE(AXISTEN_IF_MSIX_TO_RAM_PIPELINE)
+   ,.AXISTEN_IF_MSIX_FROM_RAM_PIPELINE(AXISTEN_IF_MSIX_FROM_RAM_PIPELINE)
+   ,.AXISTEN_IF_MSIX_RX_PARITY_EN(AXISTEN_IF_MSIX_RX_PARITY_EN)
+   ,.AXISTEN_IF_ENABLE_INTERNAL_MSIX_TABLE(AXISTEN_IF_ENABLE_INTERNAL_MSIX_TABLE)
+   ,.AXISTEN_IF_SIM_SHORT_CPL_TIMEOUT(AXISTEN_IF_SIM_SHORT_CPL_TIMEOUT)
+   ,.AXISTEN_IF_CQ_EN_POISONED_MEM_WR(AXISTEN_IF_CQ_EN_POISONED_MEM_WR)
+   ,.PM_ASPML0S_TIMEOUT(PM_ASPML0S_TIMEOUT)
+   ,.PM_L1_REENTRY_DELAY(PM_L1_REENTRY_DELAY)
+   ,.PM_ASPML1_ENTRY_DELAY(PM_ASPML1_ENTRY_DELAY)
+   ,.PM_ENABLE_SLOT_POWER_CAPTURE(PM_ENABLE_SLOT_POWER_CAPTURE)
+   ,.PM_PME_SERVICE_TIMEOUT_DELAY(PM_PME_SERVICE_TIMEOUT_DELAY)
+   ,.PM_PME_TURNOFF_ACK_DELAY(PM_PME_TURNOFF_ACK_DELAY)
+   ,.PL_UPSTREAM_FACING(PL_UPSTREAM_FACING)
+   ,.PL_LINK_CAP_MAX_LINK_WIDTH(PL_LINK_CAP_MAX_LINK_WIDTH)
+   ,.PL_LINK_CAP_MAX_LINK_SPEED(PL_LINK_CAP_MAX_LINK_SPEED)
+   ,.PL_DISABLE_DC_BALANCE(PL_DISABLE_DC_BALANCE)
+   ,.PL_DISABLE_EI_INFER_IN_L0(PL_DISABLE_EI_INFER_IN_L0)
+   ,.PL_N_FTS(PL_N_FTS)
+   ,.PL_DISABLE_UPCONFIG_CAPABLE(PL_DISABLE_UPCONFIG_CAPABLE)
+   ,.PL_DISABLE_RETRAIN_ON_FRAMING_ERROR(PL_DISABLE_RETRAIN_ON_FRAMING_ERROR)
+   ,.PL_DISABLE_RETRAIN_ON_EB_ERROR(PL_DISABLE_RETRAIN_ON_EB_ERROR)
+   ,.PL_DISABLE_RETRAIN_ON_SPECIFIC_FRAMING_ERROR(PL_DISABLE_RETRAIN_ON_SPECIFIC_FRAMING_ERROR)
+   ,.PL_REPORT_ALL_PHY_ERRORS(PL_REPORT_ALL_PHY_ERRORS)
+   ,.PL_DISABLE_LFSR_UPDATE_ON_SKP(PL_DISABLE_LFSR_UPDATE_ON_SKP)
+   ,.PL_LANE0_EQ_CONTROL(PL_LANE0_EQ_CONTROL)
+   ,.PL_LANE1_EQ_CONTROL(PL_LANE1_EQ_CONTROL)
+   ,.PL_LANE2_EQ_CONTROL(PL_LANE2_EQ_CONTROL)
+   ,.PL_LANE3_EQ_CONTROL(PL_LANE3_EQ_CONTROL)
+   ,.PL_LANE4_EQ_CONTROL(PL_LANE4_EQ_CONTROL)
+   ,.PL_LANE5_EQ_CONTROL(PL_LANE5_EQ_CONTROL)
+   ,.PL_LANE6_EQ_CONTROL(PL_LANE6_EQ_CONTROL)
+   ,.PL_LANE7_EQ_CONTROL(PL_LANE7_EQ_CONTROL)
+   ,.PL_LANE8_EQ_CONTROL(PL_LANE8_EQ_CONTROL)
+   ,.PL_LANE9_EQ_CONTROL(PL_LANE9_EQ_CONTROL)
+   ,.PL_LANE10_EQ_CONTROL(PL_LANE10_EQ_CONTROL)
+   ,.PL_LANE11_EQ_CONTROL(PL_LANE11_EQ_CONTROL)
+   ,.PL_LANE12_EQ_CONTROL(PL_LANE12_EQ_CONTROL)
+   ,.PL_LANE13_EQ_CONTROL(PL_LANE13_EQ_CONTROL)
+   ,.PL_LANE14_EQ_CONTROL(PL_LANE14_EQ_CONTROL)
+   ,.PL_LANE15_EQ_CONTROL(PL_LANE15_EQ_CONTROL)
+   ,.PL_EQ_BYPASS_PHASE23(PL_EQ_BYPASS_PHASE23)
+   ,.PL_EQ_ADAPT_ITER_COUNT(PL_EQ_ADAPT_ITER_COUNT)
+   ,.PL_EQ_ADAPT_REJECT_RETRY_COUNT(PL_EQ_ADAPT_REJECT_RETRY_COUNT)
+   ,.PL_EQ_SHORT_ADAPT_PHASE(PL_EQ_SHORT_ADAPT_PHASE)
+   ,.PL_EQ_ADAPT_DISABLE_COEFF_CHECK(PL_EQ_ADAPT_DISABLE_COEFF_CHECK)
+   ,.PL_EQ_ADAPT_DISABLE_PRESET_CHECK(PL_EQ_ADAPT_DISABLE_PRESET_CHECK)
+   ,.PL_EQ_DEFAULT_TX_PRESET(PL_EQ_DEFAULT_TX_PRESET)
+   ,.PL_EQ_DEFAULT_RX_PRESET_HINT(PL_EQ_DEFAULT_RX_PRESET_HINT)
+   ,.PL_EQ_RX_ADAPT_EQ_PHASE0(PL_EQ_RX_ADAPT_EQ_PHASE0)
+   ,.PL_EQ_RX_ADAPT_EQ_PHASE1(PL_EQ_RX_ADAPT_EQ_PHASE1)
+   ,.PL_EQ_DISABLE_MISMATCH_CHECK(PL_EQ_DISABLE_MISMATCH_CHECK)
+   ,.PL_RX_L0S_EXIT_TO_RECOVERY(PL_RX_L0S_EXIT_TO_RECOVERY)
+   ,.PL_EQ_TX_8G_EQ_TS2_ENABLE(PL_EQ_TX_8G_EQ_TS2_ENABLE)
+   ,.PL_DISABLE_AUTO_EQ_SPEED_CHANGE_TO_GEN4(PL_DISABLE_AUTO_EQ_SPEED_CHANGE_TO_GEN4)
+   ,.PL_DISABLE_AUTO_EQ_SPEED_CHANGE_TO_GEN3(PL_DISABLE_AUTO_EQ_SPEED_CHANGE_TO_GEN3)
+   ,.PL_DISABLE_AUTO_SPEED_CHANGE_TO_GEN2(PL_DISABLE_AUTO_SPEED_CHANGE_TO_GEN2)
+   ,.PL_DESKEW_ON_SKIP_IN_GEN12(PL_DESKEW_ON_SKIP_IN_GEN12)
+   ,.PL_INFER_EI_DISABLE_REC_RC(PL_INFER_EI_DISABLE_REC_RC)
+   ,.PL_INFER_EI_DISABLE_REC_SPD(PL_INFER_EI_DISABLE_REC_SPD)
+   ,.PL_INFER_EI_DISABLE_LPBK_ACTIVE(PL_INFER_EI_DISABLE_LPBK_ACTIVE)
+   ,.PL_RX_ADAPT_TIMER_RRL_GEN3(PL_RX_ADAPT_TIMER_RRL_GEN3)
+   ,.PL_RX_ADAPT_TIMER_RRL_CLOBBER_TX_TS(PL_RX_ADAPT_TIMER_RRL_CLOBBER_TX_TS)
+   ,.PL_RX_ADAPT_TIMER_RRL_GEN4(PL_RX_ADAPT_TIMER_RRL_GEN4)
+   ,.PL_RX_ADAPT_TIMER_CLWS_GEN3(PL_RX_ADAPT_TIMER_CLWS_GEN3)
+   ,.PL_RX_ADAPT_TIMER_CLWS_CLOBBER_TX_TS(PL_RX_ADAPT_TIMER_CLWS_CLOBBER_TX_TS)
+   ,.PL_RX_ADAPT_TIMER_CLWS_GEN4(PL_RX_ADAPT_TIMER_CLWS_GEN4)
+   ,.PL_DISABLE_LANE_REVERSAL(PL_DISABLE_LANE_REVERSAL)
+   ,.PL_CFG_STATE_ROBUSTNESS_ENABLE(PL_CFG_STATE_ROBUSTNESS_ENABLE)
+   ,.PL_REDO_EQ_SOURCE_SELECT(PL_REDO_EQ_SOURCE_SELECT)
+   ,.PL_DEEMPH_SOURCE_SELECT(PL_DEEMPH_SOURCE_SELECT)
+   ,.PL_EXIT_LOOPBACK_ON_EI_ENTRY(PL_EXIT_LOOPBACK_ON_EI_ENTRY)
+   ,.PL_QUIESCE_GUARANTEE_DISABLE(PL_QUIESCE_GUARANTEE_DISABLE)
+   ,.PL_SRIS_ENABLE(PL_SRIS_ENABLE)
+   ,.PL_SRIS_SKPOS_GEN_SPD_VEC(PL_SRIS_SKPOS_GEN_SPD_VEC)
+   ,.PL_SRIS_SKPOS_REC_SPD_VEC(PL_SRIS_SKPOS_REC_SPD_VEC)
+   ,.PL_SIM_FAST_LINK_TRAINING(PL_SIM_FAST_LINK_TRAINING)
+   ,.PL_USER_SPARE(PL_USER_SPARE)
+   ,.LL_ACK_TIMEOUT_EN(LL_ACK_TIMEOUT_EN)
+   ,.LL_ACK_TIMEOUT(LL_ACK_TIMEOUT)
+   ,.LL_ACK_TIMEOUT_FUNC(LL_ACK_TIMEOUT_FUNC)
+   ,.LL_REPLAY_TIMEOUT_EN(LL_REPLAY_TIMEOUT_EN)
+   ,.LL_REPLAY_TIMEOUT(LL_REPLAY_TIMEOUT)
+   ,.LL_REPLAY_TIMEOUT_FUNC(LL_REPLAY_TIMEOUT_FUNC)
+   ,.LL_REPLAY_TO_RAM_PIPELINE(LL_REPLAY_TO_RAM_PIPELINE)
+   ,.LL_REPLAY_FROM_RAM_PIPELINE(LL_REPLAY_FROM_RAM_PIPELINE)
+   ,.LL_DISABLE_SCHED_TX_NAK(LL_DISABLE_SCHED_TX_NAK)
+   ,.LL_TX_TLP_PARITY_CHK(LL_TX_TLP_PARITY_CHK)
+   ,.LL_RX_TLP_PARITY_GEN(LL_RX_TLP_PARITY_GEN)
+   ,.LL_USER_SPARE(LL_USER_SPARE)
+   ,.IS_SWITCH_PORT(IS_SWITCH_PORT)
+   ,.CFG_BYPASS_MODE_ENABLE(CFG_BYPASS_MODE_ENABLE)
+   ,.TL_PF_ENABLE_REG(TL_PF_ENABLE_REG)
+   ,.TL_CREDITS_CD(TL_CREDITS_CD)
+   ,.TL_CREDITS_CH(TL_CREDITS_CH)
+   ,.TL_COMPLETION_RAM_SIZE(TL_COMPLETION_RAM_SIZE)
+   ,.TL_COMPLETION_RAM_NUM_TLPS(TL_COMPLETION_RAM_NUM_TLPS)
+   ,.TL_CREDITS_NPD(TL_CREDITS_NPD)
+   ,.TL_CREDITS_NPH(TL_CREDITS_NPH)
+   ,.TL_CREDITS_PD(TL_CREDITS_PD)
+   ,.TL_CREDITS_PH(TL_CREDITS_PH)
+   ,.TL_RX_COMPLETION_TO_RAM_WRITE_PIPELINE(TL_RX_COMPLETION_TO_RAM_WRITE_PIPELINE)
+   ,.TL_RX_COMPLETION_TO_RAM_READ_PIPELINE(TL_RX_COMPLETION_TO_RAM_READ_PIPELINE)
+   ,.TL_RX_COMPLETION_FROM_RAM_READ_PIPELINE(TL_RX_COMPLETION_FROM_RAM_READ_PIPELINE)
+   ,.TL_POSTED_RAM_SIZE(TL_POSTED_RAM_SIZE)
+   ,.TL_RX_POSTED_TO_RAM_WRITE_PIPELINE(TL_RX_POSTED_TO_RAM_WRITE_PIPELINE)
+   ,.TL_RX_POSTED_TO_RAM_READ_PIPELINE(TL_RX_POSTED_TO_RAM_READ_PIPELINE)
+   ,.TL_RX_POSTED_FROM_RAM_READ_PIPELINE(TL_RX_POSTED_FROM_RAM_READ_PIPELINE)
+   ,.TL_TX_MUX_STRICT_PRIORITY(TL_TX_MUX_STRICT_PRIORITY)
+   ,.TL_TX_TLP_STRADDLE_ENABLE(TL_TX_TLP_STRADDLE_ENABLE)
+   ,.TL_TX_TLP_TERMINATE_PARITY(TL_TX_TLP_TERMINATE_PARITY)
+   ,.TL_FC_UPDATE_MIN_INTERVAL_TLP_COUNT(TL_FC_UPDATE_MIN_INTERVAL_TLP_COUNT)
+   ,.TL_FC_UPDATE_MIN_INTERVAL_TIME(TL_FC_UPDATE_MIN_INTERVAL_TIME)
+   ,.TL_USER_SPARE(TL_USER_SPARE)
+   ,.PF0_CLASS_CODE(PF0_CLASS_CODE)
+   ,.PF1_CLASS_CODE(PF1_CLASS_CODE)
+   ,.PF2_CLASS_CODE(PF2_CLASS_CODE)
+   ,.PF3_CLASS_CODE(PF3_CLASS_CODE)
+   ,.PF0_INTERRUPT_PIN(PF0_INTERRUPT_PIN)
+   ,.PF1_INTERRUPT_PIN(PF1_INTERRUPT_PIN)
+   ,.PF2_INTERRUPT_PIN(PF2_INTERRUPT_PIN)
+   ,.PF3_INTERRUPT_PIN(PF3_INTERRUPT_PIN)
+   ,.PF0_CAPABILITY_POINTER(PF0_CAPABILITY_POINTER)
+   ,.PF1_CAPABILITY_POINTER(PF1_CAPABILITY_POINTER)
+   ,.PF2_CAPABILITY_POINTER(PF2_CAPABILITY_POINTER)
+   ,.PF3_CAPABILITY_POINTER(PF3_CAPABILITY_POINTER)
+   ,.VF0_CAPABILITY_POINTER(VF0_CAPABILITY_POINTER)
+   ,.LEGACY_CFG_EXTEND_INTERFACE_ENABLE(LEGACY_CFG_EXTEND_INTERFACE_ENABLE)
+   ,.EXTENDED_CFG_EXTEND_INTERFACE_ENABLE(EXTENDED_CFG_EXTEND_INTERFACE_ENABLE)
+   ,.TL2CFG_IF_PARITY_CHK(TL2CFG_IF_PARITY_CHK)
+   ,.PF0_BAR0_CONTROL(PF0_BAR0_CONTROL)
+   ,.PF1_BAR0_CONTROL(PF1_BAR0_CONTROL)
+   ,.PF2_BAR0_CONTROL(PF2_BAR0_CONTROL)
+   ,.PF3_BAR0_CONTROL(PF3_BAR0_CONTROL)
+   ,.PF0_BAR0_APERTURE_SIZE(PF0_BAR0_APERTURE_SIZE)
+   ,.PF1_BAR0_APERTURE_SIZE(PF1_BAR0_APERTURE_SIZE)
+   ,.PF2_BAR0_APERTURE_SIZE(PF2_BAR0_APERTURE_SIZE)
+   ,.PF3_BAR0_APERTURE_SIZE(PF3_BAR0_APERTURE_SIZE)
+   ,.PF0_BAR1_CONTROL(PF0_BAR1_CONTROL)
+   ,.PF1_BAR1_CONTROL(PF1_BAR1_CONTROL)
+   ,.PF2_BAR1_CONTROL(PF2_BAR1_CONTROL)
+   ,.PF3_BAR1_CONTROL(PF3_BAR1_CONTROL)
+   ,.PF0_BAR1_APERTURE_SIZE(PF0_BAR1_APERTURE_SIZE)
+   ,.PF1_BAR1_APERTURE_SIZE(PF1_BAR1_APERTURE_SIZE)
+   ,.PF2_BAR1_APERTURE_SIZE(PF2_BAR1_APERTURE_SIZE)
+   ,.PF3_BAR1_APERTURE_SIZE(PF3_BAR1_APERTURE_SIZE)
+   ,.PF0_BAR2_CONTROL(PF0_BAR2_CONTROL)
+   ,.PF1_BAR2_CONTROL(PF1_BAR2_CONTROL)
+   ,.PF2_BAR2_CONTROL(PF2_BAR2_CONTROL)
+   ,.PF3_BAR2_CONTROL(PF3_BAR2_CONTROL)
+   ,.PF0_BAR2_APERTURE_SIZE(PF0_BAR2_APERTURE_SIZE)
+   ,.PF1_BAR2_APERTURE_SIZE(PF1_BAR2_APERTURE_SIZE)
+   ,.PF2_BAR2_APERTURE_SIZE(PF2_BAR2_APERTURE_SIZE)
+   ,.PF3_BAR2_APERTURE_SIZE(PF3_BAR2_APERTURE_SIZE)
+   ,.PF0_BAR3_CONTROL(PF0_BAR3_CONTROL)
+   ,.PF1_BAR3_CONTROL(PF1_BAR3_CONTROL)
+   ,.PF2_BAR3_CONTROL(PF2_BAR3_CONTROL)
+   ,.PF3_BAR3_CONTROL(PF3_BAR3_CONTROL)
+   ,.PF0_BAR3_APERTURE_SIZE(PF0_BAR3_APERTURE_SIZE)
+   ,.PF1_BAR3_APERTURE_SIZE(PF1_BAR3_APERTURE_SIZE)
+   ,.PF2_BAR3_APERTURE_SIZE(PF2_BAR3_APERTURE_SIZE)
+   ,.PF3_BAR3_APERTURE_SIZE(PF3_BAR3_APERTURE_SIZE)
+   ,.PF0_BAR4_CONTROL(PF0_BAR4_CONTROL)
+   ,.PF1_BAR4_CONTROL(PF1_BAR4_CONTROL)
+   ,.PF2_BAR4_CONTROL(PF2_BAR4_CONTROL)
+   ,.PF3_BAR4_CONTROL(PF3_BAR4_CONTROL)
+   ,.PF0_BAR4_APERTURE_SIZE(PF0_BAR4_APERTURE_SIZE)
+   ,.PF1_BAR4_APERTURE_SIZE(PF1_BAR4_APERTURE_SIZE)
+   ,.PF2_BAR4_APERTURE_SIZE(PF2_BAR4_APERTURE_SIZE)
+   ,.PF3_BAR4_APERTURE_SIZE(PF3_BAR4_APERTURE_SIZE)
+   ,.PF0_BAR5_CONTROL(PF0_BAR5_CONTROL)
+   ,.PF1_BAR5_CONTROL(PF1_BAR5_CONTROL)
+   ,.PF2_BAR5_CONTROL(PF2_BAR5_CONTROL)
+   ,.PF3_BAR5_CONTROL(PF3_BAR5_CONTROL)
+   ,.PF0_BAR5_APERTURE_SIZE(PF0_BAR5_APERTURE_SIZE)
+   ,.PF1_BAR5_APERTURE_SIZE(PF1_BAR5_APERTURE_SIZE)
+   ,.PF2_BAR5_APERTURE_SIZE(PF2_BAR5_APERTURE_SIZE)
+   ,.PF3_BAR5_APERTURE_SIZE(PF3_BAR5_APERTURE_SIZE)
+   ,.PF0_EXPANSION_ROM_ENABLE(PF0_EXPANSION_ROM_ENABLE)
+   ,.PF1_EXPANSION_ROM_ENABLE(PF1_EXPANSION_ROM_ENABLE)
+   ,.PF2_EXPANSION_ROM_ENABLE(PF2_EXPANSION_ROM_ENABLE)
+   ,.PF3_EXPANSION_ROM_ENABLE(PF3_EXPANSION_ROM_ENABLE)
+   ,.PF0_EXPANSION_ROM_APERTURE_SIZE(PF0_EXPANSION_ROM_APERTURE_SIZE)
+   ,.PF1_EXPANSION_ROM_APERTURE_SIZE(PF1_EXPANSION_ROM_APERTURE_SIZE)
+   ,.PF2_EXPANSION_ROM_APERTURE_SIZE(PF2_EXPANSION_ROM_APERTURE_SIZE)
+   ,.PF3_EXPANSION_ROM_APERTURE_SIZE(PF3_EXPANSION_ROM_APERTURE_SIZE)
+   ,.PF0_PCIE_CAP_NEXTPTR(PF0_PCIE_CAP_NEXTPTR)
+   ,.PF1_PCIE_CAP_NEXTPTR(PF1_PCIE_CAP_NEXTPTR)
+   ,.PF2_PCIE_CAP_NEXTPTR(PF2_PCIE_CAP_NEXTPTR)
+   ,.PF3_PCIE_CAP_NEXTPTR(PF3_PCIE_CAP_NEXTPTR)
+   ,.VFG0_PCIE_CAP_NEXTPTR(VFG0_PCIE_CAP_NEXTPTR)
+   ,.VFG1_PCIE_CAP_NEXTPTR(VFG1_PCIE_CAP_NEXTPTR)
+   ,.VFG2_PCIE_CAP_NEXTPTR(VFG2_PCIE_CAP_NEXTPTR)
+   ,.VFG3_PCIE_CAP_NEXTPTR(VFG3_PCIE_CAP_NEXTPTR)
+   ,.HEADER_TYPE_OVERRIDE(HEADER_TYPE_OVERRIDE)
+   ,.PF0_LINK_CONTROL_RCB(PF0_LINK_CONTROL_RCB)
+   ,.PF0_DEV_CAP_MAX_PAYLOAD_SIZE(PF0_DEV_CAP_MAX_PAYLOAD_SIZE)
+   ,.PF1_DEV_CAP_MAX_PAYLOAD_SIZE(PF1_DEV_CAP_MAX_PAYLOAD_SIZE)
+   ,.PF2_DEV_CAP_MAX_PAYLOAD_SIZE(PF2_DEV_CAP_MAX_PAYLOAD_SIZE)
+   ,.PF3_DEV_CAP_MAX_PAYLOAD_SIZE(PF3_DEV_CAP_MAX_PAYLOAD_SIZE)
+   ,.PF0_DEV_CAP_EXT_TAG_SUPPORTED(PF0_DEV_CAP_EXT_TAG_SUPPORTED)
+   ,.PF0_DEV_CAP_ENDPOINT_L0S_LATENCY(PF0_DEV_CAP_ENDPOINT_L0S_LATENCY)
+   ,.PF0_DEV_CAP_ENDPOINT_L1_LATENCY(PF0_DEV_CAP_ENDPOINT_L1_LATENCY)
+   ,.PF0_DEV_CAP_FUNCTION_LEVEL_RESET_CAPABLE(PF0_DEV_CAP_FUNCTION_LEVEL_RESET_CAPABLE)
+   ,.PF0_LINK_CAP_ASPM_SUPPORT(PF0_LINK_CAP_ASPM_SUPPORT)
+   ,.PF0_LINK_STATUS_SLOT_CLOCK_CONFIG(PF0_LINK_STATUS_SLOT_CLOCK_CONFIG)
+   ,.PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN1(PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN1)
+   ,.PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN2(PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN2)
+   ,.PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN3(PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN3)
+   ,.PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN4(PF0_LINK_CAP_L0S_EXIT_LATENCY_COMCLK_GEN4)
+   ,.PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN1(PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN1)
+   ,.PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN2(PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN2)
+   ,.PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN3(PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN3)
+   ,.PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN4(PF0_LINK_CAP_L0S_EXIT_LATENCY_GEN4)
+   ,.PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN1(PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN1)
+   ,.PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN2(PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN2)
+   ,.PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN3(PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN3)
+   ,.PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN4(PF0_LINK_CAP_L1_EXIT_LATENCY_COMCLK_GEN4)
+   ,.PF0_LINK_CAP_L1_EXIT_LATENCY_GEN1(PF0_LINK_CAP_L1_EXIT_LATENCY_GEN1)
+   ,.PF0_LINK_CAP_L1_EXIT_LATENCY_GEN2(PF0_LINK_CAP_L1_EXIT_LATENCY_GEN2)
+   ,.PF0_LINK_CAP_L1_EXIT_LATENCY_GEN3(PF0_LINK_CAP_L1_EXIT_LATENCY_GEN3)
+   ,.PF0_LINK_CAP_L1_EXIT_LATENCY_GEN4(PF0_LINK_CAP_L1_EXIT_LATENCY_GEN4)
+   ,.PF0_DEV_CAP2_CPL_TIMEOUT_DISABLE(PF0_DEV_CAP2_CPL_TIMEOUT_DISABLE)
+   ,.PF0_DEV_CAP2_32B_ATOMIC_COMPLETER_SUPPORT(PF0_DEV_CAP2_32B_ATOMIC_COMPLETER_SUPPORT)
+   ,.PF0_DEV_CAP2_64B_ATOMIC_COMPLETER_SUPPORT(PF0_DEV_CAP2_64B_ATOMIC_COMPLETER_SUPPORT)
+   ,.PF0_DEV_CAP2_128B_CAS_ATOMIC_COMPLETER_SUPPORT(PF0_DEV_CAP2_128B_CAS_ATOMIC_COMPLETER_SUPPORT)
+   ,.PF0_DEV_CAP2_LTR_SUPPORT(PF0_DEV_CAP2_LTR_SUPPORT)
+   ,.PF0_DEV_CAP2_TPH_COMPLETER_SUPPORT(PF0_DEV_CAP2_TPH_COMPLETER_SUPPORT)
+   ,.PF0_DEV_CAP2_OBFF_SUPPORT(PF0_DEV_CAP2_OBFF_SUPPORT)
+   ,.PF0_DEV_CAP2_ARI_FORWARD_ENABLE(PF0_DEV_CAP2_ARI_FORWARD_ENABLE)
+   ,.PF0_MSI_CAP_NEXTPTR(PF0_MSI_CAP_NEXTPTR)
+   ,.PF1_MSI_CAP_NEXTPTR(PF1_MSI_CAP_NEXTPTR)
+   ,.PF2_MSI_CAP_NEXTPTR(PF2_MSI_CAP_NEXTPTR)
+   ,.PF3_MSI_CAP_NEXTPTR(PF3_MSI_CAP_NEXTPTR)
+   ,.PF0_MSI_CAP_PERVECMASKCAP(PF0_MSI_CAP_PERVECMASKCAP)
+   ,.PF1_MSI_CAP_PERVECMASKCAP(PF1_MSI_CAP_PERVECMASKCAP)
+   ,.PF2_MSI_CAP_PERVECMASKCAP(PF2_MSI_CAP_PERVECMASKCAP)
+   ,.PF3_MSI_CAP_PERVECMASKCAP(PF3_MSI_CAP_PERVECMASKCAP)
+   ,.PF0_MSI_CAP_MULTIMSGCAP(PF0_MSI_CAP_MULTIMSGCAP)
+   ,.PF1_MSI_CAP_MULTIMSGCAP(PF1_MSI_CAP_MULTIMSGCAP)
+   ,.PF2_MSI_CAP_MULTIMSGCAP(PF2_MSI_CAP_MULTIMSGCAP)
+   ,.PF3_MSI_CAP_MULTIMSGCAP(PF3_MSI_CAP_MULTIMSGCAP)
+   ,.PF0_MSIX_CAP_NEXTPTR(PF0_MSIX_CAP_NEXTPTR)
+   ,.PF1_MSIX_CAP_NEXTPTR(PF1_MSIX_CAP_NEXTPTR)
+   ,.PF2_MSIX_CAP_NEXTPTR(PF2_MSIX_CAP_NEXTPTR)
+   ,.PF3_MSIX_CAP_NEXTPTR(PF3_MSIX_CAP_NEXTPTR)
+   ,.VFG0_MSIX_CAP_NEXTPTR(VFG0_MSIX_CAP_NEXTPTR)
+   ,.VFG1_MSIX_CAP_NEXTPTR(VFG1_MSIX_CAP_NEXTPTR)
+   ,.VFG2_MSIX_CAP_NEXTPTR(VFG2_MSIX_CAP_NEXTPTR)
+   ,.VFG3_MSIX_CAP_NEXTPTR(VFG3_MSIX_CAP_NEXTPTR)
+   ,.PF0_MSIX_CAP_PBA_BIR(PF0_MSIX_CAP_PBA_BIR)
+   ,.PF1_MSIX_CAP_PBA_BIR(PF1_MSIX_CAP_PBA_BIR)
+   ,.PF2_MSIX_CAP_PBA_BIR(PF2_MSIX_CAP_PBA_BIR)
+   ,.PF3_MSIX_CAP_PBA_BIR(PF3_MSIX_CAP_PBA_BIR)
+   ,.VFG0_MSIX_CAP_PBA_BIR(VFG0_MSIX_CAP_PBA_BIR)
+   ,.VFG1_MSIX_CAP_PBA_BIR(VFG1_MSIX_CAP_PBA_BIR)
+   ,.VFG2_MSIX_CAP_PBA_BIR(VFG2_MSIX_CAP_PBA_BIR)
+   ,.VFG3_MSIX_CAP_PBA_BIR(VFG3_MSIX_CAP_PBA_BIR)
+   ,.PF0_MSIX_CAP_PBA_OFFSET(PF0_MSIX_CAP_PBA_OFFSET)
+   ,.PF1_MSIX_CAP_PBA_OFFSET(PF1_MSIX_CAP_PBA_OFFSET)
+   ,.PF2_MSIX_CAP_PBA_OFFSET(PF2_MSIX_CAP_PBA_OFFSET)
+   ,.PF3_MSIX_CAP_PBA_OFFSET(PF3_MSIX_CAP_PBA_OFFSET)
+   ,.VFG0_MSIX_CAP_PBA_OFFSET(VFG0_MSIX_CAP_PBA_OFFSET)
+   ,.VFG1_MSIX_CAP_PBA_OFFSET(VFG1_MSIX_CAP_PBA_OFFSET)
+   ,.VFG2_MSIX_CAP_PBA_OFFSET(VFG2_MSIX_CAP_PBA_OFFSET)
+   ,.VFG3_MSIX_CAP_PBA_OFFSET(VFG3_MSIX_CAP_PBA_OFFSET)
+   ,.PF0_MSIX_CAP_TABLE_BIR(PF0_MSIX_CAP_TABLE_BIR)
+   ,.PF1_MSIX_CAP_TABLE_BIR(PF1_MSIX_CAP_TABLE_BIR)
+   ,.PF2_MSIX_CAP_TABLE_BIR(PF2_MSIX_CAP_TABLE_BIR)
+   ,.PF3_MSIX_CAP_TABLE_BIR(PF3_MSIX_CAP_TABLE_BIR)
+   ,.VFG0_MSIX_CAP_TABLE_BIR(VFG0_MSIX_CAP_TABLE_BIR)
+   ,.VFG1_MSIX_CAP_TABLE_BIR(VFG1_MSIX_CAP_TABLE_BIR)
+   ,.VFG2_MSIX_CAP_TABLE_BIR(VFG2_MSIX_CAP_TABLE_BIR)
+   ,.VFG3_MSIX_CAP_TABLE_BIR(VFG3_MSIX_CAP_TABLE_BIR)
+   ,.PF0_MSIX_CAP_TABLE_OFFSET(PF0_MSIX_CAP_TABLE_OFFSET)
+   ,.PF1_MSIX_CAP_TABLE_OFFSET(PF1_MSIX_CAP_TABLE_OFFSET)
+   ,.PF2_MSIX_CAP_TABLE_OFFSET(PF2_MSIX_CAP_TABLE_OFFSET)
+   ,.PF3_MSIX_CAP_TABLE_OFFSET(PF3_MSIX_CAP_TABLE_OFFSET)
+   ,.VFG0_MSIX_CAP_TABLE_OFFSET(VFG0_MSIX_CAP_TABLE_OFFSET)
+   ,.VFG1_MSIX_CAP_TABLE_OFFSET(VFG1_MSIX_CAP_TABLE_OFFSET)
+   ,.VFG2_MSIX_CAP_TABLE_OFFSET(VFG2_MSIX_CAP_TABLE_OFFSET)
+   ,.VFG3_MSIX_CAP_TABLE_OFFSET(VFG3_MSIX_CAP_TABLE_OFFSET)
+   ,.PF0_MSIX_CAP_TABLE_SIZE(PF0_MSIX_CAP_TABLE_SIZE)
+   ,.PF1_MSIX_CAP_TABLE_SIZE(PF1_MSIX_CAP_TABLE_SIZE)
+   ,.PF2_MSIX_CAP_TABLE_SIZE(PF2_MSIX_CAP_TABLE_SIZE)
+   ,.PF3_MSIX_CAP_TABLE_SIZE(PF3_MSIX_CAP_TABLE_SIZE)
+   ,.VFG0_MSIX_CAP_TABLE_SIZE(VFG0_MSIX_CAP_TABLE_SIZE)
+   ,.VFG1_MSIX_CAP_TABLE_SIZE(VFG1_MSIX_CAP_TABLE_SIZE)
+   ,.VFG2_MSIX_CAP_TABLE_SIZE(VFG2_MSIX_CAP_TABLE_SIZE)
+   ,.VFG3_MSIX_CAP_TABLE_SIZE(VFG3_MSIX_CAP_TABLE_SIZE)
+   ,.PF0_MSIX_VECTOR_COUNT(PF0_MSIX_VECTOR_COUNT)
+   ,.PF0_PM_CAP_ID(PF0_PM_CAP_ID)
+   ,.PF0_PM_CAP_NEXTPTR(PF0_PM_CAP_NEXTPTR)
+   ,.PF1_PM_CAP_NEXTPTR(PF1_PM_CAP_NEXTPTR)
+   ,.PF2_PM_CAP_NEXTPTR(PF2_PM_CAP_NEXTPTR)
+   ,.PF3_PM_CAP_NEXTPTR(PF3_PM_CAP_NEXTPTR)
+   ,.PF0_PM_CAP_PMESUPPORT_D3HOT(PF0_PM_CAP_PMESUPPORT_D3HOT)
+   ,.PF0_PM_CAP_PMESUPPORT_D1(PF0_PM_CAP_PMESUPPORT_D1)
+   ,.PF0_PM_CAP_PMESUPPORT_D0(PF0_PM_CAP_PMESUPPORT_D0)
+   ,.PF0_PM_CAP_SUPP_D1_STATE(PF0_PM_CAP_SUPP_D1_STATE)
+   ,.PF0_PM_CAP_VER_ID(PF0_PM_CAP_VER_ID)
+   ,.PF0_PM_CSR_NOSOFTRESET(PF0_PM_CSR_NOSOFTRESET)
+   ,.PM_ENABLE_L23_ENTRY(PM_ENABLE_L23_ENTRY)
+   ,.DNSTREAM_LINK_NUM(DNSTREAM_LINK_NUM)
+   ,.AUTO_FLR_RESPONSE(AUTO_FLR_RESPONSE)
+   ,.PF0_DSN_CAP_NEXTPTR(PF0_DSN_CAP_NEXTPTR)
+   ,.PF1_DSN_CAP_NEXTPTR(PF1_DSN_CAP_NEXTPTR)
+   ,.PF2_DSN_CAP_NEXTPTR(PF2_DSN_CAP_NEXTPTR)
+   ,.PF3_DSN_CAP_NEXTPTR(PF3_DSN_CAP_NEXTPTR)
+   ,.DSN_CAP_ENABLE(DSN_CAP_ENABLE)
+   ,.PF0_VC_CAP_VER(PF0_VC_CAP_VER)
+   ,.PF0_VC_CAP_NEXTPTR(PF0_VC_CAP_NEXTPTR)
+   ,.PF0_VC_CAP_ENABLE(PF0_VC_CAP_ENABLE)
+   ,.PF0_SECONDARY_PCIE_CAP_NEXTPTR(PF0_SECONDARY_PCIE_CAP_NEXTPTR)
+   ,.PF0_AER_CAP_NEXTPTR(PF0_AER_CAP_NEXTPTR)
+   ,.PF1_AER_CAP_NEXTPTR(PF1_AER_CAP_NEXTPTR)
+   ,.PF2_AER_CAP_NEXTPTR(PF2_AER_CAP_NEXTPTR)
+   ,.PF3_AER_CAP_NEXTPTR(PF3_AER_CAP_NEXTPTR)
+   ,.PF0_AER_CAP_ECRC_GEN_AND_CHECK_CAPABLE(PF0_AER_CAP_ECRC_GEN_AND_CHECK_CAPABLE)
+   ,.ARI_CAP_ENABLE(ARI_CAP_ENABLE)
+   ,.PF0_ARI_CAP_NEXTPTR(PF0_ARI_CAP_NEXTPTR)
+   ,.PF1_ARI_CAP_NEXTPTR(PF1_ARI_CAP_NEXTPTR)
+   ,.PF2_ARI_CAP_NEXTPTR(PF2_ARI_CAP_NEXTPTR)
+   ,.PF3_ARI_CAP_NEXTPTR(PF3_ARI_CAP_NEXTPTR)
+   ,.VFG0_ARI_CAP_NEXTPTR(VFG0_ARI_CAP_NEXTPTR)
+   ,.VFG1_ARI_CAP_NEXTPTR(VFG1_ARI_CAP_NEXTPTR)
+   ,.VFG2_ARI_CAP_NEXTPTR(VFG2_ARI_CAP_NEXTPTR)
+   ,.VFG3_ARI_CAP_NEXTPTR(VFG3_ARI_CAP_NEXTPTR)
+   ,.PF0_ARI_CAP_VER(PF0_ARI_CAP_VER)
+   ,.PF0_ARI_CAP_NEXT_FUNC(PF0_ARI_CAP_NEXT_FUNC)
+   ,.PF1_ARI_CAP_NEXT_FUNC(PF1_ARI_CAP_NEXT_FUNC)
+   ,.PF2_ARI_CAP_NEXT_FUNC(PF2_ARI_CAP_NEXT_FUNC)
+   ,.PF3_ARI_CAP_NEXT_FUNC(PF3_ARI_CAP_NEXT_FUNC)
+   ,.PF0_LTR_CAP_NEXTPTR(PF0_LTR_CAP_NEXTPTR)
+   ,.PF0_LTR_CAP_VER(PF0_LTR_CAP_VER)
+   ,.PF0_LTR_CAP_MAX_SNOOP_LAT(PF0_LTR_CAP_MAX_SNOOP_LAT)
+   ,.PF0_LTR_CAP_MAX_NOSNOOP_LAT(PF0_LTR_CAP_MAX_NOSNOOP_LAT)
+   ,.LTR_TX_MESSAGE_ON_LTR_ENABLE(LTR_TX_MESSAGE_ON_LTR_ENABLE)
+   ,.LTR_TX_MESSAGE_ON_FUNC_POWER_STATE_CHANGE(LTR_TX_MESSAGE_ON_FUNC_POWER_STATE_CHANGE)
+   ,.LTR_TX_MESSAGE_MINIMUM_INTERVAL(LTR_TX_MESSAGE_MINIMUM_INTERVAL)
+   ,.SRIOV_CAP_ENABLE(SRIOV_CAP_ENABLE)
+   ,.PF0_SRIOV_CAP_NEXTPTR(PF0_SRIOV_CAP_NEXTPTR)
+   ,.PF1_SRIOV_CAP_NEXTPTR(PF1_SRIOV_CAP_NEXTPTR)
+   ,.PF2_SRIOV_CAP_NEXTPTR(PF2_SRIOV_CAP_NEXTPTR)
+   ,.PF3_SRIOV_CAP_NEXTPTR(PF3_SRIOV_CAP_NEXTPTR)
+   ,.PF0_SRIOV_CAP_VER(PF0_SRIOV_CAP_VER)
+   ,.PF1_SRIOV_CAP_VER(PF1_SRIOV_CAP_VER)
+   ,.PF2_SRIOV_CAP_VER(PF2_SRIOV_CAP_VER)
+   ,.PF3_SRIOV_CAP_VER(PF3_SRIOV_CAP_VER)
+   ,.PF0_SRIOV_ARI_CAPBL_HIER_PRESERVED(PF0_SRIOV_ARI_CAPBL_HIER_PRESERVED)
+   ,.PF1_SRIOV_ARI_CAPBL_HIER_PRESERVED(PF1_SRIOV_ARI_CAPBL_HIER_PRESERVED)
+   ,.PF2_SRIOV_ARI_CAPBL_HIER_PRESERVED(PF2_SRIOV_ARI_CAPBL_HIER_PRESERVED)
+   ,.PF3_SRIOV_ARI_CAPBL_HIER_PRESERVED(PF3_SRIOV_ARI_CAPBL_HIER_PRESERVED)
+   ,.PF0_SRIOV_CAP_INITIAL_VF(PF0_SRIOV_CAP_INITIAL_VF)
+   ,.PF1_SRIOV_CAP_INITIAL_VF(PF1_SRIOV_CAP_INITIAL_VF)
+   ,.PF2_SRIOV_CAP_INITIAL_VF(PF2_SRIOV_CAP_INITIAL_VF)
+   ,.PF3_SRIOV_CAP_INITIAL_VF(PF3_SRIOV_CAP_INITIAL_VF)
+   ,.PF0_SRIOV_CAP_TOTAL_VF(PF0_SRIOV_CAP_TOTAL_VF)
+   ,.PF1_SRIOV_CAP_TOTAL_VF(PF1_SRIOV_CAP_TOTAL_VF)
+   ,.PF2_SRIOV_CAP_TOTAL_VF(PF2_SRIOV_CAP_TOTAL_VF)
+   ,.PF3_SRIOV_CAP_TOTAL_VF(PF3_SRIOV_CAP_TOTAL_VF)
+   ,.PF0_SRIOV_FUNC_DEP_LINK(PF0_SRIOV_FUNC_DEP_LINK)
+   ,.PF1_SRIOV_FUNC_DEP_LINK(PF1_SRIOV_FUNC_DEP_LINK)
+   ,.PF2_SRIOV_FUNC_DEP_LINK(PF2_SRIOV_FUNC_DEP_LINK)
+   ,.PF3_SRIOV_FUNC_DEP_LINK(PF3_SRIOV_FUNC_DEP_LINK)
+   ,.PF0_SRIOV_FIRST_VF_OFFSET(PF0_SRIOV_FIRST_VF_OFFSET)
+   ,.PF1_SRIOV_FIRST_VF_OFFSET(PF1_SRIOV_FIRST_VF_OFFSET)
+   ,.PF2_SRIOV_FIRST_VF_OFFSET(PF2_SRIOV_FIRST_VF_OFFSET)
+   ,.PF3_SRIOV_FIRST_VF_OFFSET(PF3_SRIOV_FIRST_VF_OFFSET)
+   ,.PF0_SRIOV_VF_DEVICE_ID(PF0_SRIOV_VF_DEVICE_ID)
+   ,.PF1_SRIOV_VF_DEVICE_ID(PF1_SRIOV_VF_DEVICE_ID)
+   ,.PF2_SRIOV_VF_DEVICE_ID(PF2_SRIOV_VF_DEVICE_ID)
+   ,.PF3_SRIOV_VF_DEVICE_ID(PF3_SRIOV_VF_DEVICE_ID)
+   ,.PF0_SRIOV_SUPPORTED_PAGE_SIZE(PF0_SRIOV_SUPPORTED_PAGE_SIZE)
+   ,.PF1_SRIOV_SUPPORTED_PAGE_SIZE(PF1_SRIOV_SUPPORTED_PAGE_SIZE)
+   ,.PF2_SRIOV_SUPPORTED_PAGE_SIZE(PF2_SRIOV_SUPPORTED_PAGE_SIZE)
+   ,.PF3_SRIOV_SUPPORTED_PAGE_SIZE(PF3_SRIOV_SUPPORTED_PAGE_SIZE)
+   ,.PF0_SRIOV_BAR0_CONTROL(PF0_SRIOV_BAR0_CONTROL)
+   ,.PF1_SRIOV_BAR0_CONTROL(PF1_SRIOV_BAR0_CONTROL)
+   ,.PF2_SRIOV_BAR0_CONTROL(PF2_SRIOV_BAR0_CONTROL)
+   ,.PF3_SRIOV_BAR0_CONTROL(PF3_SRIOV_BAR0_CONTROL)
+   ,.PF0_SRIOV_BAR0_APERTURE_SIZE(PF0_SRIOV_BAR0_APERTURE_SIZE)
+   ,.PF1_SRIOV_BAR0_APERTURE_SIZE(PF1_SRIOV_BAR0_APERTURE_SIZE)
+   ,.PF2_SRIOV_BAR0_APERTURE_SIZE(PF2_SRIOV_BAR0_APERTURE_SIZE)
+   ,.PF3_SRIOV_BAR0_APERTURE_SIZE(PF3_SRIOV_BAR0_APERTURE_SIZE)
+   ,.PF0_SRIOV_BAR1_CONTROL(PF0_SRIOV_BAR1_CONTROL)
+   ,.PF1_SRIOV_BAR1_CONTROL(PF1_SRIOV_BAR1_CONTROL)
+   ,.PF2_SRIOV_BAR1_CONTROL(PF2_SRIOV_BAR1_CONTROL)
+   ,.PF3_SRIOV_BAR1_CONTROL(PF3_SRIOV_BAR1_CONTROL)
+   ,.PF0_SRIOV_BAR1_APERTURE_SIZE(PF0_SRIOV_BAR1_APERTURE_SIZE)
+   ,.PF1_SRIOV_BAR1_APERTURE_SIZE(PF1_SRIOV_BAR1_APERTURE_SIZE)
+   ,.PF2_SRIOV_BAR1_APERTURE_SIZE(PF2_SRIOV_BAR1_APERTURE_SIZE)
+   ,.PF3_SRIOV_BAR1_APERTURE_SIZE(PF3_SRIOV_BAR1_APERTURE_SIZE)
+   ,.PF0_SRIOV_BAR2_CONTROL(PF0_SRIOV_BAR2_CONTROL)
+   ,.PF1_SRIOV_BAR2_CONTROL(PF1_SRIOV_BAR2_CONTROL)
+   ,.PF2_SRIOV_BAR2_CONTROL(PF2_SRIOV_BAR2_CONTROL)
+   ,.PF3_SRIOV_BAR2_CONTROL(PF3_SRIOV_BAR2_CONTROL)
+   ,.PF0_SRIOV_BAR2_APERTURE_SIZE(PF0_SRIOV_BAR2_APERTURE_SIZE)
+   ,.PF1_SRIOV_BAR2_APERTURE_SIZE(PF1_SRIOV_BAR2_APERTURE_SIZE)
+   ,.PF2_SRIOV_BAR2_APERTURE_SIZE(PF2_SRIOV_BAR2_APERTURE_SIZE)
+   ,.PF3_SRIOV_BAR2_APERTURE_SIZE(PF3_SRIOV_BAR2_APERTURE_SIZE)
+   ,.PF0_SRIOV_BAR3_CONTROL(PF0_SRIOV_BAR3_CONTROL)
+   ,.PF1_SRIOV_BAR3_CONTROL(PF1_SRIOV_BAR3_CONTROL)
+   ,.PF2_SRIOV_BAR3_CONTROL(PF2_SRIOV_BAR3_CONTROL)
+   ,.PF3_SRIOV_BAR3_CONTROL(PF3_SRIOV_BAR3_CONTROL)
+   ,.PF0_SRIOV_BAR3_APERTURE_SIZE(PF0_SRIOV_BAR3_APERTURE_SIZE)
+   ,.PF1_SRIOV_BAR3_APERTURE_SIZE(PF1_SRIOV_BAR3_APERTURE_SIZE)
+   ,.PF2_SRIOV_BAR3_APERTURE_SIZE(PF2_SRIOV_BAR3_APERTURE_SIZE)
+   ,.PF3_SRIOV_BAR3_APERTURE_SIZE(PF3_SRIOV_BAR3_APERTURE_SIZE)
+   ,.PF0_SRIOV_BAR4_CONTROL(PF0_SRIOV_BAR4_CONTROL)
+   ,.PF1_SRIOV_BAR4_CONTROL(PF1_SRIOV_BAR4_CONTROL)
+   ,.PF2_SRIOV_BAR4_CONTROL(PF2_SRIOV_BAR4_CONTROL)
+   ,.PF3_SRIOV_BAR4_CONTROL(PF3_SRIOV_BAR4_CONTROL)
+   ,.PF0_SRIOV_BAR4_APERTURE_SIZE(PF0_SRIOV_BAR4_APERTURE_SIZE)
+   ,.PF1_SRIOV_BAR4_APERTURE_SIZE(PF1_SRIOV_BAR4_APERTURE_SIZE)
+   ,.PF2_SRIOV_BAR4_APERTURE_SIZE(PF2_SRIOV_BAR4_APERTURE_SIZE)
+   ,.PF3_SRIOV_BAR4_APERTURE_SIZE(PF3_SRIOV_BAR4_APERTURE_SIZE)
+   ,.PF0_SRIOV_BAR5_CONTROL(PF0_SRIOV_BAR5_CONTROL)
+   ,.PF1_SRIOV_BAR5_CONTROL(PF1_SRIOV_BAR5_CONTROL)
+   ,.PF2_SRIOV_BAR5_CONTROL(PF2_SRIOV_BAR5_CONTROL)
+   ,.PF3_SRIOV_BAR5_CONTROL(PF3_SRIOV_BAR5_CONTROL)
+   ,.PF0_SRIOV_BAR5_APERTURE_SIZE(PF0_SRIOV_BAR5_APERTURE_SIZE)
+   ,.PF1_SRIOV_BAR5_APERTURE_SIZE(PF1_SRIOV_BAR5_APERTURE_SIZE)
+   ,.PF2_SRIOV_BAR5_APERTURE_SIZE(PF2_SRIOV_BAR5_APERTURE_SIZE)
+   ,.PF3_SRIOV_BAR5_APERTURE_SIZE(PF3_SRIOV_BAR5_APERTURE_SIZE)
+   ,.PF0_TPHR_CAP_NEXTPTR(PF0_TPHR_CAP_NEXTPTR)
+   ,.PF1_TPHR_CAP_NEXTPTR(PF1_TPHR_CAP_NEXTPTR)
+   ,.PF2_TPHR_CAP_NEXTPTR(PF2_TPHR_CAP_NEXTPTR)
+   ,.PF3_TPHR_CAP_NEXTPTR(PF3_TPHR_CAP_NEXTPTR)
+   ,.VFG0_TPHR_CAP_NEXTPTR(VFG0_TPHR_CAP_NEXTPTR)
+   ,.VFG1_TPHR_CAP_NEXTPTR(VFG1_TPHR_CAP_NEXTPTR)
+   ,.VFG2_TPHR_CAP_NEXTPTR(VFG2_TPHR_CAP_NEXTPTR)
+   ,.VFG3_TPHR_CAP_NEXTPTR(VFG3_TPHR_CAP_NEXTPTR)
+   ,.PF0_TPHR_CAP_VER(PF0_TPHR_CAP_VER)
+   ,.PF0_TPHR_CAP_INT_VEC_MODE(PF0_TPHR_CAP_INT_VEC_MODE)
+   ,.PF0_TPHR_CAP_DEV_SPECIFIC_MODE(PF0_TPHR_CAP_DEV_SPECIFIC_MODE)
+   ,.PF0_TPHR_CAP_ST_TABLE_LOC(PF0_TPHR_CAP_ST_TABLE_LOC)
+   ,.PF0_TPHR_CAP_ST_TABLE_SIZE(PF0_TPHR_CAP_ST_TABLE_SIZE)
+   ,.PF0_TPHR_CAP_ST_MODE_SEL(PF0_TPHR_CAP_ST_MODE_SEL)
+   ,.PF1_TPHR_CAP_ST_MODE_SEL(PF1_TPHR_CAP_ST_MODE_SEL)
+   ,.PF2_TPHR_CAP_ST_MODE_SEL(PF2_TPHR_CAP_ST_MODE_SEL)
+   ,.PF3_TPHR_CAP_ST_MODE_SEL(PF3_TPHR_CAP_ST_MODE_SEL)
+   ,.VFG0_TPHR_CAP_ST_MODE_SEL(VFG0_TPHR_CAP_ST_MODE_SEL)
+   ,.VFG1_TPHR_CAP_ST_MODE_SEL(VFG1_TPHR_CAP_ST_MODE_SEL)
+   ,.VFG2_TPHR_CAP_ST_MODE_SEL(VFG2_TPHR_CAP_ST_MODE_SEL)
+   ,.VFG3_TPHR_CAP_ST_MODE_SEL(VFG3_TPHR_CAP_ST_MODE_SEL)
+   ,.PF0_TPHR_CAP_ENABLE(PF0_TPHR_CAP_ENABLE)
+   ,.TPH_TO_RAM_PIPELINE(TPH_TO_RAM_PIPELINE)
+   ,.TPH_FROM_RAM_PIPELINE(TPH_FROM_RAM_PIPELINE)
+   ,.MCAP_ENABLE(MCAP_ENABLE)
+   ,.MCAP_CONFIGURE_OVERRIDE(MCAP_CONFIGURE_OVERRIDE)
+   ,.MCAP_CAP_NEXTPTR(MCAP_CAP_NEXTPTR)
+   ,.MCAP_VSEC_ID(MCAP_VSEC_ID)
+   ,.MCAP_VSEC_REV(MCAP_VSEC_REV)
+   ,.MCAP_VSEC_LEN(MCAP_VSEC_LEN)
+   ,.MCAP_FPGA_BITSTREAM_VERSION(MCAP_FPGA_BITSTREAM_VERSION)
+   ,.MCAP_INTERRUPT_ON_MCAP_EOS(MCAP_INTERRUPT_ON_MCAP_EOS)
+   ,.MCAP_INTERRUPT_ON_MCAP_ERROR(MCAP_INTERRUPT_ON_MCAP_ERROR)
+   ,.MCAP_INPUT_GATE_DESIGN_SWITCH(MCAP_INPUT_GATE_DESIGN_SWITCH)
+   ,.MCAP_EOS_DESIGN_SWITCH(MCAP_EOS_DESIGN_SWITCH)
+   ,.MCAP_GATE_MEM_ENABLE_DESIGN_SWITCH(MCAP_GATE_MEM_ENABLE_DESIGN_SWITCH)
+   ,.MCAP_GATE_IO_ENABLE_DESIGN_SWITCH(MCAP_GATE_IO_ENABLE_DESIGN_SWITCH)
+   ,.SIM_JTAG_IDCODE(SIM_JTAG_IDCODE)
+   ,.DEBUG_AXIST_DISABLE_FEATURE_BIT(DEBUG_AXIST_DISABLE_FEATURE_BIT)
+   ,.DEBUG_TL_DISABLE_RX_TLP_ORDER_CHECKS(DEBUG_TL_DISABLE_RX_TLP_ORDER_CHECKS)
+   ,.DEBUG_TL_DISABLE_FC_TIMEOUT(DEBUG_TL_DISABLE_FC_TIMEOUT)
+   ,.DEBUG_PL_DISABLE_SCRAMBLING(DEBUG_PL_DISABLE_SCRAMBLING)
+   ,.DEBUG_PL_DISABLE_REC_ENTRY_ON_DYNAMIC_DSKEW_FAIL (DEBUG_PL_DISABLE_REC_ENTRY_ON_DYNAMIC_DSKEW_FAIL )
+   ,.DEBUG_PL_DISABLE_REC_ENTRY_ON_RX_BUFFER_UNDER_OVER_FLOW (DEBUG_PL_DISABLE_REC_ENTRY_ON_RX_BUFFER_UNDER_OVER_FLOW )
+   ,.DEBUG_PL_DISABLE_LES_UPDATE_ON_SKP_ERROR(DEBUG_PL_DISABLE_LES_UPDATE_ON_SKP_ERROR)
+   ,.DEBUG_PL_DISABLE_LES_UPDATE_ON_SKP_PARITY_ERROR(DEBUG_PL_DISABLE_LES_UPDATE_ON_SKP_PARITY_ERROR)
+   ,.DEBUG_PL_DISABLE_LES_UPDATE_ON_DEFRAMER_ERROR(DEBUG_PL_DISABLE_LES_UPDATE_ON_DEFRAMER_ERROR)
+   ,.DEBUG_PL_SIM_RESET_LFSR(DEBUG_PL_SIM_RESET_LFSR)
+   ,.DEBUG_PL_SPARE(DEBUG_PL_SPARE)
+   ,.DEBUG_LL_SPARE(DEBUG_LL_SPARE)
+   ,.DEBUG_TL_SPARE(DEBUG_TL_SPARE)
+   ,.DEBUG_AXI4ST_SPARE(DEBUG_AXI4ST_SPARE)
+   ,.DEBUG_CFG_SPARE(DEBUG_CFG_SPARE)
+   ,.DEBUG_CAR_SPARE(DEBUG_CAR_SPARE)
+   ,.SPARE_BIT0(AXISTEN_IF_RQ_CC_REGISTERED_TREADY)
+   ,.SPARE_BIT1(SPARE_BIT1)
+   ,.SPARE_BIT2(SPARE_BIT2)
+   ,.SPARE_BIT3(SPARE_BIT3)
+   ,.SPARE_BIT4(SPARE_BIT4)
+   ,.SPARE_BIT5(SPARE_BIT5)
+   ,.SPARE_BIT6(SPARE_BIT6)
+   ,.SPARE_BIT7(SPARE_BIT7)
+   ,.SPARE_BIT8(SPARE_BIT8)
+   ,.SPARE_BYTE0(SPARE_BYTE0)
+   ,.SPARE_BYTE1(SPARE_BYTE1)
+   ,.SPARE_BYTE2(SPARE_BYTE2)
+   ,.SPARE_BYTE3(SPARE_BYTE3)
+   ,.SPARE_WORD0(SPARE_WORD0)
+   ,.SPARE_WORD1(SPARE_WORD1)
+   ,.SPARE_WORD2(SPARE_WORD2)
+   ,.SPARE_WORD3(SPARE_WORD3)
+
+   ,.AXISTEN_IF_CCIX_RX_CREDIT_LIMIT(AXISTEN_IF_CCIX_RX_CREDIT_LIMIT)
+   ,.AXISTEN_IF_CCIX_TX_CREDIT_LIMIT(AXISTEN_IF_CCIX_TX_CREDIT_LIMIT)
+   ,.AXISTEN_IF_CCIX_TX_REGISTERED_TREADY(AXISTEN_IF_CCIX_TX_REGISTERED_TREADY)
+   ,.CCIX_DIRECT_ATTACH_MODE(CCIX_DIRECT_ATTACH_MODE)
+   ,.CCIX_ENABLE(CCIX_ENABLE)
+   ,.CCIX_VENDOR_ID(CCIX_VENDOR_ID)
+   ,.PF0_ATS_CAP_INV_QUEUE_DEPTH(PF0_ATS_CAP_INV_QUEUE_DEPTH)
+   ,.PF0_ATS_CAP_NEXTPTR(PF0_ATS_CAP_NEXTPTR)
+   ,.PF0_ATS_CAP_ON(PF0_ATS_CAP_ON)
+   ,.PF0_PRI_CAP_NEXTPTR(PF0_PRI_CAP_NEXTPTR)
+   ,.PF0_PRI_CAP_ON(PF0_PRI_CAP_ON)
+   ,.PF0_PRI_OST_PR_CAPACITY(PF0_PRI_OST_PR_CAPACITY)
+   ,.PF0_VC_ARB_CAPABILITY(PF0_VC_ARB_CAPABILITY)
+   ,.PF0_VC_ARB_TBL_OFFSET(PF0_VC_ARB_TBL_OFFSET)
+   ,.PF0_VC_EXTENDED_COUNT(PF0_VC_EXTENDED_COUNT)
+   ,.PF0_VC_LOW_PRIORITY_EXTENDED_COUNT(PF0_VC_LOW_PRIORITY_EXTENDED_COUNT)
+   ,.PF1_ATS_CAP_INV_QUEUE_DEPTH(PF1_ATS_CAP_INV_QUEUE_DEPTH)
+   ,.PF1_ATS_CAP_NEXTPTR(PF1_ATS_CAP_NEXTPTR)
+   ,.PF1_ATS_CAP_ON(PF1_ATS_CAP_ON)
+   ,.PF1_PRI_CAP_NEXTPTR(PF1_PRI_CAP_NEXTPTR)
+   ,.PF1_PRI_CAP_ON(PF1_PRI_CAP_ON)
+   ,.PF1_PRI_OST_PR_CAPACITY(PF1_PRI_OST_PR_CAPACITY)
+   ,.PF2_ATS_CAP_INV_QUEUE_DEPTH(PF2_ATS_CAP_INV_QUEUE_DEPTH)
+   ,.PF2_ATS_CAP_NEXTPTR(PF2_ATS_CAP_NEXTPTR)
+   ,.PF2_ATS_CAP_ON(PF2_ATS_CAP_ON)
+   ,.PF2_PRI_CAP_NEXTPTR(PF2_PRI_CAP_NEXTPTR)
+   ,.PF2_PRI_CAP_ON(PF2_PRI_CAP_ON)
+   ,.PF2_PRI_OST_PR_CAPACITY(PF2_PRI_OST_PR_CAPACITY)
+   ,.PF3_ATS_CAP_INV_QUEUE_DEPTH(PF3_ATS_CAP_INV_QUEUE_DEPTH)
+   ,.PF3_ATS_CAP_NEXTPTR(PF3_ATS_CAP_NEXTPTR)
+   ,.PF3_ATS_CAP_ON(PF3_ATS_CAP_ON)
+   ,.PF3_PRI_CAP_NEXTPTR(PF3_PRI_CAP_NEXTPTR)
+   ,.PF3_PRI_CAP_ON(PF3_PRI_CAP_ON)
+   ,.PF3_PRI_OST_PR_CAPACITY(PF3_PRI_OST_PR_CAPACITY)
+   ,.PL_CTRL_SKP_GEN_ENABLE(PL_CTRL_SKP_GEN_ENABLE)
+   ,.PL_CTRL_SKP_PARITY_AND_CRC_CHECK_DISABLE(PL_CTRL_SKP_PARITY_AND_CRC_CHECK_DISABLE)
+   ,.PL_USER_SPARE2(PL_USER_SPARE2)
+   ,.TL_CREDITS_CD_VC1(TL_CREDITS_CD_VC1)
+   ,.TL_CREDITS_CH_VC1(TL_CREDITS_CH_VC1)
+   ,.TL_CREDITS_NPD_VC1(TL_CREDITS_NPD_VC1)
+   ,.TL_CREDITS_NPH_VC1(TL_CREDITS_NPH_VC1)
+   ,.TL_CREDITS_PD_VC1(TL_CREDITS_PD_VC1)
+   ,.TL_CREDITS_PH_VC1(TL_CREDITS_PH_VC1)
+   ,.TL_FC_UPDATE_MIN_INTERVAL_TIME_VC1(TL_FC_UPDATE_MIN_INTERVAL_TIME_VC1)
+   ,.TL_FC_UPDATE_MIN_INTERVAL_TLP_COUNT_VC1(TL_FC_UPDATE_MIN_INTERVAL_TLP_COUNT_VC1)
+   ,.TL_FEATURE_ENABLE_FC_SCALING(TL_FEATURE_ENABLE_FC_SCALING)
+   ,.VFG0_ATS_CAP_INV_QUEUE_DEPTH(VFG0_ATS_CAP_INV_QUEUE_DEPTH)
+   ,.VFG0_ATS_CAP_NEXTPTR(VFG0_ATS_CAP_NEXTPTR)
+   ,.VFG0_ATS_CAP_ON(VFG0_ATS_CAP_ON)
+   ,.VFG1_ATS_CAP_INV_QUEUE_DEPTH(VFG1_ATS_CAP_INV_QUEUE_DEPTH)
+   ,.VFG1_ATS_CAP_NEXTPTR(VFG1_ATS_CAP_NEXTPTR)
+   ,.VFG1_ATS_CAP_ON(VFG1_ATS_CAP_ON)
+   ,.VFG2_ATS_CAP_INV_QUEUE_DEPTH(VFG2_ATS_CAP_INV_QUEUE_DEPTH)
+   ,.VFG2_ATS_CAP_NEXTPTR(VFG2_ATS_CAP_NEXTPTR)
+   ,.VFG2_ATS_CAP_ON(VFG2_ATS_CAP_ON)
+   ,.VFG3_ATS_CAP_INV_QUEUE_DEPTH(VFG3_ATS_CAP_INV_QUEUE_DEPTH)
+   ,.VFG3_ATS_CAP_NEXTPTR(VFG3_ATS_CAP_NEXTPTR)
+   ,.VFG3_ATS_CAP_ON(VFG3_ATS_CAP_ON)
+
+  ) pcie_4_c_e4_inst ( 
+//
+// GEN4 SPEED Code
+//
+    .AXIUSERIN(axi_user_in[7:0])
+   ,.AXIUSEROUT(axi_user_out[7:0])
+   ,.CCIXTXCREDIT(ccix_tx_credit) // WIP new output
+   ,.CFGBUSNUMBER(cfg_bus_number[7:0])
+   ,.CFGCONFIGSPACEENABLE(cfg_config_space_enable)
+   ,.CFGCURRENTSPEED(cfg_current_speed[1:0])
+   ,.CFGDEVIDPF0(cfg_dev_id_pf0[15:0])
+   ,.CFGDEVIDPF1(cfg_dev_id_pf1[15:0])
+   ,.CFGDEVIDPF2(cfg_dev_id_pf2[15:0])
+   ,.CFGDEVIDPF3(cfg_dev_id_pf3[15:0])
+   ,.CFGDSBUSNUMBER(cfg_ds_bus_number[7:0])
+   ,.CFGDSDEVICENUMBER(cfg_ds_device_number[4:0])
+   ,.CFGDSFUNCTIONNUMBER(cfg_ds_function_number[2:0])
+   ,.CFGDSN(cfg_dsn[63:0])
+   ,.CFGDSPORTNUMBER(cfg_ds_port_number[7:0])
+   ,.CFGERRCORIN(cfg_err_cor_in)
+   ,.CFGERRCOROUT(cfg_err_cor_out)
+   ,.CFGERRFATALOUT(cfg_err_fatal_out)
+   ,.CFGERRNONFATALOUT(cfg_err_nonfatal_out)
+   ,.CFGERRUNCORIN(cfg_err_uncor_in)
+   ,.CFGEXTFUNCTIONNUMBER(cfg_ext_function_number[7:0])
+   ,.CFGEXTREADDATA(cfg_ext_read_data[31:0])
+   ,.CFGEXTREADDATAVALID(cfg_ext_read_data_valid)
+   ,.CFGEXTREADRECEIVED(cfg_ext_read_received)
+   ,.CFGEXTREGISTERNUMBER(cfg_ext_register_number[9:0])
+   ,.CFGEXTWRITEBYTEENABLE(cfg_ext_write_byte_enable[3:0])
+   ,.CFGEXTWRITEDATA(cfg_ext_write_data[31:0])
+   ,.CFGEXTWRITERECEIVED(cfg_ext_write_received)
+   ,.CFGFCCPLD(cfg_fc_cpld[11:0])
+   ,.CFGFCCPLH(cfg_fc_cplh[7:0])
+   ,.CFGFCNPD(cfg_fc_npd[11:0])
+   ,.CFGFCNPH(cfg_fc_nph[7:0])
+   ,.CFGFCPD(cfg_fc_pd[11:0])
+   ,.CFGFCPH(cfg_fc_ph[7:0])
+   ,.CFGFCSEL(cfg_fc_sel[2:0])
+   ,.CFGFCVCSEL (cfg_fc_vc_sel)
+   ,.CFGFLRDONE(cfg_flr_done[3:0])
+   ,.CFGFLRINPROCESS(cfg_flr_in_process[3:0])
+   ,.CFGFUNCTIONPOWERSTATE(cfg_function_power_state[11:0])
+   ,.CFGFUNCTIONSTATUS(cfg_function_status[15:0])
+   ,.CFGHOTRESETIN(cfg_hot_reset_in)
+   ,.CFGHOTRESETOUT(cfg_hot_reset_out)
+   ,.CFGINTERRUPTINT(cfg_interrupt_int[3:0])
+   ,.CFGINTERRUPTMSIATTR(cfg_interrupt_msi_attr[2:0])
+   ,.CFGINTERRUPTMSIDATA(cfg_interrupt_msi_data[31:0])
+   ,.CFGINTERRUPTMSIENABLE(cfg_interrupt_msi_enable[3:0])
+   ,.CFGINTERRUPTMSIFAIL(cfg_interrupt_msi_fail)
+   ,.CFGINTERRUPTMSIFUNCTIONNUMBER(cfg_interrupt_msi_function_number[7:0])
+   ,.CFGINTERRUPTMSIINT(cfg_interrupt_msi_int[31:0])
+   ,.CFGINTERRUPTMSIMASKUPDATE(cfg_interrupt_msi_mask_update)
+   ,.CFGINTERRUPTMSIMMENABLE(cfg_interrupt_msi_mmenable[11:0])
+   ,.CFGINTERRUPTMSIPENDINGSTATUS(cfg_interrupt_msi_pending_status[31:0])
+   ,.CFGINTERRUPTMSIPENDINGSTATUSDATAENABLE(cfg_interrupt_msi_pending_status_data_enable)
+   ,.CFGINTERRUPTMSIPENDINGSTATUSFUNCTIONNUM(cfg_interrupt_msi_pending_status_function_num[1:0])
+   ,.CFGINTERRUPTMSISELECT(cfg_interrupt_msi_select[1:0])
+   ,.CFGINTERRUPTMSISENT(cfg_interrupt_msi_sent)
+   ,.CFGINTERRUPTMSITPHPRESENT(cfg_interrupt_msi_tph_present)
+   ,.CFGINTERRUPTMSITPHSTTAG(cfg_interrupt_msi_tph_st_tag[7:0])
+   ,.CFGINTERRUPTMSITPHTYPE(cfg_interrupt_msi_tph_type[1:0])
+   ,.CFGINTERRUPTMSIXADDRESS(cfg_interrupt_msix_address[63:0])
+   ,.CFGINTERRUPTMSIXDATA(cfg_interrupt_msix_data[31:0])
+   ,.CFGINTERRUPTMSIXENABLE(cfg_interrupt_msix_enable[3:0])
+   ,.CFGINTERRUPTMSIXINT(cfg_interrupt_msix_int)
+   ,.CFGINTERRUPTMSIXMASK(cfg_interrupt_msix_mask[3:0])
+   ,.CFGINTERRUPTMSIXVECPENDING(cfg_interrupt_msix_vec_pending[1:0])
+   ,.CFGINTERRUPTMSIXVECPENDINGSTATUS(cfg_interrupt_msix_vec_pending_status)
+   ,.CFGINTERRUPTPENDING(cfg_interrupt_pending[3:0])
+   ,.CFGINTERRUPTSENT(cfg_interrupt_sent)
+   ,.CFGLINKPOWERSTATE(cfg_link_power_state[1:0])
+   ,.CFGLINKTRAININGENABLE(cfg_link_training_enable)
+   ,.CFGLOCALERROROUT(cfg_local_error_out[4:0])
+   ,.CFGLOCALERRORVALID(cfg_local_error_valid)
+   ,.CFGLTRENABLE(cfg_ltr_enable)
+   ,.CFGLTSSMSTATE(cfg_ltssm_state[5:0])
+   ,.CFGMAXPAYLOAD(cfg_max_payload[1:0])
+   ,.CFGMAXREADREQ(cfg_max_read_req[2:0])
+   ,.CFGMGMTADDR(cfg_mgmt_addr[9:0])
+   ,.CFGMGMTBYTEENABLE(cfg_mgmt_byte_enable[3:0])
+   ,.CFGMGMTDEBUGACCESS(cfg_mgmt_debug_access)
+   ,.CFGMGMTFUNCTIONNUMBER(cfg_mgmt_function_number[7:0])
+   ,.CFGMGMTREAD(cfg_mgmt_read)
+   ,.CFGMGMTREADDATA(cfg_mgmt_read_data[31:0])
+   ,.CFGMGMTREADWRITEDONE(cfg_mgmt_read_write_done)
+   ,.CFGMGMTWRITE(cfg_mgmt_write)
+   ,.CFGMGMTWRITEDATA(cfg_mgmt_write_data[31:0])
+   ,.CFGMSGRECEIVED(cfg_msg_received)
+   ,.CFGMSGRECEIVEDDATA(cfg_msg_received_data[7:0])
+   ,.CFGMSGRECEIVEDTYPE(cfg_msg_received_type[4:0])
+   ,.CFGMSGTRANSMIT(cfg_msg_transmit)
+   ,.CFGMSGTRANSMITDATA(cfg_msg_transmit_data[31:0])
+   ,.CFGMSGTRANSMITDONE(cfg_msg_transmit_done)
+   ,.CFGMSGTRANSMITTYPE(cfg_msg_transmit_type[2:0])
+   ,.CFGMSIXRAMADDRESS(cfg_msix_ram_address[12:0])
+   ,.CFGMSIXRAMREADDATA(cfg_msix_ram_read_data[35:0])
+   ,.CFGMSIXRAMREADENABLE(cfg_msix_ram_read_enable)
+   ,.CFGMSIXRAMWRITEBYTEENABLE(cfg_msix_ram_write_byte_enable[3:0])
+   ,.CFGMSIXRAMWRITEDATA(cfg_msix_ram_write_data[35:0])
+   ,.CFGNEGOTIATEDWIDTH(cfg_negotiated_width[2:0])
+   ,.CFGOBFFENABLE(cfg_obff_enable[1:0])
+   ,.CFGPHYLINKDOWN(cfg_phy_link_down_wire)
+   ,.CFGPHYLINKSTATUS(cfg_phy_link_status[1:0])
+   ,.CFGPLSTATUSCHANGE(cfg_pl_status_change)
+   ,.CFGPMASPML1ENTRYREJECT(cfg_pm_aspm_l1_entry_reject)
+   ,.CFGPMASPMTXL0SENTRYDISABLE(cfg_pm_aspm_tx_l0s_entry_disable)
+   ,.CFGPOWERSTATECHANGEACK(cfg_power_state_change_ack)
+   ,.CFGPOWERSTATECHANGEINTERRUPT(cfg_power_state_change_interrupt)
+   ,.CFGRCBSTATUS(cfg_rcb_status[3:0])
+   ,.CFGREQPMTRANSITIONL23READY(cfg_req_pm_transition_l23_ready)
+   ,.CFGREVIDPF0(cfg_rev_id_pf0[7:0])
+   ,.CFGREVIDPF1(cfg_rev_id_pf1[7:0])
+   ,.CFGREVIDPF2(cfg_rev_id_pf2[7:0])
+   ,.CFGREVIDPF3(cfg_rev_id_pf3[7:0])
+   ,.CFGRXPMSTATE(cfg_rx_pm_state[1:0])
+   ,.CFGSUBSYSIDPF0(cfg_subsys_id_pf0[15:0])
+   ,.CFGSUBSYSIDPF1(cfg_subsys_id_pf1[15:0])
+   ,.CFGSUBSYSIDPF2(cfg_subsys_id_pf2[15:0])
+   ,.CFGSUBSYSIDPF3(cfg_subsys_id_pf3[15:0])
+   ,.CFGSUBSYSVENDID(cfg_subsys_vend_id[15:0])
+   ,.CFGTPHRAMADDRESS(cfg_tph_ram_address[11:0])
+   ,.CFGTPHRAMREADDATA(cfg_tph_ram_read_data[35:0])
+   ,.CFGTPHRAMREADENABLE(cfg_tph_ram_read_enable)
+   ,.CFGTPHRAMWRITEBYTEENABLE(cfg_tph_ram_write_byte_enable[3:0])
+   ,.CFGTPHRAMWRITEDATA(cfg_tph_ram_write_data[35:0])
+   ,.CFGTPHREQUESTERENABLE(cfg_tph_requester_enable[3:0])
+   ,.CFGTPHSTMODE(cfg_tph_st_mode[11:0])
+   ,.CFGTXPMSTATE(cfg_tx_pm_state[1:0])
+   ,.CFGVC1ENABLE (cfg_vc1_enable) // WIP new outputs
+   ,.CFGVC1NEGOTIATIONPENDING (cfg_vc1_negotiation_pending) // WIP new outputs
+   ,.CFGVENDID(cfg_vend_id[15:0])
+   ,.CFGVFFLRDONE(cfg_vf_flr_done)
+   ,.CFGVFFLRFUNCNUM(cfg_vf_flr_func_num[7:0])
+   ,.CONFMCAPDESIGNSWITCH(conf_mcap_design_switch)
+   ,.CONFMCAPEOS(conf_mcap_eos)
+   ,.CONFMCAPINUSEBYPCIE(conf_mcap_in_use_by_pcie)
+   ,.CONFMCAPREQUESTBYCONF(conf_mcap_request_by_conf)
+   ,.CONFREQDATA(conf_req_data[31:0])
+   ,.CONFREQREADY(conf_req_ready)
+   ,.CONFREQREGNUM(conf_req_reg_num[3:0])
+   ,.CONFREQTYPE(conf_req_type[1:0])
+   ,.CONFREQVALID(conf_req_valid)
+   ,.CONFRESPRDATA(conf_resp_rdata[31:0])
+   ,.CONFRESPVALID(conf_resp_valid)
+   ,.CORECLK(core_clk)
+   ,.CORECLKMIREPLAYRAM0(core_clk)
+   ,.CORECLKMIREPLAYRAM1(core_clk)
+   ,.CORECLKMIRXCOMPLETIONRAM0(core_clk)
+   ,.CORECLKMIRXCOMPLETIONRAM1(core_clk)
+   ,.CORECLKMIRXPOSTEDREQUESTRAM0(core_clk)
+   ,.CORECLKMIRXPOSTEDREQUESTRAM1(core_clk)
+   ,.CORECLKCCIX(core_clk) // WIP fix ccix clk connection
+   ,.DBGCTRL0OUT( )
+   ,.DBGCTRL1OUT( )
+   ,.DBGDATA0OUT( )
+   ,.DBGDATA1OUT(dbg_data1_out )
+   ,.DBGSEL0(6'd0)
+   ,.DBGSEL1(6'd0)
+   ,.DRPADDR(drp_addr[9:0])
+   ,.DRPCLK(drp_clk)
+   ,.DRPDI(drp_di[15:0])
+   ,.DRPDO(drp_do[15:0])
+   ,.DRPEN(drp_en)
+   ,.DRPRDY(drp_rdy)
+   ,.DRPWE(drp_we)
+   // CCIX new ports
+   ,.CCIXOPTIMIZEDTLPTXANDRXENABLE (ccix_optimized_tlp_tx_and_rx_enable)
+   // Status outputs from CCIX RX FIFO to TL
+   ,.CCIXRXTLPFORWARDED0(ccix_rx_tlp_forwarded0_int) // WIP new outputs
+   ,.CCIXRXTLPFORWARDEDLENGTH0(ccix_rx_tlp_forwarded_length0_int) // WIP new outputs
+   ,.CCIXRXTLPFORWARDED1(ccix_rx_tlp_forwarded1_int) // WIP new outputs
+   ,.CCIXRXTLPFORWARDEDLENGTH1(ccix_rx_tlp_forwarded_length1_int) // WIP new outputs
+   ,.CCIXRXFIFOOVERFLOW(ccix_rx_fifo_overflow_int) // WIP new outputs
+   ,.CCIXRXCORRECTABLEERRORDETECTED(ccix_rx_correctable_error_detected_int) // WIP new outputs
+   ,.CCIXRXUNCORRECTABLEERRORDETECTED(ccix_rx_uncorrectable_error_detected_int) // WIP new outputs
+   ,.MAXISCCIXRXTUSER(m_axis_ccix_rx_tuser_int) // WIP new outputs
+   ,.MAXISCCIXRXTVALID(m_axis_ccix_rx_tvalid_int) // WIP new outputs
+   ,.SAXISCCIXTXTDATA(s_axis_ccix_tx_tdata)
+   ,.SAXISCCIXTXTVALID(s_axis_ccix_tx_tvalid)
+   ,.SAXISCCIXTXTUSER(s_axis_ccix_tx_tuser)
+   ,.MAXISCQTDATA(m_axis_cq_tdata_int[255:0])
+   ,.MAXISCQTKEEP(m_axis_cq_tkeep_int[7:0])
+   ,.MAXISCQTLAST(m_axis_cq_tlast_int)
+   ,.MAXISCQTREADY(m_axis_cq_tready_int[21:0])
+   ,.MAXISCQTUSER(m_axis_cq_tuser_int[87:0])
+   ,.MAXISCQTVALID(m_axis_cq_tvalid_int)
+   ,.MAXISRCTDATA(m_axis_rc_tdata_int[255:0])
+   ,.MAXISRCTKEEP(m_axis_rc_tkeep_int[7:0])
+   ,.MAXISRCTLAST(m_axis_rc_tlast_int)
+   ,.MAXISRCTREADY(m_axis_rc_tready_int[21:0])
+   ,.MAXISRCTUSER(m_axis_rc_tuser_int[74:0])
+   ,.MAXISRCTVALID(m_axis_rc_tvalid_int)
+   ,.MCAPCLK(mcap_clk)
+   ,.MGMTRESETN(mgmt_reset_n)
+   ,.MGMTSTICKYRESETN(mgmt_sticky_reset_n)
+   ,.MIREPLAYRAMADDRESS0(mi_replay_ram_address0[8:0])
+   ,.MIREPLAYRAMADDRESS1(mi_replay_ram_address1[8:0])
+   ,.MIREPLAYRAMERRCOR(mi_replay_ram_err_cor[5:0])
+   ,.MIREPLAYRAMERRUNCOR(mi_replay_ram_err_uncor[5:0])
+   ,.MIREPLAYRAMREADDATA0(mi_replay_ram_read_data0[127:0])
+   ,.MIREPLAYRAMREADDATA1(mi_replay_ram_read_data1[127:0])
+   ,.MIREPLAYRAMREADENABLE0(mi_replay_ram_read_enable0)
+   ,.MIREPLAYRAMREADENABLE1(mi_replay_ram_read_enable1)
+   ,.MIREPLAYRAMWRITEDATA0(mi_replay_ram_write_data0[127:0])
+   ,.MIREPLAYRAMWRITEDATA1(mi_replay_ram_write_data1[127:0])
+   ,.MIREPLAYRAMWRITEENABLE0(mi_replay_ram_write_enable0)
+   ,.MIREPLAYRAMWRITEENABLE1(mi_replay_ram_write_enable1)
+   ,.MIRXCOMPLETIONRAMERRCOR(mi_rx_completion_ram_err_cor[11:0])
+   ,.MIRXCOMPLETIONRAMERRUNCOR(mi_rx_completion_ram_err_uncor[11:0])
+   ,.MIRXCOMPLETIONRAMREADADDRESS0(mi_rx_completion_ram_read_address0[8:0])
+   ,.MIRXCOMPLETIONRAMREADADDRESS1(mi_rx_completion_ram_read_address1[8:0])
+   ,.MIRXCOMPLETIONRAMREADDATA0(mi_rx_completion_ram_read_data0[143:0])
+   ,.MIRXCOMPLETIONRAMREADDATA1(mi_rx_completion_ram_read_data1[143:0])
+   ,.MIRXCOMPLETIONRAMREADENABLE0(mi_rx_completion_ram_read_enable0[1:0])
+   ,.MIRXCOMPLETIONRAMREADENABLE1(mi_rx_completion_ram_read_enable1[1:0])
+   ,.MIRXCOMPLETIONRAMWRITEADDRESS0(mi_rx_completion_ram_write_address0[8:0])
+   ,.MIRXCOMPLETIONRAMWRITEADDRESS1(mi_rx_completion_ram_write_address1[8:0])
+   ,.MIRXCOMPLETIONRAMWRITEDATA0(mi_rx_completion_ram_write_data0[143:0])
+   ,.MIRXCOMPLETIONRAMWRITEDATA1(mi_rx_completion_ram_write_data1[143:0])
+   ,.MIRXCOMPLETIONRAMWRITEENABLE0(mi_rx_completion_ram_write_enable0[1:0])
+   ,.MIRXCOMPLETIONRAMWRITEENABLE1(mi_rx_completion_ram_write_enable1[1:0])
+   ,.MIRXPOSTEDREQUESTRAMERRCOR(mi_rx_posted_request_ram_err_cor[5:0])
+   ,.MIRXPOSTEDREQUESTRAMERRUNCOR(mi_rx_posted_request_ram_err_uncor[5:0])
+   ,.MIRXPOSTEDREQUESTRAMREADADDRESS0(mi_rx_posted_request_ram_read_address0[8:0])
+   ,.MIRXPOSTEDREQUESTRAMREADADDRESS1(mi_rx_posted_request_ram_read_address1[8:0])
+   ,.MIRXPOSTEDREQUESTRAMREADDATA0(mi_rx_posted_request_ram_read_data0[143:0])
+   ,.MIRXPOSTEDREQUESTRAMREADDATA1(mi_rx_posted_request_ram_read_data1[143:0])
+   ,.MIRXPOSTEDREQUESTRAMREADENABLE0(mi_rx_posted_request_ram_read_enable0)
+   ,.MIRXPOSTEDREQUESTRAMREADENABLE1(mi_rx_posted_request_ram_read_enable1)
+   ,.MIRXPOSTEDREQUESTRAMWRITEADDRESS0(mi_rx_posted_request_ram_write_address0[8:0])
+   ,.MIRXPOSTEDREQUESTRAMWRITEADDRESS1(mi_rx_posted_request_ram_write_address1[8:0])
+   ,.MIRXPOSTEDREQUESTRAMWRITEDATA0(mi_rx_posted_request_ram_write_data0[143:0])
+   ,.MIRXPOSTEDREQUESTRAMWRITEDATA1(mi_rx_posted_request_ram_write_data1[143:0])
+   ,.MIRXPOSTEDREQUESTRAMWRITEENABLE0(mi_rx_posted_request_ram_write_enable0)
+   ,.MIRXPOSTEDREQUESTRAMWRITEENABLE1(mi_rx_posted_request_ram_write_enable1)
+   ,.PCIECOMPLDELIVERED(pcie_compl_delivered[1:0])
+   ,.PCIECOMPLDELIVEREDTAG0(pcie_compl_delivered_tag0[7:0])
+   ,.PCIECOMPLDELIVEREDTAG1(pcie_compl_delivered_tag1[7:0])
+   ,.PCIECQNPREQ(pcie_cq_np_req[1:0])
+   ,.PCIECQNPREQCOUNT(pcie_cq_np_req_count_int[5:0])
+   ,.PCIECQNPUSERCREDITRCVD(pcie_cq_np_user_credit_rcvd)
+   ,.PCIECQPIPELINEEMPTY(pcie_cq_pipeline_empty)
+   ,.PCIEPERST0B(pcie_perst0_b)
+   ,.PCIEPERST1B(pcie_perst1_b)
+   ,.MCAPPERST0B(mcap_rst_b)
+   ,.MCAPPERST1B(mcap_rst_b)
+   ,.PCIEPOSTEDREQDELIVERED(pcie_posted_req_delivered)
+   ,.PCIERQSEQNUM0(pcie_rq_seq_num0_cc[5:0])
+   ,.PCIERQSEQNUM1(pcie_rq_seq_num1[5:0])
+   ,.PCIERQSEQNUMVLD0(pcie_rq_seq_num_vld0_cc)
+   ,.PCIERQSEQNUMVLD1(pcie_rq_seq_num_vld1)
+   ,.PCIERQTAG0(pcie_rq_tag0[7:0])
+   ,.PCIERQTAG1(pcie_rq_tag1[7:0])
+   ,.PCIERQTAGAV(pcie_rq_tag_av[3:0])
+   ,.PCIERQTAGVLD0(pcie_rq_tag_vld0)
+   ,.PCIERQTAGVLD1(pcie_rq_tag_vld1)
+   ,.PCIETFCNPDAV(pcie_tfc_npd_av[3:0])
+   ,.PCIETFCNPHAV(pcie_tfc_nph_av[3:0])
+   ,.PIPECLKEN(1'b1)
+   ,.PIPECLK(pipe_clk_to_e4)
+   ,.PIPEEQFS(pipe_eq_fs[5:0])
+   ,.PIPEEQLF(pipe_eq_lf[5:0])
+   ,.PIPERESETN(pipe_reset_n)
+   ,.PIPERX00CHARISK(pipe_rx00_char_is_k[1:0])
+   ,.PIPERX00DATA(pipe_rx00_data[31:0])
+   ,.PIPERX00DATAVALID(pipe_rx00_data_valid)
+   ,.PIPERX00ELECIDLE(pipe_rx00_elec_idle)
+   ,.PIPERX00EQCONTROL(pipe_rx00_eq_control[1:0])
+   ,.PIPERX00EQDONE(pipe_rx00_eq_done)
+   ,.PIPERX00EQLPADAPTDONE(pipe_rx00_eq_lp_adapt_done)
+   ,.PIPERX00EQLPLFFSSEL(pipe_rx00_eq_lp_lf_fs_sel)
+   ,.PIPERX00EQLPNEWTXCOEFFORPRESET(pipe_rx00_eq_lp_new_tx_coeff_or_preset[17:0])
+   ,.PIPERX00PHYSTATUS(pipe_rx00_phy_status)
+   ,.PIPERX00POLARITY(pipe_rx00_polarity)
+   ,.PIPERX00STARTBLOCK(pipe_rx00_start_block[1:0])
+   ,.PIPERX00STATUS(pipe_rx00_status[2:0])
+   ,.PIPERX00SYNCHEADER(pipe_rx00_sync_header[1:0])
+   ,.PIPERX00VALID(pipe_rx00_valid)
+   ,.PIPERX01CHARISK(pipe_rx01_char_is_k[1:0])
+   ,.PIPERX01DATA(pipe_rx01_data[31:0])
+   ,.PIPERX01DATAVALID(pipe_rx01_data_valid)
+   ,.PIPERX01ELECIDLE(pipe_rx01_elec_idle)
+   ,.PIPERX01EQCONTROL(pipe_rx01_eq_control[1:0])
+   ,.PIPERX01EQDONE(pipe_rx01_eq_done)
+   ,.PIPERX01EQLPADAPTDONE(pipe_rx01_eq_lp_adapt_done)
+   ,.PIPERX01EQLPLFFSSEL(pipe_rx01_eq_lp_lf_fs_sel)
+   ,.PIPERX01EQLPNEWTXCOEFFORPRESET(pipe_rx01_eq_lp_new_tx_coeff_or_preset[17:0])
+   ,.PIPERX01PHYSTATUS(pipe_rx01_phy_status)
+   ,.PIPERX01POLARITY(pipe_rx01_polarity)
+   ,.PIPERX01STARTBLOCK(pipe_rx01_start_block[1:0])
+   ,.PIPERX01STATUS(pipe_rx01_status[2:0])
+   ,.PIPERX01SYNCHEADER(pipe_rx01_sync_header[1:0])
+   ,.PIPERX01VALID(pipe_rx01_valid)
+   ,.PIPERX02CHARISK(pipe_rx02_char_is_k[1:0])
+   ,.PIPERX02DATA(pipe_rx02_data[31:0])
+   ,.PIPERX02DATAVALID(pipe_rx02_data_valid)
+   ,.PIPERX02ELECIDLE(pipe_rx02_elec_idle)
+   ,.PIPERX02EQCONTROL(pipe_rx02_eq_control[1:0])
+   ,.PIPERX02EQDONE(pipe_rx02_eq_done)
+   ,.PIPERX02EQLPADAPTDONE(pipe_rx02_eq_lp_adapt_done)
+   ,.PIPERX02EQLPLFFSSEL(pipe_rx02_eq_lp_lf_fs_sel)
+   ,.PIPERX02EQLPNEWTXCOEFFORPRESET(pipe_rx02_eq_lp_new_tx_coeff_or_preset[17:0])
+   ,.PIPERX02PHYSTATUS(pipe_rx02_phy_status)
+   ,.PIPERX02POLARITY(pipe_rx02_polarity)
+   ,.PIPERX02STARTBLOCK(pipe_rx02_start_block[1:0])
+   ,.PIPERX02STATUS(pipe_rx02_status[2:0])
+   ,.PIPERX02SYNCHEADER(pipe_rx02_sync_header[1:0])
+   ,.PIPERX02VALID(pipe_rx02_valid)
+   ,.PIPERX03CHARISK(pipe_rx03_char_is_k[1:0])
+   ,.PIPERX03DATA(pipe_rx03_data[31:0])
+   ,.PIPERX03DATAVALID(pipe_rx03_data_valid)
+   ,.PIPERX03ELECIDLE(pipe_rx03_elec_idle)
+   ,.PIPERX03EQCONTROL(pipe_rx03_eq_control[1:0])
+   ,.PIPERX03EQDONE(pipe_rx03_eq_done)
+   ,.PIPERX03EQLPADAPTDONE(pipe_rx03_eq_lp_adapt_done)
+   ,.PIPERX03EQLPLFFSSEL(pipe_rx03_eq_lp_lf_fs_sel)
+   ,.PIPERX03EQLPNEWTXCOEFFORPRESET(pipe_rx03_eq_lp_new_tx_coeff_or_preset[17:0])
+   ,.PIPERX03PHYSTATUS(pipe_rx03_phy_status)
+   ,.PIPERX03POLARITY(pipe_rx03_polarity)
+   ,.PIPERX03STARTBLOCK(pipe_rx03_start_block[1:0])
+   ,.PIPERX03STATUS(pipe_rx03_status[2:0])
+   ,.PIPERX03SYNCHEADER(pipe_rx03_sync_header[1:0])
+   ,.PIPERX03VALID(pipe_rx03_valid)
+   ,.PIPERX04CHARISK(pipe_rx04_char_is_k[1:0])
+   ,.PIPERX04DATA(pipe_rx04_data[31:0])
+   ,.PIPERX04DATAVALID(pipe_rx04_data_valid)
+   ,.PIPERX04ELECIDLE(pipe_rx04_elec_idle)
+   ,.PIPERX04EQCONTROL(pipe_rx04_eq_control[1:0])
+   ,.PIPERX04EQDONE(pipe_rx04_eq_done)
+   ,.PIPERX04EQLPADAPTDONE(pipe_rx04_eq_lp_adapt_done)
+   ,.PIPERX04EQLPLFFSSEL(pipe_rx04_eq_lp_lf_fs_sel)
+   ,.PIPERX04EQLPNEWTXCOEFFORPRESET(pipe_rx04_eq_lp_new_tx_coeff_or_preset[17:0])
+   ,.PIPERX04PHYSTATUS(pipe_rx04_phy_status)
+   ,.PIPERX04POLARITY(pipe_rx04_polarity)
+   ,.PIPERX04STARTBLOCK(pipe_rx04_start_block[1:0])
+   ,.PIPERX04STATUS(pipe_rx04_status[2:0])
+   ,.PIPERX04SYNCHEADER(pipe_rx04_sync_header[1:0])
+   ,.PIPERX04VALID(pipe_rx04_valid)
+   ,.PIPERX05CHARISK(pipe_rx05_char_is_k[1:0])
+   ,.PIPERX05DATA(pipe_rx05_data[31:0])
+   ,.PIPERX05DATAVALID(pipe_rx05_data_valid)
+   ,.PIPERX05ELECIDLE(pipe_rx05_elec_idle)
+   ,.PIPERX05EQCONTROL(pipe_rx05_eq_control[1:0])
+   ,.PIPERX05EQDONE(pipe_rx05_eq_done)
+   ,.PIPERX05EQLPADAPTDONE(pipe_rx05_eq_lp_adapt_done)
+   ,.PIPERX05EQLPLFFSSEL(pipe_rx05_eq_lp_lf_fs_sel)
+   ,.PIPERX05EQLPNEWTXCOEFFORPRESET(pipe_rx05_eq_lp_new_tx_coeff_or_preset[17:0])
+   ,.PIPERX05PHYSTATUS(pipe_rx05_phy_status)
+   ,.PIPERX05POLARITY(pipe_rx05_polarity)
+   ,.PIPERX05STARTBLOCK(pipe_rx05_start_block[1:0])
+   ,.PIPERX05STATUS(pipe_rx05_status[2:0])
+   ,.PIPERX05SYNCHEADER(pipe_rx05_sync_header[1:0])
+   ,.PIPERX05VALID(pipe_rx05_valid)
+   ,.PIPERX06CHARISK(pipe_rx06_char_is_k[1:0])
+   ,.PIPERX06DATA(pipe_rx06_data[31:0])
+   ,.PIPERX06DATAVALID(pipe_rx06_data_valid)
+   ,.PIPERX06ELECIDLE(pipe_rx06_elec_idle)
+   ,.PIPERX06EQCONTROL(pipe_rx06_eq_control[1:0])
+   ,.PIPERX06EQDONE(pipe_rx06_eq_done)
+   ,.PIPERX06EQLPADAPTDONE(pipe_rx06_eq_lp_adapt_done)
+   ,.PIPERX06EQLPLFFSSEL(pipe_rx06_eq_lp_lf_fs_sel)
+   ,.PIPERX06EQLPNEWTXCOEFFORPRESET(pipe_rx06_eq_lp_new_tx_coeff_or_preset[17:0])
+   ,.PIPERX06PHYSTATUS(pipe_rx06_phy_status)
+   ,.PIPERX06POLARITY(pipe_rx06_polarity)
+   ,.PIPERX06STARTBLOCK(pipe_rx06_start_block[1:0])
+   ,.PIPERX06STATUS(pipe_rx06_status[2:0])
+   ,.PIPERX06SYNCHEADER(pipe_rx06_sync_header[1:0])
+   ,.PIPERX06VALID(pipe_rx06_valid)
+   ,.PIPERX07CHARISK(pipe_rx07_char_is_k[1:0])
+   ,.PIPERX07DATA(pipe_rx07_data[31:0])
+   ,.PIPERX07DATAVALID(pipe_rx07_data_valid)
+   ,.PIPERX07ELECIDLE(pipe_rx07_elec_idle)
+   ,.PIPERX07EQCONTROL(pipe_rx07_eq_control[1:0])
+   ,.PIPERX07EQDONE(pipe_rx07_eq_done)
+   ,.PIPERX07EQLPADAPTDONE(pipe_rx07_eq_lp_adapt_done)
+   ,.PIPERX07EQLPLFFSSEL(pipe_rx07_eq_lp_lf_fs_sel)
+   ,.PIPERX07EQLPNEWTXCOEFFORPRESET(pipe_rx07_eq_lp_new_tx_coeff_or_preset[17:0])
+   ,.PIPERX07PHYSTATUS(pipe_rx07_phy_status)
+   ,.PIPERX07POLARITY(pipe_rx07_polarity)
+   ,.PIPERX07STARTBLOCK(pipe_rx07_start_block[1:0])
+   ,.PIPERX07STATUS(pipe_rx07_status[2:0])
+   ,.PIPERX07SYNCHEADER(pipe_rx07_sync_header[1:0])
+   ,.PIPERX07VALID(pipe_rx07_valid)
+   ,.PIPERX08CHARISK(pipe_rx08_char_is_k[1:0])
+   ,.PIPERX08DATA(pipe_rx08_data[31:0])
+   ,.PIPERX08DATAVALID(pipe_rx08_data_valid)
+   ,.PIPERX08ELECIDLE(pipe_rx08_elec_idle)
+   ,.PIPERX08EQCONTROL(pipe_rx08_eq_control[1:0])
+   ,.PIPERX08EQDONE(pipe_rx08_eq_done)
+   ,.PIPERX08EQLPADAPTDONE(pipe_rx08_eq_lp_adapt_done)
+   ,.PIPERX08EQLPLFFSSEL(pipe_rx08_eq_lp_lf_fs_sel)
+   ,.PIPERX08EQLPNEWTXCOEFFORPRESET(pipe_rx08_eq_lp_new_tx_coeff_or_preset[17:0])
+   ,.PIPERX08PHYSTATUS(pipe_rx08_phy_status)
+   ,.PIPERX08POLARITY(pipe_rx08_polarity)
+   ,.PIPERX08STARTBLOCK(pipe_rx08_start_block[1:0])
+   ,.PIPERX08STATUS(pipe_rx08_status[2:0])
+   ,.PIPERX08SYNCHEADER(pipe_rx08_sync_header[1:0])
+   ,.PIPERX08VALID(pipe_rx08_valid)
+   ,.PIPERX09CHARISK(pipe_rx09_char_is_k[1:0])
+   ,.PIPERX09DATA(pipe_rx09_data[31:0])
+   ,.PIPERX09DATAVALID(pipe_rx09_data_valid)
+   ,.PIPERX09ELECIDLE(pipe_rx09_elec_idle)
+   ,.PIPERX09EQCONTROL(pipe_rx09_eq_control[1:0])
+   ,.PIPERX09EQDONE(pipe_rx09_eq_done)
+   ,.PIPERX09EQLPADAPTDONE(pipe_rx09_eq_lp_adapt_done)
+   ,.PIPERX09EQLPLFFSSEL(pipe_rx09_eq_lp_lf_fs_sel)
+   ,.PIPERX09EQLPNEWTXCOEFFORPRESET(pipe_rx09_eq_lp_new_tx_coeff_or_preset[17:0])
+   ,.PIPERX09PHYSTATUS(pipe_rx09_phy_status)
+   ,.PIPERX09POLARITY(pipe_rx09_polarity)
+   ,.PIPERX09STARTBLOCK(pipe_rx09_start_block[1:0])
+   ,.PIPERX09STATUS(pipe_rx09_status[2:0])
+   ,.PIPERX09SYNCHEADER(pipe_rx09_sync_header[1:0])
+   ,.PIPERX09VALID(pipe_rx09_valid)
+   ,.PIPERX10CHARISK(pipe_rx10_char_is_k[1:0])
+   ,.PIPERX10DATA(pipe_rx10_data[31:0])
+   ,.PIPERX10DATAVALID(pipe_rx10_data_valid)
+   ,.PIPERX10ELECIDLE(pipe_rx10_elec_idle)
+   ,.PIPERX10EQCONTROL(pipe_rx10_eq_control[1:0])
+   ,.PIPERX10EQDONE(pipe_rx10_eq_done)
+   ,.PIPERX10EQLPADAPTDONE(pipe_rx10_eq_lp_adapt_done)
+   ,.PIPERX10EQLPLFFSSEL(pipe_rx10_eq_lp_lf_fs_sel)
+   ,.PIPERX10EQLPNEWTXCOEFFORPRESET(pipe_rx10_eq_lp_new_tx_coeff_or_preset[17:0])
+   ,.PIPERX10PHYSTATUS(pipe_rx10_phy_status)
+   ,.PIPERX10POLARITY(pipe_rx10_polarity)
+   ,.PIPERX10STARTBLOCK(pipe_rx10_start_block[1:0])
+   ,.PIPERX10STATUS(pipe_rx10_status[2:0])
+   ,.PIPERX10SYNCHEADER(pipe_rx10_sync_header[1:0])
+   ,.PIPERX10VALID(pipe_rx10_valid)
+   ,.PIPERX11CHARISK(pipe_rx11_char_is_k[1:0])
+   ,.PIPERX11DATA(pipe_rx11_data[31:0])
+   ,.PIPERX11DATAVALID(pipe_rx11_data_valid)
+   ,.PIPERX11ELECIDLE(pipe_rx11_elec_idle)
+   ,.PIPERX11EQCONTROL(pipe_rx11_eq_control[1:0])
+   ,.PIPERX11EQDONE(pipe_rx11_eq_done)
+   ,.PIPERX11EQLPADAPTDONE(pipe_rx11_eq_lp_adapt_done)
+   ,.PIPERX11EQLPLFFSSEL(pipe_rx11_eq_lp_lf_fs_sel)
+   ,.PIPERX11EQLPNEWTXCOEFFORPRESET(pipe_rx11_eq_lp_new_tx_coeff_or_preset[17:0])
+   ,.PIPERX11PHYSTATUS(pipe_rx11_phy_status)
+   ,.PIPERX11POLARITY(pipe_rx11_polarity)
+   ,.PIPERX11STARTBLOCK(pipe_rx11_start_block[1:0])
+   ,.PIPERX11STATUS(pipe_rx11_status[2:0])
+   ,.PIPERX11SYNCHEADER(pipe_rx11_sync_header[1:0])
+   ,.PIPERX11VALID(pipe_rx11_valid)
+   ,.PIPERX12CHARISK(pipe_rx12_char_is_k[1:0])
+   ,.PIPERX12DATA(pipe_rx12_data[31:0])
+   ,.PIPERX12DATAVALID(pipe_rx12_data_valid)
+   ,.PIPERX12ELECIDLE(pipe_rx12_elec_idle)
+   ,.PIPERX12EQCONTROL(pipe_rx12_eq_control[1:0])
+   ,.PIPERX12EQDONE(pipe_rx12_eq_done)
+   ,.PIPERX12EQLPADAPTDONE(pipe_rx12_eq_lp_adapt_done)
+   ,.PIPERX12EQLPLFFSSEL(pipe_rx12_eq_lp_lf_fs_sel)
+   ,.PIPERX12EQLPNEWTXCOEFFORPRESET(pipe_rx12_eq_lp_new_tx_coeff_or_preset[17:0])
+   ,.PIPERX12PHYSTATUS(pipe_rx12_phy_status)
+   ,.PIPERX12POLARITY(pipe_rx12_polarity)
+   ,.PIPERX12STARTBLOCK(pipe_rx12_start_block[1:0])
+   ,.PIPERX12STATUS(pipe_rx12_status[2:0])
+   ,.PIPERX12SYNCHEADER(pipe_rx12_sync_header[1:0])
+   ,.PIPERX12VALID(pipe_rx12_valid)
+   ,.PIPERX13CHARISK(pipe_rx13_char_is_k[1:0])
+   ,.PIPERX13DATA(pipe_rx13_data[31:0])
+   ,.PIPERX13DATAVALID(pipe_rx13_data_valid)
+   ,.PIPERX13ELECIDLE(pipe_rx13_elec_idle)
+   ,.PIPERX13EQCONTROL(pipe_rx13_eq_control[1:0])
+   ,.PIPERX13EQDONE(pipe_rx13_eq_done)
+   ,.PIPERX13EQLPADAPTDONE(pipe_rx13_eq_lp_adapt_done)
+   ,.PIPERX13EQLPLFFSSEL(pipe_rx13_eq_lp_lf_fs_sel)
+   ,.PIPERX13EQLPNEWTXCOEFFORPRESET(pipe_rx13_eq_lp_new_tx_coeff_or_preset[17:0])
+   ,.PIPERX13PHYSTATUS(pipe_rx13_phy_status)
+   ,.PIPERX13POLARITY(pipe_rx13_polarity)
+   ,.PIPERX13STARTBLOCK(pipe_rx13_start_block[1:0])
+   ,.PIPERX13STATUS(pipe_rx13_status[2:0])
+   ,.PIPERX13SYNCHEADER(pipe_rx13_sync_header[1:0])
+   ,.PIPERX13VALID(pipe_rx13_valid)
+   ,.PIPERX14CHARISK(pipe_rx14_char_is_k[1:0])
+   ,.PIPERX14DATA(pipe_rx14_data[31:0])
+   ,.PIPERX14DATAVALID(pipe_rx14_data_valid)
+   ,.PIPERX14ELECIDLE(pipe_rx14_elec_idle)
+   ,.PIPERX14EQCONTROL(pipe_rx14_eq_control[1:0])
+   ,.PIPERX14EQDONE(pipe_rx14_eq_done)
+   ,.PIPERX14EQLPADAPTDONE(pipe_rx14_eq_lp_adapt_done)
+   ,.PIPERX14EQLPLFFSSEL(pipe_rx14_eq_lp_lf_fs_sel)
+   ,.PIPERX14EQLPNEWTXCOEFFORPRESET(pipe_rx14_eq_lp_new_tx_coeff_or_preset[17:0])
+   ,.PIPERX14PHYSTATUS(pipe_rx14_phy_status)
+   ,.PIPERX14POLARITY(pipe_rx14_polarity)
+   ,.PIPERX14STARTBLOCK(pipe_rx14_start_block[1:0])
+   ,.PIPERX14STATUS(pipe_rx14_status[2:0])
+   ,.PIPERX14SYNCHEADER(pipe_rx14_sync_header[1:0])
+   ,.PIPERX14VALID(pipe_rx14_valid)
+   ,.PIPERX15CHARISK(pipe_rx15_char_is_k[1:0])
+   ,.PIPERX15DATA(pipe_rx15_data[31:0])
+   ,.PIPERX15DATAVALID(pipe_rx15_data_valid)
+   ,.PIPERX15ELECIDLE(pipe_rx15_elec_idle)
+   ,.PIPERX15EQCONTROL(pipe_rx15_eq_control[1:0])
+   ,.PIPERX15EQDONE(pipe_rx15_eq_done)
+   ,.PIPERX15EQLPADAPTDONE(pipe_rx15_eq_lp_adapt_done)
+   ,.PIPERX15EQLPLFFSSEL(pipe_rx15_eq_lp_lf_fs_sel)
+   ,.PIPERX15EQLPNEWTXCOEFFORPRESET(pipe_rx15_eq_lp_new_tx_coeff_or_preset[17:0])
+   ,.PIPERX15PHYSTATUS(pipe_rx15_phy_status)
+   ,.PIPERX15POLARITY(pipe_rx15_polarity)
+   ,.PIPERX15STARTBLOCK(pipe_rx15_start_block[1:0])
+   ,.PIPERX15STATUS(pipe_rx15_status[2:0])
+   ,.PIPERX15SYNCHEADER(pipe_rx15_sync_header[1:0])
+   ,.PIPERX15VALID(pipe_rx15_valid)
+   ,.PIPERXEQLPLFFS(pipe_rx_eq_lp_lf_fs[5:0])
+   ,.PIPERXEQLPTXPRESET(pipe_rx_eq_lp_tx_preset[3:0])
+   ,.PIPETX00CHARISK(pipe_tx00_char_is_k[1:0])
+   ,.PIPETX00COMPLIANCE(pipe_tx00_compliance)
+   ,.PIPETX00DATA(pipe_tx00_data_out[31:0])
+   ,.PIPETX00DATAVALID(pipe_tx00_data_valid)
+   ,.PIPETX00ELECIDLE(pipe_tx00_elec_idle)
+   ,.PIPETX00EQCOEFF(pipe_tx00_eq_coeff[17:0])
+   ,.PIPETX00EQCONTROL(pipe_tx00_eq_control[1:0])
+   ,.PIPETX00EQDEEMPH(pipe_tx00_eq_deemph[5:0])
+   ,.PIPETX00EQDONE(pipe_tx00_eq_done)
+   ,.PIPETX00POWERDOWN(pipe_tx00_powerdown[1:0])
+   ,.PIPETX00STARTBLOCK(pipe_tx00_start_block)
+   ,.PIPETX00SYNCHEADER(pipe_tx00_sync_header[1:0])
+   ,.PIPETX01CHARISK(pipe_tx01_char_is_k[1:0])
+   ,.PIPETX01COMPLIANCE(pipe_tx01_compliance)
+   ,.PIPETX01DATA(pipe_tx01_data_out[31:0])
+   ,.PIPETX01DATAVALID(pipe_tx01_data_valid)
+   ,.PIPETX01ELECIDLE(pipe_tx01_elec_idle)
+   ,.PIPETX01EQCOEFF(pipe_tx01_eq_coeff[17:0])
+   ,.PIPETX01EQCONTROL(pipe_tx01_eq_control[1:0])
+   ,.PIPETX01EQDEEMPH(pipe_tx01_eq_deemph[5:0])
+   ,.PIPETX01EQDONE(pipe_tx01_eq_done)
+   ,.PIPETX01POWERDOWN(pipe_tx01_powerdown[1:0])
+   ,.PIPETX01STARTBLOCK(pipe_tx01_start_block)
+   ,.PIPETX01SYNCHEADER(pipe_tx01_sync_header[1:0])
+   ,.PIPETX02CHARISK(pipe_tx02_char_is_k[1:0])
+   ,.PIPETX02COMPLIANCE(pipe_tx02_compliance)
+   ,.PIPETX02DATA(pipe_tx02_data_out[31:0])
+   ,.PIPETX02DATAVALID(pipe_tx02_data_valid)
+   ,.PIPETX02ELECIDLE(pipe_tx02_elec_idle)
+   ,.PIPETX02EQCOEFF(pipe_tx02_eq_coeff[17:0])
+   ,.PIPETX02EQCONTROL(pipe_tx02_eq_control[1:0])
+   ,.PIPETX02EQDEEMPH(pipe_tx02_eq_deemph[5:0])
+   ,.PIPETX02EQDONE(pipe_tx02_eq_done)
+   ,.PIPETX02POWERDOWN(pipe_tx02_powerdown[1:0])
+   ,.PIPETX02STARTBLOCK(pipe_tx02_start_block)
+   ,.PIPETX02SYNCHEADER(pipe_tx02_sync_header[1:0])
+   ,.PIPETX03CHARISK(pipe_tx03_char_is_k[1:0])
+   ,.PIPETX03COMPLIANCE(pipe_tx03_compliance)
+   ,.PIPETX03DATA(pipe_tx03_data_out[31:0])
+   ,.PIPETX03DATAVALID(pipe_tx03_data_valid)
+   ,.PIPETX03ELECIDLE(pipe_tx03_elec_idle)
+   ,.PIPETX03EQCOEFF(pipe_tx03_eq_coeff[17:0])
+   ,.PIPETX03EQCONTROL(pipe_tx03_eq_control[1:0])
+   ,.PIPETX03EQDEEMPH(pipe_tx03_eq_deemph[5:0])
+   ,.PIPETX03EQDONE(pipe_tx03_eq_done)
+   ,.PIPETX03POWERDOWN(pipe_tx03_powerdown[1:0])
+   ,.PIPETX03STARTBLOCK(pipe_tx03_start_block)
+   ,.PIPETX03SYNCHEADER(pipe_tx03_sync_header[1:0])
+   ,.PIPETX04CHARISK(pipe_tx04_char_is_k[1:0])
+   ,.PIPETX04COMPLIANCE(pipe_tx04_compliance)
+   ,.PIPETX04DATA(pipe_tx04_data_out[31:0])
+   ,.PIPETX04DATAVALID(pipe_tx04_data_valid)
+   ,.PIPETX04ELECIDLE(pipe_tx04_elec_idle)
+   ,.PIPETX04EQCOEFF(pipe_tx04_eq_coeff[17:0])
+   ,.PIPETX04EQCONTROL(pipe_tx04_eq_control[1:0])
+   ,.PIPETX04EQDEEMPH(pipe_tx04_eq_deemph[5:0])
+   ,.PIPETX04EQDONE(pipe_tx04_eq_done)
+   ,.PIPETX04POWERDOWN(pipe_tx04_powerdown[1:0])
+   ,.PIPETX04STARTBLOCK(pipe_tx04_start_block)
+   ,.PIPETX04SYNCHEADER(pipe_tx04_sync_header[1:0])
+   ,.PIPETX05CHARISK(pipe_tx05_char_is_k[1:0])
+   ,.PIPETX05COMPLIANCE(pipe_tx05_compliance)
+   ,.PIPETX05DATA(pipe_tx05_data_out[31:0])
+   ,.PIPETX05DATAVALID(pipe_tx05_data_valid)
+   ,.PIPETX05ELECIDLE(pipe_tx05_elec_idle)
+   ,.PIPETX05EQCOEFF(pipe_tx05_eq_coeff[17:0])
+   ,.PIPETX05EQCONTROL(pipe_tx05_eq_control[1:0])
+   ,.PIPETX05EQDEEMPH(pipe_tx05_eq_deemph[5:0])
+   ,.PIPETX05EQDONE(pipe_tx05_eq_done)
+   ,.PIPETX05POWERDOWN(pipe_tx05_powerdown[1:0])
+   ,.PIPETX05STARTBLOCK(pipe_tx05_start_block)
+   ,.PIPETX05SYNCHEADER(pipe_tx05_sync_header[1:0])
+   ,.PIPETX06CHARISK(pipe_tx06_char_is_k[1:0])
+   ,.PIPETX06COMPLIANCE(pipe_tx06_compliance)
+   ,.PIPETX06DATA(pipe_tx06_data_out[31:0])
+   ,.PIPETX06DATAVALID(pipe_tx06_data_valid)
+   ,.PIPETX06ELECIDLE(pipe_tx06_elec_idle)
+   ,.PIPETX06EQCOEFF(pipe_tx06_eq_coeff[17:0])
+   ,.PIPETX06EQCONTROL(pipe_tx06_eq_control[1:0])
+   ,.PIPETX06EQDEEMPH(pipe_tx06_eq_deemph[5:0])
+   ,.PIPETX06EQDONE(pipe_tx06_eq_done)
+   ,.PIPETX06POWERDOWN(pipe_tx06_powerdown[1:0])
+   ,.PIPETX06STARTBLOCK(pipe_tx06_start_block)
+   ,.PIPETX06SYNCHEADER(pipe_tx06_sync_header[1:0])
+   ,.PIPETX07CHARISK(pipe_tx07_char_is_k[1:0])
+   ,.PIPETX07COMPLIANCE(pipe_tx07_compliance)
+   ,.PIPETX07DATA(pipe_tx07_data_out[31:0])
+   ,.PIPETX07DATAVALID(pipe_tx07_data_valid)
+   ,.PIPETX07ELECIDLE(pipe_tx07_elec_idle)
+   ,.PIPETX07EQCOEFF(pipe_tx07_eq_coeff[17:0])
+   ,.PIPETX07EQCONTROL(pipe_tx07_eq_control[1:0])
+   ,.PIPETX07EQDEEMPH(pipe_tx07_eq_deemph[5:0])
+   ,.PIPETX07EQDONE(pipe_tx07_eq_done)
+   ,.PIPETX07POWERDOWN(pipe_tx07_powerdown[1:0])
+   ,.PIPETX07STARTBLOCK(pipe_tx07_start_block)
+   ,.PIPETX07SYNCHEADER(pipe_tx07_sync_header[1:0])
+   ,.PIPETX08CHARISK(pipe_tx08_char_is_k[1:0])
+   ,.PIPETX08COMPLIANCE(pipe_tx08_compliance)
+   ,.PIPETX08DATA(pipe_tx08_data_out[31:0])
+   ,.PIPETX08DATAVALID(pipe_tx08_data_valid)
+   ,.PIPETX08ELECIDLE(pipe_tx08_elec_idle)
+   ,.PIPETX08EQCOEFF(pipe_tx08_eq_coeff[17:0])
+   ,.PIPETX08EQCONTROL(pipe_tx08_eq_control[1:0])
+   ,.PIPETX08EQDEEMPH(pipe_tx08_eq_deemph[5:0])
+   ,.PIPETX08EQDONE(pipe_tx08_eq_done)
+   ,.PIPETX08POWERDOWN(pipe_tx08_powerdown[1:0])
+   ,.PIPETX08STARTBLOCK(pipe_tx08_start_block)
+   ,.PIPETX08SYNCHEADER(pipe_tx08_sync_header[1:0])
+   ,.PIPETX09CHARISK(pipe_tx09_char_is_k[1:0])
+   ,.PIPETX09COMPLIANCE(pipe_tx09_compliance)
+   ,.PIPETX09DATA(pipe_tx09_data_out[31:0])
+   ,.PIPETX09DATAVALID(pipe_tx09_data_valid)
+   ,.PIPETX09ELECIDLE(pipe_tx09_elec_idle)
+   ,.PIPETX09EQCOEFF(pipe_tx09_eq_coeff[17:0])
+   ,.PIPETX09EQCONTROL(pipe_tx09_eq_control[1:0])
+   ,.PIPETX09EQDEEMPH(pipe_tx09_eq_deemph[5:0])
+   ,.PIPETX09EQDONE(pipe_tx09_eq_done)
+   ,.PIPETX09POWERDOWN(pipe_tx09_powerdown[1:0])
+   ,.PIPETX09STARTBLOCK(pipe_tx09_start_block)
+   ,.PIPETX09SYNCHEADER(pipe_tx09_sync_header[1:0])
+   ,.PIPETX10CHARISK(pipe_tx10_char_is_k[1:0])
+   ,.PIPETX10COMPLIANCE(pipe_tx10_compliance)
+   ,.PIPETX10DATA(pipe_tx10_data_out[31:0])
+   ,.PIPETX10DATAVALID(pipe_tx10_data_valid)
+   ,.PIPETX10ELECIDLE(pipe_tx10_elec_idle)
+   ,.PIPETX10EQCOEFF(pipe_tx10_eq_coeff[17:0])
+   ,.PIPETX10EQCONTROL(pipe_tx10_eq_control[1:0])
+   ,.PIPETX10EQDEEMPH(pipe_tx10_eq_deemph[5:0])
+   ,.PIPETX10EQDONE(pipe_tx10_eq_done)
+   ,.PIPETX10POWERDOWN(pipe_tx10_powerdown[1:0])
+   ,.PIPETX10STARTBLOCK(pipe_tx10_start_block)
+   ,.PIPETX10SYNCHEADER(pipe_tx10_sync_header[1:0])
+   ,.PIPETX11CHARISK(pipe_tx11_char_is_k[1:0])
+   ,.PIPETX11COMPLIANCE(pipe_tx11_compliance)
+   ,.PIPETX11DATA(pipe_tx11_data_out[31:0])
+   ,.PIPETX11DATAVALID(pipe_tx11_data_valid)
+   ,.PIPETX11ELECIDLE(pipe_tx11_elec_idle)
+   ,.PIPETX11EQCOEFF(pipe_tx11_eq_coeff[17:0])
+   ,.PIPETX11EQCONTROL(pipe_tx11_eq_control[1:0])
+   ,.PIPETX11EQDEEMPH(pipe_tx11_eq_deemph[5:0])
+   ,.PIPETX11EQDONE(pipe_tx11_eq_done)
+   ,.PIPETX11POWERDOWN(pipe_tx11_powerdown[1:0])
+   ,.PIPETX11STARTBLOCK(pipe_tx11_start_block)
+   ,.PIPETX11SYNCHEADER(pipe_tx11_sync_header[1:0])
+   ,.PIPETX12CHARISK(pipe_tx12_char_is_k[1:0])
+   ,.PIPETX12COMPLIANCE(pipe_tx12_compliance)
+   ,.PIPETX12DATA(pipe_tx12_data_out[31:0])
+   ,.PIPETX12DATAVALID(pipe_tx12_data_valid)
+   ,.PIPETX12ELECIDLE(pipe_tx12_elec_idle)
+   ,.PIPETX12EQCOEFF(pipe_tx12_eq_coeff[17:0])
+   ,.PIPETX12EQCONTROL(pipe_tx12_eq_control[1:0])
+   ,.PIPETX12EQDEEMPH(pipe_tx12_eq_deemph[5:0])
+   ,.PIPETX12EQDONE(pipe_tx12_eq_done)
+   ,.PIPETX12POWERDOWN(pipe_tx12_powerdown[1:0])
+   ,.PIPETX12STARTBLOCK(pipe_tx12_start_block)
+   ,.PIPETX12SYNCHEADER(pipe_tx12_sync_header[1:0])
+   ,.PIPETX13CHARISK(pipe_tx13_char_is_k[1:0])
+   ,.PIPETX13COMPLIANCE(pipe_tx13_compliance)
+   ,.PIPETX13DATA(pipe_tx13_data_out[31:0])
+   ,.PIPETX13DATAVALID(pipe_tx13_data_valid)
+   ,.PIPETX13ELECIDLE(pipe_tx13_elec_idle)
+   ,.PIPETX13EQCOEFF(pipe_tx13_eq_coeff[17:0])
+   ,.PIPETX13EQCONTROL(pipe_tx13_eq_control[1:0])
+   ,.PIPETX13EQDEEMPH(pipe_tx13_eq_deemph[5:0])
+   ,.PIPETX13EQDONE(pipe_tx13_eq_done)
+   ,.PIPETX13POWERDOWN(pipe_tx13_powerdown[1:0])
+   ,.PIPETX13STARTBLOCK(pipe_tx13_start_block)
+   ,.PIPETX13SYNCHEADER(pipe_tx13_sync_header[1:0])
+   ,.PIPETX14CHARISK(pipe_tx14_char_is_k[1:0])
+   ,.PIPETX14COMPLIANCE(pipe_tx14_compliance)
+   ,.PIPETX14DATA(pipe_tx14_data_out[31:0])
+   ,.PIPETX14DATAVALID(pipe_tx14_data_valid)
+   ,.PIPETX14ELECIDLE(pipe_tx14_elec_idle)
+   ,.PIPETX14EQCOEFF(pipe_tx14_eq_coeff[17:0])
+   ,.PIPETX14EQCONTROL(pipe_tx14_eq_control[1:0])
+   ,.PIPETX14EQDEEMPH(pipe_tx14_eq_deemph[5:0])
+   ,.PIPETX14EQDONE(pipe_tx14_eq_done)
+   ,.PIPETX14POWERDOWN(pipe_tx14_powerdown[1:0])
+   ,.PIPETX14STARTBLOCK(pipe_tx14_start_block)
+   ,.PIPETX14SYNCHEADER(pipe_tx14_sync_header[1:0])
+   ,.PIPETX15CHARISK(pipe_tx15_char_is_k[1:0])
+   ,.PIPETX15COMPLIANCE(pipe_tx15_compliance)
+   ,.PIPETX15DATA(pipe_tx15_data_out[31:0])
+   ,.PIPETX15DATAVALID(pipe_tx15_data_valid)
+   ,.PIPETX15ELECIDLE(pipe_tx15_elec_idle)
+   ,.PIPETX15EQCOEFF(pipe_tx15_eq_coeff[17:0])
+   ,.PIPETX15EQCONTROL(pipe_tx15_eq_control[1:0])
+   ,.PIPETX15EQDEEMPH(pipe_tx15_eq_deemph[5:0])
+   ,.PIPETX15EQDONE(pipe_tx15_eq_done)
+   ,.PIPETX15POWERDOWN(pipe_tx15_powerdown[1:0])
+   ,.PIPETX15STARTBLOCK(pipe_tx15_start_block)
+   ,.PIPETX15SYNCHEADER(pipe_tx15_sync_header[1:0])
+   ,.PIPETXDEEMPH(pipe_tx_deemph)
+   ,.PIPETXMARGIN(pipe_tx_margin[2:0])
+   ,.PIPETXRATE(pipe_tx_rate[1:0])
+   ,.PIPETXRCVRDET(pipe_tx_rcvr_det)
+   ,.PIPETXRESET(pipe_tx_reset)
+   ,.PIPETXSWING(pipe_tx_swing)
+   ,.PLEQINPROGRESS(pl_eq_in_progress)
+   ,.PLEQPHASE(pl_eq_phase[1:0])
+   ,.PLEQRESETEIEOSCOUNT(pl_eq_reset_eieos_count)
+   ,.PLGEN2UPSTREAMPREFERDEEMPH(pl_gen2_upstream_prefer_deemph)
+   ,.PLGEN34EQMISMATCH(pl_gen34_eq_mismatch)
+   ,.PLGEN34REDOEQSPEED(pl_gen34_redo_eq_speed)
+   ,.PLGEN34REDOEQUALIZATION(pl_gen34_redo_equalization)
+   ,.RESETN(reset_n)
+   ,.SAXISCCTDATA(s_axis_cc_tdata_int[255:0])
+   ,.SAXISCCTKEEP(s_axis_cc_tkeep_int[7:0])
+   ,.SAXISCCTLAST(s_axis_cc_tlast_int)
+   ,.SAXISCCTREADY(s_axis_cc_tready_int[3:0])
+   ,.SAXISCCTUSER(s_axis_cc_tuser_int[32:0])
+   ,.SAXISCCTVALID(s_axis_cc_tvalid_int)
+   ,.SAXISRQTDATA(s_axis_rq_tdata_int[255:0])
+   ,.SAXISRQTKEEP(s_axis_rq_tkeep_int[7:0])
+   ,.SAXISRQTLAST(s_axis_rq_tlast_int)
+   ,.SAXISRQTREADY(s_axis_rq_tready_int[3:0])
+   ,.SAXISRQTUSER(s_axis_rq_tuser_int[61:0])
+   ,.SAXISRQTVALID(s_axis_rq_tvalid_int)
+   ,.USERCLK2(user_clk2_to_e4)
+   ,.USERCLKEN(user_clk_en_to_e4)
+   ,.USERCLK(user_clk_to_e4)
+   ,.USERSPAREIN({32{1'b0}})
+   ,.USERSPAREOUT( )
+
+  );
+
+
+  // BlockRAM Module
+
+  xp4_usp_smsw_bram 
+ #(
+   .TCQ(TCQ)
+  ,.AXISTEN_IF_MSIX_TO_RAM_PIPELINE(AXISTEN_IF_MSIX_TO_RAM_PIPELINE)
+  ,.AXISTEN_IF_MSIX_FROM_RAM_PIPELINE(AXISTEN_IF_MSIX_FROM_RAM_PIPELINE)
+  ,.TPH_TO_RAM_PIPELINE(TPH_TO_RAM_PIPELINE)
+  ,.TPH_FROM_RAM_PIPELINE(TPH_FROM_RAM_PIPELINE)
+  ,.TL_COMPLETION_RAM_SIZE(TL_COMPLETION_RAM_SIZE)
+  ,.TL_RX_COMPLETION_TO_RAM_WRITE_PIPELINE(TL_RX_COMPLETION_TO_RAM_WRITE_PIPELINE)
+  ,.TL_RX_COMPLETION_TO_RAM_READ_PIPELINE(TL_RX_COMPLETION_TO_RAM_READ_PIPELINE)
+  ,.TL_RX_COMPLETION_FROM_RAM_READ_PIPELINE(TL_RX_COMPLETION_FROM_RAM_READ_PIPELINE)
+  ,.TL_RX_POSTED_TO_RAM_WRITE_PIPELINE(TL_RX_POSTED_TO_RAM_WRITE_PIPELINE)
+  ,.TL_RX_POSTED_TO_RAM_READ_PIPELINE(TL_RX_POSTED_TO_RAM_READ_PIPELINE)
+  ,.TL_RX_POSTED_FROM_RAM_READ_PIPELINE(TL_RX_POSTED_FROM_RAM_READ_PIPELINE)
+  ,.LL_REPLAY_TO_RAM_PIPELINE(LL_REPLAY_TO_RAM_PIPELINE)
+  ,.LL_REPLAY_FROM_RAM_PIPELINE(LL_REPLAY_FROM_RAM_PIPELINE)
+  ,.TL_PF_ENABLE_REG(TL_PF_ENABLE_REG)
+  ,.SRIOV_CAP_ENABLE(SRIOV_CAP_ENABLE)
+  ,.PF0_SRIOV_CAP_TOTAL_VF(PF0_SRIOV_CAP_TOTAL_VF)
+  ,.PF1_SRIOV_CAP_TOTAL_VF(PF1_SRIOV_CAP_TOTAL_VF)
+  ,.PF2_SRIOV_CAP_TOTAL_VF(PF2_SRIOV_CAP_TOTAL_VF)
+  ,.PF3_SRIOV_CAP_TOTAL_VF(PF3_SRIOV_CAP_TOTAL_VF)
+  ,.PF0_TPHR_CAP_ENABLE(PF0_TPHR_CAP_ENABLE)
+  ,.MSIX_CAP_TABLE_SIZE(MSIX_CAP_TABLE_SIZE)
+  ,.MSIX_TABLE_RAM_ENABLE(MSIX_TABLE_RAM_ENABLE)
+
+
+  ) pcie_4_0_bram_inst (
+
+   .core_clk_i(core_clk)
+  ,.user_clk_i(user_clk) 
+  ,.reset_i(!reset_n)
+//  ,.core_reset_i(!core_reset_n)
+  ,.mi_rep_addr_i(mi_replay_ram_address0[8:0])
+  ,.mi_rep_wdata_i({mi_replay_ram_write_data1[127:0],mi_replay_ram_write_data0[127:0]})
+  ,.mi_rep_wen_i(mi_replay_ram_write_enable0)
+  ,.mi_rep_rdata_o({mi_replay_ram_read_data1[127:0],mi_replay_ram_read_data0[127:0]})
+  ,.mi_rep_rden_i(mi_replay_ram_read_enable0)
+  ,.mi_rep_err_cor_o(mi_replay_ram_err_cor[3:0])
+  ,.mi_rep_err_uncor_o(mi_replay_ram_err_uncor[3:0])
+  ,.mi_req_waddr0_i(mi_rx_posted_request_ram_write_address0[8:0])
+  ,.mi_req_wdata0_i(mi_rx_posted_request_ram_write_data0[143:0])
+  ,.mi_req_wen0_i(mi_rx_posted_request_ram_write_enable0)
+  ,.mi_req_waddr1_i(mi_rx_posted_request_ram_write_address1[8:0])
+  ,.mi_req_wdata1_i(mi_rx_posted_request_ram_write_data1[143:0])
+  ,.mi_req_wen1_i(mi_rx_posted_request_ram_write_enable1)
+  ,.mi_req_raddr0_i(mi_rx_posted_request_ram_read_address0[8:0])
+  ,.mi_req_rdata0_o(mi_rx_posted_request_ram_read_data0[143:0])
+  ,.mi_req_ren0_i(mi_rx_posted_request_ram_read_enable0)
+  ,.mi_req_raddr1_i(mi_rx_posted_request_ram_read_address1[8:0])
+  ,.mi_req_rdata1_o(mi_rx_posted_request_ram_read_data1[143:0])
+  ,.mi_req_ren1_i(mi_rx_posted_request_ram_read_enable1)
+  ,.mi_req_err_cor_o(mi_rx_posted_request_ram_err_cor[5:0])
+  ,.mi_req_err_uncor_o(mi_rx_posted_request_ram_err_uncor[5:0])
+  ,.mi_cpl_waddr0_i(mi_rx_completion_ram_write_address0[8:0])
+  ,.mi_cpl_wdata0_i(mi_rx_completion_ram_write_data0[143:0])
+  ,.mi_cpl_wen0_i(mi_rx_completion_ram_write_enable0[1:0])
+  ,.mi_cpl_waddr1_i(mi_rx_completion_ram_write_address1[8:0])
+  ,.mi_cpl_wdata1_i(mi_rx_completion_ram_write_data1[143:0])
+  ,.mi_cpl_wen1_i(mi_rx_completion_ram_write_enable1[1:0])
+  ,.mi_cpl_raddr0_i(mi_rx_completion_ram_read_address0[8:0])
+  ,.mi_cpl_rdata0_o(mi_rx_completion_ram_read_data0[143:0])
+  ,.mi_cpl_ren0_i(mi_rx_completion_ram_read_enable0[1:0])
+  ,.mi_cpl_raddr1_i(mi_rx_completion_ram_read_address1[8:0])
+  ,.mi_cpl_rdata1_o(mi_rx_completion_ram_read_data1[143:0])
+  ,.mi_cpl_ren1_i(mi_rx_completion_ram_read_enable1[1:0])
+  ,.mi_cpl_err_cor_o(mi_rx_completion_ram_err_cor[11:0])
+  ,.mi_cpl_err_uncor_o(mi_rx_completion_ram_err_uncor[11:0])
+  ,.cfg_msix_waddr_i(cfg_msix_ram_address[12:0])
+  ,.cfg_msix_wdata_i(cfg_msix_ram_write_data[31:0])
+  ,.cfg_msix_wdip_i(cfg_msix_ram_write_data[35:32])
+  ,.cfg_msix_wen_i(cfg_msix_ram_write_byte_enable[3:0])
+  ,.cfg_msix_rdata_o(cfg_msix_ram_read_data[31:0])
+  ,.cfg_msix_rdop_o(cfg_msix_ram_read_data[35:32])
+  ,.cfg_msix_ren_i(cfg_msix_ram_read_enable)
+  ,.user_tph_stt_func_num_i(user_tph_stt_func_num[7:0])
+  ,.user_tph_stt_index_i(user_tph_stt_index[5:0])
+  ,.user_tph_stt_rd_en_i(user_tph_stt_rd_en)
+  ,.user_tph_stt_rd_data_o(user_tph_stt_rd_data[7:0])
+  ,.cfg_tph_waddr_i(cfg_tph_ram_address[11:0])
+  ,.cfg_tph_wdata_i(cfg_tph_ram_write_data[31:0])
+  ,.cfg_tph_wdip_i(cfg_tph_ram_write_data[35:32])
+  ,.cfg_tph_wen_i(cfg_tph_ram_write_byte_enable[3:0])
+  ,.cfg_tph_rdata_o(cfg_tph_ram_read_data[31:0])
+  ,.cfg_tph_rdop_o(cfg_tph_ram_read_data[35:32])
+  ,.cfg_tph_ren_i(cfg_tph_ram_read_enable)
+
+  );
+
+  assign mi_replay_ram_err_cor[5:4] = 2'b00;
+  assign mi_replay_ram_err_uncor[5:4] = 2'b00;
+
+  // Initialization Controller Module
+
+  xp4_usp_smsw_model_init_ctrl
+ #(
+    .TCQ(TCQ)
+   ,.PL_UPSTREAM_FACING(PL_UPSTREAM_FACING)
+   ,.IS_SWITCH_PORT(IS_SWITCH_PORT)
+   ,.CRM_CORE_CLK_FREQ_500(CRM_CORE_CLK_FREQ_500)
+   ,.CRM_USER_CLK_FREQ(CRM_USER_CLK_FREQ)
+
+  ) pcie_4_0_init_ctrl_inst ( 
+
+    .core_clk_i (core_clk)
+   ,.user_clk_i (user_clk)
+   ,.reset_n_o (reset_n)
+   ,.core_reset_n_o (core_reset_n)
+   ,.pipe_reset_n_o (pipe_reset_n)
+   ,.mgmt_reset_n_o (mgmt_reset_n)
+   ,.mgmt_sticky_reset_n_o (mgmt_sticky_reset_n)
+   ,.phy_rdy_i (phy_rdy)
+   ,.cfg_hot_reset_in_i(cfg_hot_reset_in)
+   ,.cfg_phy_link_down_i(cfg_phy_link_down_wire)
+   ,.cfg_phy_link_down_user_clk_o(cfg_phy_link_down_user_clk)
+   ,.state_o ()
+   ,.user_clk_en_o(user_clk_en)
+   ,.user_clkgate_en_o(user_clkgate_en)
+
+  );
+
+  // VF Decode Module
+  
+  xp4_usp_smsw_vf_decode
+ #(
+    .TCQ(TCQ)
+   ,.TL_PF_ENABLE_REG(TL_PF_ENABLE_REG)
+   ,.PF0_SRIOV_CAP_TOTAL_VF(PF0_SRIOV_CAP_TOTAL_VF)
+   ,.PF1_SRIOV_CAP_TOTAL_VF(PF1_SRIOV_CAP_TOTAL_VF)
+   ,.PF2_SRIOV_CAP_TOTAL_VF(PF2_SRIOV_CAP_TOTAL_VF)
+   ,.PF3_SRIOV_CAP_TOTAL_VF(PF3_SRIOV_CAP_TOTAL_VF)
+   ,.PF0_SRIOV_FIRST_VF_OFFSET(PF0_SRIOV_FIRST_VF_OFFSET)
+   ,.PF1_SRIOV_FIRST_VF_OFFSET(PF1_SRIOV_FIRST_VF_OFFSET)
+   ,.PF2_SRIOV_FIRST_VF_OFFSET(PF2_SRIOV_FIRST_VF_OFFSET)
+   ,.PF3_SRIOV_FIRST_VF_OFFSET(PF3_SRIOV_FIRST_VF_OFFSET)
+   ,.SRIOV_CAP_ENABLE(SRIOV_CAP_ENABLE)
+   ,.ARI_CAP_ENABLE(ARI_CAP_ENABLE)
+
+  ) pcie_4_0_vf_decode_inst (
+
+     .clk_i(user_clk)
+    ,.reset_i(!reset_n)
+    ,.link_down_i(cfg_phy_link_down_user_clk)
+    ,.cfg_ext_write_received_i(cfg_ext_write_received)
+    ,.cfg_ext_register_number_i(cfg_ext_register_number[9:0])
+    ,.cfg_ext_function_number_i(cfg_ext_function_number[7:0])
+    ,.cfg_ext_write_data_i(cfg_ext_write_data[31:0])
+    ,.cfg_ext_write_byte_enable_i(cfg_ext_write_byte_enable[3:0])
+    ,.cfg_flr_in_process_i(cfg_flr_in_process[3:0])
+
+    ,.cfg_vf_flr_in_process_o(cfg_vf_flr_in_process[251:0])
+    ,.cfg_vf_status_o(cfg_vf_status[503:0])
+    ,.cfg_vf_power_state_o(cfg_vf_power_state[755:0])
+    ,.cfg_vf_tph_requester_enable_o(cfg_vf_tph_requester_enable[251:0])
+    ,.cfg_vf_tph_st_mode_o(cfg_vf_tph_st_mode[755:0])
+    ,.cfg_interrupt_msix_vf_enable_o(cfg_interrupt_msix_vf_enable[251:0])
+    ,.cfg_interrupt_msix_vf_mask_o(cfg_interrupt_msix_vf_mask[251:0])
+
+  );
+
+  // PL EQ Interface Module
+
+  xp4_usp_smsw_pl_eq
+ #(
+     .TCQ(TCQ)
+    ,.IMPL_TARGET(IMPL_TARGET)
+    ,.PL_UPSTREAM_FACING(PL_UPSTREAM_FACING)
+
+  ) pcie_4_0_pl_eq_inst (
+
+     .clk_i(user_clk)
+    ,.reset_i(!reset_n)
+    ,.link_down_reset_i(cfg_phy_link_down_user_clk)
+
+    ,.cfg_ltssm_state_i(cfg_ltssm_state[5:0])     
+    ,.pl_redo_eq_i(pl_redo_eq)
+    ,.pl_redo_eq_speed_i(pl_redo_eq_speed)
+    ,.pl_eq_mismatch_o(pl_eq_mismatch)
+    ,.pl_redo_eq_pending_o(pl_redo_eq_pending)
+    ,.pl_gen34_redo_equalization_o(pl_gen34_redo_equalization)
+    ,.pl_gen34_redo_eq_speed_o(pl_gen34_redo_eq_speed)
+    ,.pl_gen34_eq_mismatch_i(pl_gen34_eq_mismatch)
+
+  );
+
+  // AXI4ST 256b/512b Bridge Module
+  xp4_usp_smsw_512b_intfc
+ #(
+        .TCQ(TCQ),
+        .IMPL_TARGET(IMPL_TARGET),
+        .AXISTEN_IF_EXT_512_INTFC_RAM_STYLE(AXISTEN_IF_EXT_512_INTFC_RAM_STYLE),
+        .AXI4_USER_DATA_WIDTH(AXI4_DATA_WIDTH),
+        .AXI4_CORE_DATA_WIDTH(256),
+        .AXI4_USER_CQ_TUSER_WIDTH(AXI4_CQ_TUSER_WIDTH),
+        .AXI4_USER_CC_TUSER_WIDTH(AXI4_CC_TUSER_WIDTH),
+        .AXI4_USER_RQ_TUSER_WIDTH(AXI4_RQ_TUSER_WIDTH),
+        .AXI4_USER_RC_TUSER_WIDTH(AXI4_RC_TUSER_WIDTH),
+        .AXI4_CORE_CQ_TUSER_WIDTH(88),
+        .AXI4_CORE_CC_TUSER_WIDTH(33),
+        .AXI4_CORE_RQ_TUSER_WIDTH(62),
+        .AXI4_CORE_RC_TUSER_WIDTH(75),
+        .AXI4_USER_CQ_TKEEP_WIDTH(AXI4_TKEEP_WIDTH),
+        .AXI4_USER_CC_TKEEP_WIDTH(AXI4_TKEEP_WIDTH),
+        .AXI4_USER_RQ_TKEEP_WIDTH(AXI4_TKEEP_WIDTH),
+        .AXI4_USER_RC_TKEEP_WIDTH(AXI4_TKEEP_WIDTH),
+        .AXI4_CORE_CQ_TKEEP_WIDTH(8),
+        .AXI4_CORE_CC_TKEEP_WIDTH(8),
+        .AXI4_CORE_RQ_TKEEP_WIDTH(8),
+        .AXI4_CORE_RC_TKEEP_WIDTH(8),
+        .AXI4_CORE_CQ_TREADY_WIDTH(22),
+        .AXI4_CORE_RC_TREADY_WIDTH(22),
+
+        .AXISTEN_IF_EXT_512_CQ_STRADDLE(AXISTEN_IF_EXT_512_CQ_STRADDLE),
+        .AXISTEN_IF_EXT_512_CC_STRADDLE(AXISTEN_IF_EXT_512_CC_STRADDLE),
+        .AXISTEN_IF_EXT_512_RQ_STRADDLE(AXISTEN_IF_EXT_512_RQ_STRADDLE),
+        .AXISTEN_IF_EXT_512_RC_STRADDLE(AXISTEN_IF_EXT_512_RC_STRADDLE),
+        .AXISTEN_IF_EXT_512_RC_4TLP_STRADDLE(AXISTEN_IF_EXT_512_RC_4TLP_STRADDLE),
+        .AXISTEN_IF_CQ_ALIGNMENT_MODE(AXISTEN_IF_CQ_ALIGNMENT_MODE),
+        .AXISTEN_IF_CC_ALIGNMENT_MODE(AXISTEN_IF_CC_ALIGNMENT_MODE),
+        .AXISTEN_IF_RQ_ALIGNMENT_MODE(AXISTEN_IF_RQ_ALIGNMENT_MODE),
+        .AXISTEN_IF_RC_ALIGNMENT_MODE(AXISTEN_IF_RC_ALIGNMENT_MODE),
+        .AXISTEN_IF_RQ_CC_REGISTERED_TREADY(AXISTEN_IF_RQ_CC_REGISTERED_TREADY),
+        .AXISTEN_IF_RX_PARITY_EN(AXISTEN_IF_RX_PARITY_EN),
+        .AXISTEN_IF_TX_PARITY_EN(AXISTEN_IF_TX_PARITY_EN)
+
+     ) pcie4_0_512b_intfc_mod (
+
+        .user_clk_i         (user_clk),
+        .user_clk2_i        (user_clk2),
+        .user_clk_en_i      (user_clk_en),
+        .reset_n_user_clk_i (reset_n),
+        .reset_n_user_clk2_i(core_reset_n),
+        .link_down_reset_i  (cfg_phy_link_down_user_clk),
+   //     .conf_mcap_design_switch_i(conf_mcap_design_switch),
+        //-----------------------------------
+        // Client-side signals
+        //-----------------------------------
+        // CQ Interface
+        .m_axis_cq_tdata_o  (m_axis_cq_tdata),
+        .m_axis_cq_tvalid_o (m_axis_cq_tvalid),
+        .m_axis_cq_tuser_o  (m_axis_cq_tuser),
+        .m_axis_cq_tlast_o  (m_axis_cq_tlast),
+        .m_axis_cq_tkeep_o  (m_axis_cq_tkeep),
+        .m_axis_cq_tready_i (m_axis_cq_tready[0]),
+        .pcie_cq_np_req_i   (pcie_cq_np_req),
+        .pcie_cq_np_req_count_o(pcie_cq_np_req_count_axi512),
+        // CC Interface
+        .s_axis_cc_tdata_i  (s_axis_cc_tdata),
+        .s_axis_cc_tvalid_i (s_axis_cc_tvalid),
+        .s_axis_cc_tuser_i  (s_axis_cc_tuser),
+        .s_axis_cc_tlast_i  (s_axis_cc_tlast),
+        .s_axis_cc_tkeep_i  (s_axis_cc_tkeep),
+        .s_axis_cc_tready_o (s_axis_cc_tready_axi512),
+        // RQ Interface
+        .s_axis_rq_tdata_i  (s_axis_rq_tdata),
+        .s_axis_rq_tvalid_i (s_axis_rq_tvalid),
+        .s_axis_rq_tuser_i  (s_axis_rq_tuser),
+        .s_axis_rq_tlast_i  (s_axis_rq_tlast),
+        .s_axis_rq_tkeep_i  (s_axis_rq_tkeep),
+        .s_axis_rq_tready_o (s_axis_rq_tready_axi512),
+        // RC Interface
+        .m_axis_rc_tdata_o  (m_axis_rc_tdata),
+        .m_axis_rc_tvalid_o (m_axis_rc_tvalid),
+        .m_axis_rc_tuser_o  (m_axis_rc_tuser),
+        .m_axis_rc_tlast_o  (m_axis_rc_tlast),
+        .m_axis_rc_tkeep_o  (m_axis_rc_tkeep),
+        .m_axis_rc_tready_i (m_axis_rc_tready[0]),
+        //-----------------------------------
+        // Core-side signals
+        //-----------------------------------
+        // CQ Interface
+        .core_cq_tdata_i    (m_axis_cq_tdata_int),
+        .core_cq_tvalid_i   (m_axis_cq_tvalid_int),
+        .core_cq_tuser_i    (m_axis_cq_tuser_int),
+        .core_cq_tlast_i    (m_axis_cq_tlast_int),
+        .core_cq_tkeep_i    (m_axis_cq_tkeep_int),
+        .core_cq_tready_o   (m_axis_cq_tready_axi512),
+        .posted_req_delivered_o(pcie_posted_req_delivered),
+        .cq_pipeline_empty_o(pcie_cq_pipeline_empty),
+        .cq_np_user_credit_rcvd_o(pcie_cq_np_user_credit_rcvd),
+        // CC Interface
+        .core_cc_tdata_o    (s_axis_cc_tdata_axi512),
+        .core_cc_tvalid_o   (s_axis_cc_tvalid_axi512),
+        .core_cc_tuser_o    (s_axis_cc_tuser_axi512),
+        .core_cc_tlast_o    (s_axis_cc_tlast_axi512),
+        .core_cc_tkeep_o    (s_axis_cc_tkeep_axi512),
+        .core_cc_tready_i   (s_axis_cc_tready_int),
+        // RQ Interface
+        .core_rq_tdata_o    (s_axis_rq_tdata_axi512),
+        .core_rq_tvalid_o   (s_axis_rq_tvalid_axi512),
+        .core_rq_tuser_o    (s_axis_rq_tuser_axi512),
+        .core_rq_tlast_o    (s_axis_rq_tlast_axi512),
+        .core_rq_tkeep_o    (s_axis_rq_tkeep_axi512),
+        .core_rq_tready_i   (s_axis_rq_tready_int),
+        // RC Interface
+        .core_rc_tdata_i    (m_axis_rc_tdata_int),
+        .core_rc_tvalid_i   (m_axis_rc_tvalid_int),
+        .core_rc_tuser_i    (m_axis_rc_tuser_int),
+        .core_rc_tlast_i    (m_axis_rc_tlast_int),
+        .core_rc_tkeep_i    (m_axis_rc_tkeep_int),
+        .core_rc_tready_o   (m_axis_rc_tready_axi512),
+        .compl_delivered_o  (pcie_compl_delivered),
+        .compl_delivered_tag0_o(pcie_compl_delivered_tag0),
+        .compl_delivered_tag1_o(pcie_compl_delivered_tag1)
+        );
+
+      assign s_axis_cc_tdata_int = s_axis_cc_tdata_axi512;
+      assign s_axis_cc_tvalid_int = s_axis_cc_tvalid_axi512;
+      assign s_axis_cc_tuser_int = s_axis_cc_tuser_axi512;
+      assign s_axis_cc_tlast_int = s_axis_cc_tlast_axi512;
+      assign s_axis_cc_tkeep_int = s_axis_cc_tkeep_axi512;
+      
+      assign s_axis_rq_tdata_int = s_axis_rq_tdata_axi512;
+      assign s_axis_rq_tvalid_int = s_axis_rq_tvalid_axi512;
+      assign s_axis_rq_tuser_int = s_axis_rq_tuser_axi512;
+      assign s_axis_rq_tlast_int = s_axis_rq_tlast_axi512;
+      assign s_axis_rq_tkeep_int = s_axis_rq_tkeep_axi512;
+
+   assign m_axis_cq_tready_int[21:0] = (AXISTEN_IF_EXT_512 == "TRUE") ? 
+                                                           m_axis_cq_tready_axi512 :
+                                                           m_axis_cq_tready;
+
+   assign m_axis_rc_tready_int[21:0] = (AXISTEN_IF_EXT_512 == "TRUE") ? 
+                                                           m_axis_rc_tready_axi512 :
+                                                           m_axis_rc_tready;
+
+   assign s_axis_cc_tready = (AXISTEN_IF_EXT_512 == "TRUE") ? {4{s_axis_cc_tready_axi512}} :
+                                                              s_axis_cc_tready_int;
+
+   assign s_axis_rq_tready = (AXISTEN_IF_EXT_512 == "TRUE") ? {4{s_axis_rq_tready_axi512}} :
+                                                              s_axis_rq_tready_int;
+
+   assign pcie_cq_np_req_count = (AXISTEN_IF_EXT_512 == "TRUE") ? pcie_cq_np_req_count_axi512:
+                                                                  pcie_cq_np_req_count_int;
+
+
+
+  generate if ((TL_USER_SPARE[1]) ||
+               ((CRM_CORE_CLK_FREQ_500 == "TRUE") && (CRM_USER_CLK_FREQ[1:0] == 2'b11)) ||
+               ((CRM_CORE_CLK_FREQ_500 == "FALSE") && (CRM_USER_CLK_FREQ[1:0] == 2'b10))) begin: seqnum_fifo_bypass
+  
+    assign pcie_rq_seq_num0[5:0] = pcie_rq_seq_num0_cc[5:0];
+    assign pcie_rq_seq_num_vld0 = pcie_rq_seq_num_vld0_cc;
+  
+  end else begin: seqnum_fifo
+  
+     //
+     // Sequence Number FIFOs
+     //
+
+  xp4_usp_smsw_seqnum_fifo #(
+     .RAM_WIDTH(7), 
+     .RAM_DEPTH(16), 
+     .FIFO_FULL_HIGH_THRESHOLD(16),
+     .ADDR_WIDTH(4)
+   ) seq_fifo_0 (
+     .core_reset_n_i(reset_n),
+     .core_clk_i(core_clk),
+     .user_reset_n_i(reset_n),
+     .user_clk_i(user_clk),
+     .data_i({pcie_rq_seq_num_vld0_cc, pcie_rq_seq_num0_cc[5:0]}),
+     .data_o({pcie_rq_seq_num_vld0, pcie_rq_seq_num0[5:0]})
+   );
+
+  end
+  endgenerate
+
+// WIP shared with m_axis_ccix_rx_tdata
+assign m_axis_ccix_rx_tdata_int = dbg_data1_out;
+
+  // CCIX RX soft FIFO
+xp4_usp_smsw_model_tl_rx_ccix_fifo #
+  (
+   .ADDRESS_WIDTH(9),
+   .RAM_WORD_COUNT(512),
+   .MAX_TLP_COUNT(32),
+   .MAX_TLP_COUNT_BITS(6),
+   .TCQ(TCQ),
+   .IMPL_TARGET("SOFT")
+   ) 
+  tl_rx_ccix_fifo_mod
+  (
+   .user_clk_ccix_i(core_clk),
+   .reset_n_ccix_i(core_reset_n),
+   .link_down_reset_i(cfg_phy_link_down_wire),
+   // Attributes
+   .attr_ccix_direct_attach_mode_i(ccix_optimized_tlp_tx_and_rx_enable),
+   .attr_tl_rx_ccix_fifo_ram_size_i(1'b1),
+   .attr_tl_rx_ccix_fifo_to_ram_write_pipeline_i(1'b0),
+   .attr_tl_rx_ccix_fifo_to_ram_read_pipeline_i(1'b0),
+   .attr_tl_rx_ccix_fifo_from_ram_read_pipeline_i(1'b0),
+   .attr_test_mode_pin_char_i(1'b0),
+   // Data from TL
+   .s_axis_ccix_rx_tdata_i(m_axis_ccix_rx_tdata_int),
+   .s_axis_ccix_rx_tvalid_i(m_axis_ccix_rx_tvalid_int),
+   .s_axis_ccix_rx_tuser_i(m_axis_ccix_rx_tuser_int[44:0]),
+   // Status outputs from CCIX RX FIFO to TL
+   .ccix_rx_tlp_forwarded0_o(ccix_rx_tlp_forwarded0_int),
+   .ccix_rx_tlp_forwarded_length0_o(ccix_rx_tlp_forwarded_length0_int),
+   .ccix_rx_tlp_forwarded1_o(ccix_rx_tlp_forwarded1_int),
+   .ccix_rx_tlp_forwarded_length1_o(ccix_rx_tlp_forwarded_length1_int[0]),
+   .ccix_rx_fifo_overflow_o(ccix_rx_fifo_overflow_int),
+   .ccix_rx_correctable_error_detected_o(ccix_rx_correctable_error_detected_int),
+   .ccix_rx_uncorrectable_error_detected_o(ccix_rx_uncorrectable_error_detected_int),
+   // Data to CCIX protocol processing block
+   .m_axis_ccix_rx_tdata_o(m_axis_ccix_rx_tdata), // 256-bit data
+   .m_axis_ccix_rx_tvalid_o(m_axis_ccix_rx_tvalid),
+   .m_axis_ccix_rx_tuser_o(m_axis_ccix_rx_tuser), // tuser bus
+   .ccix_rx_credit_i(ccix_rx_credit),
+   .ccix_rx_credit_av_o(ccix_rx_credit_av),
+   // RAM interface
+   .mi_rx_ccix_fifo_ram_write_address0_o(mi_rx_ccix_fifo_ram_write_address0),
+   .mi_rx_ccix_fifo_ram_write_data0_o(mi_rx_ccix_fifo_ram_write_data0),
+   .mi_rx_ccix_fifo_ram_write_enable0_o(mi_rx_ccix_fifo_ram_write_enable0),
+   .mi_rx_ccix_fifo_ram_write_address1_o(mi_rx_ccix_fifo_ram_write_address1),
+   .mi_rx_ccix_fifo_ram_write_data1_o(mi_rx_ccix_fifo_ram_write_data1),
+   .mi_rx_ccix_fifo_ram_write_enable1_o(mi_rx_ccix_fifo_ram_write_enable1),
+   .mi_rx_ccix_fifo_ram_read_address0_o(mi_rx_ccix_fifo_ram_read_address0),
+   .mi_rx_ccix_fifo_ram_read_data0_i(mi_rx_ccix_fifo_ram_read_data0),
+   .mi_rx_ccix_fifo_ram_read_enable0_o(mi_rx_ccix_fifo_ram_read_enable0),
+   .mi_rx_ccix_fifo_ram_read_address1_o(mi_rx_ccix_fifo_ram_read_address1),
+   .mi_rx_ccix_fifo_ram_read_data1_i(mi_rx_ccix_fifo_ram_read_data1),
+   .mi_rx_ccix_fifo_ram_read_enable1_o(mi_rx_ccix_fifo_ram_read_enable1),
+   .mi_rx_ccix_fifo_ram_err_cor_i(mi_rx_ccix_fifo_ram_err_cor),
+   .mi_rx_ccix_fifo_ram_err_uncor_i(mi_rx_ccix_fifo_ram_err_uncor)
+   );
+  
+  // BRAM for CCIX RX FIFO
+
+xp4_usp_smsw_model_ccix_rx_fifo_bram #
+  (
+   .TCQ(TCQ),
+// FIXME: define attributes and connect to the top level
+   .TL_RX_CCIX_FIFO_TO_RAM_WRITE_PIPELINE("FALSE"),
+   .TL_RX_CCIX_FIFO_TO_RAM_READ_PIPELINE("FALSE"),
+   .TL_RX_CCIX_FIFO_FROM_RAM_READ_PIPELINE("FALSE")
+   )
+  ccix_rx_fifo_bram_mod
+    (
+     .user_clk_ccix_i(core_clk),
+     .reset_n_ccix_i(core_reset_n),
+
+     .mi_req_waddr0_i(mi_rx_ccix_fifo_ram_write_address0),
+     .mi_req_wdata0_i(mi_rx_ccix_fifo_ram_write_data0),
+     .mi_req_wen0_i(mi_rx_ccix_fifo_ram_write_enable0),
+     .mi_req_waddr1_i(mi_rx_ccix_fifo_ram_write_address1),
+     .mi_req_wdata1_i(mi_rx_ccix_fifo_ram_write_data1),
+     .mi_req_wen1_i(mi_rx_ccix_fifo_ram_write_enable1),
+
+     .mi_req_raddr0_i(mi_rx_ccix_fifo_ram_read_address0),
+     .mi_req_ren0_i(mi_rx_ccix_fifo_ram_read_enable0),
+     .mi_req_rdata0_o(mi_rx_ccix_fifo_ram_read_data0),
+     .mi_req_raddr1_i(mi_rx_ccix_fifo_ram_read_address1),
+     .mi_req_ren1_i(mi_rx_ccix_fifo_ram_read_enable1),
+     .mi_req_rdata1_o(mi_rx_ccix_fifo_ram_read_data1),
+
+     .mi_req_err_cor_o(mi_rx_ccix_fifo_ram_err_cor),
+     .mi_req_err_uncor_o(mi_rx_ccix_fifo_ram_err_uncor)
+     );
+
+endmodule
+
+//--------------------------------------------------------------------------------------------------
+
+module xp4_usp_smsw_model_ccix_rx_fifo_bram #(
+
+  parameter           TCQ = 100
+, parameter           TL_RX_CCIX_FIFO_TO_RAM_WRITE_PIPELINE="FALSE"
+, parameter           TL_RX_CCIX_FIFO_TO_RAM_READ_PIPELINE="FALSE"
+, parameter           TL_RX_CCIX_FIFO_FROM_RAM_READ_PIPELINE="FALSE"
+  ) (
+     input  wire           user_clk_ccix_i,
+     input  wire          reset_n_ccix_i,
+
+     input  wire   [8:0]   mi_req_waddr0_i,
+     input  wire [143:0]   mi_req_wdata0_i,
+     input  wire           mi_req_wen0_i,
+     input  wire   [8:0]   mi_req_waddr1_i,
+     input  wire [143:0]   mi_req_wdata1_i,
+     input  wire           mi_req_wen1_i,
+
+     input  wire   [8:0]   mi_req_raddr0_i,
+     input  wire           mi_req_ren0_i,
+     output wire [143:0]   mi_req_rdata0_o,
+     input  wire   [8:0]   mi_req_raddr1_i,
+     input  wire           mi_req_ren1_i,
+     output wire [143:0]   mi_req_rdata1_o,
+
+     output wire   [5:0]   mi_req_err_cor_o,
+     output wire   [5:0]   mi_req_err_uncor_o
+     );
+
+  xp4_usp_smsw_bram_16k #
+    (
+    .TCQ (TCQ),
+    .TO_RAM_WRITE_PIPELINE(TL_RX_CCIX_FIFO_TO_RAM_WRITE_PIPELINE),
+    .TO_RAM_READ_PIPELINE(TL_RX_CCIX_FIFO_TO_RAM_READ_PIPELINE),
+    .FROM_RAM_READ_PIPELINE(TL_RX_CCIX_FIFO_FROM_RAM_READ_PIPELINE)
+     )
+  bram_post_inst 
+    (
+     .clk_i(user_clk_ccix_i),
+     .reset_i(reset_n_ccix_i),
+
+    .waddr0_i(mi_req_waddr0_i[8:0]),
+    .wdata0_i(mi_req_wdata0_i[143:0]),
+    .wen0_i(mi_req_wen0_i),
+    .waddr1_i(mi_req_waddr1_i[8:0]),
+    .wdata1_i(mi_req_wdata1_i[143:0]),
+    .wen1_i(mi_req_wen1_i),
+    .raddr0_i(mi_req_raddr0_i[8:0]),
+    .rdata0_o(mi_req_rdata0_o[143:0]),
+    .ren0_i(mi_req_ren0_i),
+    .raddr1_i(mi_req_raddr1_i[8:0]),
+    .rdata1_o(mi_req_rdata1_o[143:0]),
+    .ren1_i(mi_req_ren1_i),
+    .err_cor_o(mi_req_err_cor_o[5:0]),
+    .err_uncor_o(mi_req_err_uncor_o[5:0])
+  );
+
+endmodule
+
+//--------------------------------------------------------------------------------------------------
+`timescale 1ps/1ps
+
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_pl_eq #(
+    parameter             TCQ = 100
+   ,parameter             IMPL_TARGET = "SOFT"
+   ,parameter             PL_UPSTREAM_FACING="TRUE"
+  ) (
+   
+    input  wire           clk_i
+   ,input  wire           reset_i
+   ,input  wire           link_down_reset_i
+
+   ,input  wire [5:0]     cfg_ltssm_state_i
+   ,input  wire           pl_redo_eq_i
+   ,input  wire           pl_redo_eq_speed_i
+   ,output reg            pl_eq_mismatch_o
+   ,output reg            pl_redo_eq_pending_o
+   
+   ,output wire           pl_gen34_redo_equalization_o
+   ,output wire           pl_gen34_redo_eq_speed_o
+   ,input  wire           pl_gen34_eq_mismatch_i
+   );
+
+   reg                    pl_eq_mismatch_w;
+   reg                    pl_redo_eq_pending_w;
+
+   generate  
+  
+     if (PL_UPSTREAM_FACING == "TRUE") begin 
+
+       always @(*) begin
+
+         pl_eq_mismatch_w = pl_eq_mismatch_o;
+         pl_redo_eq_pending_w = pl_redo_eq_pending_o;
+    
+         if (!pl_eq_mismatch_o && (cfg_ltssm_state_i[5:0] == 6'h0B) && pl_gen34_eq_mismatch_i) begin
+    
+           pl_eq_mismatch_w = 1'b1;
+    
+         end else if (!pl_redo_eq_pending_o && (cfg_ltssm_state_i[5:0] == 6'h0D) && pl_gen34_eq_mismatch_i) begin
+    
+           pl_redo_eq_pending_w = 1'b1;
+      
+         end else if (pl_redo_eq_pending_o && pl_redo_eq_i) begin
+    
+           pl_redo_eq_pending_w = 1'b0;
+    
+         end
+    
+       end
+
+     end else begin // PL_UPSTREAM_FACING == FALSE
+ 
+       always @(*) begin
+
+         pl_eq_mismatch_w = pl_gen34_eq_mismatch_i;
+         pl_redo_eq_pending_w = 1'b0;
+
+       end
+
+     end
+
+   endgenerate
+   
+   always @(posedge clk_i) begin
+
+     if (reset_i) begin
+
+       pl_eq_mismatch_o <= #(TCQ) 1'b0;
+       pl_redo_eq_pending_o <= #(TCQ) 1'b0;
+
+     end else if (link_down_reset_i) begin   
+
+       pl_eq_mismatch_o <= #(TCQ) 1'b0;
+       pl_redo_eq_pending_o <= #(TCQ) 1'b0;
+
+     end else begin
+     
+       pl_eq_mismatch_o <= #(TCQ) pl_eq_mismatch_w;
+       pl_redo_eq_pending_o <= #(TCQ) pl_redo_eq_pending_w;
+
+     end
+
+   end
+
+   assign pl_gen34_redo_equalization_o = pl_redo_eq_i;
+   assign pl_gen34_redo_eq_speed_o = pl_redo_eq_speed_i;
+
+endmodule // pcie_4_0_pl_eq
+
+
+`timescale 1ps/1ps
+
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_seqnum_fifo #(
+
+  // Parameters
+
+  parameter            TCQ                               = 1,
+  parameter 		       RAM_WIDTH                         = 6,
+  parameter 		       RAM_DEPTH                         = 4,
+  parameter 		       ADDR_WIDTH                        = 2,
+  parameter 		       FIFO_FULL_HIGH_THRESHOLD          = 3'd4,
+  parameter 		       FIFO_FULL_LOW_THRESHOLD           = 3'd1,
+
+  parameter 		       IN_FSM_SIZE                       = 2,
+  parameter 		       IN_FSM_IDLE                       = 2'b01,
+  parameter 		       IN_FSM_CHANGE                     = 2'b10,
+  parameter            NO_UPDATE_PREV_DATA_ON_FIFO_FULL  = 1'b0
+  )
+  (
+  input 	                    core_reset_n_i,
+  input                       core_clk_i,
+
+  input                       user_reset_n_i,
+  input                       user_clk_i,
+
+  input  [(RAM_WIDTH-1):0]    data_i, 
+  output [(RAM_WIDTH-1):0]    data_o
+
+  );  
+
+
+  // Local Registers
+
+  reg [RAM_WIDTH-1:0] 	       reg_ram[RAM_DEPTH-1:0];
+
+  integer                      index;
+  reg [ADDR_WIDTH:0] 	       write_addr;
+  reg [ADDR_WIDTH:0] 	       write_addr_read_clk;
+  reg [ADDR_WIDTH:0] 	       read_addr;
+  reg [ADDR_WIDTH:0] 	       read_addr_wrclk;
+  reg 			       fifo_full;
+
+  reg [(IN_FSM_SIZE-1):0]      reg_in_fsm_state /* synthesis syn_state_machine=1 */;
+  reg [(IN_FSM_SIZE-1):0]      reg_in_fsm_next_state;
+
+  reg [(RAM_WIDTH-1):0]        reg_prev_data;
+  reg [(RAM_WIDTH-1):0]        reg_out_data;
+
+  reg [(RAM_WIDTH-1):0]        data_int;
+
+  // Local wires
+
+  wire [ADDR_WIDTH:0] 	       write_addr_next;
+  wire [ADDR_WIDTH:0] 	       read_addr_next;
+  wire [ADDR_WIDTH:0] 	       read_side_occupancy;
+  wire [ADDR_WIDTH:0] 	       write_side_occupancy;
+  wire 			       read_data_valid;
+  wire 			       fifo_empty;
+  wire 			       write_enable;
+  wire [RAM_WIDTH-1:0] 	       ram_write_data;
+  wire [RAM_WIDTH-1:0] 	       ram_read_data;
+
+  wire [(RAM_WIDTH-1):0]       prev_data_w;
+ 
+  wire [(IN_FSM_SIZE-1):0]     in_fsm_state_w;
+
+  //  Capture data_i
+  always @(posedge core_clk_i or negedge core_reset_n_i)
+    if (~core_reset_n_i)
+      data_int <= #(TCQ) {RAM_WIDTH{1'b0}};
+    else 
+      data_int <= #(TCQ) data_i;
+
+  // Capture LTSSM state on change
+  always @(posedge core_clk_i or negedge core_reset_n_i)
+    if (~core_reset_n_i)
+      reg_prev_data <= #(TCQ) {RAM_WIDTH{1'b0}};
+    else if (((data_int != prev_data_w) || (in_fsm_state_w == IN_FSM_CHANGE) ) & 
+	     (~NO_UPDATE_PREV_DATA_ON_FIFO_FULL | (~fifo_full & NO_UPDATE_PREV_DATA_ON_FIFO_FULL)))
+      reg_prev_data <= #(TCQ) data_int;
+  
+  // FSM Looks for change in the LTSSM state
+
+  always @(posedge core_clk_i or negedge core_reset_n_i)
+    if (~core_reset_n_i)
+      reg_in_fsm_state <= #(TCQ) IN_FSM_IDLE;
+    else
+      reg_in_fsm_state <= #(TCQ) reg_in_fsm_next_state;
+
+  // FSM Next State Logic
+
+  always @( * )
+    case (in_fsm_state_w)
+      IN_FSM_IDLE :
+        if (data_int != reg_prev_data)
+          reg_in_fsm_next_state = IN_FSM_CHANGE;
+        else
+          reg_in_fsm_next_state = IN_FSM_IDLE;
+      IN_FSM_CHANGE : 
+        reg_in_fsm_next_state = IN_FSM_IDLE;
+      default : 
+        reg_in_fsm_next_state = IN_FSM_IDLE;
+    endcase   
+
+  // FIFO Write Side Processes
+
+  assign  ram_write_data = data_int;
+  //assign  write_enable = (data_int != prev_data_w) || (in_fsm_state_w == IN_FSM_CHANGE);
+  assign  write_enable = (data_int[6]);
+  assign  write_addr_next = write_addr + {{ADDR_WIDTH{1'b0}}, 1'b1};
+
+  always @(posedge core_clk_i or negedge core_reset_n_i)
+    if (~core_reset_n_i)
+      write_addr <= {ADDR_WIDTH+1{1'b0}};
+    else if (write_enable & ~fifo_full)
+      write_addr <= write_addr_next;
+
+  // Write into RAM 
+  always @(posedge core_clk_i or negedge core_reset_n_i)
+    if (~core_reset_n_i)
+      begin
+	for (index=0; index < RAM_DEPTH; index=index+1)
+	  reg_ram[index] <= {RAM_WIDTH{1'b0}};
+      end
+    else if (write_enable)
+      reg_ram[write_addr[ADDR_WIDTH-1:0]] <= ram_write_data;
+
+  // FIFO Read Side Processes
+
+  assign      read_addr_next = read_addr +  {{ADDR_WIDTH-1{1'b0}}, 1'b1};
+
+  always @(posedge user_clk_i or negedge user_reset_n_i)
+    if (~user_reset_n_i)
+      read_addr <= {ADDR_WIDTH+1{1'b0}};
+    else if (read_data_valid)
+      read_addr <= read_addr_next;
+
+  // Convert write pointer to the read clk domain
+  always @(posedge user_clk_i or negedge user_reset_n_i)
+    if (~user_reset_n_i)
+      write_addr_read_clk <= {ADDR_WIDTH+1{1'b0}};
+    else
+      write_addr_read_clk <= write_addr;
+  
+  // Maintain read-side occupancy
+  assign read_side_occupancy = (write_addr_read_clk - read_addr);
+  assign fifo_empty = (read_side_occupancy == {ADDR_WIDTH+1{1'b0}});
+  assign read_data_valid = ~fifo_empty;
+  assign ram_read_data = reg_ram[read_addr[ADDR_WIDTH-1:0]];
+
+  /* convert read pointer to write clock domain */
+  always @(posedge core_clk_i or negedge core_reset_n_i)
+    if (~core_reset_n_i)
+      read_addr_wrclk <= {ADDR_WIDTH+1{1'b0}};
+    else
+      read_addr_wrclk <= read_addr;
+
+  assign write_side_occupancy = write_addr - read_addr_wrclk;
+
+  // Generate FIFO full condition
+  always @(posedge core_clk_i or negedge core_reset_n_i)
+    if (~core_reset_n_i)
+      fifo_full <= 1'b0;
+    else
+      if (write_side_occupancy[ADDR_WIDTH] ||
+	  (write_side_occupancy[ADDR_WIDTH-1:0] == FIFO_FULL_HIGH_THRESHOLD))
+	fifo_full <= 1'b1;
+      else
+	// Clear when FIFO occupancy goes below low threshold
+	if (~write_side_occupancy[ADDR_WIDTH] &&
+	    (write_side_occupancy[ADDR_WIDTH-1:0] <= FIFO_FULL_LOW_THRESHOLD))
+	  fifo_full <= 1'b0;
+
+  // Latch Last
+  always @(posedge user_clk_i or negedge user_reset_n_i)
+    if (~user_reset_n_i)
+      reg_out_data <= #(TCQ) {RAM_WIDTH{1'b0}};
+    else
+      if (read_data_valid)
+        reg_out_data <= #(TCQ) ram_read_data;
+      else
+	reg_out_data <= #(TCQ) 'h0;
+
+  // Assignments
+
+  assign in_fsm_state_w = reg_in_fsm_state;
+  assign data_o = reg_out_data;
+  assign prev_data_w = reg_prev_data; 
+  
+endmodule // pcie3_ccm_fifo
+//--------------------------------------------------------------------------------------------------
+`timescale 1ps/1ps
+
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_vf_decode #(
+
+  parameter           TCQ = 100
+ ,parameter           NUM_VFS = 252
+ ,parameter [1:0]     TL_PF_ENABLE_REG=2'h0
+ ,parameter [15:0]    PF0_SRIOV_CAP_TOTAL_VF=16'h0
+ ,parameter [15:0]    PF1_SRIOV_CAP_TOTAL_VF=16'h0
+ ,parameter [15:0]    PF2_SRIOV_CAP_TOTAL_VF=16'h0
+ ,parameter [15:0]    PF3_SRIOV_CAP_TOTAL_VF=16'h0
+ ,parameter [15:0]    PF0_SRIOV_FIRST_VF_OFFSET=16'h0
+ ,parameter [15:0]    PF1_SRIOV_FIRST_VF_OFFSET=16'h0
+ ,parameter [15:0]    PF2_SRIOV_FIRST_VF_OFFSET=16'h0
+ ,parameter [15:0]    PF3_SRIOV_FIRST_VF_OFFSET=16'h0
+ ,parameter [3:0]     SRIOV_CAP_ENABLE=4'h0
+ ,parameter           ARI_CAP_ENABLE="FALSE"
+
+
+  ) (
+
+  input wire          clk_i
+ ,input wire          reset_i
+ ,input wire          link_down_i
+ ,input wire          cfg_ext_write_received_i
+ ,input wire [9:0]    cfg_ext_register_number_i
+ ,input wire [7:0]    cfg_ext_function_number_i
+ ,input wire [31:0]   cfg_ext_write_data_i
+ ,input wire [3:0]    cfg_ext_write_byte_enable_i
+ ,input wire [3:0]    cfg_flr_in_process_i
+
+ ,output reg [NUM_VFS-1:0]   cfg_vf_flr_in_process_o
+ ,output reg [2*NUM_VFS-1:0] cfg_vf_status_o          // Bit 0: Memory Space Enable; Bit 1: Bus Master Enable
+ ,output reg [3*NUM_VFS-1:0] cfg_vf_power_state_o     // 000b - D0-Uninitialized; 001b - D0-Active; 010b - D1; 100b - D3hot
+ ,output reg [NUM_VFS-1:0]   cfg_vf_tph_requester_enable_o
+ ,output reg [3*NUM_VFS-1:0] cfg_vf_tph_st_mode_o     
+ ,output reg [NUM_VFS-1:0]   cfg_interrupt_msix_vf_enable_o
+ ,output reg [NUM_VFS-1:0]   cfg_interrupt_msix_vf_mask_o
+
+  );
+
+  localparam [9:0]   REG_DEV_CTRL=10'h1E;
+  localparam         REG_DEV_CTRL__FLR_SIZE=1;
+  localparam         REG_DEV_CTRL__FLR=15;
+
+  localparam [9:0]   REG_PCI_CMD=10'h1;
+  localparam         REG_PCI_CMD__BME_SIZE=1;  
+  localparam         REG_PCI_CMD__BME=2;
+  localparam         REG_PCI_CMD__MSE_SIZE=1;  
+  localparam         REG_PCI_CMD__MSE=1;  
+
+  localparam [9:0]   REG_PM_CSR=10'h11;
+  localparam         REG_PM_CSR__PS_SIZE=2;
+  localparam         REG_PM_CSR__PS=0;
+
+  localparam [9:0]   REG_TPH_CR=10'h8A;
+  localparam         REG_TPH_CR__RQE_SIZE=1;  
+  localparam         REG_TPH_CR__RQE=8;  
+  localparam         REG_TPH_CR__STMS_SIZE=3;
+  localparam         REG_TPH_CR__STMS=0;
+
+  localparam [9:0]   REG_MSIX_CR=10'h18;
+  localparam         REG_MSIX_CR__EN_SIZE=1;  
+  localparam         REG_MSIX_CR__EN=31;  
+  localparam         REG_MSIX_CR__MSK_SIZE=1;
+  localparam         REG_MSIX_CR__MSK=30;
+  localparam         PF_VF_MAP_WIDTH=256;
+
+  reg                 cfg_ext_write_received;
+  reg [9:0]           cfg_ext_register_number;
+  reg [7:0]           cfg_ext_function_number;
+  reg [31:0]          cfg_ext_write_data;
+  reg [3:0]           cfg_ext_write_byte_enable;
+
+  reg [NUM_VFS-1:0]   cfg_vf_flr_in_process_w;
+  reg [2*NUM_VFS-1:0] cfg_vf_status_w;
+  reg [3*NUM_VFS-1:0] cfg_vf_power_state_w;
+  reg [NUM_VFS-1:0]   cfg_vf_tph_requester_enable_w;
+  reg [3*NUM_VFS-1:0] cfg_vf_tph_st_mode_w;
+  reg [NUM_VFS-1:0]   cfg_interrupt_msix_vf_enable_w;
+  reg [NUM_VFS-1:0]   cfg_interrupt_msix_vf_mask_w;
+  reg [NUM_VFS-1:0]   cfg_interrupt_msix_vf_flr_msk_w;
+  reg [NUM_VFS-1:0]   reg_cfg_interrupt_msix_vf_flr_msk;
+
+  wire [NUM_VFS-1:0]  cfg_vf_active_w;
+  reg [NUM_VFS-1:0]   reg_cfg_vf_active;
+  reg [NUM_VFS-1:0]   cfg_vf_active;
+
+  wire [7:0]          cfg_ext_function_number_w;
+  wire [7:0]          cfg_ext_function_number_w_2_b0;
+  wire [7:0]          cfg_ext_function_number_w_2_b1;
+  wire [7:0]          cfg_ext_function_number_w_3_b0;
+  wire [7:0]          cfg_ext_function_number_w_3_b1;
+  wire [7:0]          cfg_ext_function_number_w_3_b2;
+  wire [3:0]          pf_mapenable;
+  wire                pf_as_vf;
+  wire [2:0]          pf_as_vf_mapd;
+
+  // Only use attributes in these static assignments for PF_VF_MAP
+  wire [(PF_VF_MAP_WIDTH-1):0] pf0_vf_size;
+  wire [(PF_VF_MAP_WIDTH-1):0] pf1_vf_size;
+  wire [(PF_VF_MAP_WIDTH-1):0] pf2_vf_size;
+  wire [(PF_VF_MAP_WIDTH-1):0] pf3_vf_size;
+  wire [(PF_VF_MAP_WIDTH-1):0] pf0_vf_mapd;
+  wire [(PF_VF_MAP_WIDTH-1):0] pf1_vf_mapd;
+  wire [(PF_VF_MAP_WIDTH-1):0] pf2_vf_mapd;
+  wire [(PF_VF_MAP_WIDTH-1):0] pf3_vf_mapd;
+
+  wire [(PF_VF_MAP_WIDTH-1):0] pf0_vf_map_w;
+  wire [(PF_VF_MAP_WIDTH-1):0] pf1_vf_map_w;
+  wire [(PF_VF_MAP_WIDTH-1):0] pf2_vf_map_w;
+  wire [(PF_VF_MAP_WIDTH-1):0] pf3_vf_map_w;
+
+  integer                      i;
+
+  always @(posedge clk_i) begin
+  
+    if (reset_i) begin
+
+      cfg_ext_write_received <= #(TCQ) 1'b0;
+      cfg_ext_register_number <= #(TCQ) 10'b0;
+      cfg_ext_function_number <= #(TCQ) 8'b0;
+      cfg_ext_write_data <= #(TCQ) 32'b0;
+      cfg_ext_write_byte_enable <= #(TCQ) 4'b0;
+
+      cfg_vf_flr_in_process_o <= #(TCQ) {NUM_VFS{1'b0}};
+      cfg_vf_status_o <= #(TCQ) {2*NUM_VFS{1'b0}};
+      cfg_vf_power_state_o <= #(TCQ) {3*NUM_VFS{1'b0}};
+      cfg_vf_tph_requester_enable_o <= #(TCQ) {2*NUM_VFS{1'b0}};
+      cfg_vf_tph_st_mode_o <= #(TCQ) {3*NUM_VFS{1'b0}};
+      cfg_interrupt_msix_vf_enable_o <= #(TCQ) {NUM_VFS{1'b0}};
+      cfg_interrupt_msix_vf_mask_o <= #(TCQ) {NUM_VFS{1'b0}};
+
+      reg_cfg_vf_active <= #(TCQ) {NUM_VFS{1'b0}};
+      reg_cfg_interrupt_msix_vf_flr_msk <= #(TCQ) {NUM_VFS{1'b1}};   
+
+    end else if (link_down_i) begin
+
+      cfg_ext_write_received <= #(TCQ) 1'b0;
+      cfg_ext_register_number <= #(TCQ) 10'b0;
+      cfg_ext_function_number <= #(TCQ) 8'b0;
+      cfg_ext_write_data <= #(TCQ) 32'b0;
+      cfg_ext_write_byte_enable <= #(TCQ) 4'b0;
+
+      cfg_vf_flr_in_process_o <= #(TCQ) {NUM_VFS{1'b0}};
+      cfg_vf_status_o <= #(TCQ) {2*NUM_VFS{1'b0}};
+      cfg_vf_power_state_o <= #(TCQ) {3*NUM_VFS{1'b0}};
+      cfg_vf_tph_requester_enable_o <= #(TCQ) {2*NUM_VFS{1'b0}};
+      cfg_vf_tph_st_mode_o <= #(TCQ) {3*NUM_VFS{1'b0}};
+      cfg_interrupt_msix_vf_enable_o <= #(TCQ) {NUM_VFS{1'b0}};
+      cfg_interrupt_msix_vf_mask_o <= #(TCQ) {NUM_VFS{1'b0}};
+
+      reg_cfg_vf_active <= #(TCQ) {NUM_VFS{1'b0}};
+      reg_cfg_interrupt_msix_vf_flr_msk <= #(TCQ) {NUM_VFS{1'b1}};   
+
+    end else begin
+
+      cfg_ext_write_received <= #(TCQ) cfg_ext_write_received_i;
+      cfg_ext_register_number <= #(TCQ) cfg_ext_register_number_i;
+      cfg_ext_function_number <= #(TCQ) cfg_ext_function_number_i; 
+      cfg_ext_write_data <= #(TCQ) cfg_ext_write_data_i;
+      cfg_ext_write_byte_enable <= #(TCQ) cfg_ext_write_byte_enable_i;
+
+      cfg_vf_flr_in_process_o <= #(TCQ) cfg_vf_flr_in_process_w;
+      cfg_vf_status_o <= #(TCQ) cfg_vf_status_w;
+      cfg_vf_power_state_o <= #(TCQ) cfg_vf_power_state_w;
+      cfg_vf_tph_requester_enable_o <= #(TCQ) cfg_vf_tph_requester_enable_w;
+      cfg_vf_tph_st_mode_o <= #(TCQ) cfg_vf_tph_st_mode_w;
+      cfg_interrupt_msix_vf_enable_o <= #(TCQ) cfg_interrupt_msix_vf_enable_w & cfg_interrupt_msix_vf_flr_msk_w;
+      cfg_interrupt_msix_vf_mask_o <= #(TCQ) cfg_interrupt_msix_vf_mask_w & cfg_interrupt_msix_vf_flr_msk_w;
+
+      reg_cfg_vf_active <= #(TCQ) cfg_vf_active_w;
+      reg_cfg_interrupt_msix_vf_flr_msk <= #(TCQ) cfg_interrupt_msix_vf_flr_msk_w;
+
+    end
+
+  end
+
+  /*
+  *  1)
+  *  if any of the PF sees a FLR (cfg_flr_in_process_i bits set to 1b),
+  *  then, corresponding VF bits in cfg_interrupt_msix_vf_enable_o and
+  *  cfg_interrupt_msix_vf_mask_o must be reset.
+  *  2)
+  *  if any of the VF sees a FLR (cfg_vf_flr_in_process_w bits set to 1b),
+  *  then, corresponding VF bits in cfg_interrupt_msix_vf_enable_o and
+  *  cfg_interrupt_msix_vf_mask_o must be reset.
+  */
+
+  always @ (*) begin
+
+    for (i = 0; i < 252; i = i + 1) begin
+
+      if (cfg_flr_in_process_i[0] & pf0_vf_map_w[i+4])
+        cfg_interrupt_msix_vf_flr_msk_w[i] = 1'b0;
+      else if (!cfg_flr_in_process_i[0] & pf0_vf_map_w[i+4])
+        cfg_interrupt_msix_vf_flr_msk_w[i] = 1'b1;
+      else
+	cfg_interrupt_msix_vf_flr_msk_w[i] = reg_cfg_interrupt_msix_vf_flr_msk[i];
+
+    end
+
+    for (i = 0; i < 252; i = i + 1) begin
+
+      if (cfg_flr_in_process_i[1] & pf1_vf_map_w[i+4])
+        cfg_interrupt_msix_vf_flr_msk_w[i] = 1'b0; 
+      else if (!cfg_flr_in_process_i[1] & pf1_vf_map_w[i+4])
+        cfg_interrupt_msix_vf_flr_msk_w[i] = 1'b1; 
+      else
+	cfg_interrupt_msix_vf_flr_msk_w[i] = reg_cfg_interrupt_msix_vf_flr_msk[i];
+
+    end
+
+    for (i = 0; i < 252; i = i + 1) begin
+
+      if (cfg_flr_in_process_i[2] & pf2_vf_map_w[i+4])
+        cfg_interrupt_msix_vf_flr_msk_w[i] = 1'b0; 
+      else if (!cfg_flr_in_process_i[2] & pf2_vf_map_w[i+4])
+        cfg_interrupt_msix_vf_flr_msk_w[i] = 1'b1; 
+      else
+	cfg_interrupt_msix_vf_flr_msk_w[i] = reg_cfg_interrupt_msix_vf_flr_msk[i];
+
+    end
+
+    for (i = 0; i < 252; i = i + 1) begin
+
+      if (cfg_flr_in_process_i[3] & pf3_vf_map_w[i+4])
+        cfg_interrupt_msix_vf_flr_msk_w[i] = 1'b0; 
+      else if (!cfg_flr_in_process_i[3] & pf3_vf_map_w[i+4])
+        cfg_interrupt_msix_vf_flr_msk_w[i] = 1'b1; 
+      else
+	cfg_interrupt_msix_vf_flr_msk_w[i] = reg_cfg_interrupt_msix_vf_flr_msk[i];
+
+    end
+
+    for (i = 0; i < 252; i = i + 1) begin
+
+      if (cfg_vf_flr_in_process_w[i])
+        cfg_interrupt_msix_vf_flr_msk_w[i] = 1'b0;
+      else
+        cfg_interrupt_msix_vf_flr_msk_w[i] = 1'b1;
+
+    end
+
+  end
+
+  always @(*) begin
+
+    cfg_vf_flr_in_process_w = cfg_vf_flr_in_process_o;
+    cfg_vf_status_w = cfg_vf_status_o;
+    cfg_vf_power_state_w = cfg_vf_power_state_o;
+    cfg_vf_tph_requester_enable_w = cfg_vf_tph_requester_enable_o;
+    cfg_vf_tph_st_mode_w = cfg_vf_tph_st_mode_o;
+    cfg_interrupt_msix_vf_enable_w = cfg_interrupt_msix_vf_enable_o; 
+    cfg_interrupt_msix_vf_mask_w = cfg_interrupt_msix_vf_mask_o;
+    cfg_vf_active = cfg_vf_active_w;
+
+    if (cfg_ext_write_received && (cfg_ext_function_number > 3)) begin
+
+      if (cfg_ext_register_number == REG_DEV_CTRL) begin
+
+        if (cfg_ext_write_byte_enable[1])
+          cfg_vf_flr_in_process_w[cfg_ext_function_number_w] = cfg_ext_write_data[REG_DEV_CTRL__FLR];
+
+      end else if (cfg_ext_register_number == REG_PCI_CMD) begin
+
+        if (cfg_ext_write_byte_enable[0]) begin
+
+          cfg_vf_status_w[cfg_ext_function_number_w_2_b0] = cfg_ext_write_data[REG_PCI_CMD__MSE]; 
+          cfg_vf_status_w[cfg_ext_function_number_w_2_b1] = cfg_ext_write_data[REG_PCI_CMD__BME]; 
+          cfg_vf_active[cfg_ext_function_number_w] = cfg_ext_write_data[REG_PCI_CMD__BME] | cfg_ext_write_data[REG_PCI_CMD__MSE];
+          // if Function in D0-Uninit then transtion to D0-Active
+          if ((!cfg_vf_power_state_w[cfg_ext_function_number_w_3_b0]) &&
+              (!cfg_vf_power_state_w[cfg_ext_function_number_w_3_b1]) &&
+              (!cfg_vf_power_state_w[cfg_ext_function_number_w_3_b2]))
+            cfg_vf_power_state_w[cfg_ext_function_number_w_3_b0] = cfg_vf_active_w[cfg_ext_function_number_w];
+
+        end
+
+      end else if (cfg_ext_register_number == REG_PM_CSR) begin
+
+        if (cfg_ext_write_byte_enable[0]) begin
+
+          cfg_vf_power_state_w[cfg_ext_function_number_w_3_b0] = cfg_vf_active[cfg_ext_function_number_w] && 
+					                           (!cfg_ext_write_data[REG_PM_CSR__PS] || 
+					                            !cfg_ext_write_data[REG_PM_CSR__PS+REG_PM_CSR__PS_SIZE-1]);
+          cfg_vf_power_state_w[cfg_ext_function_number_w_3_b1] = (cfg_ext_write_data[REG_PM_CSR__PS] && 
+		                                                  !cfg_ext_write_data[REG_PM_CSR__PS+REG_PM_CSR__PS_SIZE-1]); 
+          cfg_vf_power_state_w[cfg_ext_function_number_w_3_b2] = (cfg_ext_write_data[REG_PM_CSR__PS] && 
+		                                                  cfg_ext_write_data[REG_PM_CSR__PS+REG_PM_CSR__PS_SIZE-1]); 
+
+        end
+
+      end else if (cfg_ext_register_number == REG_TPH_CR) begin
+
+        if (cfg_ext_write_byte_enable[0]) begin
+
+          cfg_vf_tph_st_mode_w[cfg_ext_function_number_w_3_b0] = cfg_ext_write_data[REG_TPH_CR__STMS];
+          cfg_vf_tph_st_mode_w[cfg_ext_function_number_w_3_b1] = cfg_ext_write_data[REG_TPH_CR__STMS+1]; 
+          cfg_vf_tph_st_mode_w[cfg_ext_function_number_w_3_b2] = cfg_ext_write_data[REG_TPH_CR__STMS+2]; 
+
+        end
+
+        if (cfg_ext_write_byte_enable[1])
+          cfg_vf_tph_requester_enable_w[cfg_ext_function_number_w] = cfg_ext_write_data[REG_TPH_CR__RQE]; 
+
+      end else if (cfg_ext_register_number == REG_MSIX_CR) begin
+
+        if (cfg_ext_write_byte_enable[3]) begin
+          cfg_interrupt_msix_vf_enable_w[cfg_ext_function_number_w] = cfg_ext_write_data[REG_MSIX_CR__EN];
+          cfg_interrupt_msix_vf_mask_w[cfg_ext_function_number_w] = cfg_ext_write_data[REG_MSIX_CR__MSK];
+        end
+
+      end
+
+    end
+
+  end
+
+  assign cfg_ext_function_number_w = cfg_ext_function_number - 4;
+  assign cfg_ext_function_number_w_2_b0 = 2*(cfg_ext_function_number_w)+0;
+  assign cfg_ext_function_number_w_2_b1 = 2*(cfg_ext_function_number_w)+1;
+  assign cfg_ext_function_number_w_3_b0 = 3*(cfg_ext_function_number_w)+0;
+  assign cfg_ext_function_number_w_3_b1 = 3*(cfg_ext_function_number_w)+1;
+  assign cfg_ext_function_number_w_3_b2 = 3*(cfg_ext_function_number_w)+2;
+  assign cfg_vf_active_w = reg_cfg_vf_active;
+
+  // Decoded number of pfs
+  assign pf_mapenable[0] = 1'b1;
+  assign pf_mapenable[1] = (TL_PF_ENABLE_REG == 2'h1) | (TL_PF_ENABLE_REG == 2'h2) | (TL_PF_ENABLE_REG == 2'h3) ;
+  assign pf_mapenable[2] = (TL_PF_ENABLE_REG == 2'h2) | (TL_PF_ENABLE_REG == 2'h3) ;
+  assign pf_mapenable[3] = (TL_PF_ENABLE_REG == 2'h3) ;
+  
+  // These bit-widths are sized for max. 256 functions and single bus no.
+  assign pf0_vf_size = {PF_VF_MAP_WIDTH{pf_mapenable[0]}} << PF0_SRIOV_CAP_TOTAL_VF[7:0];
+  assign pf1_vf_size = {PF_VF_MAP_WIDTH{pf_mapenable[1]}} << PF1_SRIOV_CAP_TOTAL_VF[7:0];
+  assign pf2_vf_size = {PF_VF_MAP_WIDTH{pf_mapenable[2]}} << PF2_SRIOV_CAP_TOTAL_VF[7:0];
+  assign pf3_vf_size = {PF_VF_MAP_WIDTH{pf_mapenable[3]}} << PF3_SRIOV_CAP_TOTAL_VF[7:0];
+  
+  // Make sure to disable the VFs based on the individual PF enables
+  assign pf0_vf_mapd = pf_mapenable[0] ? (~pf0_vf_size << (        PF0_SRIOV_FIRST_VF_OFFSET[7:0])) : 'b0;
+  assign pf1_vf_mapd = pf_mapenable[1] ? (~pf1_vf_size << (8'h01 + PF1_SRIOV_FIRST_VF_OFFSET[7:0])) : 'b0;
+  assign pf2_vf_mapd = pf_mapenable[2] ? (~pf2_vf_size << (8'h02 + PF2_SRIOV_FIRST_VF_OFFSET[7:0])) : 'b0;
+  assign pf3_vf_mapd = pf_mapenable[3] ? (~pf3_vf_size << (8'h03 + PF3_SRIOV_FIRST_VF_OFFSET[7:0])) : 'b0;
+  
+  assign pf_as_vf = ((SRIOV_CAP_ENABLE[0] == 1'b1) && (ARI_CAP_ENABLE == "FALSE")) ;
+  assign pf_as_vf_mapd = pf_as_vf ? pf0_vf_mapd[3:1] : 3'h0;
+  
+  assign pf0_vf_map_w = {pf0_vf_mapd[(PF_VF_MAP_WIDTH-1):4],{pf_as_vf_mapd,pf_mapenable[0]}};
+  assign pf1_vf_map_w = {pf1_vf_mapd[(PF_VF_MAP_WIDTH-1):4],{2'h0,pf_mapenable[1],1'h0}};
+  assign pf2_vf_map_w = {pf2_vf_mapd[(PF_VF_MAP_WIDTH-1):4],{1'h0,pf_mapenable[2],2'h0}};
+  assign pf3_vf_map_w = {pf3_vf_mapd[(PF_VF_MAP_WIDTH-1):4],{pf_mapenable[3], 3'h0}};
+
+endmodule
+
+
+
+//--------------------------------------------------------------------------------------------------
+`timescale 1ps/1ps
+
+`define XPREG(clk, reset_n, q,d,rstval)          \
+    always @(posedge clk)                        \
+    begin                                        \
+     if (reset_n == 1'b0)                        \
+         q <= #(TCQ) rstval;                     \
+     else                                        \
+         q <= #(TCQ)  d;                         \
+     end
+
+
+`define XPLREG(clk,reset_n,load,q,d,rstval,ldval)       \
+always @(posedge clk)                                   \
+begin                                                   \
+  if (reset_n == 1'b0)                                  \
+    q <= #(TCQ) rstval;                                 \
+  else if (load == 1'b1)                                \
+    q <= #(TCQ) ldval;                                  \
+  else                                                  \
+    q <= #(TCQ)  d;                                     \
+end
+
+
+module xp4_usp_smsw_model_tl_rx_ccix_fifo #
+  (
+   parameter ADDRESS_WIDTH = 9, // RAM address width: 8 = 8Kbytes RAM, 9 = 16Kbytes, 10 = 32Kbytes
+   parameter RAM_WORD_COUNT = 512, // RAM size in number of words, 256 = 8Kbytes, 512 = 16Kbytes, 1024 = 32Kbytes
+   parameter MAX_TLP_COUNT = 32, // FIFO capacity in packets
+   parameter MAX_TLP_COUNT_BITS = 6, // number of bits for representing MAX_TLP_COUNT
+   parameter TCQ = 100,
+   parameter IMPL_TARGET = "SOFT"
+   ) 
+  (
+   // Clocks and resets
+    input  wire           user_clk_ccix_i
+   ,input  wire           reset_n_ccix_i
+   ,input  wire           link_down_reset_i
+   // Attributes
+   ,input wire            attr_ccix_direct_attach_mode_i  // Enables TL support for Optimized CCIX TLPs
+   ,input wire            attr_tl_rx_ccix_fifo_ram_size_i // 0 = 4K, 1 = 16K
+   ,input wire            attr_tl_rx_ccix_fifo_to_ram_write_pipeline_i
+   // Indicates the presence of a pipeline register on write address, data, and write enable
+   ,input wire            attr_tl_rx_ccix_fifo_to_ram_read_pipeline_i
+   // Indicates the presence of a pipeline register on read address and read enable
+   ,input wire            attr_tl_rx_ccix_fifo_from_ram_read_pipeline_i
+   // Indicates the presence of a pipeline register on read data
+   ,input wire            attr_test_mode_pin_char_i // Diagnostic pin to enable data loopback (tied to 0 in soft version)
+   // Data from TL
+   ,input wire [255:0]    s_axis_ccix_rx_tdata_i // 256-bit data
+   ,input wire            s_axis_ccix_rx_tvalid_i // Valid
+   ,input wire [44:0]     s_axis_ccix_rx_tuser_i // tuser bus
+                         // [0] = is_sop0, [2:1] = is_sop0_ptr,
+                         // [3] = is_sop1, [4] = is_sop1_ptr
+                         // [5] = is_eop0, [8:6] = is_eop0_ptr,
+                         // [9] = is_eop1, [11:10] = is_eop1_ptr,
+                         // [12] = discontinue,
+                         // [44:13] = odd parity
+ // Data to downstream CCIX protocol processing block
+   ,output wire [255:0]  m_axis_ccix_rx_tdata_o // 256-bit data
+   ,output wire          m_axis_ccix_rx_tvalid_o // Valid
+   ,output wire [45:0]   m_axis_ccix_rx_tuser_o // tuser bus
+                         // [0] = is_sop0, [1] = is_sop0_ptr,
+                         // [2] = is_sop1, [3] = is_sop1_ptr,
+                         // [4] = is_eop0, [7:5] = is_eop0_ptr,
+                         // [8] = is_eop1, [11:9] = is_eop1_ptr,
+                         // [12] = discontinue, [44:13] = odd parity
+   ,input wire           ccix_rx_credit_i // Flow control credits from CCIX protocol processing block
+   ,output reg [7:0]     ccix_rx_credit_av_o // Current value of available credit maintained by the bridge
+   // Status outputs to TL
+   ,output reg           ccix_rx_tlp_forwarded0_o // Bridge forwarded a TLP downstream from its FIFO
+   ,output reg  [5:0]    ccix_rx_tlp_forwarded_length0_o // Length of TLP signaled by
+                                                          // ccix_rx_tlp_forwarded0_i in units of 16 bytes
+   ,output reg           ccix_rx_tlp_forwarded1_o // Bridge forwarded a TLP downstream from its FIFO
+   ,output reg           ccix_rx_tlp_forwarded_length1_o // Length of TLP signaled by
+                                                          // ccix_rx_tlp_forwarded1_i in units of
+                                                          // 16 bytes (0 = 0 bytes, 1 = 16 bytes)
+   ,output reg           ccix_rx_fifo_overflow_o // Overflow detected in the soft bridge FIFO.
+   ,output reg           ccix_rx_correctable_error_detected_o // Correctable ECC error detected in
+                                                               // soft bridge FIFO RAM.
+   ,output reg           ccix_rx_uncorrectable_error_detected_o // Uncorrectable ECC error detected in
+                                                               // soft bridge FIFO RAM.
+   // RAM interface
+   ,output reg  [8:0]     mi_rx_ccix_fifo_ram_write_address0_o // Write address to lower order BRAMs
+   ,output wire [143:0]   mi_rx_ccix_fifo_ram_write_data0_o // Write data to lower order BRAMs
+   ,output wire           mi_rx_ccix_fifo_ram_write_enable0_o // Write Enable to lower order BRAMs,
+   ,output reg  [8:0]     mi_rx_ccix_fifo_ram_write_address1_o  // Write address to higher order BRAMs
+   ,output wire [143:0]   mi_rx_ccix_fifo_ram_write_data1_o  // Write data to higher order BRAMs
+   ,output wire           mi_rx_ccix_fifo_ram_write_enable1_o // Write Enable to higher order BRAMs,
+   ,output reg  [8:0]     mi_rx_ccix_fifo_ram_read_address0_o  // Read address to lower order BRAMs
+   ,input wire[143:0]     mi_rx_ccix_fifo_ram_read_data0_i  // Read data to lower order BRAMs
+   ,output reg            mi_rx_ccix_fifo_ram_read_enable0_o  // Read Enable to lower order BRAMs,
+   ,output reg  [8:0]     mi_rx_ccix_fifo_ram_read_address1_o  // Read address to higher order BRAMs
+   ,input wire[143:0]     mi_rx_ccix_fifo_ram_read_data1_i  // Read data to higher order BRAMs
+   ,output reg            mi_rx_ccix_fifo_ram_read_enable1_o  // Read Enable to higher order BRAMs,
+   ,input wire[5:0]       mi_rx_ccix_fifo_ram_err_cor_i // Correctable error from RAM
+   ,input wire[5:0]       mi_rx_ccix_fifo_ram_err_uncor_i  // Uncorrectable error from RAM
+   );
+
+   localparam  META_RAM_WIDTH = ADDRESS_WIDTH + // ram_write_addr;
+       2 + // write_sop0_ptr[1:0],
+       3 + // write_eop0_ptr[2:0],
+       1 + // write_sop1,
+       2 + // write_sop1_ptr.
+       1 + // write_eop1,
+       2 + // write_eop1_ptr[1:0],
+           1 + // write_sop_prev
+           1;  // write_sop2
+
+   localparam  OUTPUT_FIFO_DEPTH = 9;
+   localparam  OUTPUT_FIFO_HIGH_THRESHOLD = 8;
+
+  wire                          in_sop0_i;
+  wire [1:0] 			in_sop0_ptr_i;
+  wire  			in_sop1_i;
+  wire  			in_sop1_ptr_i;
+  wire  			in_eop0_i;
+  wire [2:0] 			in_eop0_ptr_i;
+  wire  			in_eop1_i;
+  wire [1:0] 			in_eop1_ptr_i;
+  wire  			in_err_i;
+  wire [31:0]  			in_parity_i;
+
+  reg 				write_tlp_in_progress;
+  reg 				write_tlp_in_progress_wire;
+
+  reg [ADDRESS_WIDTH-1:0] 	write_ptr;
+  reg [ADDRESS_WIDTH-1:0] 	write_ptr_wire;
+  reg [ADDRESS_WIDTH-1:0] 	write_ptr_saved;
+  reg [ADDRESS_WIDTH-1:0] 	write_ptr_saved_wire;
+  reg 				write_tlp_offset_saved_wire;
+  reg 				write_tlp_offset_saved;
+  reg 				del_in_progress;
+  reg 				del_in_progress_wire;
+  reg [ADDRESS_WIDTH-1:0] 	ram_write_addr;
+  reg [ADDRESS_WIDTH-1:0] 	ram_write_addr_wire;
+  reg [1:0] 			ram_write_enable;
+  reg [1:0] 			ram_write_enable_wire;
+  reg [255:0] 			ram_write_data;
+  reg [31:0] 			ram_write_parity;
+  
+  wire 				fifo_full;
+  reg 				fifo_overflow_wire;
+  wire [ADDRESS_WIDTH+1:0] 	ram_capacity;
+  reg [ADDRESS_WIDTH+2:0] 	free_word_count;
+  reg [ADDRESS_WIDTH+2:0] 	free_word_count_wire;
+  reg [ADDRESS_WIDTH+1:0] 	word_count_current_tlp;
+  reg [ADDRESS_WIDTH+1:0] 	word_count_current_tlp_wire;
+  wire [ADDRESS_WIDTH+2:0] 	free_word_count_plus_word_count_current_tlp;
+  reg [MAX_TLP_COUNT_BITS-1:0] 	free_tlp_count_wire;
+  reg [MAX_TLP_COUNT_BITS-1:0] 	free_tlp_count;
+  reg 				free_word_count_zero; // free_word_count == 0
+  wire 				free_word_count_le_one; // free_word_count <= 1
+  reg 				free_tlp_count_zero;
+  reg 				free_word_count_zero_wire;
+  reg 				free_tlp_count_zero_wire;
+  reg 				single_tlp_write;
+  reg 				single_tlp_write_wire;
+  reg 				dual_tlp_write;
+  reg 				dual_tlp_write_wire;
+  reg 				single_tlp_write1;
+  reg 				dual_tlp_write1;
+  reg 				single_tlp_write2;
+  reg 				dual_tlp_write2;
+  wire 				single_tlp_write_final;
+  wire 				dual_tlp_write_final;
+  
+  reg [MAX_TLP_COUNT_BITS-1:0] 	fifo_tlp_count;
+  reg [MAX_TLP_COUNT_BITS-1:0] 	fifo_tlp_count_wire;
+  reg 				fifo_tlp_count_non_zero;
+  reg 				fifo_tlp_count_non_zero_wire;
+  reg [MAX_TLP_COUNT_BITS:0] 	fifo_tlp_count_captured_on_err;
+  reg [MAX_TLP_COUNT_BITS:0] 	fifo_tlp_count_captured_on_err_wire;
+  reg 				suspend_straddle_on_err;
+  reg 				suspend_straddle_on_err_wire;
+  
+  reg [1:0] 			write_sop0_ptr;
+  reg [2:0] 			write_eop0_ptr;
+  reg 				write_sop1;
+  reg [1:0] 			write_sop1_ptr;
+  reg 				write_eop1;
+  reg [1:0] 			write_eop1_ptr;
+  reg 				write_sop2;
+  reg 				meta_ram_write_enable;
+  reg [1:0] 			current_write_sop_ptr;
+  reg [1:0] 			write_sop0_ptr_wire;
+  reg [2:0] 			write_eop0_ptr_wire;
+  reg 				write_sop1_wire;
+  reg [1:0] 			write_sop1_ptr_wire;
+  reg 				write_eop1_wire;
+  reg [1:0] 			write_eop1_ptr_wire;
+  reg 				write_sop2_wire;
+  reg 				write_sop_prev;
+  reg 				write_meta_ram_tlp_in_progress;
+  reg 				write_sop_prev_wire;
+  reg 				write_meta_ram_tlp_in_progress_wire;
+  reg 				meta_ram_write_enable_wire;
+  reg [1:0] 			current_write_sop_ptr_wire;
+  reg [MAX_TLP_COUNT_BITS-2:0] 	meta_ram_write_ptr;
+  reg [MAX_TLP_COUNT_BITS-2:0] 	meta_ram_write_ptr_wire;
+  
+  reg [META_RAM_WIDTH-1:0] 	meta_ram[MAX_TLP_COUNT-1:0];
+  wire [META_RAM_WIDTH-1:0] 	meta_ram_write_data;
+  
+  reg [ADDRESS_WIDTH-1:0] 	read_ptr;
+  reg [ADDRESS_WIDTH-1:0] 	read_ptr_wire;
+  reg 				read_tlp_offset;
+  reg 				read_tlp_offset_wire;  
+  reg [MAX_TLP_COUNT_BITS-2:0] 	meta_ram_read_ptr;
+  reg [MAX_TLP_COUNT_BITS-2:0] 	meta_ram_read_ptr_wire;
+  reg 				fifo_read_enable;
+  reg 				fifo_read_enable_wire;
+  reg 				read_data_valid_1;
+  reg 				read_data_valid_2;
+  reg 				read_data_valid_3;
+  reg 				read_data_valid;
+  reg 				read_data_valid_1_wire;
+  reg 				read_data_valid_2_wire;
+  reg 				read_data_valid_3_wire;
+  reg 				read_data_valid_wire;
+  reg 				read_full_word;
+  reg 				read_full_word_wire;
+  reg 				read_in_progress;
+  reg 				read_in_progress_wire;
+  reg [1:0] 			last_read_tlp_eop_ptr;
+  reg [1:0] 			last_read_tlp_eop_ptr_wire;
+  
+  wire 				read_eop0;
+  wire 				read_eop0_1;
+  wire 				read_eop1_1;
+  wire [META_RAM_WIDTH-1:0] 	meta_ram_read_data;
+  wire [1:0] 			read_sop0_ptr;
+  wire [2:0] 			read_eop0_ptr;
+  wire 				read_sop1;
+  wire [1:0] 			read_sop1_ptr;
+  wire 				read_eop1;
+  wire [1:0] 			read_eop1_ptr;
+  wire 				read_sop_prev;
+  wire 				read_sop2;
+  wire 				read_second_tlp;
+  wire [14:0] 			read_metadata;
+  
+  reg [14:0] 			read_metadata_1;
+  reg [14:0] 			read_metadata_2;
+  reg [14:0] 			read_metadata_3;
+  reg [14:0] 			read_metadata_out;
+  wire [14:0] 			read_metadata_1_wire;
+  wire [14:0] 			read_metadata_2_wire;
+  wire [14:0] 			read_metadata_3_wire;
+  wire [14:0] 			read_metadata_out_wire;
+   
+   (* ram_style = "distributed" *) reg [288+4+15-1:0]          output_fifo_ram[OUTPUT_FIFO_DEPTH-1:0];
+
+  wire [288+12+15-1:0] 		output_fifo_write_data_wire;
+  reg [288+12+15-1:0] 		output_fifo_write_data_reg;
+  reg 				read_data_valid_reg;
+  wire [288+4+15-1:0] 		output_fifo_write_data;
+  reg [3:0] 			output_fifo_write_ptr;
+  reg [3:0] 			output_fifo_write_ptr_wire;
+  reg [3:0] 			output_fifo_read_ptr;
+  reg [3:0] 			output_fifo_read_ptr_wire;
+  reg [3:0] 			output_fifo_word_count;
+  reg [3:0] 			output_fifo_word_count_wire;
+  reg [3:0] 			output_fifo_exp_word_count;
+  reg [3:0] 			output_fifo_exp_word_count_wire;
+
+  wire [288+4+15-1:0] 		output_fifo_read_word;
+  wire [255:0] 			output_fifo_read_data;
+  wire [31:0] 			output_fifo_read_parity;
+  wire [1:0] 			output_fifo_read_sop0_ptr;
+  wire 				output_fifo_read_eop0;
+  wire [2:0] 			output_fifo_read_eop0_ptr;
+  wire 				output_fifo_read_sop1;
+  wire [1:0] 			output_fifo_read_sop1_ptr;
+  wire 				output_fifo_read_eop1;
+  wire [1:0] 			output_fifo_read_eop1_ptr;   
+  wire 				output_fifo_read_sop_prev;
+  wire 				output_fifo_read_sop2;
+  wire 				output_fifo_read_second_tlp;
+  wire [1:0] 			output_fifo_read_correctable_error;
+  wire [1:0] 			output_fifo_read_uncorrectable_error;
+  reg 				output_fifo_almost_full;
+  reg 				output_fifo_almost_full_wire;
+  reg 				output_fifo_non_empty;
+  reg 				output_fifo_non_empty_wire;
+  reg 				output_fifo_read_active;
+
+  reg [255:0] 			out_data_wire;
+  reg [31:0] 			out_parity_wire;
+  reg 				out_data_valid_wire;
+  reg 				out_data_valid_o;
+  reg 				out_sop0_wire;
+  reg 				out_sop0_ptr_wire;
+  reg 				out_eop0_wire;
+  reg [2:0] 			out_eop0_ptr_wire;
+  reg 				out_err0_wire;
+  reg 				out_sop1_wire;
+  reg 				out_eop1_wire;
+  reg 				out_eop1_ptr_wire;
+  reg 				out_err1_wire;
+  reg [1:0] 			out_tlp_alignment;
+  reg [1:0] 			out_tlp_alignment_wire;
+  
+  reg 				out_sop0_o;
+  reg 				out_sop0_ptr_o;
+  reg 				out_eop0_o;
+  reg [2:0] 			out_eop0_ptr_o;
+  reg 				out_err0_o;
+  reg 				out_sop1_o;
+  reg 				out_eop1_o;
+  reg 				out_eop1_ptr_o;
+  reg 				out_err1_o;
+
+  reg [255:0] 			out_data_reg;
+  reg [31:0] 			out_parity_reg;
+  wire [31:0] 			out_parity_o;
+  reg [1:0] 			out_data_mux_sel0_wire;
+  reg [2:0] 			out_data_mux_sel1_wire;
+  reg [2:0] 			out_data_mux_sel2_wire;
+  reg [2:0] 			out_data_mux_sel3_wire;
+  reg [1:0] 			out_data_mux_sel0;
+  reg [2:0] 			out_data_mux_sel1;
+  reg [2:0] 			out_data_mux_sel2;
+  reg [2:0] 			out_data_mux_sel3;
+
+  reg [191:0] 			saved_read_data;
+  reg [191:0] 			saved_read_data_wire;
+  reg [23:0] 			saved_read_parity;
+  reg [23:0] 			saved_read_parity_wire;
+  reg [191:0] 			saved_read_data_out;
+  reg [191:0] 			saved_read_data_out_wire;
+  reg [23:0] 			saved_read_parity_out;
+  reg [23:0] 			saved_read_parity_out_wire;
+  
+  reg 				saved_read_sop;
+  reg 				saved_read_sop_wire;
+  reg 				saved_read_sop1;
+  reg 				saved_read_sop1_wire;
+  reg 				saved_read_eop;
+  reg 				saved_read_eop_wire;
+  reg [2:0] 			saved_read_eop_ptr;
+  reg 				saved_read_eop1_ptr;
+  reg [2:0] 			saved_read_eop_ptr_wire;
+  reg 				saved_read_eop1_ptr_wire;
+  reg [1:0] 			saved_read_sop1_ptr;
+  reg [1:0] 			saved_read_sop1_ptr_wire;
+  reg 				saved_read_uncorrectable_error;
+  reg 				saved_read_uncorrectable_error1;
+  reg 				saved_read_uncorrectable_error2;
+  reg 				saved_read_uncorrectable_error_wire;
+  reg 				saved_read_uncorrectable_error1_wire;
+  reg 				saved_read_uncorrectable_error2_wire;
+  
+  reg 				ecc_corr_err_detected_wire;
+  reg 				ecc_uncorr_err_detected_wire;
+
+  wire 				ccix_app_ready;
+  reg [7:0] 			available_credit_wire;
+  reg 				available_credit_zero_wire;
+  reg 				available_credit_one_wire;
+  reg 				available_credit_zero;
+  reg 				available_credit_one;
+
+  reg 				egress_tlp_in_progress;
+  reg 				egress_tlp_in_progress_wire;
+  reg [7:0] 			tlp_in_progress_payload_dw_count;
+  reg [7:0] 			tlp_in_progress_payload_dw_count_wire;
+  wire [7:0] 			tlp_in_progress_payload_dw_count_plus;
+  reg 				ccix_rx_tlp_forwarded0_wire;
+  reg [5:0] 			ccix_rx_tlp_forwarded_length0_wire;
+  reg 				ccix_rx_tlp_forwarded1_wire;
+  reg 				ccix_rx_tlp_forwarded_length1_wire;
+
+ // State Machine states
+   localparam          NUM_STATES = 3;
+   localparam          IDLE_ST_WITH_STRADDLE = 2'd0;
+   localparam          CONTINUE_TLP_WITH_STRADDLE = 2'd1;
+   localparam          SEND_LAST_WORD_WITH_STRADDLE = 2'd2;
+
+  reg [NUM_STATES-1:0] 		state;
+  reg [NUM_STATES-1:0] 		next_state;
+
+
+  reg 				sync_load;
+  // Generate a load pulse to initialize flops synchronously
+  `XPREG(user_clk_ccix_i, reset_n_ccix_i, sync_load, 1'b0, 1'b1)
+
+    // Separate framing information from tuser inputs
+  assign       in_sop0_i = s_axis_ccix_rx_tuser_i[0];
+  assign       in_sop0_ptr_i = s_axis_ccix_rx_tuser_i[2:1];
+  assign       in_sop1_i = s_axis_ccix_rx_tuser_i[3];
+  assign       in_sop1_ptr_i = s_axis_ccix_rx_tuser_i[4];
+  assign       in_eop0_i = s_axis_ccix_rx_tuser_i[5];
+  assign       in_eop0_ptr_i = s_axis_ccix_rx_tuser_i[8:6];
+  assign       in_eop1_i = s_axis_ccix_rx_tuser_i[9];
+  assign       in_eop1_ptr_i = s_axis_ccix_rx_tuser_i[11:10];
+  assign       in_err_i = s_axis_ccix_rx_tuser_i[12];
+  assign       in_parity_i[31:0] = s_axis_ccix_rx_tuser_i[44:13];
+
+  // Keep track of a packet in progress on the write side
+  always @(*)
+    begin
+      write_tlp_in_progress_wire = write_tlp_in_progress;
+      if (link_down_reset_i)
+	write_tlp_in_progress_wire = 1'b0;
+      else if (s_axis_ccix_rx_tvalid_i)
+	begin
+          if (~write_tlp_in_progress)
+            // No TLP in progress, set flag if we get SOP0 with no EOP0, or sop1 with no eop1
+            write_tlp_in_progress_wire = (in_sop0_i & ~in_eop0_i) | (in_sop1_i & ~in_eop1_i);
+          else
+            begin
+              // TLP in progress.
+              if (in_err_i)
+		// Current TLP terminated with error.
+		// Set flag if we get SOP0 with no EOP0, or sop1 with no eop1
+		write_tlp_in_progress_wire = (in_sop0_i & ~in_eop0_i) | (in_sop1_i & ~in_eop1_i);
+              else
+		// Keep flag set if there is no EOP, or if we have EOP0 with another packet
+		// starting but not ending in this cycle.
+		write_tlp_in_progress_wire = ~in_eop0_i | (in_sop0_i & ~in_eop1_i) | in_sop1_i;
+            end // else: !if(~write_tlp_in_progress)
+	end // if (s_axis_ccix_rx_tvalid_i)
+    end // always @ (*)
+
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i,  write_tlp_in_progress, write_tlp_in_progress_wire, 1'b0)
+
+   // Set del_in_progress flag when FIFO becomes full until EOP is received
+   always @(*)
+     begin
+    del_in_progress_wire = del_in_progress;
+        if (link_down_reset_i)
+      del_in_progress_wire = 1'b0;
+    else if (fifo_full & s_axis_ccix_rx_tvalid_i)
+      begin
+         if (write_tlp_in_progress)
+           begin
+          if (~in_err_i)
+            begin
+               // Set flag if there is no EOP, or if there is an EOP but there is a new SOP with no EOP
+               if (~in_eop0_i | (in_sop0_i & ~in_eop1_i) | in_sop1_i)
+             del_in_progress_wire = 1'b1;
+               else
+             del_in_progress_wire = 1'b0;
+            end
+          else
+            // TLP terminated with error, check if there is a new TLP starting this cycle
+            // and there is no FIFO space available to write it.
+            begin
+               // Set flag if there is a new SOP with no EOP
+               if (((in_sop0_i & ~in_eop0_i) | (in_sop1_i & ~in_eop1_i)) &&
+               (free_word_count_plus_word_count_current_tlp[ADDRESS_WIDTH+2] ||
+                (free_word_count_plus_word_count_current_tlp[ADDRESS_WIDTH+1: 1] == 
+                 {(ADDRESS_WIDTH+1){1'b0}})))
+             del_in_progress_wire = 1'b1;
+               else
+             del_in_progress_wire = 1'b0;
+            end // else: !if(~in_err_i)
+           end // if (write_tlp_in_progress)
+         else
+           begin
+          // No TLP currently in progress.  Set flag id new TLP is continuing to next cycle
+                 if ((in_sop0_i & ~in_eop0_i) | (in_sop1_i & ~in_eop1_i)) 
+            del_in_progress_wire = 1'b1;
+          else
+            del_in_progress_wire = 1'b0;
+           end // else: !if(write_tlp_in_progress)
+      end // if (fifo_full & s_axis_ccix_rx_tvalid_i)
+    else
+      // Clear flag at the end of a packet when the FIFO is no longer full.
+      if (del_in_progress & ~fifo_full & s_axis_ccix_rx_tvalid_i &
+          (in_eop0_i | (in_err_i & ~((in_sop0_i & ~in_eop0_i) | (in_sop1_i & ~in_eop1_i)))))
+        del_in_progress_wire = 1'b0;
+     end // always @ (*)
+
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, del_in_progress, del_in_progress_wire, 1'b0)
+   
+   // Generate FIFO full condition
+   assign fifo_full = free_word_count_zero | free_tlp_count_zero;
+
+  // Signal an overflow if the FIFO is full or it the meta RAM is full and new data arrives.
+  // Once overflow is set, it is sticky until cleared by a reset.
+  always @(*)
+    begin
+      fifo_overflow_wire = ccix_rx_fifo_overflow_o;
+      if (link_down_reset_i)
+	fifo_overflow_wire = 1'b0;
+      else if ((s_axis_ccix_rx_tvalid_i & in_eop0_i & ~in_err_i & (fifo_full | del_in_progress)) ||
+               ((free_tlp_count[MAX_TLP_COUNT_BITS-1:1] == {MAX_TLP_COUNT_BITS-1{1'b0}}) &&
+		s_axis_ccix_rx_tvalid_i & in_eop1_i & ~in_err_i)) // 2 TLPs arrived when there is room for only 1
+	fifo_overflow_wire = 1'b1;
+    end
+  
+  `XPREG(user_clk_ccix_i, reset_n_ccix_i, ccix_rx_fifo_overflow_o, fifo_overflow_wire, 1'b0)
+
+   // Save write pointer and SOP offset at the start of a TLP
+   always @(*)
+     begin
+       write_ptr_saved_wire = write_ptr_saved;
+       write_tlp_offset_saved_wire = write_tlp_offset_saved;
+       if (link_down_reset_i)
+	 begin
+           write_ptr_saved_wire = {ADDRESS_WIDTH{1'b0}};
+           write_tlp_offset_saved_wire = 1'b0;
+	 end
+       else
+	 if (s_axis_ccix_rx_tvalid_i)
+           begin
+             if (write_tlp_in_progress)
+               begin
+		 if (in_err_i)
+		   // Current TLP in progress terminated with error.
+		   begin
+		     // write pointer and TLP offset will be rewound to their saved values
+		     if (~in_sop0_i)
+		       begin
+			 // No new TLP in this cycle, so keep the saved values unchanged
+		       end
+		     else
+		       begin
+			 // New TLP starting this cycle with SOP 0
+			 case(write_tlp_offset_saved)
+			   1'b0:
+			     begin
+			       if (in_eop0_i && ~in_eop1_i && ~in_eop0_ptr_i[2])
+				 // New TLP ended in the first half, change offset
+				 // to point to second half.
+				 write_tlp_offset_saved_wire = 1'b1;
+			       if ((in_eop0_i & in_eop0_ptr_i[2]) |
+				   in_eop1_i)
+				 // New TLP ended in the second half, increment saved pointer
+				 write_ptr_saved_wire = write_ptr_saved + {{ADDRESS_WIDTH-1{1'b0}}, 1'b1};
+			     end
+			   default:
+			     begin
+			       if (in_eop0_i)
+				 begin
+				   // New TLP ended in the second half, increment saved pointer
+				   write_ptr_saved_wire = write_ptr_saved + {{ADDRESS_WIDTH-1{1'b0}}, 1'b1};
+				   write_tlp_offset_saved_wire = 1'b0;
+				 end
+			     end
+			 endcase // case(write_tlp_offset_saved)
+		       end // else: !if(~in_sop0_i)
+		   end // if (in_err_i)
+		 else
+		   begin
+		     // TLP in progress, no error in this cycle.
+		     if (in_eop0_i && ~in_eop1_i && ~in_eop0_ptr_i[2])
+		       // New TLP ended in the first half, change offset
+		       // to point to second half.
+		       begin
+			 write_ptr_saved_wire = write_ptr;
+			 write_tlp_offset_saved_wire = 1'b1;
+		       end
+		     else if ((in_eop0_i & in_eop0_ptr_i[2]) |
+			      in_eop1_i)
+		       // New TLP ended in the second half
+		       begin
+			 write_ptr_saved_wire = write_ptr + {{ADDRESS_WIDTH-1{1'b0}}, 1'b1};
+			 write_tlp_offset_saved_wire = 1'b0;
+		       end
+		   end // else: !if(in_err_i)
+	       end // if (write_tlp_in_progress)
+	     else
+               // No TLP in progress from last cycle.
+               // The incoming TLP will be stored at the offset in  write_tlp_offset_saved.
+               begin
+		 case(write_tlp_offset_saved)
+		   1'b0:
+		     begin
+		       if (in_eop0_i && ~in_eop1_i && ~in_eop0_ptr_i[2])
+			 // New TLP ended in the first half, change offset
+			 // to point to second half.
+			 begin
+			   write_ptr_saved_wire = write_ptr;
+			   write_tlp_offset_saved_wire = 1'b1;
+			 end
+		       else if ((in_eop0_i & in_eop0_ptr_i[2]) |
+				in_eop1_i)
+			 // New TLP ended in the second half, increment write pointer
+			 write_ptr_saved_wire = write_ptr + {{ADDRESS_WIDTH-1{1'b0}}, 1'b1};
+		     end // case: 1'b0
+		   default:
+		     begin
+		       if (in_eop0_i)
+			 begin
+			   // New TLP ended in the second half, increment write pointer
+			   write_ptr_saved_wire = write_ptr + {{ADDRESS_WIDTH-1{1'b0}}, 1'b1};
+			   write_tlp_offset_saved_wire = 1'b0;
+			 end
+		     end
+		 endcase // case(write_tlp_offset_saved)
+               end // else: !if(write_tlp_in_progress)
+	   end // if (s_axis_ccix_rx_tvalid_i)
+     end // always @ (*)
+
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, write_ptr_saved, write_ptr_saved_wire, {ADDRESS_WIDTH{1'b0}})
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, write_tlp_offset_saved, write_tlp_offset_saved_wire, 1'b0)
+   
+   // Write pointer for FIFO
+   always @(*)
+     begin
+       write_ptr_wire = write_ptr;
+        if (link_down_reset_i)
+	  begin
+            write_ptr_wire = {ADDRESS_WIDTH{1'b0}};
+	  end
+	else
+	  if (s_axis_ccix_rx_tvalid_i)
+            begin
+              // Rewind write pointer on EOP under errors
+              if (write_tlp_in_progress & in_err_i) 
+		begin
+		  if (in_sop0_i & // New TLP beginning in this cycle
+		      (in_sop0_ptr_i[1] | // TLP begins in upper half
+		       ~in_eop0_i | // A new packet with no EOP in this cycle
+		       (in_eop0_i &  in_eop0_ptr_i[2]) | // TLP ends in Dwords 4-7.
+		       in_sop1_i)   // The word has two TLPs
+		      )
+		    write_ptr_wire = write_ptr_saved + {{ADDRESS_WIDTH-1{1'b0}}, 1'b1};
+		  else
+		    write_ptr_wire = write_ptr_saved;
+		end
+              else if (del_in_progress | fifo_full)
+		begin
+		  write_ptr_wire = write_ptr_saved;
+		end
+              else
+		// Increment write pointer when there is no more room to write in the current word.
+		begin
+		  if (write_tlp_in_progress)
+		    begin
+		      if (~in_eop0_i | // No EOP in this cycle
+			  (in_eop0_i & in_eop0_ptr_i[2]) |
+			  // The word has a single EOP and the TLP ends in Dwords 4-7.
+			  in_sop0_i)
+			// A new TLP is starting
+			write_ptr_wire = write_ptr + {{ADDRESS_WIDTH-1{1'b0}}, 1'b1};
+		    end
+		  else
+		    begin
+		      if (in_sop0_ptr_i[1] | // TLP begins in upper half
+			  ~in_eop0_i | // A new packet with no EOP in this cycle
+			  (in_eop0_i &  in_eop0_ptr_i[2]) | // TLP ends in Dwords 4-7.
+			  in_sop1_i)   // The word has two TLPs
+			write_ptr_wire = write_ptr + {{ADDRESS_WIDTH-1{1'b0}}, 1'b1};
+		    end // else: !if(write_tlp_in_progress)
+		end // if (~del_in_progress & ~fifo_full)
+	    end // if (s_axis_ccix_rx_tvalid_i)
+     end // always @ (*)
+   
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, write_ptr, write_ptr_wire, {ADDRESS_WIDTH{1'b0}})
+
+   // Write-side registers for the RAM interface
+
+   always @(*)
+     begin
+       ram_write_addr_wire = {ADDRESS_WIDTH{1'b0}};
+       if (s_axis_ccix_rx_tvalid_i &
+           ((~fifo_full & 
+             (~del_in_progress | in_sop0_i)) |
+            (write_tlp_in_progress & fifo_full & in_err_i & in_sop0_i)))
+	 begin
+           if (write_tlp_in_progress)
+             begin
+               if (in_err_i)
+		 // TLP will be written into the starting address of the last good TLP
+		 // at the offset 
+		 begin
+		   ram_write_addr_wire = write_ptr_saved;
+		 end
+               else
+		 // TLP will be written into the next address
+		 begin
+		   ram_write_addr_wire = write_ptr;
+		 end // else: !if(in_err_i)
+             end // if (write_tlp_in_progress)
+           else
+             // New TLP
+             begin
+               ram_write_addr_wire = write_ptr;
+             end // else: !if(write_tlp_in_progress)
+	 end // if (s_axis_ccix_rx_tvalid_i &...
+     end // always @ (*)
+
+   always @(*)
+     begin
+    ram_write_enable_wire = 2'b00;
+    if (link_down_reset_i)
+      begin
+        ram_write_enable_wire = 2'b00;
+      end
+       else if (s_axis_ccix_rx_tvalid_i &
+		((~fifo_full & 
+		  (~del_in_progress | in_sop0_i)) |
+		 (write_tlp_in_progress & fifo_full & in_err_i & in_sop0_i)))
+	 begin
+           if (write_tlp_in_progress)
+             begin
+               if (in_err_i)
+		 // TLP will be written into the starting address of the last good TLP
+		 // at the offset 
+		 begin
+		   if (~in_sop0_i)
+		     ram_write_enable_wire = 2'b00;
+		   else
+		     case(write_tlp_offset_saved)
+		       1'b0: ram_write_enable_wire = 2'b11;
+		       1'b1: ram_write_enable_wire = 2'b10;
+		     endcase // case(write_tlp_offset)
+		 end
+               else
+		 // TLP will be written into the next address
+		 begin
+		   ram_write_enable_wire = 2'b11;
+		 end // else: !if(in_err_i)
+             end // if (write_tlp_in_progress)
+           else
+             // New TLP
+             begin
+               if (in_sop0_ptr_i[1])
+		 ram_write_enable_wire = 2'b10;
+               else
+		 ram_write_enable_wire = 2'b11;
+	     end // else: !if(write_tlp_in_progress)
+	 end // if (s_axis_ccix_rx_tvalid_i &...
+       else
+	 ram_write_enable_wire = 2'b00;
+     end // always @ (*)
+
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, ram_write_addr, ram_write_addr_wire, {ADDRESS_WIDTH{1'b0}})
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, ram_write_enable[0], ram_write_enable_wire[0], 1'b0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, ram_write_enable[1], ram_write_enable_wire[1], 1'b0)
+
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, ram_write_data[127:0],
+      (attr_test_mode_pin_char_i? output_fifo_write_data_reg[127:0]:s_axis_ccix_rx_tdata_i[127:0]),
+      128'd0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, ram_write_data[255:128], 
+      (attr_test_mode_pin_char_i? output_fifo_write_data_reg[255:128]:s_axis_ccix_rx_tdata_i[255:128]),
+      128'd0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, ram_write_parity[15:0],
+      (attr_test_mode_pin_char_i? output_fifo_write_data_reg[256+15:256]:in_parity_i[15:0]),
+      16'd0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, ram_write_parity[31:16],
+      (attr_test_mode_pin_char_i? output_fifo_write_data_reg[256+31:256+16]:in_parity_i[31:16]),
+      16'd0)
+
+   generate
+     if (ADDRESS_WIDTH == 7)
+       begin
+         `XPREG(user_clk_ccix_i, reset_n_ccix_i, 
+		mi_rx_ccix_fifo_ram_write_address0_o, {2'b00, ram_write_addr_wire}, 
+		{ADDRESS_WIDTH{1'b0}})
+         `XPREG(user_clk_ccix_i, reset_n_ccix_i, 
+		mi_rx_ccix_fifo_ram_write_address1_o, {2'b00, ram_write_addr_wire}, 
+            {ADDRESS_WIDTH{1'b0}})
+       end
+     else // ADDRESS_WIDTH == 9
+       begin
+         `XPREG(user_clk_ccix_i, reset_n_ccix_i, 
+		mi_rx_ccix_fifo_ram_write_address0_o, 
+		(attr_tl_rx_ccix_fifo_ram_size_i? ram_write_addr_wire : {2'b00, ram_write_addr_wire}),
+		{ADDRESS_WIDTH{1'b0}})
+         `XPREG(user_clk_ccix_i, reset_n_ccix_i, 
+		mi_rx_ccix_fifo_ram_write_address1_o, 
+		(attr_tl_rx_ccix_fifo_ram_size_i? ram_write_addr_wire : {2'b00, ram_write_addr_wire}),
+		{ADDRESS_WIDTH{1'b0}})
+	   end // else: !if(ADDRESS_WIDTH == 7)
+   endgenerate
+
+   assign          mi_rx_ccix_fifo_ram_write_data0_o = {ram_write_parity[15:0], ram_write_data[127:0]};
+   assign          mi_rx_ccix_fifo_ram_write_data1_o = {ram_write_parity[31:16], ram_write_data[255:128]};
+   assign          mi_rx_ccix_fifo_ram_write_enable0_o = ram_write_enable[0];
+   assign          mi_rx_ccix_fifo_ram_write_enable1_o = ram_write_enable[1];
+
+   // Maintain free word count in FIFO for the sake of determining the FIFO full condition.
+   // the free word count is maintained in multiples of 128 bits.
+
+  assign          free_word_count_plus_word_count_current_tlp = free_word_count + {1'b0, word_count_current_tlp};
+
+   always @(*)
+     begin
+       free_word_count_wire = free_word_count;
+       free_word_count_zero_wire = free_word_count_zero;
+    if (link_down_reset_i)
+      begin
+        free_word_count_wire =  {1'b0, ram_capacity} - 
+                    {{(ADDRESS_WIDTH+2){1'b0}}, 1'b1};
+        free_word_count_zero_wire = 1'b0;
+      end
+    else if (s_axis_ccix_rx_tvalid_i)
+      begin
+        if (in_err_i & ~in_sop0_i)
+          begin
+            // Current TLP ended in error, and there is no TLP in this cycle.
+            // Restore the free word count to the value before the current TLP
+            if (read_data_valid_1 & read_full_word)
+              begin
+		// Full-word read
+		free_word_count_wire =  free_word_count_plus_word_count_current_tlp +
+					{{(ADDRESS_WIDTH+1){1'b0}}, 2'b10};
+		free_word_count_zero_wire = 1'b0;
+              end
+            else if (read_data_valid_1 & ~read_full_word)
+              // Half-word read
+              begin
+		free_word_count_wire =  free_word_count_plus_word_count_current_tlp +
+					{{(ADDRESS_WIDTH+2){1'b0}}, 1'b1};
+		free_word_count_zero_wire = 1'b0;
+              end
+            else
+              begin
+		// No read in this cycle
+		free_word_count_wire =  free_word_count_plus_word_count_current_tlp;
+		free_word_count_zero_wire = 1'b0;
+              end
+	  end // if (in_err_i & ~in_sop0_i)
+        else if ( // Cases where a full word is being written into the FIFO
+		  ((~fifo_full & ~del_in_progress) &
+		   (~write_tlp_in_progress & ~in_sop0_ptr_i[1] & 
+		    (~in_eop0_i | in_eop0_ptr_i[2] | in_sop1_i))) |
+		  // First word of a new TLP 
+		  (in_err_i & in_sop0_i & ~in_sop0_ptr_i[1] & 
+		   (~in_eop0_i | in_eop0_ptr_i[2] | in_sop1_i)) |
+		  // First word of a new TLP after an error
+		  ((~fifo_full & ~del_in_progress) &
+		   write_tlp_in_progress & ~in_err_i &
+		   (~in_eop0_i | in_eop0_ptr_i[2] | in_sop0_i)) 
+		  // New word of a continuing TLP
+		  )
+          begin
+            // Full-word write
+            if (read_data_valid_1 & read_full_word)
+              begin
+		// Full-word read
+		if (del_in_progress | in_err_i)
+		  begin
+		    free_word_count_wire =  free_word_count_plus_word_count_current_tlp;
+		    free_word_count_zero_wire = 1'b0;
+		  end
+              end
+            else if (read_data_valid_1 & ~read_full_word)
+              // Half-word read
+              begin
+		if (del_in_progress | in_err_i)
+		  begin
+		    free_word_count_wire =  free_word_count_plus_word_count_current_tlp 
+					    - {{ADDRESS_WIDTH+2{1'b0}}, 1'b1};
+		    // Set flag if (free_word_count + word_count_current_tlp <= 1)
+		    free_word_count_zero_wire = free_word_count_plus_word_count_current_tlp[ADDRESS_WIDTH+2] ||
+						(free_word_count_plus_word_count_current_tlp[ADDRESS_WIDTH+1: 1]
+						 == {(ADDRESS_WIDTH+1){1'b0}});
+		  end
+		else
+		  begin
+		    free_word_count_wire =  free_word_count - {{(ADDRESS_WIDTH+2){1'b0}}, 1'b1};
+		    // Set flag if (free_word_count <= 1)
+		    free_word_count_zero_wire = free_word_count[ADDRESS_WIDTH+2] ||
+						(free_word_count[ADDRESS_WIDTH+1: 1]
+						 == {(ADDRESS_WIDTH+1){1'b0}});
+		  end // else: !if(in_err_i)
+              end // if (read_data_valid_1 & ~read_full_word)
+            else
+              begin
+		// No data being read
+		if (del_in_progress | in_err_i)
+		  begin
+		    free_word_count_wire =  free_word_count_plus_word_count_current_tlp 
+					    - {{(ADDRESS_WIDTH+1){1'b0}}, 2'b10};
+		    // Set flag if (free_word_count + word_count_current_tlp <= 2)
+		    free_word_count_zero_wire = free_word_count_plus_word_count_current_tlp[ADDRESS_WIDTH+2] ||
+						((free_word_count_plus_word_count_current_tlp[ADDRESS_WIDTH+1: 2]
+						  == {ADDRESS_WIDTH{1'b0}}) &&
+						 (free_word_count_plus_word_count_current_tlp[1:0] != 2'b11));
+		  end
+		else
+		  begin
+                    free_word_count_wire =  free_word_count - {{(ADDRESS_WIDTH+1){1'b0}}, 2'b10};
+		    // Set flag if (free_word_count <= 2)
+		    free_word_count_zero_wire = free_word_count[ADDRESS_WIDTH+2] ||
+						((free_word_count[ADDRESS_WIDTH+1: 2] == {ADDRESS_WIDTH{1'b0}}) &&
+						 (free_word_count[1:0] != 2'b11));
+		  end // else: !if(in_err_i)
+              end // else: !if(read_data_valid_1 & ~read_full_word)
+          end // if (...
+        else if (
+		 // Cases where a half word is being written into the FIFO
+		 (~fifo_full & ~del_in_progress) |
+		 // Normal TLP being written
+		 (in_err_i & in_sop0_i & in_sop0_ptr_i[1]) |
+		 (in_err_i & in_sop0_i & in_eop0_i & ~in_eop0_ptr_i[2])
+		 )
+          begin
+            // Half-word write
+            if (read_data_valid_1 & read_full_word)
+              begin
+		// Full-word read
+		free_word_count_zero_wire = 1'b0;
+		if (del_in_progress | in_err_i)
+		  free_word_count_wire =  free_word_count_plus_word_count_current_tlp +
+					  {{ADDRESS_WIDTH+2{1'b0}}, 1'b1};
+		else
+		  free_word_count_wire =  free_word_count + {{ADDRESS_WIDTH+2{1'b0}}, 1'b1};
+              end
+            else if (read_data_valid_1 & ~read_full_word)
+              // Half-word read
+              begin
+		if (del_in_progress | in_err_i)
+		  begin
+		    free_word_count_wire =  free_word_count_plus_word_count_current_tlp;
+		    free_word_count_zero_wire = free_word_count_zero &&
+						(word_count_current_tlp == {ADDRESS_WIDTH+2{1'b0}});
+		  end
+              end
+            else
+              begin
+		// No data being read
+		if (del_in_progress | in_err_i)
+		  begin
+                    free_word_count_wire =  free_word_count_plus_word_count_current_tlp -
+					    {{(ADDRESS_WIDTH+2){1'b0}}, 1'b1};
+		    // Set flag if (free_word_count + word_count_current_tlp <= 1)
+		    free_word_count_zero_wire = free_word_count_plus_word_count_current_tlp[ADDRESS_WIDTH+2] ||
+						(free_word_count_plus_word_count_current_tlp[ADDRESS_WIDTH+1: 1]
+						 == {(ADDRESS_WIDTH+1){1'b0}});
+		  end
+		else
+		  begin
+		    free_word_count_wire =  free_word_count - {{(ADDRESS_WIDTH+2){1'b0}}, 1'b1};
+		    // Set flag if (free_word_count <= 1)
+		    free_word_count_zero_wire = free_word_count[ADDRESS_WIDTH+2] ||
+						(free_word_count[ADDRESS_WIDTH+1: 1] == {(ADDRESS_WIDTH+1){1'b0}});
+		  end
+              end // else: !if(read_data_valid_1 & ~read_full_word)
+	  end // if (...
+        else
+          begin
+            if (read_data_valid_1 & read_full_word)
+              begin
+		// Full-word read
+		free_word_count_wire =  free_word_count + {{(ADDRESS_WIDTH+1){1'b0}}, 2'b10};
+              end
+            else if (read_data_valid_1 & ~read_full_word)
+              // Half-word read
+              begin
+		free_word_count_wire =  free_word_count + {{(ADDRESS_WIDTH+2){1'b0}}, 1'b1};
+              end
+            else
+              begin
+              end // else: !if(read_data_valid_1 & ~read_full_word)
+          end // else: !if(~del_in_progress | (in_eop0_i & in_sop0_i & in_sop0_ptr_i[1]))
+      end // if (s_axis_ccix_rx_tvalid_i)
+    else
+      begin
+         // No data being written in this cycle
+        if (read_data_valid_1 & read_full_word)
+          // Full-word read
+          free_word_count_wire =  free_word_count + {{(ADDRESS_WIDTH+1){1'b0}}, 2'b10};
+        else if (read_data_valid_1 & ~read_full_word)
+          // Half-word read
+          free_word_count_wire =  free_word_count + {{(ADDRESS_WIDTH+2){1'b0}}, 1'b1};
+         
+        if (read_data_valid_1)
+          free_word_count_zero_wire = 1'b0;
+      end // else: !if(s_axis_ccix_rx_tvalid_i)
+     end // always @ (*)
+  
+  generate
+     if (RAM_WORD_COUNT == 512)
+       begin
+          assign ram_capacity = attr_tl_rx_ccix_fifo_ram_size_i? 11'd1024 : 11'd256;
+       end
+     else
+       begin
+          assign ram_capacity = 9'd256;
+       end
+   endgenerate
+
+   `XPLREG(user_clk_ccix_i, reset_n_ccix_i, sync_load, free_word_count,
+       free_word_count_wire, 10'd255,
+       {1'b0, ram_capacity} - {{(ADDRESS_WIDTH+2){1'b0}}, 1'b1})
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, free_word_count_zero, free_word_count_zero_wire, 1'b0)
+     assign free_word_count_le_one = (free_tlp_count[MAX_TLP_COUNT_BITS-1:1] == {MAX_TLP_COUNT_BITS-1{1'b0}});
+
+  // Keep track of the size of a TLP being received (in multiples of 128 bits)
+   always @(*)
+     begin
+    word_count_current_tlp_wire = word_count_current_tlp;
+    if (link_down_reset_i)
+      word_count_current_tlp_wire = {ADDRESS_WIDTH+2{1'b0}};
+    else if (s_axis_ccix_rx_tvalid_i &
+             ((~fifo_full & ~del_in_progress) | in_sop0_i))
+      begin
+        if (write_tlp_in_progress)
+          begin
+            if (in_err_i)
+              begin
+		// TLP ended in error, reset count
+		if (in_sop0_i & ~in_sop0_ptr_i[1] & ~in_eop0_i)
+		  // New TLP starting in lower half of word and continuing to next cycle
+		  word_count_current_tlp_wire = {{ADDRESS_WIDTH{1'b0}}, 2'b10};
+		else if (in_sop1_i & ~in_eop1_i)
+		  // New TLP starting in upper half of word and continuing to next cycle
+		  word_count_current_tlp_wire = {{ADDRESS_WIDTH+1{1'b0}}, 1'b1};
+		else if (in_sop0_i & in_sop0_ptr_i[1] & ~in_eop0_i)
+		  // New TLP starting in upper half of word and continuing to next cycle
+		  word_count_current_tlp_wire = {{ADDRESS_WIDTH+1{1'b0}}, 1'b1};
+	      end // if (in_err_i)
+            else
+              begin
+		if (~in_eop0_i)
+		  // TLP is continuing in this cycle, both halves of the word are valid
+		  word_count_current_tlp_wire = word_count_current_tlp + 
+						{{ADDRESS_WIDTH{1'b0}}, 2'b10};
+                else if (in_sop1_i)
+		  // This word has EOP0, SOP0, EOP1, SOP1
+		  word_count_current_tlp_wire = {ADDRESS_WIDTH+2{1'b0}};
+		else if (~in_eop1_i)
+		  // A TLP started with SOP0 and is continuing to next cycle
+		  begin
+		    if (in_eop0_ptr_i[2])
+		      // Previous TLP ended in the upper half, so do not count the upper half
+		      word_count_current_tlp_wire = {ADDRESS_WIDTH+2{1'b0}};
+                    else
+		      word_count_current_tlp_wire = {{ADDRESS_WIDTH+1{1'b0}}, 1'b1};
+		  end
+              end // else: !if(in_err_i)
+          end // if (write_tlp_in_progress)
+        else
+          // No TLP currently in progress
+          begin
+            if (in_sop1_i)
+              begin
+		// We have SOP0, EOP0, SOP1
+		if (in_eop0_ptr_i[2])
+		  // First TLP ended in the upper half, so do not count the upper half
+		  word_count_current_tlp_wire = {ADDRESS_WIDTH+2{1'b0}};
+                else
+		  word_count_current_tlp_wire = {{ADDRESS_WIDTH+1{1'b0}}, 1'b1};
+              end
+            else if (in_sop0_i)
+              begin
+		if (~in_sop0_ptr_i[1])
+		  word_count_current_tlp_wire = {{ADDRESS_WIDTH{1'b0}}, 2'b10};
+		else
+                  word_count_current_tlp_wire = {{ADDRESS_WIDTH+1{1'b0}}, 1'b1};
+              end
+          end // else: !if(write_tlp_in_progress)
+      end // if (s_axis_ccix_rx_tvalid_i &...
+     end // always @ (*)
+
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, word_count_current_tlp, word_count_current_tlp_wire, {ADDRESS_WIDTH+2{1'b0}})
+
+   // Maintain free TLP count in FIFO for the sake of determining the FIFO full condition.
+   
+   always @(*)
+     begin
+       free_tlp_count_wire = free_tlp_count;
+       free_tlp_count_zero_wire = free_tlp_count_zero;
+       
+       if (link_down_reset_i)
+	 begin
+           free_tlp_count_wire = MAX_TLP_COUNT;
+           free_tlp_count_zero_wire = 1'b0;
+	 end
+       else
+	 begin
+	   if (s_axis_ccix_rx_tvalid_i)
+             begin
+               if ((del_in_progress | fifo_full) &
+		   (in_err_i | in_eop0_i))
+		 begin
+		   // Discard current TLP in progress.  Accept any new TLP.
+		   if (in_err_i & in_eop1_i)
+		     // Two new TLPs in incoming beat
+		     begin
+		       if (read_data_valid_1 & read_eop0_1 & read_eop1_1)
+			 // Two TLPs being read out
+			 begin
+			 end
+		       else if (read_data_valid_1 & read_eop0_1)
+			 // Single TLP being read out
+			 begin
+			   free_tlp_count_wire = free_tlp_count - {{MAX_TLP_COUNT_BITS-1{1'b0}}, 1'b1};
+			   free_tlp_count_zero_wire = (free_tlp_count == {{MAX_TLP_COUNT_BITS-1{1'b0}}, 1'b1});
+			 end
+		       else
+			 // No TLP being read
+			 begin
+			   free_tlp_count_wire = free_tlp_count - {{MAX_TLP_COUNT_BITS-2{1'b0}}, 2'b10};
+			   free_tlp_count_zero_wire = (free_tlp_count == {{MAX_TLP_COUNT_BITS-2{1'b0}}, 2'b10});
+			 end // else: !if(read_data_valid_1 & read_eop0_1)
+		     end // if (in_err_i & in_eop1_i)
+		   else if ((in_err_i & in_eop0_i) | in_eop1_i)
+		     // One TLP being written
+		     begin
+		       if (read_data_valid_1 & read_eop0_1 & read_eop1_1)
+			 // Two TLPs being read out
+			 begin
+			   free_tlp_count_wire = free_tlp_count + {{MAX_TLP_COUNT_BITS-1{1'b0}}, 1'b1};
+			   free_tlp_count_zero_wire = 1'b0;
+			 end
+		       else if (read_data_valid_1 & read_eop0_1)
+			 // Single TLP being read out
+			 begin
+			 end
+		       else
+			 // No TLP being read
+			 begin
+			   free_tlp_count_wire = free_tlp_count - {{MAX_TLP_COUNT_BITS-1{1'b0}}, 1'b1};
+			   free_tlp_count_zero_wire = (free_tlp_count == {{MAX_TLP_COUNT_BITS-1{1'b0}}, 1'b1});
+			 end
+		     end // if ((in_err_i & in_eop0_i) | in_eop1_i)
+		   else
+		     // No TLP being written
+		     begin
+		       if (read_data_valid_1 & read_eop0_1 & read_eop1_1)
+			 // Two TLPs being read out
+			 begin
+			   free_tlp_count_wire = free_tlp_count + {{MAX_TLP_COUNT_BITS-2{1'b0}}, 2'b10};
+			   free_tlp_count_zero_wire = 1'b0;
+			 end
+		       else if (read_data_valid_1 & read_eop0_1)
+			 // Single TLP being read out
+			 begin
+			   free_tlp_count_wire = free_tlp_count + {{MAX_TLP_COUNT_BITS-1{1'b0}}, 1'b1};
+			   free_tlp_count_zero_wire = 1'b0;
+			 end
+		     end // else: !if(in_eop1_i)
+		 end // if ((del_in_progress | fifo_full) &...
+               else
+		 // Normal case
+		 if (in_eop0_i & in_eop1_i)
+		   // Two TLPs being written
+		   begin
+		     if (read_data_valid_1 & read_eop0_1 & read_eop1_1)
+		       // Two TLPs being read out
+		       begin
+		       end
+		     else if (read_data_valid_1 & read_eop0_1)
+		       // Single TLP being read out
+		       begin
+			 free_tlp_count_wire = free_tlp_count - {{MAX_TLP_COUNT_BITS-1{1'b0}}, 1'b1};
+			 free_tlp_count_zero_wire = (free_tlp_count == {{MAX_TLP_COUNT_BITS-1{1'b0}}, 1'b1});
+		       end
+		     else
+		       // No TLP being read
+                       begin
+			 free_tlp_count_wire = free_tlp_count - {{MAX_TLP_COUNT_BITS-2{1'b0}}, 2'b10};
+			 free_tlp_count_zero_wire = (free_tlp_count[MAX_TLP_COUNT_BITS-1:2] == {MAX_TLP_COUNT_BITS-2{1'b0}}) &&
+						    (free_tlp_count[1:0] != 2'b11);
+		       end // else: !if(read_data_valid_1 & read_eop0_1)
+		   end // if (in_eop0_i & in_eop1_i)
+		 else if (in_eop0_i | in_eop1_i)
+		   // Single TLP being written
+		   begin
+		     if (read_data_valid_1 & read_eop0_1 & read_eop1_1)
+		       // Two TLPs being read out
+		       begin
+			 free_tlp_count_wire = free_tlp_count + {{MAX_TLP_COUNT_BITS-1{1'b0}}, 1'b1};
+			 free_tlp_count_zero_wire = 1'b0;
+		       end
+		     else  if (read_data_valid_1 & read_eop0_1)
+		       // Single TLP being read out
+		       begin
+		       end
+		     else
+		       // No TLP being read
+                       begin
+			 free_tlp_count_wire = free_tlp_count - {{MAX_TLP_COUNT_BITS-1{1'b0}}, 1'b1};
+			 free_tlp_count_zero_wire = (free_tlp_count == {{MAX_TLP_COUNT_BITS-1{1'b0}}, 1'b1});
+		       end
+		   end // if (in_eop0_i | in_eop1_i)
+		 else
+		   // No TLP being written
+		   begin
+		     if (read_data_valid_1 & read_eop0_1 & read_eop1_1)
+		       // Two TLPs being read out
+		       begin
+			 free_tlp_count_wire = free_tlp_count + {{MAX_TLP_COUNT_BITS-2{1'b0}}, 2'b10};
+			 free_tlp_count_zero_wire = 1'b0;
+		       end
+		     else if (read_data_valid_1 & read_eop0_1)
+		       // Single TLP being read out
+		       begin
+			 free_tlp_count_wire = free_tlp_count + {{MAX_TLP_COUNT_BITS-1{1'b0}}, 1'b1};
+			 free_tlp_count_zero_wire = 1'b0;
+		       end
+		   end // else: !if(in_eop0_i | in_eop1_i)
+	     end // if (s_axis_ccix_rx_tvalid_i)
+           else
+             begin
+               if (read_data_valid_1 & read_eop0_1 & read_eop1_1)
+		 // Two TLPs being read out
+		 begin
+		   free_tlp_count_wire = free_tlp_count + {{MAX_TLP_COUNT_BITS-2{1'b0}}, 2'b10};
+		   free_tlp_count_zero_wire = 1'b0;
+		 end
+               else if (read_data_valid_1 & read_eop0_1)
+		 // Single TLP being read out
+		 begin
+		   free_tlp_count_wire = free_tlp_count + {{MAX_TLP_COUNT_BITS-1{1'b0}}, 1'b1};
+		   free_tlp_count_zero_wire = 1'b0;
+		 end
+	     end // else: !if(s_axis_ccix_rx_tvalid_i)
+	 end // else: !if(link_down_reset_i)
+     end // always @ (*)
+
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, free_tlp_count, free_tlp_count_wire, MAX_TLP_COUNT)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, free_tlp_count_zero, free_tlp_count_zero_wire, 1'b0)
+
+ //--------------------------------------------------------------------------------------------------------
+
+   // Generate delayed versions of write signals to keep track of read-side FIFO occupancy.
+   always @(*)
+     begin
+    single_tlp_write_wire = 1'b0;
+    dual_tlp_write_wire = 1'b0;
+    if (link_down_reset_i)
+      begin
+         single_tlp_write_wire = 1'b0;
+         dual_tlp_write_wire = 1'b0;
+      end
+    else if (s_axis_ccix_rx_tvalid_i &
+	     (del_in_progress | fifo_full) &
+             (in_err_i | in_eop0_i))
+      // A TLP ended with FIFO full.  Discard this TLP.
+      // If there is a new TLP in the incoming beat, accept them.
+      begin
+        if (in_err_i & in_eop1_i)
+          // Two new TLPs in incoming beat
+          begin
+            dual_tlp_write_wire = 1'b1;
+            single_tlp_write_wire = 1'b0;
+          end
+        else if ((in_err_i & in_eop0_i) | in_eop1_i)
+          // One new TLP in incoming beat
+          begin
+            dual_tlp_write_wire = 1'b0;
+            single_tlp_write_wire = 1'b1;
+          end
+        else
+          begin
+            dual_tlp_write_wire = 1'b0;
+            single_tlp_write_wire = 1'b0;
+          end // else: !if((in_err_i & in_eop0_i) | in_eop1_i)
+      end // if (s_axis_ccix_rx_tvalid_i &...
+       // Normal case
+    else if (s_axis_ccix_rx_tvalid_i &
+	     ~fifo_full & ~del_in_progress)
+        begin
+          dual_tlp_write_wire = in_eop1_i;
+          single_tlp_write_wire = in_eop0_i & ~in_eop1_i;
+        end
+    else
+      begin
+        single_tlp_write_wire = 1'b0;
+        dual_tlp_write_wire = 1'b0;
+      end // else: !if(s_axis_ccix_rx_tvalid_i &...
+     end // always @ (*)
+   
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, single_tlp_write, single_tlp_write_wire, 1'b0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, dual_tlp_write, dual_tlp_write_wire, 1'b0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, single_tlp_write1, single_tlp_write, 1'b0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, dual_tlp_write1, dual_tlp_write, 1'b0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, single_tlp_write2, single_tlp_write1, 1'b0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, dual_tlp_write2, dual_tlp_write1, 1'b0)
+
+     // Select delayed version of tlp_write signals when there is an external pipeline register
+     assign single_tlp_write_final = attr_tl_rx_ccix_fifo_to_ram_write_pipeline_i? single_tlp_write2: single_tlp_write1;
+     assign dual_tlp_write_final = attr_tl_rx_ccix_fifo_to_ram_write_pipeline_i? dual_tlp_write2: dual_tlp_write1;
+
+   // Keep track of FIFO occupancy for read side
+  always @(*)
+    begin
+      fifo_tlp_count_wire = fifo_tlp_count;
+      fifo_tlp_count_non_zero_wire = fifo_tlp_count_non_zero;
+      fifo_read_enable_wire = 1'b0;
+      if (link_down_reset_i)
+	begin
+          fifo_tlp_count_wire = {MAX_TLP_COUNT_BITS{1'b0}};
+          fifo_tlp_count_non_zero_wire = 1'b0;
+          fifo_read_enable_wire = 1'b0;
+	end
+      else
+	begin
+          if (dual_tlp_write_final)
+            // Two TLPs being written
+            begin
+              if (fifo_read_enable & read_eop0 & read_eop1)
+		// Two TLPs being read out
+		begin
+		  fifo_read_enable_wire = fifo_tlp_count_non_zero & ~output_fifo_almost_full;
+		end
+              else if (fifo_read_enable & read_eop0)
+		// Single TLP being read out
+		begin
+		  fifo_tlp_count_wire = fifo_tlp_count + {{MAX_TLP_COUNT_BITS-1{1'b0}}, 1'b1};
+		  fifo_tlp_count_non_zero_wire = 1'b1;
+		  fifo_read_enable_wire = ~output_fifo_almost_full;
+		end
+              else
+		// No TLP being read
+		begin
+		  fifo_tlp_count_wire = fifo_tlp_count + {{MAX_TLP_COUNT_BITS-2{1'b0}}, 2'b10};
+		  fifo_tlp_count_non_zero_wire = 1'b1;
+		  fifo_read_enable_wire = ~output_fifo_almost_full;
+		end // else: !if(fifo_read_enable & read_eop0)
+            end // if (dual_tlp_write_final)
+          else if (single_tlp_write_final)
+            // Single TLP being written
+            begin
+              if (fifo_read_enable & read_eop0 & read_eop1)
+		// Two TLPs being read out
+		begin
+		  fifo_tlp_count_wire = fifo_tlp_count - {{MAX_TLP_COUNT_BITS-1{1'b0}}, 1'b1};
+		  fifo_tlp_count_non_zero_wire = (fifo_tlp_count > {{MAX_TLP_COUNT_BITS-1{1'b0}}, 1'b1});
+		  fifo_read_enable_wire = (fifo_tlp_count > {{MAX_TLP_COUNT_BITS-1{1'b0}}, 1'b1}) &&
+					  (~output_fifo_almost_full);
+		end
+              else     if (fifo_read_enable & read_eop0)
+		// Single TLP being read out
+		begin
+		  fifo_read_enable_wire = fifo_tlp_count_non_zero & ~output_fifo_almost_full;
+		end
+              else
+		// No TLP being read
+		begin
+		  fifo_tlp_count_wire = fifo_tlp_count + {{MAX_TLP_COUNT_BITS-1{1'b0}}, 1'b1};
+		  fifo_tlp_count_non_zero_wire = 1'b1;
+		  fifo_read_enable_wire = ~output_fifo_almost_full;
+		end // else: !if(fifo_read_enable & read_eop0)
+            end // if (single_tlp_write_final)
+          else
+            // No TLP being written
+            begin
+              if (fifo_read_enable & read_eop0 & read_eop1)
+		// Two TLPs being read out
+		begin
+		  fifo_tlp_count_wire = fifo_tlp_count - {{MAX_TLP_COUNT_BITS-2{1'b0}}, 2'b10};
+		  fifo_tlp_count_non_zero_wire = (fifo_tlp_count > {{MAX_TLP_COUNT_BITS-2{1'b0}}, 2'b10});
+		  fifo_read_enable_wire = (fifo_tlp_count > {{MAX_TLP_COUNT_BITS-2{1'b0}}, 2'b10}) &&
+					  (~output_fifo_almost_full);
+		end
+              else     if (fifo_read_enable & read_eop0)
+		// Single TLP being read out
+		begin
+		  fifo_tlp_count_wire = fifo_tlp_count - {{MAX_TLP_COUNT_BITS-1{1'b0}}, 1'b1};
+		  fifo_tlp_count_non_zero_wire = (fifo_tlp_count > {{MAX_TLP_COUNT_BITS-1{1'b0}}, 1'b1});
+		  fifo_read_enable_wire = (fifo_tlp_count > {{MAX_TLP_COUNT_BITS-1{1'b0}}, 1'b1}) &&
+					  (~output_fifo_almost_full);
+		end
+              else
+		fifo_read_enable_wire = fifo_tlp_count_non_zero & ~output_fifo_almost_full;
+            end // else: !if(single_tlp_write_final)
+	end // else: !if(link_down_reset_i)
+    end // always @ (*)
+   
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, fifo_tlp_count, fifo_tlp_count_wire, {MAX_TLP_COUNT_BITS{1'b0}})
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, fifo_tlp_count_non_zero, fifo_tlp_count_non_zero_wire, 1'b0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, fifo_read_enable, fifo_read_enable_wire, 1'b0)
+   
+
+   // Write metadata for TLPs
+   assign meta_ram_write_data = {
+                 write_sop2,
+                 write_sop_prev,
+                 write_eop1_ptr[1:0], 
+                 write_eop1,
+                 write_sop1_ptr[1:0],
+                 write_sop1,
+                 write_eop0_ptr[2:0],
+                 write_sop0_ptr[1:0],
+                 ram_write_addr};
+     
+  // TLP Metadata fields:
+  // ram_write_addr:  Pointer to data RAM location where the ending Dword of the TLP is stored.
+  // write_sop0_ptr: Alignment of the first Dword of the TLP.
+  //                3: TLP started on Dword 6.  2: TLP started on Dword 4.
+  //                1: TLP started on Dword 2.  
+  //                0:  if write_sop_prev is 0, TLP started on Dword 0, otherwise it started on
+  //                    Dword 6 of the previous word.
+  // write_eop0_ptr: Alignment of the final Dword of the TLP (0 through 7) 
+  // write_sop1: When set, indicates that a second TLP starts in the same word.
+  // write_sop1_ptr: Alignment of the first Dword of the TLP signaled by write_sop1.
+  //                1:  TLP started on Dword 2. 2:  TLP started on Dword 4.
+  //                3:  TLP started on Dword 6.
+  // write_eop1: Indicates that a second TLP starts and ends in the same word.
+  // write_eop1_ptr: Alignment of the final Dword of the TLP signaled by write_eop1.
+  //                0:  TLP ended on Dword 4. 1:  TLP ended on Dword 5.
+  //                2:  TLP ended on Dword 6. 3:  TLP ended on Dword 7.
+  // write_sop_prev:  If this flag is set to 1, the first TLP started on Dword 6 of the word
+  //               in which the previous TLP ended.
+  // write_sop2:  When set, indicates that a third TLP is starting in Dword 6 of the word in which
+  //              the current TLP is ending.  This case corresponds to a beat in which a TLP is ending
+  //               with EOP0, a second TLP starts and ends with SOP0/EOP1, and a third TLP starts with SOP1.
+
+  always @(*)
+    begin
+      write_sop0_ptr_wire = 2'd0;
+      write_eop0_ptr_wire = 3'd0;
+      write_sop1_wire = 1'b0;
+      write_sop1_ptr_wire = 2'd0;
+      write_eop1_wire = 1'b0;
+      write_eop1_ptr_wire = 2'd0;
+      write_sop_prev_wire = 1'b0; // Indicates that the TLP began in the previous cycle at Dword 6
+      write_sop2_wire = 1'b0; 
+      write_meta_ram_tlp_in_progress_wire = write_meta_ram_tlp_in_progress; // A TLP that started on DW 6 position
+                                                                            // is currently in progress
+      meta_ram_write_enable_wire = 1'b0;
+      current_write_sop_ptr_wire = current_write_sop_ptr;
+      if (link_down_reset_i)
+	begin
+          write_meta_ram_tlp_in_progress_wire = 1'b0;
+	  meta_ram_write_enable_wire = 1'b0;
+	end // if (link_down_reset_i)
+      else if (s_axis_ccix_rx_tvalid_i &
+               ((~fifo_full & 
+		 (~del_in_progress | in_sop0_i)) |
+		(write_tlp_in_progress & fifo_full & in_err_i & in_sop0_i)))
+	begin
+          if (write_tlp_in_progress)
+            begin
+              if (in_err_i)
+		// TLP will be written into the starting address of the last good TLP
+		// at the offset 
+		begin
+		  write_meta_ram_tlp_in_progress_wire = in_eop0_ptr_i[2] & in_sop1_i & in_sop1_ptr_i;
+		  write_sop_prev_wire = 1'b0;
+                  write_sop2_wire = 1'b0;
+		  if (in_sop1_i)
+		    current_write_sop_ptr_wire = {1'b1, in_sop1_ptr_i};
+		  else
+		    current_write_sop_ptr_wire = in_sop0_ptr_i;
+		  
+		  if (~in_eop0_i)
+		    meta_ram_write_enable_wire = 1'b0;
+		  else
+		    case(write_tlp_offset_saved)
+		      1'b0:
+			begin
+			  write_sop0_ptr_wire = in_sop0_ptr_i;
+			  write_eop0_ptr_wire = in_eop0_ptr_i;
+			  write_sop1_wire = in_sop1_i;
+			  write_sop1_ptr_wire = {1'b1, in_sop1_ptr_i};
+			  write_eop1_wire = in_eop1_i;
+			  write_eop1_ptr_wire = in_eop1_ptr_i;
+			  meta_ram_write_enable_wire = 1'b1;
+			end // case: 1'b0
+		      1'b1:
+			begin
+			  // Write data into the upper half of the current word
+			  write_sop0_ptr_wire = in_sop0_ptr_i;
+			  write_eop0_ptr_wire = in_eop0_ptr_i;
+			  write_sop1_wire = 1'b0;
+			  write_sop1_ptr_wire = 2'd0;
+			  write_eop1_wire = 1'b0;
+			  write_eop1_ptr_wire = 2'd0;
+			  meta_ram_write_enable_wire = 1'b1;
+			end // case: 1'b1
+		    endcase // case(write_tlp_offset_saved)
+		end // if (in_err_i)
+              else
+		begin
+		  // TLP will be written into the next address
+		  if (in_eop0_i)
+		    write_meta_ram_tlp_in_progress_wire = (in_eop0_ptr_i[2] && in_sop0_i && 
+							   (in_sop0_ptr_i == 2'b11)) |
+							  in_sop1_i;
+		  write_sop_prev_wire = write_meta_ram_tlp_in_progress;
+		  if (in_eop0_i)
+		    begin
+		      if (in_sop1_i)
+			current_write_sop_ptr_wire = {1'b1, in_sop1_ptr_i};
+		      else if (in_sop0_i)
+			current_write_sop_ptr_wire = in_sop0_ptr_i;
+
+		      if (write_meta_ram_tlp_in_progress)
+			write_sop0_ptr_wire = 2'd0;
+		      else
+			write_sop0_ptr_wire = current_write_sop_ptr;
+		      write_eop0_ptr_wire = in_eop0_ptr_i;
+		      write_sop1_wire = in_sop0_i;
+		      write_sop1_ptr_wire = in_sop0_ptr_i[1:0];
+		      write_eop1_wire = in_eop1_i;
+		      write_eop1_ptr_wire = in_eop1_ptr_i;
+		      write_sop2_wire = in_sop1_i;
+		      meta_ram_write_enable_wire = 1'b1;
+		    end // if (in_eop0_i)
+		  else
+		    meta_ram_write_enable_wire = 1'b0;
+		end // else: !if(in_err_i)
+            end // if (write_tlp_in_progress)
+          else
+            // New TLP
+            begin
+              write_meta_ram_tlp_in_progress_wire = in_eop0_ptr_i[2] & in_sop1_i & in_sop1_ptr_i;
+              write_sop_prev_wire = 1'b0;
+              if (in_sop1_i)
+		current_write_sop_ptr_wire = {1'b1, in_sop1_ptr_i};
+              else
+		current_write_sop_ptr_wire = in_sop0_ptr_i;
+              if (in_eop0_i)
+		begin
+		  write_sop0_ptr_wire = in_sop0_ptr_i;
+		  write_eop0_ptr_wire = in_eop0_ptr_i;
+		  write_sop1_wire = in_sop1_i;
+		  write_sop1_ptr_wire = {1'b1, in_sop1_ptr_i};
+		  write_eop1_wire = in_eop1_i;
+		  write_eop1_ptr_wire = in_eop1_ptr_i;
+		  write_sop2_wire = 1'b0;
+		  meta_ram_write_enable_wire = 1'b1;
+		end // if (in_eop0_i)
+              else
+		meta_ram_write_enable_wire = 1'b0;
+            end // else: !if(write_tlp_in_progress)
+	end // if (in_data_valid & ~fifo_full &...
+      else
+	meta_ram_write_enable_wire = 1'b0;
+    end // always @ (*)
+
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, write_sop0_ptr, write_sop0_ptr_wire , 2'd0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, write_eop0_ptr, write_eop0_ptr_wire , 3'd0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, write_sop1, write_sop1_wire , 1'b0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, write_sop1_ptr, write_sop1_ptr_wire , 2'd0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, write_eop1, write_eop1_wire , 1'b0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, write_eop1_ptr, write_eop1_ptr_wire , 2'd0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, meta_ram_write_enable, meta_ram_write_enable_wire, 1'b0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, current_write_sop_ptr, current_write_sop_ptr_wire, 2'd0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, write_sop_prev, write_sop_prev_wire, 1'b0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, write_sop2, write_sop2_wire , 1'b0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, write_meta_ram_tlp_in_progress, write_meta_ram_tlp_in_progress_wire, 1'b0)
+
+   always @(*)
+     begin
+    meta_ram_write_ptr_wire = meta_ram_write_ptr;
+    if (link_down_reset_i)
+      meta_ram_write_ptr_wire = {MAX_TLP_COUNT_BITS-1{1'b0}};
+    else
+      if (meta_ram_write_enable)
+        meta_ram_write_ptr_wire = meta_ram_write_ptr + {{MAX_TLP_COUNT_BITS-2{1'b0}}, 1'b1};
+     end
+
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, meta_ram_write_ptr, meta_ram_write_ptr_wire, {MAX_TLP_COUNT_BITS-1{1'b0}})
+
+     // Set a flag to disable straddle temporarily on the read side when an error is detected.
+     // Save the FIFO occupancy at the time and count it down to zero when TLPs are dequeued.
+     // Enable straddle back when the count reaches zero.
+   always @(*)
+     begin
+       begin
+	 fifo_tlp_count_captured_on_err_wire = fifo_tlp_count_captured_on_err;
+	 suspend_straddle_on_err_wire = suspend_straddle_on_err;
+       end
+       if (link_down_reset_i)
+	 begin
+	   fifo_tlp_count_captured_on_err_wire = {MAX_TLP_COUNT_BITS+1{1'b0}};
+	   suspend_straddle_on_err_wire = 1'b0;
+	 end
+       else if (s_axis_ccix_rx_tvalid_i &
+		write_tlp_in_progress & in_err_i)
+	 begin
+	   // TLP being deleted from FIFO.
+	   // Set flag to suspend straddle for dequeue temporarily.
+	   suspend_straddle_on_err_wire = 1'b1;
+	   // Sample current occupancy
+	   fifo_tlp_count_captured_on_err_wire = {1'b0, fifo_tlp_count} + {{MAX_TLP_COUNT_BITS-2{1'b0}}, 3'd6};
+	 end
+       else
+	 begin
+	   // Decrement count on dequeueing a TLP.
+	   if (fifo_read_enable)
+             begin
+               if (read_eop0)
+		 begin
+		   if (read_eop1)
+		     fifo_tlp_count_captured_on_err_wire = fifo_tlp_count_captured_on_err - {{MAX_TLP_COUNT_BITS-1{1'b0}}, 2'b10};
+		   else
+		     fifo_tlp_count_captured_on_err_wire = fifo_tlp_count_captured_on_err - {{MAX_TLP_COUNT_BITS{1'b0}}, 1'b1};
+		 end
+             end
+	   if (fifo_tlp_count_captured_on_err[MAX_TLP_COUNT_BITS])
+             suspend_straddle_on_err_wire = 1'b0;
+	 end // else: !if(in_data_valid_i & write_tlp_in_progress & in_err_i)
+       
+     end // always @ (*)
+
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, fifo_tlp_count_captured_on_err, fifo_tlp_count_captured_on_err_wire,
+      {MAX_TLP_COUNT_BITS+1{1'b0}})
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, suspend_straddle_on_err, suspend_straddle_on_err_wire, 1'b0)
+
+   always @(posedge user_clk_ccix_i)
+     if (meta_ram_write_enable)
+       meta_ram[meta_ram_write_ptr] <=  meta_ram_write_data;
+   
+   //--------------------------------------------------------------------------------------------------------
+   // Read side of FIFO
+   //--------------------------------------------------------------------------------------------------------
+
+   assign meta_ram_read_data = meta_ram[meta_ram_read_ptr];
+   
+   assign read_eop0 = (meta_ram_read_data[ADDRESS_WIDTH-1:0] == read_ptr);
+   assign read_sop0_ptr = meta_ram_read_data[ADDRESS_WIDTH+1: ADDRESS_WIDTH];
+   assign read_eop0_ptr = meta_ram_read_data[ADDRESS_WIDTH+4: ADDRESS_WIDTH+2];
+   assign read_sop1 = meta_ram_read_data[ADDRESS_WIDTH+5];
+   assign read_sop1_ptr = meta_ram_read_data[ADDRESS_WIDTH+7: ADDRESS_WIDTH+6];
+   assign read_eop1 = meta_ram_read_data[ADDRESS_WIDTH+8];
+   assign read_eop1_ptr = meta_ram_read_data[ADDRESS_WIDTH+10: ADDRESS_WIDTH+9];
+   assign read_sop_prev = meta_ram_read_data[ADDRESS_WIDTH+11];
+   assign read_sop2 = meta_ram_read_data[ADDRESS_WIDTH+12];
+
+   // Second TLP eligible to read if its EOP is in the current word, or if the FIFO has more than 2 TLPs
+
+   assign read_second_tlp = read_eop0 & read_sop1 & 
+	  (read_eop1 |
+	   ((|fifo_tlp_count[MAX_TLP_COUNT_BITS-1:1]) & ~suspend_straddle_on_err));
+
+   assign read_metadata = {read_second_tlp, read_sop2, read_sop_prev, read_eop1_ptr, read_eop1, read_sop1_ptr, read_sop1,
+                read_eop0_ptr, read_eop0, read_sop0_ptr};
+
+   // FIFO read pointer
+   always @(*)
+     begin
+       read_ptr_wire = read_ptr;
+       read_tlp_offset_wire = read_tlp_offset;
+        if (link_down_reset_i)
+      begin
+        read_ptr_wire = {ADDRESS_WIDTH{1'b0}};
+        read_tlp_offset_wire = 1'b0;
+      end
+    else
+      if (fifo_read_enable)
+        begin
+          if (~read_eop0 | (read_eop0 & (read_eop0_ptr[2] | read_eop1)) |
+              (read_eop0 & read_sop1 & (|fifo_tlp_count[MAX_TLP_COUNT_BITS-1:1]) &
+               ~suspend_straddle_on_err) |
+              // Read a full word if the current TLP is ending and 
+              // there are at least 2 TLPs in the FIFO.
+              read_tlp_offset)
+            begin
+              read_ptr_wire = read_ptr + {{ADDRESS_WIDTH-1{1'b0}}, 1'b1};
+              read_tlp_offset_wire = 1'b0;
+            end
+          else
+            read_tlp_offset_wire = 1'b1;
+	end // if (fifo_read_enable)
+     end // always @ (*)
+  
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, read_ptr, read_ptr_wire, {ADDRESS_WIDTH{1'b0}})
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, read_tlp_offset, read_tlp_offset_wire, 1'b0)
+          
+   generate
+     if (ADDRESS_WIDTH == 7)
+       begin
+         `XPREG(user_clk_ccix_i, reset_n_ccix_i,
+		mi_rx_ccix_fifo_ram_read_address0_o, {2'b00, read_ptr_wire}, 
+		{ADDRESS_WIDTH{1'b0}})
+         `XPREG(user_clk_ccix_i, reset_n_ccix_i,
+		mi_rx_ccix_fifo_ram_read_address1_o, {2'b00, read_ptr_wire}, 
+		{ADDRESS_WIDTH{1'b0}})
+        end
+     else // ADDRESS_WIDTH == 9
+       begin
+         `XPREG(user_clk_ccix_i,reset_n_ccix_i,
+		mi_rx_ccix_fifo_ram_read_address0_o, 
+		(attr_tl_rx_ccix_fifo_ram_size_i? read_ptr_wire : {2'b00, read_ptr_wire}),
+		{ADDRESS_WIDTH{1'b0}})
+         `XPREG(user_clk_ccix_i, reset_n_ccix_i,
+		mi_rx_ccix_fifo_ram_read_address1_o, 
+		(attr_tl_rx_ccix_fifo_ram_size_i? read_ptr_wire : {2'b00, read_ptr_wire}),
+		{ADDRESS_WIDTH{1'b0}})
+	   end // else: !if(ADDRESS_WIDTH == 7)
+     endgenerate
+
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i,
+	  mi_rx_ccix_fifo_ram_read_enable0_o,
+	  fifo_read_enable_wire, 1'b0)
+
+   // When reading from the same address as the write, suppress read enable to the
+   // upper half of the RAM.
+
+  wire fifo_read_enable_upper_wire;
+  assign fifo_read_enable_upper_wire = fifo_read_enable_wire &&
+                                   ~((ram_write_addr_wire == read_ptr_wire) &&
+                                     ram_write_enable_wire[1]);
+
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, mi_rx_ccix_fifo_ram_read_enable1_o,
+	  fifo_read_enable_upper_wire, 1'b0)
+
+   // Metadata RAM read pointer
+   always @(*)
+     begin
+        meta_ram_read_ptr_wire = meta_ram_read_ptr;
+        if (link_down_reset_i)
+      meta_ram_read_ptr_wire = {MAX_TLP_COUNT_BITS-1{1'b0}};
+    else if (fifo_read_enable & read_eop0)
+      meta_ram_read_ptr_wire = meta_ram_read_ptr + {{MAX_TLP_COUNT_BITS-2{1'b0}}, 1'b1};
+     end
+   
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, meta_ram_read_ptr, meta_ram_read_ptr_wire, {MAX_TLP_COUNT_BITS-1{1'b0}})
+           
+   // Read data from RAM becomes valid 2 or 3 cycles after starting the read, depending on whether an extra
+   // register is present in the read pipeline.
+   always @(*)
+     begin
+    read_data_valid_1_wire = 1'b0;
+    read_data_valid_2_wire = 1'b0;
+    read_data_valid_3_wire = 1'b0;
+    read_data_valid_wire = 1'b0;
+
+    if (link_down_reset_i)
+      begin
+         read_data_valid_1_wire = 1'b0;
+         read_data_valid_2_wire = 1'b0;
+         read_data_valid_3_wire = 1'b0;
+         read_data_valid_wire = 1'b0;
+      end
+    else
+      begin
+         read_data_valid_1_wire = fifo_read_enable;
+         read_data_valid_2_wire = read_data_valid_1;
+         read_data_valid_3_wire = read_data_valid_2;
+         read_data_valid_wire = attr_tl_rx_ccix_fifo_to_ram_read_pipeline_i? 
+                    (attr_tl_rx_ccix_fifo_from_ram_read_pipeline_i? read_data_valid_3: read_data_valid_2):
+                    (attr_tl_rx_ccix_fifo_from_ram_read_pipeline_i? read_data_valid_2: read_data_valid_1);
+      end
+     end // always @ (*)
+         
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, read_data_valid_1,  read_data_valid_1_wire, 1'b0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, read_data_valid_2,  read_data_valid_2_wire, 1'b0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, read_data_valid_3,  read_data_valid_3_wire, 1'b0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, read_data_valid,  read_data_valid_wire, 1'b0)
+
+   assign read_metadata_1_wire = read_metadata;
+   assign read_metadata_2_wire = read_metadata_1;
+   assign read_metadata_3_wire = read_metadata_2;
+   assign read_metadata_out_wire = attr_tl_rx_ccix_fifo_to_ram_read_pipeline_i?
+      (attr_tl_rx_ccix_fifo_from_ram_read_pipeline_i? read_metadata_3 : read_metadata_2):
+      (attr_tl_rx_ccix_fifo_from_ram_read_pipeline_i? read_metadata_2 : read_metadata_1);
+   
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i,  read_metadata_1, read_metadata_1_wire, 15'd0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i,  read_metadata_2, read_metadata_2_wire, 15'd0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i,  read_metadata_3, read_metadata_3_wire, 15'd0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i,  read_metadata_out, read_metadata_out_wire, 15'd0)
+   
+   assign read_eop0_1 =  read_metadata_1[2];
+   assign read_eop1_1 =  read_metadata_1[9];   
+
+   always @(*)
+     begin
+    read_in_progress_wire = read_in_progress;
+    if (link_down_reset_i)
+      read_in_progress_wire = 1'b0;
+    else
+      if (~read_in_progress)
+        begin
+          if (fifo_read_enable &
+              (~read_eop0 | // First TLP continuing to next beat
+               (read_eop0 & read_sop1 & (|fifo_tlp_count[MAX_TLP_COUNT_BITS-1:1]) &
+		~suspend_straddle_on_err & ~read_eop1)
+               // Second TLP continuing to next beat
+               ))
+            read_in_progress_wire = 1'b1;
+        end
+      else
+        begin
+          if (fifo_read_enable & read_eop0 &
+              ~(read_sop1 & (|fifo_tlp_count[MAX_TLP_COUNT_BITS-1:1]) &
+		~suspend_straddle_on_err & ~read_eop1))
+            read_in_progress_wire = 1'b0;
+        end // else: !if(~read_in_progress)
+     end // always @ (*)
+
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, read_in_progress, read_in_progress_wire, 1'b0)
+
+     // Keep track of the ending offset of the last TLP.  If a new TLP overlaps with the previous TLP
+     // in the first half of the word, this helps avoid double-counting.
+   always @(*)
+     begin
+       last_read_tlp_eop_ptr_wire = last_read_tlp_eop_ptr;
+       if (link_down_reset_i)
+     last_read_tlp_eop_ptr_wire = 2'b11;
+       else if (fifo_read_enable & read_eop0)
+     begin
+       if (read_eop1)
+         last_read_tlp_eop_ptr_wire = {1'b1, read_eop1_ptr[1]};
+       else
+         last_read_tlp_eop_ptr_wire = read_eop0_ptr[2:1];
+     end
+     end // always @ (*)
+  
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i,  last_read_tlp_eop_ptr, last_read_tlp_eop_ptr_wire, 2'b11)
+
+   always @(*)
+     begin
+    read_full_word_wire = 1'b0;
+    if (read_in_progress)
+      begin
+        read_full_word_wire = ~read_eop0 | read_eop0_ptr[2] | read_eop1 |
+			      // Read a full word if the current TLP is ending and there are at least 2 TLPs in the FIFO.
+			      (read_eop0 & read_sop1 & (|fifo_tlp_count[MAX_TLP_COUNT_BITS-1:1]) &
+			       ~suspend_straddle_on_err);
+      end
+    else
+      begin
+        if (last_read_tlp_eop_ptr == 2'b00)
+          // Last TLP ended at DW 1, so the first half of this word is already counted.
+          // Count only the upper half.
+          read_full_word_wire = 1'b0;
+        else
+          read_full_word_wire = ~read_sop0_ptr[1] & (~read_eop0 |  read_eop0_ptr[2] | read_eop1 |
+       // Read a full word if the current TLP is ending and there are at least 2 TLPs in the FIFO.
+						     (read_eop0 & read_sop1 & 
+						      (|fifo_tlp_count[MAX_TLP_COUNT_BITS-1:1]) &
+						      ~suspend_straddle_on_err));
+      end // else: !if(read_in_progress)
+     end // always @ (*)
+
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i,  read_full_word, read_full_word_wire, 1'b0)
+
+   //--------------------------------------------------------------------------------------------------------
+   // Output FIFO
+   //--------------------------------------------------------------------------------------------------------
+
+     assign output_fifo_write_data_wire = {read_metadata_out[14:0],
+                       mi_rx_ccix_fifo_ram_err_uncor_i[5:0],
+                       mi_rx_ccix_fifo_ram_err_cor_i[5:0],
+                       mi_rx_ccix_fifo_ram_read_data1_i[143:128],
+                       mi_rx_ccix_fifo_ram_read_data0_i[143:128],
+                       mi_rx_ccix_fifo_ram_read_data1_i[127:0],
+                       mi_rx_ccix_fifo_ram_read_data0_i[127:0]
+                       };
+   
+  // Capture read data from RAMs
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, output_fifo_write_data_reg[127:0],
+      output_fifo_write_data_wire[127:0], 128'd0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, output_fifo_write_data_reg[255:128],
+      output_fifo_write_data_wire[255:128], 128'd0)
+  // Capture read parity from RAMs
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, output_fifo_write_data_reg[256+15:256],
+      output_fifo_write_data_wire[256+15:256], 16'd0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, output_fifo_write_data_reg[256+31:256+16],
+      output_fifo_write_data_wire[256+31:256+16], 16'd0)
+  // Capture correctable error from RAMs
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, output_fifo_write_data_reg[256+32+2:256+32],
+      output_fifo_write_data_wire[256+32+2:256+32], 3'd0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, output_fifo_write_data_reg[256+32+5:256+32+3],
+      output_fifo_write_data_wire[256+32+5:256+32+3], 3'd0)
+  // Capture uncorrectable error from RAMs
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, output_fifo_write_data_reg[256+32+8:256+32+6],
+      output_fifo_write_data_wire[256+32+8:256+32+6], 3'd0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, output_fifo_write_data_reg[256+32+11:256+32+9],
+      output_fifo_write_data_wire[256+32+11:256+32+9], 3'd0)
+   // Register metadata
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, output_fifo_write_data_reg[256+32+12+14:256+32+12],
+      output_fifo_write_data_wire[256+32+12+14:256+32+12], 15'd0)
+
+   //`XPREG(user_clk_ccix_i, reset_n_ccix_i, output_fifo_write_data_reg, output_fifo_write_data_wire, 326'd0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, read_data_valid_reg, read_data_valid, 1'b0)
+
+  assign output_fifo_write_data[287:0] = output_fifo_write_data_reg[287:0]; // Data
+  assign output_fifo_write_data[288] = |output_fifo_write_data_reg[290:288]; // Correctable Error Low
+  assign output_fifo_write_data[289] = |output_fifo_write_data_reg[293:291]; // Correctable Error High
+  assign output_fifo_write_data[290] = |output_fifo_write_data_reg[296:294]; // Uncorrectable Error Low
+  assign output_fifo_write_data[291] = |output_fifo_write_data_reg[299:297]; // Uncorrectable Error High
+  assign output_fifo_write_data[292+15-1:292] = output_fifo_write_data_reg[314:300]; // Metadata
+
+   always @(posedge user_clk_ccix_i)
+     if (read_data_valid_reg)
+       output_fifo_ram[output_fifo_write_ptr] <= output_fifo_write_data;
+
+   always @(*)
+     begin
+    output_fifo_write_ptr_wire = output_fifo_write_ptr;
+    if (link_down_reset_i)
+      output_fifo_write_ptr_wire = 4'd0;
+    else if (read_data_valid_reg)
+      begin
+         if (output_fifo_write_ptr == OUTPUT_FIFO_DEPTH-1)
+           output_fifo_write_ptr_wire = 4'd0;
+         else
+           output_fifo_write_ptr_wire = output_fifo_write_ptr_wire + 4'd1;
+      end
+     end // always @ (*)
+
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, output_fifo_write_ptr, output_fifo_write_ptr_wire, 4'd0)
+
+   always @(*)
+     begin
+    output_fifo_read_ptr_wire = output_fifo_read_ptr;
+    if (link_down_reset_i)
+      output_fifo_read_ptr_wire = 4'd0;
+    else if (output_fifo_read_active)
+      begin
+         if (output_fifo_read_ptr == OUTPUT_FIFO_DEPTH-1)
+           output_fifo_read_ptr_wire = 4'd0;
+         else
+           output_fifo_read_ptr_wire = output_fifo_read_ptr_wire + 4'd1;
+      end
+     end // always @ (*)
+   
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, output_fifo_read_ptr, output_fifo_read_ptr_wire, 4'd0)
+
+    // Keep track of TLP count in Output FIFO to determine empty status
+   always @(*)
+     begin
+    output_fifo_word_count_wire = output_fifo_word_count;
+    output_fifo_non_empty_wire = output_fifo_non_empty;
+    if (link_down_reset_i)
+      begin
+         output_fifo_word_count_wire = 4'd0;
+         output_fifo_non_empty_wire = 1'b0;
+      end
+    else if (read_data_valid_reg & ~output_fifo_read_active)
+      begin
+         output_fifo_word_count_wire = output_fifo_word_count + 4'd1;
+         output_fifo_non_empty_wire = 1'b1;
+      end
+    else if (~read_data_valid_reg & output_fifo_read_active)
+      begin
+         output_fifo_word_count_wire = output_fifo_word_count - 4'd1;
+         output_fifo_non_empty_wire = (output_fifo_word_count > 4'd1);
+      end
+     end // always @ (*)
+
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, output_fifo_word_count, output_fifo_word_count_wire, 4'd0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, output_fifo_non_empty, output_fifo_non_empty_wire, 1'b0)
+
+    // Determine Output FIFO occupancy including the TLPs in flight on the read path.
+   always @(*)
+     begin
+    output_fifo_exp_word_count_wire = output_fifo_exp_word_count;
+    output_fifo_almost_full_wire = output_fifo_almost_full;
+    if (link_down_reset_i)
+      begin
+         output_fifo_exp_word_count_wire = 4'd0;
+         output_fifo_almost_full_wire = 1'b0;
+      end
+    else if (fifo_read_enable & ~output_fifo_read_active)
+      begin
+         output_fifo_exp_word_count_wire = output_fifo_exp_word_count + 4'd1;
+         output_fifo_almost_full_wire = (output_fifo_exp_word_count >=
+                         (OUTPUT_FIFO_HIGH_THRESHOLD-1));
+      end
+    else if (~fifo_read_enable & output_fifo_read_active)
+      begin
+         output_fifo_exp_word_count_wire = output_fifo_exp_word_count - 4'd1;
+         output_fifo_almost_full_wire = (output_fifo_exp_word_count >=
+                         (OUTPUT_FIFO_HIGH_THRESHOLD+1));
+      end
+     end // always @ (*)
+
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, output_fifo_exp_word_count, output_fifo_exp_word_count_wire, 4'd0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, output_fifo_almost_full, output_fifo_almost_full_wire, 1'b0)
+
+   assign output_fifo_read_word = output_fifo_ram[output_fifo_read_ptr];
+   assign output_fifo_read_data = output_fifo_read_word[255:0];
+   assign output_fifo_read_parity = output_fifo_read_word[256+31:256];
+   assign output_fifo_read_sop0_ptr =  output_fifo_read_word[288+4+1: 288+4];
+   assign output_fifo_read_eop0 =      output_fifo_read_word[288+4+2];
+   assign output_fifo_read_eop0_ptr =  output_fifo_read_word[288+4+5: 288+4+3];
+   assign output_fifo_read_sop1 =      output_fifo_read_word[288+4+6];
+   assign output_fifo_read_sop1_ptr =  output_fifo_read_word[288+4+8: 288+4+7];
+   assign output_fifo_read_eop1 =      output_fifo_read_word[288+4+9];
+   assign output_fifo_read_eop1_ptr =  output_fifo_read_word[288+4+11: 288+4+10];
+  assign  output_fifo_read_sop_prev =  output_fifo_read_word[288+4+12];
+  assign  output_fifo_read_sop2 =      output_fifo_read_word[288+4+13];
+  assign  output_fifo_read_second_tlp =      output_fifo_read_word[288+4+14];
+  assign output_fifo_read_correctable_error = output_fifo_read_word[288+1:288];
+  assign output_fifo_read_uncorrectable_error = output_fifo_read_word[288+3:288+2];
+
+   //--------------------------------------------------------------------------------------------------------
+   // Output State Machine
+   //--------------------------------------------------------------------------------------------------------
+
+   always @(*)
+     begin
+       // out_data_wire = out_data_o;
+       // out_parity_wire = out_parity_o;
+       out_data_mux_sel0_wire = out_data_mux_sel0;
+       out_data_mux_sel1_wire = out_data_mux_sel1;
+       out_data_mux_sel2_wire = out_data_mux_sel2;
+       out_data_mux_sel3_wire = out_data_mux_sel3;
+
+    out_sop0_wire = out_sop0_o;
+    out_sop0_ptr_wire = out_sop0_ptr_o;
+    out_eop0_wire = out_eop0_o;
+    out_eop0_ptr_wire = out_eop0_ptr_o;
+    out_err0_wire = out_err0_o;
+    out_sop1_wire = out_sop1_o;
+    out_eop1_wire = out_eop1_o;
+    out_eop1_ptr_wire = out_eop1_ptr_o;
+    out_err1_wire = out_err1_o;
+    out_tlp_alignment_wire = out_tlp_alignment;
+
+    saved_read_uncorrectable_error_wire = saved_read_uncorrectable_error;
+    saved_read_uncorrectable_error1_wire = saved_read_uncorrectable_error1;
+    saved_read_uncorrectable_error2_wire = saved_read_uncorrectable_error2;
+    saved_read_data_wire = saved_read_data;
+    saved_read_parity_wire = saved_read_parity;
+    saved_read_sop_wire = saved_read_sop;
+    saved_read_eop_wire = saved_read_eop;
+    saved_read_eop_ptr_wire = saved_read_eop_ptr;
+    saved_read_eop1_ptr_wire = saved_read_eop1_ptr;
+    saved_read_sop1_wire = saved_read_sop1;
+    saved_read_sop1_ptr_wire = saved_read_sop1_ptr;
+
+    case(1'b1)
+      state[IDLE_ST_WITH_STRADDLE]:
+        begin
+           if (ccix_app_ready)
+         begin
+            out_sop0_wire = 1'b1;
+            out_sop0_ptr_wire = 1'b0;
+
+            case(output_fifo_read_sop0_ptr)
+              2'd0:
+            begin
+              if (output_fifo_read_sop_prev)
+                // TLP started in DW 6 of the previous word, so use the first two Dwords saved.
+                begin
+                  // out_data_wire[127:0] = {output_fifo_read_data[63:0], saved_read_data[63:0]};
+                  // out_parity_wire[15:0] = {output_fifo_read_parity[7:0], saved_read_parity[7:0]};
+                  out_data_mux_sel0_wire = 2'b11;
+                  out_data_mux_sel1_wire = 3'b000;
+                end
+              else
+                begin
+                  // out_data_wire[127:0] = output_fifo_read_data[127:0];
+                  // out_parity_wire[15:0] = output_fifo_read_parity[15:0];
+                   out_data_mux_sel0_wire = 2'b00;
+                   out_data_mux_sel1_wire = 3'b001;
+                end
+
+              if (output_fifo_read_sop_prev)
+                begin
+                  if (output_fifo_read_eop0 &&
+                  (output_fifo_read_eop0_ptr[2:1] == 2'd0) &&
+                  output_fifo_read_sop1 &&
+                  (output_fifo_read_sop1_ptr == 2'd2))
+                // First TLP ended in first half of the outgoing word and there is
+                // a second TLP starting at QW 2 of the incoming word.
+                begin
+                  // out_data_wire[255:128] = output_fifo_read_data[255:128];
+                  // out_parity_wire[31:16] = output_fifo_read_parity[31:16];
+                  out_data_mux_sel2_wire = 3'b010;
+                  out_data_mux_sel3_wire = 3'b011;
+                end
+                  else
+                begin
+                  // out_data_wire[255:128] = output_fifo_read_data[191:64];
+                  // out_parity_wire[31:16] = output_fifo_read_parity[23:8];
+                  out_data_mux_sel2_wire = 3'b001;
+                  out_data_mux_sel3_wire = 3'b010;
+                end // else: !if(output_fifo_read_eop0 &&...
+                end // if (output_fifo_read_sop_prev)
+              else
+                begin
+                  // out_data_wire[255:128] = output_fifo_read_data[255:128];
+                  // out_parity_wire[31:16] = output_fifo_read_parity[31:16];
+                  out_data_mux_sel2_wire = 3'b010;
+                  out_data_mux_sel3_wire = 3'b011;
+                end // else: !if(output_fifo_read_sop_prev)
+              
+               out_sop0_wire = 1'b1;
+
+              if (output_fifo_read_sop_prev)
+                begin
+                  if (output_fifo_read_eop0 && (output_fifo_read_eop0_ptr[2:1] <= 2'd2))
+                begin
+                  out_eop0_wire = 1'b1;
+                       out_eop0_ptr_wire = output_fifo_read_eop0_ptr + 3'd2;
+                  if (~output_fifo_read_eop0_ptr[2])
+                    out_err0_wire = saved_read_uncorrectable_error | 
+                                       output_fifo_read_uncorrectable_error[0];
+                  else
+                    out_err0_wire = saved_read_uncorrectable_error | 
+                           (|output_fifo_read_uncorrectable_error[1:0]);
+                end // if (output_fifo_read_eop0 && (output_fifo_read_eop0_ptr[2:1] <= 2'd2))
+                  else
+                begin
+                  out_eop0_wire = 1'b0;
+                  out_eop0_ptr_wire = 3'd0;
+                  out_err0_wire = 1'b0;
+                end // else: !if(output_fifo_read_eop0 && (output_fifo_read_eop0_ptr[2:1] <= 2'd2))
+                end // if (output_fifo_read_sop_prev)
+              else
+                begin
+                  out_eop0_wire = output_fifo_read_eop0;
+                  if (output_fifo_read_eop0)
+                out_eop0_ptr_wire = output_fifo_read_eop0_ptr;
+                  else
+                out_eop0_ptr_wire = 3'd0;
+                  if (~output_fifo_read_eop0)
+                out_err0_wire = 1'b0;
+                  else
+                    begin
+                      if (~output_fifo_read_eop0_ptr[2])
+			out_err0_wire = output_fifo_read_uncorrectable_error[0];
+                      else
+			out_err0_wire = |output_fifo_read_uncorrectable_error[1:0];
+                    end // else: !if(output_fifo_read_sop_prev)
+                end // else: !if(output_fifo_read_sop_prev)
+
+              if (output_fifo_read_sop_prev)
+                begin
+                  if (output_fifo_read_eop0 &&
+                  (output_fifo_read_eop0_ptr[2:1] == 2'd0) &&
+                  (output_fifo_read_eop1 | output_fifo_read_second_tlp) &&
+                  output_fifo_read_sop1 &&
+                  (output_fifo_read_sop1_ptr <= 2'd2))
+                // Second TLP starting at QW 1 or 2 of the incoming word.
+                begin
+                  out_sop1_wire = 1'b1;
+                  if (output_fifo_read_eop1 &&
+                      ((output_fifo_read_sop1_ptr == 2'd2) ||
+                       ~output_fifo_read_eop1_ptr[1]))
+                    begin
+                      out_eop1_wire = 1'b1;
+                      out_eop1_ptr_wire = output_fifo_read_eop1_ptr[0];
+                      if (output_fifo_read_sop1_ptr == 2'd2)
+                    out_err1_wire = output_fifo_read_uncorrectable_error[1];
+                      else
+                    out_err1_wire = |output_fifo_read_uncorrectable_error[1:0];
+                    end
+                  else
+                    begin
+                      out_eop1_wire = 1'b0;
+                      out_eop1_ptr_wire = 1'b0;
+                      out_err1_wire = 1'b0;
+                    end // else: !if(output_fifo_read_eop1 &&...
+                end // if (output_fifo_read_eop0 &&...
+                  else
+                begin
+                  out_sop1_wire = 1'b0;
+                  out_eop1_wire = 1'b0;
+                  out_eop1_ptr_wire = 1'b0;
+                  out_err1_wire = 1'b0;
+                end // else: !if(output_fifo_read_eop0 &&...
+                end // if (output_fifo_read_sop_prev)
+              else
+                begin
+                  if (output_fifo_read_eop0 &&
+                  (output_fifo_read_eop0_ptr[2:1] <= 2'd1) &&
+                  output_fifo_read_sop1 &&
+                  (output_fifo_read_eop1 | output_fifo_read_second_tlp) &&
+                  (output_fifo_read_sop1_ptr == 2'd2))
+                // Second TLP starting at QW  2 of the incoming word.
+                begin
+                  out_sop1_wire = 1'b1;
+                  if (output_fifo_read_eop1)
+                    begin
+                      out_eop1_wire = 1'b1;
+                      out_eop1_ptr_wire = output_fifo_read_eop1_ptr[0];
+                      out_err1_wire = output_fifo_read_uncorrectable_error[1];
+                    end
+                  else
+                    begin
+                      out_eop1_wire = 1'b0;
+                      out_eop1_ptr_wire = 1'b0;
+                      out_err1_wire = 1'b0;
+                    end // else: !if(output_fifo_read_eop1 &&...
+                end // if (output_fifo_read_eop0 &&...
+                  else
+                begin
+                  out_sop1_wire = 1'b0;
+                  out_eop1_wire = 1'b0;
+                  out_eop1_ptr_wire = 1'b0;
+                  out_err1_wire = 1'b0;
+                end // else: !if(output_fifo_read_eop0 &&...
+                end // else: !if(output_fifo_read_sop_prev)
+            end // case: 2'd0
+              
+              2'd1:
+            begin
+              // out_data_wire = {64'd0, output_fifo_read_data[255:64]};
+              // out_parity_wire = {8'd0, output_fifo_read_parity[31:8]};
+              out_data_mux_sel0_wire = 2'b01;
+              out_data_mux_sel1_wire = 3'b010;
+              out_data_mux_sel2_wire = 3'b011;
+              out_data_mux_sel3_wire = 3'b000;
+
+               if (output_fifo_read_eop0)
+                 begin
+                out_sop0_wire = 1'b1;
+                out_eop0_wire = 1'b1;
+                out_eop0_ptr_wire = output_fifo_read_eop0_ptr - 3'd2;
+                out_err0_wire = |output_fifo_read_uncorrectable_error[1:0];
+                 end
+               else
+                 begin
+                out_sop0_wire = 1'b0;
+                out_eop0_wire = 1'b0;
+                out_eop0_ptr_wire = 3'd0;
+                out_err0_wire = 1'b0;
+                 end // else: !if(output_fifo_read_eop0)
+              out_sop1_wire = 1'b0;
+              out_eop1_wire = 1'b0;
+              out_eop1_ptr_wire = 1'b0;
+              out_err1_wire = 1'b0;
+            end // case: 2'd1
+              2'd2:
+            begin
+              // out_data_wire = {128'd0, output_fifo_read_data[255:128]};
+              // out_parity_wire = {16'd0, output_fifo_read_parity[31:16]};
+              out_data_mux_sel0_wire = 2'b10;
+              out_data_mux_sel1_wire = 3'b011;
+              out_data_mux_sel2_wire = 3'b000;
+              out_data_mux_sel3_wire = 3'b000;
+
+               if (output_fifo_read_eop0)
+                 begin
+                out_sop0_wire = 1'b1;
+                out_eop0_wire = 1'b1;
+                out_eop0_ptr_wire = {1'b0, output_fifo_read_eop0_ptr[1:0]};
+                out_err0_wire = output_fifo_read_uncorrectable_error[1];
+                 end
+               else
+                 begin
+                out_sop0_wire = 1'b0;
+                out_eop0_wire = 1'b0;
+                out_eop0_ptr_wire = 3'd0;
+                out_err0_wire = 1'b0;
+                 end // else: !if(output_fifo_read_eop0)
+              out_sop1_wire = 1'b0;
+              out_eop1_wire = 1'b0;
+              out_eop1_ptr_wire = 1'b0;
+              out_err1_wire = 1'b0;
+            end // case: 2'd2
+              default:
+            begin
+               out_sop0_wire = 1'b0;
+               out_eop0_wire = 1'b0;
+               out_eop0_ptr_wire = 3'd0;
+               out_err0_wire = 1'b0;
+              out_sop1_wire = 1'b0;
+              out_eop1_wire = 1'b0;
+              out_eop1_ptr_wire = 1'b0;
+              out_err1_wire = 1'b0;
+            end
+            endcase // case(output_fifo_read_sop0_ptr)
+
+           // Save the starting position of the current TLP in progress
+            if (~output_fifo_read_eop0)
+              begin
+             if (output_fifo_read_sop_prev &&
+                 (output_fifo_read_sop0_ptr == 2'd0))
+               out_tlp_alignment_wire = 2'd3;
+             else
+               out_tlp_alignment_wire = output_fifo_read_sop0_ptr;
+              end
+            else
+              // If there is a second TLP, set the starting position to its SOP pointer
+              if (output_fifo_read_sop1 &
+              (output_fifo_read_eop1 | output_fifo_read_second_tlp))
+            case(output_fifo_read_sop1_ptr)
+              2'd1:
+                begin
+                  out_tlp_alignment_wire = 2'd3;
+                end
+              2'd2:
+                begin
+                  if ((output_fifo_read_sop0_ptr == 2'd0) &&
+                  output_fifo_read_sop_prev &&
+                  (output_fifo_read_eop0_ptr[2:1] == 2'd1))
+                // 3 QW TLP.
+                // Save entire second TLP for next cycle
+                      out_tlp_alignment_wire = 2'd2;
+                  else
+                // 2 QW TLP.
+                out_tlp_alignment_wire = 2'd0;
+                end
+              default:
+                begin
+                  out_tlp_alignment_wire = 2'd3;
+                end
+            endcase // case(output_fifo_read_sop1_ptr)
+              else
+		out_tlp_alignment_wire = 2'd3;
+            
+           // Save data for next cycle
+                if (output_fifo_non_empty)
+             begin
+               if (output_fifo_read_eop0)
+             begin
+                if (output_fifo_read_sop1 && (output_fifo_read_sop1_ptr == 2'd2))
+                  // Save entire second TLP
+                  begin
+                 saved_read_data_wire[127:0] = output_fifo_read_data[255:128];
+                 saved_read_parity_wire[15:0] = output_fifo_read_parity[31:16];
+                  end
+                else
+                  // Save last QW
+                  begin
+                 saved_read_data_wire[63:0] = output_fifo_read_data[255:192];
+                 saved_read_parity_wire[7:0] = output_fifo_read_parity[31:24];
+                  end
+             end // if (output_fifo_read_eop0)
+               else
+             begin
+               case(output_fifo_read_sop0_ptr)
+                 2'd1:
+                   begin
+                 saved_read_data_wire = output_fifo_read_data[255:64];
+                 saved_read_parity_wire = output_fifo_read_parity[31:8];
+                   end
+                 2'd2:
+                   begin
+                 saved_read_data_wire = {64'd0, output_fifo_read_data[255:128]};
+                 saved_read_parity_wire = {8'd0, output_fifo_read_parity[31:16]};
+                   end
+                 default:
+                   begin
+                 saved_read_data_wire = {128'd0, output_fifo_read_data[255:192]};
+                 saved_read_parity_wire = {16'd0, output_fifo_read_parity[31:24]};
+                   end
+               endcase // case(output_fifo_read_sop0_ptr)
+             end // else: !if(output_fifo_read_eop0)
+               
+               // Save SOP pointer
+            if (~output_fifo_read_eop0)
+              begin
+                 if (output_fifo_read_sop0_ptr == 2'd0)
+                   // First word of TLP will be sent out this cycle
+                   saved_read_sop_wire = 1'b0;
+                 else
+                   // Only 3 QWs or less of the TLP available, save them for next cycle
+                   saved_read_sop_wire = 1'b1;
+              end
+            else
+              if (output_fifo_read_eop0 &&
+                  (output_fifo_read_eop1 | output_fifo_read_second_tlp) &&
+                  output_fifo_read_sop1 &&
+                  ((output_fifo_read_sop1_ptr == 2'd3) ||
+                   ((output_fifo_read_sop1_ptr == 2'd2) && 
+                output_fifo_read_sop_prev && (output_fifo_read_eop0_ptr[2:1] == 2'd1))))
+                // Second TLP must be saved for next cycle
+                saved_read_sop_wire = 1'b1;
+              else
+                saved_read_sop_wire = 1'b0;
+
+            saved_read_sop1_wire = 1'b0;
+            saved_read_sop1_ptr_wire = 2'd0;
+
+               // Save EOP
+               if (output_fifo_read_eop0 &&
+               (output_fifo_read_eop1 | output_fifo_read_second_tlp) &&
+               output_fifo_read_sop1)
+             begin
+               // Second TLP starting
+                if ((output_fifo_read_sop1_ptr == 2'd2) && 
+                output_fifo_read_sop_prev && (output_fifo_read_eop0_ptr[2:1] == 2'd1))
+                  // Save entire second TLP for next cycle
+                  begin
+                 saved_read_eop_wire = output_fifo_read_eop1;
+                 saved_read_eop_ptr_wire = {1'b1, output_fifo_read_eop1_ptr} - 
+                               {output_fifo_read_sop1_ptr, 1'b0};
+                  end
+                else
+                  // Save last QW of second TLP
+                  begin
+                       saved_read_eop_wire = output_fifo_read_eop1;
+                 saved_read_eop_ptr_wire = {2'b00, output_fifo_read_eop1_ptr[0]};
+                  end // else: !if((output_fifo_read_sop1_ptr == 2'd2) &&...
+             end // if (output_fifo_read_eop0 &&...
+               else
+             begin
+               // Single TLP being read out from FIFO.
+               // If it has an EOP, this TLP will be completely sent out 
+               // unless it has
+               // a saved QW from last cycle and it is a 5QW TLP.
+               // In that case, save its last QW and send in next cycle.
+               if ((output_fifo_read_sop0_ptr == 2'd0) &&
+                   output_fifo_read_sop_prev)
+                 begin
+                   saved_read_eop_wire = output_fifo_read_eop0;
+                   saved_read_eop_ptr_wire = {2'b00, output_fifo_read_eop0_ptr[0]};
+                 end
+               else
+                 begin
+                   saved_read_eop_wire = 1'b0;
+                   saved_read_eop_ptr_wire = 3'd0;
+                 end // else: !if((output_fifo_read_sop0_ptr == 2'd0) &&...
+             end // else: !if(output_fifo_read_eop0 &&...
+               
+            saved_read_eop1_ptr_wire = 1'b0;
+
+            // Save ECC error from this cycle
+            if (output_fifo_read_eop0 &&
+                (output_fifo_read_eop1 | output_fifo_read_second_tlp) &&
+                output_fifo_read_sop1)
+              begin
+                 // Second TLP starting
+                 if (output_fifo_read_sop1_ptr == 2'd1)
+                   saved_read_uncorrectable_error_wire = |output_fifo_read_uncorrectable_error[1:0];
+                 else
+                   saved_read_uncorrectable_error_wire = output_fifo_read_uncorrectable_error[1];
+              end
+            else
+              case(output_fifo_read_sop0_ptr)
+                2'd0: saved_read_uncorrectable_error_wire = |output_fifo_read_uncorrectable_error[1:0];
+                2'd1: saved_read_uncorrectable_error_wire = |output_fifo_read_uncorrectable_error[1:0];
+                default: saved_read_uncorrectable_error_wire = output_fifo_read_uncorrectable_error[1];
+              endcase // case(output_fifo_read_sop0_ptr)
+            saved_read_uncorrectable_error1_wire = 1'b0;
+            saved_read_uncorrectable_error2_wire = 1'b0;
+             end // if (output_fifo_non_empty)
+	 end // if (ccix_app_ready)
+        end // case: state[IDLE_ST_WITH_STRADDLE]
+
+      state[CONTINUE_TLP_WITH_STRADDLE]:
+        begin
+           // There is a TLP in progress at the FIFO output.  The current word at the FIFO output
+           // is a continuation of a previous TLP.
+          if (ccix_app_ready)
+        begin
+          case(out_tlp_alignment)
+            2'd0:
+              begin
+            // out_data_wire[63:0] = output_fifo_read_data[63:0];
+            // out_parity_wire[7:0] = output_fifo_read_parity[7:0];
+            out_data_mux_sel0_wire = 2'b00;
+
+            if (output_fifo_read_eop0 &&
+                (output_fifo_read_eop0_ptr[2:1] == 2'd0))
+              begin
+                // out_data_wire[127:64] = 64'd0;
+                // out_parity_wire[15:8] = 8'd0;
+                out_data_mux_sel1_wire = 3'b000;
+              end
+            else
+              begin
+                // out_data_wire[127:64] = output_fifo_read_data[127:64];
+                // out_parity_wire[15:8] = output_fifo_read_parity[15:8];
+                out_data_mux_sel1_wire = 3'b001;
+              end // else: !if(output_fifo_read_eop0 &&...
+             if (output_fifo_read_eop0 && (output_fifo_read_eop0_ptr[2:1] <= 2'd1))
+              // TLP ending in the first half
+              begin
+                if (output_fifo_read_sop1 &&
+                (output_fifo_read_eop1 | output_fifo_read_second_tlp))
+                  begin
+                case(output_fifo_read_sop1_ptr)
+                  2'd1:
+                    begin
+                      // out_data_wire[255:128] = output_fifo_read_data[191:64];
+                      // out_parity_wire[31:16] = output_fifo_read_parity[23:8];
+                       out_data_mux_sel2_wire = 3'b001;
+                       out_data_mux_sel3_wire = 3'b010;
+                    end
+                  default:
+                    begin
+                      // out_data_wire[255:128] = output_fifo_read_data[255:128];
+                      // out_parity_wire[31:16] = output_fifo_read_parity[31:16];
+                      out_data_mux_sel2_wire = 3'b010;
+                      out_data_mux_sel3_wire = 3'b011;
+                    end
+                endcase // case(output_fifo_read_sop1_ptr)
+                  end // if (output_fifo_read_sop1 &&...
+                else
+                  begin
+                // out_data_wire[255:128] = output_fifo_read_data[255:128];
+                // out_parity_wire[31:16] = output_fifo_read_parity[31:16];
+                out_data_mux_sel2_wire = 3'b010;
+                out_data_mux_sel3_wire = 3'b011;
+                  end // else: !if(output_fifo_read_sop1 &&...
+              end // if (output_fifo_read_eop0 && (output_fifo_read_eop0_ptr[2:1] <= 2'd1))
+            else
+              begin
+                // out_data_wire[255:128] = output_fifo_read_data[255:128];
+                // out_parity_wire[31:16] = output_fifo_read_parity[31:16];
+                out_data_mux_sel2_wire = 3'b010;
+                out_data_mux_sel3_wire = 3'b011;
+              end // else: !if(output_fifo_read_sop1 &&...
+
+            out_eop0_wire = output_fifo_read_eop0;
+            out_eop0_ptr_wire = output_fifo_read_eop0_ptr;
+
+            if (~output_fifo_read_eop0)
+              out_err0_wire = 1'b0;
+            else if (~output_fifo_read_eop0_ptr[2])
+              out_err0_wire = saved_read_uncorrectable_error | 
+                      output_fifo_read_uncorrectable_error[0];
+            else
+              out_err0_wire = saved_read_uncorrectable_error | 
+                      (|output_fifo_read_uncorrectable_error[1:0]);
+            
+            if (output_fifo_read_eop0 && (output_fifo_read_eop0_ptr[2:1] <= 2'd1) &&
+              // TLP ending in the first half
+                output_fifo_read_sop1 &&
+                (output_fifo_read_eop1 | output_fifo_read_second_tlp) &&
+                // New TLP ready to be sent
+                (output_fifo_read_sop1_ptr <= 2'd2))
+              begin
+                 out_sop0_wire = 1'b1;
+                 out_sop0_ptr_wire = 1'b1;
+                if (output_fifo_read_eop1 &&
+                (~output_fifo_read_eop1_ptr[1] ||
+                 (output_fifo_read_sop1_ptr == 2'd2)))
+                  begin
+                out_eop1_wire = 1'b1;
+                out_eop1_ptr_wire = output_fifo_read_eop1_ptr[0];
+                 if (~output_fifo_read_eop1)
+                   out_err1_wire = 1'b0;
+                 else
+                   if (output_fifo_read_sop1_ptr == 2'd2)
+                     out_err1_wire = output_fifo_read_uncorrectable_error[1];
+                   else
+                     out_err1_wire = |output_fifo_read_uncorrectable_error[1:0];
+                  end
+                else
+                  begin
+                out_eop1_wire = 1'b0;
+                out_eop1_ptr_wire = 1'b0;
+                out_err1_wire = 1'b0;
+                  end // else: !if(output_fifo_read_eop1 &&...
+              end // if (output_fifo_read_eop0 && (output_fifo_read_eop0_ptr[2:1] <= 2'd1) &&...
+            else
+              begin
+                 out_sop0_wire = 1'b0;
+                 out_sop0_ptr_wire = 1'b0;
+                 out_eop1_wire = 1'b0;
+                 out_eop1_ptr_wire = 1'b0;
+                 out_err1_wire = 1'b0;
+              end // else: !if(output_fifo_read_eop0 && (output_fifo_read_eop0_ptr[2:1] <= 2'd1) &&...
+             out_sop1_wire = 1'b0;
+              end // case: 2'd0
+
+            2'd1:
+              begin
+             // Three Qwords of data saved from last cycle.
+             // The Qwords can be:
+             // DATA DATA DATA
+             // DATA EOP SOP
+             // EOP SOP DATA
+             // SOP DATA DATA
+             // SOP EOP SOP
+            // out_data_wire[63:0] = saved_read_data[63:0];
+            // out_parity_wire[7:0] = saved_read_parity[7:0];
+            out_data_mux_sel0_wire = 2'b11;
+
+            if (saved_read_eop &&
+                (saved_read_eop_ptr[2:1] == 2'd0))
+              begin
+                // out_data_wire[127:64] = 64'd0;
+                // out_parity_wire[15:8] = 8'd0;
+                out_data_mux_sel1_wire = 3'b000;
+              end
+            else
+              begin
+                // out_data_wire[127:64] = saved_read_data[127:64];
+                // out_parity_wire[15:8] = saved_read_parity[15:8];
+                out_data_mux_sel1_wire = 3'b100;
+              end // else: !if(output_fifo_read_eop0 &&...
+            if (saved_read_eop)
+              // TLP ending in the first half
+              begin
+                if (saved_read_sop1)
+                  begin
+                 case(saved_read_sop1_ptr)
+                  2'd1:
+                    begin
+                       // Saved data = EOP SOP DATA.
+                       // Send saved data and de-assert ready.
+                      // out_data_wire[255:128] = saved_read_data[191:64];
+                      // out_parity_wire[31:16] = saved_read_parity[23:8];
+                       out_data_mux_sel2_wire = 3'b100;
+                       out_data_mux_sel3_wire = 3'b100;
+                    end
+                  default: // 2'd2
+                    begin
+                      // out_data_wire[255:128] = {output_fifo_read_data[63:0],
+                      // saved_read_data[191:128]};
+                      // out_parity_wire[31:16] = {output_fifo_read_parity[7:0],
+                      // saved_read_parity[23:16]};
+                       out_data_mux_sel2_wire = 3'b101;
+                       out_data_mux_sel3_wire = 3'b000;
+                    end
+                endcase // case(saved_read_sop1_ptr)
+                  end // if (saved_read_sop1)
+                else
+                  begin
+                // out_data_wire[255:128] = {output_fifo_read_data[63:0],
+                // saved_read_data[191:128]};
+                // out_parity_wire[31:16] = {output_fifo_read_parity[7:0],
+                // saved_read_parity[23:16]};
+                out_data_mux_sel2_wire = 3'b101;
+                out_data_mux_sel3_wire = 3'b000;
+                  end // else: !if(saved_read_sop1)
+              end // if (saved_read_eop)
+            else
+              begin
+                // out_data_wire[255:128] = {output_fifo_read_data[63:0],
+                // saved_read_data[191:128]};
+                // out_parity_wire[31:16] = {output_fifo_read_parity[7:0],
+                // saved_read_parity[23:16]};
+                out_data_mux_sel2_wire = 3'b101;
+                out_data_mux_sel3_wire = 3'b000;
+              end // else: !if(saved_read_eop && (saved_read_eop_ptr[2:1] <= 2'd1))
+
+            if (saved_read_eop ||
+                (output_fifo_read_eop0 && (output_fifo_read_eop0_ptr[2:1] == 2'd0)))
+              begin
+                out_eop0_wire = 1'b1;
+                if (saved_read_eop)
+                  out_eop0_ptr_wire = saved_read_eop_ptr;
+                else
+                  out_eop0_ptr_wire = {2'b11, output_fifo_read_eop0_ptr[0]};
+
+                if (saved_read_eop)
+                  // saved data = // EOP SOP DATA or SOP EOP SOP
+                 out_err0_wire = saved_read_uncorrectable_error;
+                 else if (output_fifo_read_eop0 && (output_fifo_read_eop0_ptr[2:1] == 2'd0))
+                   out_err0_wire = saved_read_uncorrectable_error | 
+                                               output_fifo_read_uncorrectable_error[0];
+                 else
+                   out_err0_wire = 1'b0;
+              end // if (saved_read_eop ||...
+            else
+              begin
+                out_eop0_wire = 1'b0;
+                out_eop0_ptr_wire = 3'd0;
+                out_err0_wire = 1'b0;
+              end
+
+            out_sop0_wire = saved_read_sop | saved_read_sop1;
+            if (saved_read_sop)
+              out_sop0_ptr_wire = 1'b0;
+            else if (saved_read_sop1)
+              out_sop0_ptr_wire = 1'b1;
+            else
+              out_sop0_ptr_wire = 1'b0;
+
+             if (saved_read_sop && saved_read_sop1 &&
+                 (saved_read_sop1_ptr == 2'd2))
+               // saved data = SOP EOP SOP
+               out_sop1_wire = 1'b1;
+             else
+               out_sop1_wire = 1'b0;
+               
+             if (saved_read_sop1 &&
+                 (saved_read_sop1_ptr == 2'd2))
+               // saved data = SOP EOP SOP or DATA EOP SOP
+               begin
+                  if (output_fifo_read_eop0 &&
+                  (output_fifo_read_eop0_ptr[2:1] == 2'd0))
+                begin
+                   out_eop1_wire = 1'b1;
+                   out_eop1_ptr_wire = output_fifo_read_eop0_ptr[0];
+                   out_err1_wire = saved_read_uncorrectable_error1 |
+                           output_fifo_read_uncorrectable_error[0];
+                end
+                  else
+                begin
+                   out_eop1_wire = 1'b0;
+                   out_eop1_ptr_wire = 1'b0;
+                   out_err1_wire = 1'b0;
+                end // else: !if(output_fifo_read_eop0 &&...
+               end // if (saved_read_sop && saved_read_sop1 &&...
+             else
+               begin
+                  out_sop1_wire = 1'b0;
+                  out_eop1_wire = 1'b0;
+                  out_eop1_ptr_wire = 1'b0;
+                  out_err1_wire = 1'b0;
+               end // else: !if(saved_read_sop && saved_read_sop1 &&...
+              end // case: 2'd1
+            
+            2'd2:
+              begin
+             // Two Qwords of data saved from last cycle.
+             // The Qwords can be:
+             // DATA DATA
+             // EOP SOP
+             // SOP DATA
+            // out_data_wire[63:0] = saved_read_data[63:0];
+            // out_parity_wire[7:0] = saved_read_parity[7:0];
+            out_data_mux_sel0_wire = 2'b11;
+
+            if (saved_read_eop)
+              begin
+                // out_data_wire[127:64] = 64'd0;
+                // out_parity_wire[15:8] = 8'd0;
+                out_data_mux_sel1_wire = 3'b000;
+              end
+            else
+              begin
+                // out_data_wire[127:64] = saved_read_data[127:64];
+                // out_parity_wire[15:8] = saved_read_parity[15:8];
+                out_data_mux_sel1_wire = 3'b100;
+              end // else: !if(output_fifo_read_eop0 &&...
+            if (saved_read_eop)
+              // TLP ending in the first Qword
+              begin
+                if (saved_read_sop1)
+                  begin
+                // out_data_wire[255:128] = {output_fifo_read_data[63:0],
+                // saved_read_data[127:64]};
+                // out_parity_wire[31:16] = {output_fifo_read_parity[7:0],
+                // saved_read_parity[15:8]};
+                out_data_mux_sel2_wire = 3'b100;
+                out_data_mux_sel3_wire = 3'b000;
+                  end
+                else
+                  begin
+                // out_data_wire[255:128] = output_fifo_read_data[127:0];
+                // out_parity_wire[31:16] = output_fifo_read_parity[15:0];
+                out_data_mux_sel2_wire = 3'b000;
+                out_data_mux_sel3_wire = 3'b001;
+                  end // else: !if(saved_read_sop1)
+              end // if (saved_read_eop && (saved_read_eop_ptr[2:1] == 2'd0))
+            else
+              begin
+                // out_data_wire[255:128] = output_fifo_read_data[127:0];
+                // out_parity_wire[31:16] = output_fifo_read_parity[15:0];
+                out_data_mux_sel2_wire = 3'b000;
+                out_data_mux_sel3_wire = 3'b001;
+              end // else: !if(saved_read_eop && (saved_read_eop_ptr[2:1] == 2'd0))
+
+            if (saved_read_eop ||
+                (output_fifo_read_eop0 && (output_fifo_read_eop0_ptr[2:1] <= 2'd1)))
+              begin
+                out_eop0_wire = 1'b1;
+                if (saved_read_eop)
+                  out_eop0_ptr_wire = saved_read_eop_ptr;
+                else if (output_fifo_read_eop0_ptr[2:1] == 2'd1)
+                  out_eop0_ptr_wire = {2'b11, output_fifo_read_eop0_ptr[0]};
+                else
+                  out_eop0_ptr_wire = {2'b10, output_fifo_read_eop0_ptr[0]};
+                if (saved_read_eop)
+                  out_err0_wire = saved_read_uncorrectable_error;
+                else
+                  out_err0_wire = saved_read_uncorrectable_error | 
+                          output_fifo_read_uncorrectable_error[0];
+              end // if (saved_read_eop ||...
+            else
+              begin
+                out_eop0_wire = 1'b0;
+                out_eop0_ptr_wire = 3'd0;
+                out_err0_wire = 1'b0;
+              end
+
+            out_sop0_wire = saved_read_sop | saved_read_sop1;
+            if (saved_read_sop)
+              // SOP DATA
+              out_sop0_ptr_wire = 1'b0;
+            else if (saved_read_sop1)
+              // EOP SOP
+              out_sop0_ptr_wire = 1'b1;
+            else
+              out_sop0_ptr_wire = 1'b0;
+
+             out_sop1_wire = 1'b0;
+             if (saved_read_sop1)
+               // saved data = EOP SOP
+               begin
+                  if (output_fifo_read_eop0 &&
+                  (output_fifo_read_eop0_ptr[2:1] == 2'd0))
+                begin
+                   out_eop1_wire = 1'b1;
+                   out_eop1_ptr_wire = output_fifo_read_eop0_ptr[0];
+                   out_err1_wire = saved_read_uncorrectable_error1 | 
+                           output_fifo_read_uncorrectable_error[0];
+                end
+                  else
+                begin
+                   out_eop1_wire = 1'b0;
+                   out_eop1_ptr_wire = 1'b0;
+                   out_err1_wire = 1'b0;
+                end // else: !if((saved_read_sop1_ptr == 2'd2) &&...
+               end // if (saved_read_sop1)
+             else
+               begin
+                  out_eop1_wire = 1'b0;
+                  out_eop1_ptr_wire = 1'b0;
+                  out_err1_wire = 1'b0;
+               end // else: !if(saved_read_sop1)
+              end // case: 2'd2
+
+            default: // 2'd3
+              begin
+             // One Qword of data saved from last cycle.
+             // The Qword can be DATA or SOP.
+            // out_data_wire[127:0] = {output_fifo_read_data[63:0],
+            // saved_read_data[63:0]};
+            // out_parity_wire[15:0] = {output_fifo_read_parity[7:0],
+            // saved_read_parity[7:0]};
+             out_data_mux_sel0_wire = 2'b11;
+             out_data_mux_sel1_wire = 3'b000;
+
+             if (output_fifo_read_eop0 && (output_fifo_read_eop0_ptr[2:1] == 2'd0) &&
+                 output_fifo_read_sop1_ptr[1])
+               // Data read from FIFO has EOP in the first Qword, then a gap and the next TLP
+               // starting in the upper half.
+               begin
+                 // out_data_wire[255:128] = output_fifo_read_data[255:128];
+                 // out_parity_wire[31:16] = output_fifo_read_parity[31:16];
+                 out_data_mux_sel2_wire = 3'b010;
+                 out_data_mux_sel3_wire = 3'b011;
+               end
+             else
+               begin
+                 // out_data_wire[255:128] = output_fifo_read_data[191:64];
+                 // out_parity_wire[31:16] = output_fifo_read_parity[23:8];
+                 out_data_mux_sel2_wire = 3'b001;
+                 out_data_mux_sel3_wire = 3'b010;
+               end // else: !if(output_fifo_read_eop0 && (output_fifo_read_eop0_ptr[2:1] == 2'd0) &&...
+
+            if (output_fifo_read_eop0 && (output_fifo_read_eop0_ptr[2:1] <= 2'd2))
+              begin
+                out_eop0_wire = 1'b1;
+                case(output_fifo_read_eop0_ptr[2:1])
+                  2'd0: out_eop0_ptr_wire = {2'b01, output_fifo_read_eop0_ptr[0]};
+                  2'd1: out_eop0_ptr_wire = {2'b10, output_fifo_read_eop0_ptr[0]};
+                  default: out_eop0_ptr_wire = {2'b11, output_fifo_read_eop0_ptr[0]};
+                endcase // case(output_fifo_read_eop0_ptr[2:1])
+                if (output_fifo_read_eop0_ptr[2:1] == 2'd2)
+                  out_err0_wire = saved_read_uncorrectable_error | 
+                        (|output_fifo_read_uncorrectable_error[1:0]);
+                else
+                  out_err0_wire = saved_read_uncorrectable_error | 
+                          output_fifo_read_uncorrectable_error[0];
+              end // if (output_fifo_read_eop0 && (output_fifo_read_eop0_ptr[2:1] <= 2'd2))
+            else
+              begin
+                out_eop0_wire = 1'b0;
+                out_eop0_ptr_wire = 3'd0;
+                out_err0_wire = 1'b0;
+              end
+
+            if (saved_read_sop)
+              // saved Qword is SOP
+              begin
+                out_sop0_wire = 1'b1;
+                out_sop0_ptr_wire = 1'b0;
+                if (output_fifo_read_eop0 && (output_fifo_read_eop0_ptr[2:1] == 2'd0) &&
+                output_fifo_read_sop1 && (output_fifo_read_sop1_ptr != 2'd3) &&
+                (output_fifo_read_eop1 | output_fifo_read_second_tlp))
+                  // data from FIFO = EOP SOP X X or EOP GAP SOP X
+                  out_sop1_wire = 1'b1;
+                else
+                  out_sop1_wire = 1'b0;
+              end
+            else
+              // saved Qword is DATA
+              begin
+                if (output_fifo_read_eop0 && (output_fifo_read_eop0_ptr[2:1] == 2'd0) &&
+                output_fifo_read_sop1 && (output_fifo_read_sop1_ptr != 2'd3) &&
+                (output_fifo_read_eop1 | output_fifo_read_second_tlp))
+                  // data from FIFO = EOP SOP X X or EOP GAP SOP X
+                  begin
+                 out_sop0_wire = 1'b1;
+                 out_sop0_ptr_wire = 1'b1;
+                  end
+                else
+                  begin
+                 out_sop0_wire = 1'b0;
+                 out_sop0_ptr_wire = 1'b0;
+                  end // else: !if(output_fifo_read_eop0 &&...
+                 out_sop1_wire = 1'b0;
+              end // else: !if(saved_read_sop)
+
+             if (output_fifo_read_eop0 && (output_fifo_read_eop0_ptr[2:1] == 2'd0) &&
+                 output_fifo_read_sop1 && output_fifo_read_eop1)
+                  begin
+                 case(output_fifo_read_sop1_ptr)
+                   2'd1:
+                     begin
+                    // data from FIFO = EOP SOP DATA EOP or EOP SOP EOP X
+                    if (~output_fifo_read_eop1_ptr[1])
+                      begin
+                         out_eop1_wire = 1'b1;
+                         out_eop1_ptr_wire = output_fifo_read_eop1_ptr[0];
+                         out_err1_wire = |output_fifo_read_uncorrectable_error[1:0];
+                      end
+                    else
+                      begin
+                         out_eop1_wire = 1'b0;
+                         out_eop1_ptr_wire = 1'b0;
+                         out_err1_wire = 1'b0;
+                      end // else: !if(~output_fifo_read_eop1_ptr[1])
+                     end // case: 2'd1
+                   2'd2:
+                     begin
+                    // data from FIFO = EOP GAP SOP EOP
+                    out_eop1_wire = 1'b1;
+                    out_eop1_ptr_wire = output_fifo_read_eop1_ptr[0];
+                    out_err1_wire = output_fifo_read_uncorrectable_error[1];
+                     end
+                   default:
+                     begin
+                    out_eop1_wire = 1'b0;
+                    out_eop1_ptr_wire = 1'b0;
+                    out_err1_wire = 1'b0;
+                     end // else: !if(~output_fifo_read_eop1_ptr[1])
+                 endcase // case(output_fifo_read_sop1_ptr)
+                  end // if (output_fifo_read_eop0 && (output_fifo_read_eop0_ptr[2:1] == 2'd0) &&...
+                else
+                  begin
+                 out_eop1_wire = 1'b0;
+                 out_eop1_ptr_wire = 1'b0;
+                 out_err1_wire = 1'b0;
+                  end // else: !if(output_fifo_read_eop0 && (output_fifo_read_eop0_ptr[2:1] == 2'd0) &&...
+              end // case: default
+          endcase // case(out_tlp_alignment)
+           
+           
+           // Save data for next cycle
+               if (output_fifo_non_empty)
+             begin
+               case(out_tlp_alignment)
+             2'd0:
+               begin
+                 saved_read_data_wire[63:0] = output_fifo_read_data[255:192];
+                 saved_read_parity_wire[7:0] = output_fifo_read_parity[31:24];
+               end
+             2'd1:
+               begin
+                  // Three Qwords of data saved from last cycle.
+                  // The Qwords can be:
+                  // DATA DATA DATA
+                  // DATA EOP SOP
+                  // EOP SOP DATA
+                  // SOP DATA DATA
+                  // SOP EOP SOP
+
+                  //
+                  // In the case of EOP SOP DATA, there is no data to save.
+                  // De-assert ready to hold incoming data.
+                  // In all other cases, send one QW from incoming data and save up to 3 Qwords.
+                  if (output_fifo_read_eop0 & output_fifo_read_sop1)
+                case (output_fifo_read_sop1_ptr)
+                  2'd1:
+                    begin
+                       saved_read_data_wire[191:0] = output_fifo_read_data[255:64];
+                       saved_read_parity_wire[23:0] = output_fifo_read_parity[31:8];
+                    end
+                  2'd2:
+                    begin
+                       if (output_fifo_read_eop0_ptr[2:1] == 2'd0)
+                     begin
+                        // Data from FIFO = EOP GAP SOP X
+                        saved_read_data_wire[127:0] = output_fifo_read_data[255:128];
+                        saved_read_parity_wire[15:0] = output_fifo_read_parity[31:16];
+                     end
+                       else
+                     begin
+                        // Data from FIFO = DATA EOP SOP X
+                        saved_read_data_wire[191:0] = output_fifo_read_data[255:64];
+                        saved_read_parity_wire[23:0] = output_fifo_read_parity[31:8];
+                     end
+                    end // case: 2'd2
+                  default: // 2'd3
+                    begin
+                       // Data from FIFO = DATA DATA EOP SOP
+                       saved_read_data_wire[191:0] = output_fifo_read_data[255:64];
+                       saved_read_parity_wire[23:0] = output_fifo_read_parity[31:8];
+                    end // case: default
+                endcase // case(output_fifo_read_sop1_ptr)
+                  else
+                begin
+                   saved_read_data_wire[191:0] = output_fifo_read_data[255:64];
+                   saved_read_parity_wire[23:0] = output_fifo_read_parity[31:8];
+                end // else: !if(output_fifo_read_eop0 & output_fifo_read_sop1)
+               end // case: 2'd1
+
+             2'd2:
+               begin
+                  // Two Qwords of data saved from last cycle.
+                  // The Qwords can be:
+                  // DATA DATA
+                  // EOP SOP
+                  // SOP DATA
+                  if (saved_read_eop)
+                begin
+                   // EOP SOP
+                   // TLP ends in first QW and there is a new TLP starting in the second QW.
+                   // Send one Qword from incoming data and save up to 3 Qwords.
+                   if (output_fifo_read_eop0 & output_fifo_read_sop1)
+                     case (output_fifo_read_sop1_ptr)
+                       2'd1:
+                     begin
+                        saved_read_data_wire[191:0] = output_fifo_read_data[255:64];
+                        saved_read_parity_wire[23:0] = output_fifo_read_parity[31:8];
+                     end
+                       2'd2:
+                     begin
+                        if (output_fifo_read_eop0_ptr[2:1] == 2'd0)
+                          begin
+                         // Data from FIFO = EOP GAP SOP X
+                         saved_read_data_wire[127:0] = output_fifo_read_data[255:128];
+                         saved_read_parity_wire[15:0] = output_fifo_read_parity[31:16];
+                          end
+                        else
+                          begin
+                         // Data from FIFO = DATA EOP SOP X
+                         saved_read_data_wire[191:0] = output_fifo_read_data[255:64];
+                         saved_read_parity_wire[23:0] = output_fifo_read_parity[31:8];
+                          end
+                     end // case: 2'd2
+                       default: // 2'd3
+                     begin
+                        // Data from FIFO = DATA DATA EOP SOP
+                        saved_read_data_wire[191:0] = output_fifo_read_data[255:64];
+                        saved_read_parity_wire[23:0] = output_fifo_read_parity[31:8];
+                     end // case: default
+                     endcase // case(output_fifo_read_sop1_ptr)
+                   else
+                     begin
+                    saved_read_data_wire[191:0] = output_fifo_read_data[255:64];
+                    saved_read_parity_wire[23:0] = output_fifo_read_parity[31:8];
+                     end // else: !if(output_fifo_read_eop0 & output_fifo_read_sop1)
+                end // if (saved_read_eop)
+                  else
+                begin
+                   // DATA DATA or
+                   // SOP DATA
+                   // Send two Qwords from incoming data and save up to 3 Qwords.
+                   if (output_fifo_read_eop0 & output_fifo_read_sop1)
+                     case (output_fifo_read_sop1_ptr)
+                       2'd1:
+                     begin
+                        saved_read_data_wire[191:0] = output_fifo_read_data[255:64];
+                        saved_read_parity_wire[23:0] = output_fifo_read_parity[31:8];
+                     end
+                       2'd2:
+                     begin
+                        // Data from FIFO = EOP GAP SOP X or DATA EOP SOP X
+                        saved_read_data_wire[127:0] = output_fifo_read_data[255:128];
+                        saved_read_parity_wire[15:0] = output_fifo_read_parity[31:16];
+                     end // case: 2'd2
+                       default: // 2'd3
+                     begin
+                        // Data from FIFO = DATA DATA EOP SOP
+                        saved_read_data_wire[127:0] = output_fifo_read_data[255:128];
+                        saved_read_parity_wire[15:0] = output_fifo_read_parity[31:16];
+                     end // case: default
+                     endcase // case(output_fifo_read_sop1_ptr)
+                   else
+                     begin
+                    saved_read_data_wire[127:0] = output_fifo_read_data[255:128];
+                    saved_read_parity_wire[15:0] = output_fifo_read_parity[31:16];
+                     end // else: !if(output_fifo_read_eop0 & output_fifo_read_sop1)
+                end // else: !if(saved_read_eop)
+               end // case: 2'd2
+
+             default: //2'd3
+               begin
+                  // One QW saved (DATA or SOP)
+                  if (output_fifo_read_eop0 & output_fifo_read_sop1)
+                case (output_fifo_read_sop1_ptr)
+                  2'd1:
+                    begin
+                       // Data from FIFO = EOP SOP X X
+                       saved_read_data_wire[63:0] = output_fifo_read_data[255:192];
+                       saved_read_parity_wire[7:0] = output_fifo_read_parity[31:24];
+                    end
+                  2'd2:
+                    begin
+                       // If data from FIFO = EOP GAP SOP X, there is nothing to save.
+                       // If data from FIFO = DATA EOP SOP X, save 2 Qwords.
+                       saved_read_data_wire[127:0] = output_fifo_read_data[255:128];
+                       saved_read_parity_wire[15:0] = output_fifo_read_parity[31:16];
+                    end
+                  default: // 2'd3
+                    begin
+                       // If data from FIFO = DATA DATA EOP SOP, save last Qword.
+                       saved_read_data_wire[63:0] = output_fifo_read_data[255:192];
+                       saved_read_parity_wire[7:0] = output_fifo_read_parity[31:24];
+                    end
+                endcase // case(output_fifo_read_sop1_ptr)
+                  else
+                begin
+                  saved_read_data_wire[63:0] = output_fifo_read_data[255:192];
+                  saved_read_parity_wire[7:0] = output_fifo_read_parity[31:24];
+                end // else: !if(output_fifo_read_eop0 & output_fifo_read_sop1)
+               end // case: default
+               endcase // case(out_tlp_alignment)
+
+            // Determine new TLP alignment
+            case(out_tlp_alignment)
+              2'd0:
+                begin
+                   if (output_fifo_read_eop0 & output_fifo_read_sop1 &
+                   (output_fifo_read_eop1 | output_fifo_read_second_tlp))
+                 begin
+                    case(output_fifo_read_sop1_ptr)
+                      2'd1:
+                    begin
+                      if (~output_fifo_read_eop1)
+                        // Data from FIFO = EOP SOP DATA DATA
+                         out_tlp_alignment_wire = 2'd3;
+                       // Data from FIFO = EOP SOP X X
+                      else if (output_fifo_read_eop1_ptr[1])
+                         // Data from FIFO = EOP SOP DATA EOP
+                         out_tlp_alignment_wire = 2'd3;
+                       else
+                         // Data from FIFO = EOP SOP EOP X
+                         out_tlp_alignment_wire = out_tlp_alignment;
+                    end
+                      2'd3:
+                    begin
+                       // Data from FIFO = DATA DATA EOP SOP
+                       out_tlp_alignment_wire = 2'd3;
+                    end
+                      default:
+                    begin
+                       out_tlp_alignment_wire = out_tlp_alignment;
+                    end
+                    endcase // case(output_fifo_read_sop1_ptr)
+                 end // if (output_fifo_read_eop0 & output_fifo_read_sop1 &...
+                   else
+                 out_tlp_alignment_wire = out_tlp_alignment;
+                end // case: 2'd0
+              2'd1:
+                begin
+                   // Three Qwords of data saved from last cycle.
+                   // The Qwords can be:
+                   // DATA DATA DATA
+                   // DATA EOP SOP
+                   // EOP SOP DATA
+                   // SOP DATA DATA
+                   // SOP EOP SOP
+                   if (saved_read_eop && (saved_read_eop_ptr[2:1] == 2'd0))
+                 begin
+                    // saved data = EOP SOP DATA                 
+                    // Send out EOP GAP SOP DATA.  De-assert ready.
+                    out_tlp_alignment_wire = 2'd0;
+                 end
+                   else
+                 begin
+                    // saved data is one of
+                    // DATA DATA DATA
+                    // DATA EOP SOP
+                    // SOP DATA DATA
+                    // SOP EOP SOP
+                    if (~output_fifo_read_eop0)
+                      out_tlp_alignment_wire = out_tlp_alignment;
+                    else
+                      case(output_fifo_read_eop0_ptr[2:1])
+                    2'd0:
+                      begin
+                         // Send saved data and EOP in this cycle.
+                         // If there is a second TLP, save it for next cycle.
+                         if (output_fifo_read_sop1 &&
+                         (output_fifo_read_eop1 | output_fifo_read_second_tlp))
+                           begin
+                          // Second TLP starting
+                          case(output_fifo_read_sop1_ptr)
+                            2'd1:
+                              begin
+                             if (output_fifo_read_eop1)
+                               // Data from FIFO = EOP SOP EOP X or EOP SOP DATA EOP
+                               begin
+                                  if (output_fifo_read_eop1_ptr[1])
+                                // Data from FIFO = EOP SOP DATA EOP
+                                out_tlp_alignment_wire = out_tlp_alignment;
+                                  else
+                                // Data from FIFO = EOP SOP EOP X
+                                out_tlp_alignment_wire = 2'd2;
+                               end
+                             else
+                               // Data from FIFO = EOP SOP DATA DATA
+                               out_tlp_alignment_wire = out_tlp_alignment;
+                              end // case: 2'd1
+                            default: // 2'd2
+                              begin
+                             // Data from FIFO = EOP GAP SOP X
+                             out_tlp_alignment_wire = 2'd2;
+                              end
+                          endcase // case(output_fifo_read_sop1_ptr)
+                           end // if (output_fifo_read_sop1 &&...
+                         else
+                           out_tlp_alignment_wire = out_tlp_alignment;
+                      end // case: 2'd0
+                    2'd1:
+                      begin
+                         // Data from FIFO = DATA EOP X X
+                         if (output_fifo_read_sop1 &&
+                         (output_fifo_read_eop1 | output_fifo_read_second_tlp))
+                           begin
+                          // Second TLP starting at Qword 2
+                          // Data from FIFO = DATA EOP SOP X
+                          out_tlp_alignment_wire = out_tlp_alignment;
+                           end // if (output_fifo_read_sop1 &&...
+                         else
+                           out_tlp_alignment_wire = 2'd3;
+                      end // case: 2'd1
+                    2'd2:
+                      begin
+                         // Data from FIFO = DATA DATA EOP X
+                         if (output_fifo_read_sop1 & output_fifo_read_second_tlp)
+                           out_tlp_alignment_wire = out_tlp_alignment;
+                         else
+                           out_tlp_alignment_wire = 2'd2;
+                      end
+                    default:
+                      begin
+                         // Data from FIFO = DATA DATA DATA EOP
+                         out_tlp_alignment_wire = out_tlp_alignment;
+                      end
+                      endcase // case(output_fifo_read_eop0_ptr[2:1])
+                 end // else: !if(saved_read_eop && (saved_read_eop_ptr[2:1] == 2'd0))
+                end // case: 2'd1
+
+              2'd2:
+                begin
+                   // Two Qwords of data saved from last cycle.
+                   // The Qwords can be:
+                   // DATA DATA
+                   // EOP SOP
+                   // SOP DATA
+                   if (saved_read_eop)
+                 // saved data = EOP SOP
+                 begin
+                    if (~output_fifo_read_eop0)
+                    // Send out EOP GAP SOP DATA and save 3 Qwords
+                      out_tlp_alignment_wire = 2'd1;
+                    else
+                      case(output_fifo_read_eop0_ptr[2:1])
+                    2'd0:
+                      begin
+                         // Send out EOP GAP SOP EOP in this cycle.
+                         // If there is a second TLP, save it for next cycle.
+                         if (output_fifo_read_sop1 &&
+                         (output_fifo_read_eop1 | output_fifo_read_second_tlp))
+                           begin
+                          // Second TLP starting
+                          case(output_fifo_read_sop1_ptr)
+                            2'd1:
+                              begin
+                             if (~output_fifo_read_eop1 |
+                                 output_fifo_read_eop1_ptr[1])
+                               // Data from FIFO = EOP SOP DATA EOP or EOP SOP DATA DATA
+                               out_tlp_alignment_wire = 2'd1;
+                             else
+                               // Data from FIFO = EOP SOP EOP X
+                               out_tlp_alignment_wire = out_tlp_alignment;
+                              end
+                            default: // 2'd2
+                              begin
+                             // Data from FIFO = EOP GAP SOP X
+                             out_tlp_alignment_wire = out_tlp_alignment;
+                              end
+                          endcase // case(output_fifo_read_sop1_ptr)
+                           end // if (output_fifo_read_sop1 &&...
+                         else
+                           out_tlp_alignment_wire = out_tlp_alignment;
+                      end // case: 2'd0
+                    2'd1:
+                      begin
+                         // Data from FIFO = DATA EOP X X
+                         if (output_fifo_read_sop1 &&
+                         (output_fifo_read_eop1 | output_fifo_read_second_tlp))
+                           begin
+                         // Second TLP starting at Qword 2
+                         // Data from FIFO = DATA EOP SOP X
+                         out_tlp_alignment_wire = 2'd1;
+                           end // if (output_fifo_read_sop1 &&...
+                         else
+                           out_tlp_alignment_wire = 2'd3;
+                      end // case: 2'd1
+                    2'd2:
+                      begin
+                        // Data from FIFO = DATA DATA EOP X
+                         if (output_fifo_read_sop1 &&
+                         output_fifo_read_second_tlp)
+                           begin
+                         // Second TLP starting at Qword 3.
+                         // Data from FIFO = DATA DATA EOP SOP.
+                         // Save DATA EOP SOP.
+                         out_tlp_alignment_wire = 2'd1;
+                           end
+                         else
+                           // Save DATA EOP
+                           out_tlp_alignment_wire = out_tlp_alignment;
+                      end
+                    default:
+                      begin
+                        // Data from FIFO = DATA DATA DATA EOP
+                        // Save DATA DATA EOP
+                        out_tlp_alignment_wire = 2'd1;
+                      end
+                      endcase // case(output_fifo_read_eop0_ptr[2:1])
+                 end // if (saved_read_eop)
+                   else
+                 begin
+                    // The saved Qwords can be:
+                    // DATA DATA or
+                    // SOP DATA
+                    if (~output_fifo_read_eop0)
+                      out_tlp_alignment_wire = out_tlp_alignment;
+                    else
+                      case(output_fifo_read_eop0_ptr[2:1])
+                    2'd0:
+                      begin
+                         // If there is a second TLP, save it for next cycle.
+                         if (output_fifo_read_sop1 &&
+                         (output_fifo_read_eop1 | output_fifo_read_second_tlp))
+                           begin
+                          // Second TLP starting
+                          case(output_fifo_read_sop1_ptr)
+                            2'd1:
+                              begin
+                             if (~output_fifo_read_eop1 |
+                                 output_fifo_read_eop1_ptr[1])
+                               // Data from FIFO = EOP SOP DATA EOP or EOP SOP DATA DATA
+                               out_tlp_alignment_wire = 2'd1;
+                             else
+                               // Data from FIFO = EOP SOP EOP X
+                               out_tlp_alignment_wire = out_tlp_alignment;
+                              end
+                            default: // 2'd2
+                              begin
+                             // Data from FIFO = EOP GAP SOP X
+                             out_tlp_alignment_wire = out_tlp_alignment;
+                              end
+                          endcase // case(output_fifo_read_sop1_ptr)
+                           end // if (output_fifo_read_sop1 &&...
+                         else
+                           out_tlp_alignment_wire = out_tlp_alignment;
+                      end // case: 2'd0
+                    2'd1:
+                      begin
+                           // Data from FIFO = DATA EOP X X
+                         // If there is a second TLP, save it for next cycle.
+                         out_tlp_alignment_wire = out_tlp_alignment;
+                      end // case: 2'd1
+                    2'd2:
+                        begin
+                           if (output_fifo_read_sop1 &
+                           output_fifo_read_second_tlp)
+                         // Data from FIFO = DATA DATA EOP SOP
+                         out_tlp_alignment_wire = out_tlp_alignment;
+                           else
+                         out_tlp_alignment_wire = 2'd3;
+                        end
+                      default:
+                        begin
+                           // Data from FIFO = DATA DATA DATA EOP
+                           out_tlp_alignment_wire = out_tlp_alignment;
+                        end
+                      endcase // case(output_fifo_read_eop0_ptr[2:1])
+                 end // else: !if(saved_read_eop)
+                end // case: 2'd2
+              default:
+                begin
+                   // One Qword of data saved from last cycle.
+                   // The Qword can be DATA or SOP.
+                   if (~output_fifo_read_eop0)
+                 out_tlp_alignment_wire = out_tlp_alignment;
+                   else
+                 case(output_fifo_read_eop0_ptr[2:1])
+                   2'd0:
+                     begin
+                    if (output_fifo_read_sop1 &
+                        (output_fifo_read_eop1 | output_fifo_read_second_tlp))
+                      begin
+                        if (output_fifo_read_sop1_ptr == 2'd2)
+                          // Second TLP starting at Qword 2
+                          // Data from FIFO = EOP GAP SOP X
+                          out_tlp_alignment_wire = 2'd0;
+                        else
+                          out_tlp_alignment_wire = out_tlp_alignment;
+                      end
+                    else
+                      out_tlp_alignment_wire = out_tlp_alignment;
+                     end
+                   2'd1:
+                     begin
+                    if (output_fifo_read_sop1 &
+                        (output_fifo_read_eop1 | output_fifo_read_second_tlp))
+                      // Second TLP starting at Qword 2
+                      // Data from FIFO = DATA EOP SOP X
+                      out_tlp_alignment_wire = 2'd2;
+                    else
+                      out_tlp_alignment_wire = out_tlp_alignment;
+                       end // case: 2'd1
+                     2'd2:
+                       begin
+                      out_tlp_alignment_wire = out_tlp_alignment;
+                       end
+                     default:
+                       begin
+                      // Data from FIFO = DATA DATA DATA EOP
+                      out_tlp_alignment_wire = out_tlp_alignment;
+                       end
+                 endcase // case(output_fifo_read_eop0_ptr[2:1])
+                end // case: default
+            endcase // case(out_tlp_alignment)
+
+            // Save SOP indication
+               case(out_tlp_alignment)
+             2'd0:
+               begin
+                  saved_read_sop_wire = output_fifo_read_sop1 && (output_fifo_read_sop1_ptr == 2'd3);
+               end
+             2'd1:
+               begin
+                  // Three Qwords of data saved from last cycle.
+                  // The Qwords can be:
+                  // DATA DATA DATA
+                  // DATA EOP SOP
+                  // EOP SOP DATA
+                  // SOP DATA DATA
+                  // SOP EOP SOP
+                  //
+                  // In the case of EOP SOP DATA, there is no data to save.
+                  // De-assert ready to hold incoming data.
+                  // In all other cases, send one QW from incoming data and save up to 3 Qwords.
+                  if (output_fifo_read_eop0 & output_fifo_read_sop1 &
+                  (output_fifo_read_eop1 | output_fifo_read_second_tlp))
+                case (output_fifo_read_sop1_ptr)
+                  2'd1:
+                    begin
+                       saved_read_sop_wire = 1'b1;
+                    end
+                  2'd2:
+                    begin
+                       if (output_fifo_read_eop0_ptr[2:1] == 2'd0)
+                     begin
+                        // Data from FIFO = EOP GAP SOP X
+                        saved_read_sop_wire = 1'b1;
+                     end
+                       else
+                     begin
+                        // Data from FIFO = DATA EOP SOP X
+                        saved_read_sop_wire = 1'b0;
+                     end
+                    end // case: 2'd2
+                  default: // 2'd3
+                    begin
+                       saved_read_sop_wire = 1'b0;
+                    end // case: default
+                endcase // case(output_fifo_read_sop1_ptr)
+                  else
+                saved_read_sop_wire = 1'b0;
+               end // case: 2'd1
+             2'd2:
+               begin
+                 // Two Qwords of data saved from last cycle.
+                 // The Qwords can be:
+                 // DATA DATA
+                 // EOP SOP
+                 // SOP DATA
+                 if (saved_read_eop)
+                   // saved data = EOP SOP
+                   // Save 3 Qwords
+                   begin
+                   saved_read_sop_wire = output_fifo_read_eop0 &&
+                             (output_fifo_read_eop0_ptr[2:1] == 2'd0)  &&
+                             output_fifo_read_sop1;
+                   end
+                 else
+                   begin
+                 // DATA DATA or
+                 // SOP DATA
+                   saved_read_sop_wire = output_fifo_read_eop0 &
+                             ~output_fifo_read_eop0_ptr[2] &
+                             output_fifo_read_sop1;
+                   end // else: !if(saved_read_eop)
+               end // case: 2'd2
+             default: //2'd3
+               begin
+                  // One QW saved (DATA or SOP)
+                  if (output_fifo_read_eop0 & output_fifo_read_sop1)
+                case (output_fifo_read_sop1_ptr)
+                  2'd1:
+                    begin
+                       // Data from FIFO = EOP SOP X X
+                       saved_read_sop_wire = 1'b0;
+                    end
+                  2'd2:
+                    begin
+                       // If data from FIFO = EOP GAP SOP X, there is nothing to save.
+                       // If data from FIFO = DATA EOP SOP X, save 2 Qwords.
+                       saved_read_sop_wire = 1'b1;
+                    end
+                  default: // 2'd3
+                    begin
+                       // If data from FIFO = DATA DATA EOP SOP, save last Qword.
+                       saved_read_sop_wire = 1'b1;
+                    end
+                endcase // case(output_fifo_read_sop1_ptr)
+                  else
+                saved_read_sop_wire = 1'b0;
+               end // case: default
+               endcase // case(out_tlp_alignment)
+            
+            // Save SOP1 indication
+            case(out_tlp_alignment)
+             2'd0:
+               begin
+                  saved_read_sop1_wire = 1'b0;
+                  saved_read_sop1_ptr_wire = 2'd0;
+               end
+             2'd1:
+               begin
+                  // Three Qwords of data saved from last cycle.
+                  // The Qwords can be:
+                  // DATA DATA DATA
+                  // DATA EOP SOP
+                  // EOP SOP DATA
+                  // SOP DATA DATA
+                  // SOP EOP SOP
+                  //
+                  // In the case of EOP SOP DATA, there is no data to save.
+                  // De-assert ready to hold incoming data.
+                  // In all other cases, send one QW from incoming data and save up to 3 Qwords.
+
+                  if (saved_read_eop && saved_read_sop1 && (saved_read_sop1_ptr == 2'd1))
+                begin
+                   // Saved data = EOP SOP DATA.
+                   // Send saved data and de-assert ready.
+                   saved_read_sop1_wire = output_fifo_read_sop1;
+                   saved_read_sop1_ptr_wire = output_fifo_read_sop1_ptr;
+                end
+                  else
+                if (output_fifo_read_eop0 & output_fifo_read_sop1)
+                  case (output_fifo_read_sop1_ptr)
+                    2'd1:
+                      begin
+                    // Save SOP X X
+                    saved_read_sop1_wire = 1'b0;
+                    saved_read_sop1_ptr_wire = 2'd0;
+                      end
+                    2'd2:
+                      begin
+                    if (output_fifo_read_eop0_ptr[2:1] == 2'd0)
+                      begin
+                        // Data from FIFO = EOP GAP SOP X
+                        saved_read_sop1_wire = 1'b0;
+                        saved_read_sop1_ptr_wire = 2'd0;
+                      end
+                    else
+                      begin
+                        // Data from FIFO = DATA EOP SOP X
+                        saved_read_sop1_wire = 1'b1;
+                        saved_read_sop1_ptr_wire = 2'd1;
+                      end
+                      end // case: 2'd2
+                    default: // 2'd3
+                      begin
+                    // Data from FIFO = DATA DATA EOP SOP
+                    saved_read_sop1_wire = 1'b1;
+                    saved_read_sop1_ptr_wire = 2'd2;
+                      end // case: default
+                  endcase // case(output_fifo_read_sop1_ptr)
+                else
+                  begin
+                    saved_read_sop1_wire = 1'b0;
+                    saved_read_sop1_ptr_wire = 2'd0;
+                  end // else: !if(output_fifo_read_eop0 & output_fifo_read_sop1)
+               end // case: 2'd1
+
+              2'd2:
+                begin
+                   // Two Qwords of data saved from last cycle.
+                   // The Qwords can be:
+                   // DATA DATA
+                   // EOP SOP
+                   // SOP DATA
+                   if (saved_read_eop)
+                 begin
+                    // EOP SOP
+                    // TLP ends in first QW and there is a new TLP starting in the second QW.
+                    // Send one Qword from incoming data and save up to 3 Qwords.
+                    if (output_fifo_read_eop0 & output_fifo_read_sop1)
+                      case (output_fifo_read_sop1_ptr)
+                    2'd1:
+                      begin
+                         // Save SOP X X
+                         saved_read_sop1_wire = 1'b0;
+                         saved_read_sop1_ptr_wire = 2'd0;
+                      end
+                    2'd2:
+                      begin
+                         if (output_fifo_read_eop0_ptr[2:1] == 2'd0)
+                           begin
+                          // Data from FIFO = EOP GAP SOP X
+                          saved_read_sop1_wire = 1'b0;
+                          saved_read_sop1_ptr_wire = 2'd0;
+                           end
+                         else
+                           begin
+                          // Data from FIFO = DATA EOP SOP X
+                          saved_read_sop1_wire = 1'b1;
+                          saved_read_sop1_ptr_wire = 2'd1;
+                           end
+                      end // case: 2'd2
+                    default: // 2'd3
+                      begin
+                         // Data from FIFO = DATA DATA EOP SOP
+                         saved_read_sop1_wire = 1'b1;
+                         saved_read_sop1_ptr_wire = 2'd2;
+                      end // case: default
+                      endcase // case(output_fifo_read_sop1_ptr)
+                    else
+                      begin
+                     saved_read_sop1_wire = 1'b0;
+                     saved_read_sop1_ptr_wire = 2'd0;
+                      end // else: !if(output_fifo_read_eop0 & output_fifo_read_sop1)
+                 end // if (saved_read_eop)
+                   else
+                 begin
+                    // DATA DATA or
+                    // SOP DATA
+                    // Send two Qwords from incoming data and save up to 3 Qwords.
+                    if (output_fifo_read_eop0 & output_fifo_read_sop1)
+                      case (output_fifo_read_sop1_ptr)
+                    2'd1:
+                      begin
+                         saved_read_sop1_wire = 1'b0;
+                         saved_read_sop1_ptr_wire = 2'd0;
+                      end
+                       2'd2:
+                     begin
+                        // Data from FIFO = EOP GAP SOP X or DATA EOP SOP X
+                        saved_read_sop1_wire = 1'b0;
+                        saved_read_sop1_ptr_wire = 2'd0;
+                     end // case: 2'd2
+                       default: // 2'd3
+                     begin
+                        // Data from FIFO = DATA DATA EOP SOP
+                        saved_read_sop1_wire = 1'b1;
+                        saved_read_sop1_ptr_wire = 2'd1;
+                     end // case: default
+                     endcase // case(output_fifo_read_sop1_ptr)
+                   else
+                     begin
+                    saved_read_sop1_wire = 1'b0;
+                    saved_read_sop1_ptr_wire = 2'd0;
+                     end // else: !if(output_fifo_read_eop0 & output_fifo_read_sop1)
+                 end // else: !if(saved_read_eop)
+                end // case: 2'd2
+
+              default:
+                begin
+                   // One QW saved (DATA or SOP)
+                   saved_read_sop1_wire = 1'b0;
+                   saved_read_sop1_ptr_wire = 2'd0;
+                end
+            endcase // case(out_tlp_alignment)
+
+            if (output_fifo_read_sop2)
+              begin
+                 // Save last DW for use in a later beat.
+                 saved_read_uncorrectable_error2_wire = output_fifo_read_uncorrectable_error[1];
+              end
+            else
+              begin
+                 saved_read_uncorrectable_error2_wire = 1'b0;
+              end // else: !if(output_fifo_read_sop2)
+
+            // Save EOP
+            case(out_tlp_alignment)
+             2'd0:
+               begin
+                  if (output_fifo_read_eop0 && (output_fifo_read_eop0_ptr[2:1] == 2'd0) &&
+                  output_fifo_read_sop1 && (output_fifo_read_sop1_ptr == 2'd1) &&
+                  output_fifo_read_eop1 && output_fifo_read_eop1_ptr[1])
+                begin
+                   saved_read_eop_wire = 1'b1;
+                   saved_read_eop_ptr_wire = {2'b00, output_fifo_read_eop1_ptr[0]};
+                end
+                  else
+                begin
+                   saved_read_eop_wire = 1'b0;
+                   saved_read_eop_ptr_wire = 3'd0;
+                end // else: !if(output_fifo_read_eop0 && (output_fifo_read_eop0_ptr[2:1] == 2'd0) &&...
+               end // case: 2'd0
+
+              2'd1:
+                begin
+                  // Three Qwords of data saved from last cycle.
+                  // The Qwords can be:
+                  // DATA DATA DATA
+                  // DATA EOP SOP
+                  // EOP SOP DATA
+                  // SOP DATA DATA
+                  // SOP EOP SOP
+
+                  //
+                  if (saved_read_eop && saved_read_sop1 && (saved_read_sop1_ptr == 2'd1))
+                begin
+                   // In the case of EOP SOP DATA, there is no data to save.
+                   // De-assert ready to hold incoming data.
+                   saved_read_eop_wire = 1'b0;
+                   saved_read_eop_ptr_wire = 3'd0;
+                end
+                  else
+                begin
+                   // Send first Qword, save the remaining three Qwords
+                   if (output_fifo_read_eop0 && (output_fifo_read_eop0_ptr[2:1] == 2'd0) &&
+                       output_fifo_read_sop1)
+                     begin
+                    saved_read_eop_wire = output_fifo_read_eop1;
+                    saved_read_eop_ptr_wire = {1'b1, output_fifo_read_eop1_ptr} -
+                                  {output_fifo_read_sop1_ptr, 1'b0};
+                     end
+                   else
+                     begin
+                    saved_read_eop_wire = output_fifo_read_eop0;
+                    saved_read_eop_ptr_wire = output_fifo_read_eop0_ptr - 3'd2;
+                     end // else: !if(output_fifo_read_eop0 && (output_fifo_read_eop0_ptr[2:1] == 2'd0) &&...
+                end // else: !if(saved_read_eop && saved_read_sop1 && (saved_read_sop1_ptr == 2'd1))
+                end // case: 2'd1
+              2'd2:
+                begin
+                   // Two Qwords of data saved from last cycle.
+                   // The Qwords can be:
+                   // DATA DATA
+                   // EOP SOP
+                   // SOP DATA
+                   if (saved_read_eop)
+                 begin
+                    // EOP SOP
+                    // TLP ends in first QW and there is a new TLP starting in the second QW.
+                    // Send one Qword from incoming data and save up to 3 Qwords.
+                    if (output_fifo_read_eop0)
+                      case(output_fifo_read_eop0_ptr[2:1])
+                    2'd0:
+                      begin
+                         saved_read_eop_wire = output_fifo_read_eop1;
+                         saved_read_eop_ptr_wire = {1'b1, output_fifo_read_eop1_ptr} -
+                                       {output_fifo_read_sop1_ptr, 1'b0};
+                      end
+                    default:
+                      begin
+                         saved_read_eop_wire = 1'b1;
+                         saved_read_eop_ptr_wire = output_fifo_read_eop0_ptr - 3'd2;
+                      end
+                      endcase // case(output_fifo_read_eop0_ptr[2:1])
+                    else
+                      begin
+                     saved_read_eop_wire = 1'b0;
+                     saved_read_eop_ptr_wire = 3'd0;
+                      end // else: !if(output_fifo_read_eop0)
+                 end // if (saved_read_eop)
+                   else
+                 begin
+                    // DATA DATA or
+                    // SOP DATA
+                    // Send two Qwords from incoming data and save up to 3 Qwords.
+                    if (output_fifo_read_eop0)
+                      case(output_fifo_read_eop0_ptr[2:1])
+                    2'd0:
+                      begin
+                         saved_read_eop_wire = output_fifo_read_eop1;
+                         saved_read_eop_ptr_wire = {1'b1, output_fifo_read_eop1_ptr} -
+                                       {output_fifo_read_sop1_ptr, 1'b0};
+                      end
+                    2'd1:
+                      begin
+                         saved_read_eop_wire = output_fifo_read_eop1;
+                         saved_read_eop_ptr_wire = {1'b1, output_fifo_read_eop1_ptr} -
+                                       {output_fifo_read_sop1_ptr, 1'b0};
+                      end
+                    default:
+                      begin
+                         saved_read_eop_wire = 1'b1;
+                         saved_read_eop_ptr_wire = output_fifo_read_eop0_ptr - 3'd4;
+                      end
+                      endcase // case(output_fifo_read_eop0_ptr[2:1])
+                    else
+                      begin
+                     saved_read_eop_wire = 1'b0;
+                     saved_read_eop_ptr_wire = 3'd0;
+                      end // else: !if(output_fifo_read_eop0)
+                 end // else: !if(saved_read_eop)
+                end // case: 2'd2
+              default:
+                begin
+                  // One QW saved (DATA or SOP)
+                  if (output_fifo_read_eop0)
+                case (output_fifo_read_eop0_ptr[2:1])
+                  2'd0:
+                    begin
+                       if (output_fifo_read_sop1 & ~output_fifo_read_sop1_ptr[1] &
+                       output_fifo_read_eop1 & output_fifo_read_eop1_ptr[1])
+                     begin
+                        // Data from FIFO = EOP SOP DATA EOP
+                        // Save second EOP
+                        saved_read_eop_wire = 1'b1;
+                        saved_read_eop_ptr_wire = {2'd0, output_fifo_read_eop1_ptr[0]};
+                     end
+                       else
+                     begin
+                     saved_read_eop_wire = 1'b0;
+                     saved_read_eop_ptr_wire = 3'd0;
+                      end // else: !if(output_fifo_read_eop0)
+                    end // case: 2'd0
+                  2'd1:
+                    begin
+                       // Data from FIFO = DATA EOP X X
+                       // Save 2 Qwords for next cycle
+                       saved_read_eop_wire = output_fifo_read_eop1;
+                       saved_read_eop_ptr_wire = {2'b01, output_fifo_read_eop1_ptr[0]};
+                    end
+                  2'd2:
+                    begin
+                       // Data from FIFO = DATA DATA EOP X
+                       // Save 2 Qwords for next cycle
+                       saved_read_eop_wire = 1'b0;
+                       saved_read_eop_ptr_wire = 3'd0;
+                    end
+                  default:
+                    begin
+                       // Data from FIFO = DATA DATA DATA EOP
+                       saved_read_eop_wire = 1'b1;
+                       saved_read_eop_ptr_wire = {2'd0, output_fifo_read_eop0_ptr[0]};
+                    end
+                endcase // case(output_fifo_read_eop0_ptr[2:1])
+                  else
+                begin
+                   saved_read_eop_wire = 1'b0;
+                   saved_read_eop_ptr_wire = 3'd0;
+                end // else: !if(output_fifo_read_eop0)
+                end // case: default
+            endcase // case(out_tlp_alignment)
+
+            saved_read_eop1_ptr_wire = output_fifo_read_eop1_ptr[0];
+
+            // Save ECC error from this cycle
+            case(out_tlp_alignment)
+              2'd0:
+                begin
+                   if (~output_fifo_read_eop0)
+                 saved_read_uncorrectable_error_wire = saved_read_uncorrectable_error |
+                                       (|output_fifo_read_uncorrectable_error[1:0]);
+                   else if (output_fifo_read_sop1 & ~output_fifo_read_sop1_ptr[1] &
+                    ~output_fifo_read_eop1 & output_fifo_read_second_tlp) 
+                 saved_read_uncorrectable_error_wire = |output_fifo_read_uncorrectable_error[1:0];
+                   else
+                 saved_read_uncorrectable_error_wire = output_fifo_read_uncorrectable_error[1];
+                   saved_read_uncorrectable_error1_wire = 1'b0;
+                  end
+              2'd1:
+                  begin
+                 // Three Qwords of data saved from last cycle.
+                 // The Qwords can be:
+                 // DATA DATA DATA
+                 // DATA EOP SOP
+                 // EOP SOP DATA
+                 // SOP DATA DATA
+                 // SOP EOP SOP
+                 if (saved_read_eop && (saved_read_eop_ptr[2:1] == 2'd0))
+                   begin
+                      // saved data = EOP SOP DATA
+                      // No data to save from this cycle.  De-assert ready. 
+                      saved_read_uncorrectable_error_wire = saved_read_uncorrectable_error1;
+                      saved_read_uncorrectable_error1_wire = 1'b0;
+                   end
+                 else
+                   begin
+                      if (~output_fifo_read_eop0)
+                    begin
+                       if (saved_read_sop1)
+                         saved_read_uncorrectable_error_wire = saved_read_uncorrectable_error1 |
+                                           (|output_fifo_read_uncorrectable_error[1:0]);
+                       else
+                         saved_read_uncorrectable_error_wire = saved_read_uncorrectable_error |
+                                           (|output_fifo_read_uncorrectable_error[1:0]);
+                    end
+                      else
+                    case(output_fifo_read_eop0_ptr[2:1])
+                      2'd0:
+                        begin
+                           if (output_fifo_read_sop1)
+                         case(output_fifo_read_sop1_ptr)
+                           2'd1:
+                             begin
+                                   if (~output_fifo_read_eop1 & output_fifo_read_second_tlp)
+                              saved_read_uncorrectable_error_wire = |output_fifo_read_uncorrectable_error[1:0];
+                            else
+                              saved_read_uncorrectable_error_wire = 1'b0;
+                            saved_read_uncorrectable_error1_wire = 1'b0;
+                           end
+                         default:
+                           begin
+                                     if (~output_fifo_read_eop1 & output_fifo_read_second_tlp)
+                            saved_read_uncorrectable_error_wire = output_fifo_read_uncorrectable_error[1];
+                              else
+                            saved_read_uncorrectable_error_wire = 1'b0;
+                              saved_read_uncorrectable_error1_wire = 1'b0;
+                           end
+                           endcase // case(output_fifo_read_sop1_ptr)
+                         else
+                           begin
+                          saved_read_uncorrectable_error_wire = 1'b0;
+                          saved_read_uncorrectable_error1_wire = 1'b0;
+                           end // else: !if(output_fifo_read_sop1)
+                      end // case: 2'd0
+                    2'd1:
+                      begin
+                         if (saved_read_sop1)
+                           saved_read_uncorrectable_error_wire = saved_read_uncorrectable_error1 |
+                                             output_fifo_read_uncorrectable_error[0];
+                         else
+                           saved_read_uncorrectable_error_wire = saved_read_uncorrectable_error |
+                                             output_fifo_read_uncorrectable_error[0];
+                         if (output_fifo_read_sop1)
+                           begin
+                                 if (output_fifo_read_eop1 | output_fifo_read_second_tlp)
+                            // data from FIFO = DATA EOP SOP X 
+                            saved_read_uncorrectable_error1_wire = output_fifo_read_uncorrectable_error[1];
+                          else
+                            saved_read_uncorrectable_error1_wire = 1'b0;
+                           end
+                         else
+                           saved_read_uncorrectable_error1_wire = 1'b0;
+                      end // case: 2'd1
+                    2'd2:
+                      begin
+                         if (saved_read_sop1)
+                           saved_read_uncorrectable_error_wire = saved_read_uncorrectable_error1 |
+                                             (|output_fifo_read_uncorrectable_error[1:0]);
+                         else
+                           saved_read_uncorrectable_error_wire = saved_read_uncorrectable_error |
+                                             (|output_fifo_read_uncorrectable_error[1:0]);
+                         if (output_fifo_read_sop1 &
+                                output_fifo_read_second_tlp)
+                           saved_read_uncorrectable_error1_wire = output_fifo_read_uncorrectable_error[1];
+                         else
+                           saved_read_uncorrectable_error1_wire = 1'b0;
+                      end
+                    default:
+                      begin
+                         if (saved_read_sop1)
+                           saved_read_uncorrectable_error_wire = saved_read_uncorrectable_error1 |
+                                           (|output_fifo_read_uncorrectable_error[1:0]);
+                         else
+                           saved_read_uncorrectable_error_wire = saved_read_uncorrectable_error |
+                                           (|output_fifo_read_uncorrectable_error[1:0]);
+                         saved_read_uncorrectable_error1_wire = 1'b0;
+                      end
+                      endcase // case(output_fifo_read_eop0_ptr[2:1])
+                   end // else: !if(saved_read_eop && (saved_read_eop_ptr[2:1] == 2'd0))
+                  end // case: 2'd1
+              2'd2:
+                begin
+                   // Two Qwords of data saved from last cycle.
+                   // The Qwords can be:
+                   // DATA DATA
+                   // EOP SOP
+                   // SOP DATA
+                   if (saved_read_eop)
+                 begin
+                    // saved data = EOP SOP
+                    if (~output_fifo_read_eop0)
+                      begin
+                     saved_read_uncorrectable_error_wire = saved_read_uncorrectable_error1 |
+                                           (|output_fifo_read_uncorrectable_error[1:0]);
+                     saved_read_uncorrectable_error1_wire = 1'b0;
+                      end
+                    else
+                      case(output_fifo_read_eop0_ptr[2:1])
+                      2'd0:
+                        begin
+                           if (output_fifo_read_sop1)
+                         case(output_fifo_read_sop1_ptr)
+                           2'd1:
+                             begin
+                                   if (output_fifo_read_eop1 | output_fifo_read_second_tlp)
+                              saved_read_uncorrectable_error_wire = |output_fifo_read_uncorrectable_error[1:0];
+                            else
+                              saved_read_uncorrectable_error_wire = 1'b0;
+                            saved_read_uncorrectable_error1_wire = 1'b0;
+                           end
+                         default:
+                           begin
+                                     if (output_fifo_read_eop1 | output_fifo_read_second_tlp)
+                            saved_read_uncorrectable_error_wire = output_fifo_read_uncorrectable_error[1];
+                              else
+                            saved_read_uncorrectable_error_wire = 1'b0;
+                              saved_read_uncorrectable_error1_wire = 1'b0;
+                           end
+                           endcase // case(output_fifo_read_sop1_ptr)
+                         else
+                           begin
+                          saved_read_uncorrectable_error_wire = 1'b0;
+                          saved_read_uncorrectable_error1_wire = 1'b0;
+                           end // else: !if(output_fifo_read_sop1)
+                        end // case: 2'd0
+                    2'd1:
+                      begin
+                         saved_read_uncorrectable_error_wire = saved_read_uncorrectable_error1 |
+                                           output_fifo_read_uncorrectable_error[0];
+                         if (output_fifo_read_sop1)
+                           case(output_fifo_read_sop1_ptr)
+                         2'd2:
+                           begin
+                              if (output_fifo_read_eop1 | output_fifo_read_second_tlp)
+                            saved_read_uncorrectable_error1_wire = output_fifo_read_uncorrectable_error[1];
+                              else
+                            saved_read_uncorrectable_error1_wire = 1'b0;
+                           end
+                         default:
+                           begin
+                              if (output_fifo_read_second_tlp)
+                            saved_read_uncorrectable_error1_wire = output_fifo_read_uncorrectable_error[1];
+                              else
+                            saved_read_uncorrectable_error1_wire = 1'b0;
+                           end
+                           endcase // case(output_fifo_read_sop1_ptr)
+                         else
+                           saved_read_uncorrectable_error1_wire = 1'b0;
+                      end // case: 2'd1
+                    2'd2:
+                      begin
+                         saved_read_uncorrectable_error_wire = saved_read_uncorrectable_error1 |
+                                           (|output_fifo_read_uncorrectable_error[1:0]);
+                         if (output_fifo_read_sop1)
+                           begin
+                          if (output_fifo_read_second_tlp)
+                            saved_read_uncorrectable_error1_wire = output_fifo_read_uncorrectable_error[1];
+                          else
+                            saved_read_uncorrectable_error1_wire = 1'b0;
+                           end
+                         else
+                           saved_read_uncorrectable_error1_wire = 1'b0;
+                      end // case: 2'd2
+                    default:
+                      begin
+                         saved_read_uncorrectable_error_wire = saved_read_uncorrectable_error1 |
+                                           (|output_fifo_read_uncorrectable_error[1:0]);
+                         saved_read_uncorrectable_error1_wire = 1'b0;
+                      end
+                      endcase // case(output_fifo_read_eop0_ptr[2:1])
+                 end // if (saved_read_eop)
+                   else
+                 begin
+                    // saved data = DATA DATA or SOP DATA
+                    if (~output_fifo_read_eop0)
+                      begin
+                     saved_read_uncorrectable_error_wire = saved_read_uncorrectable_error |
+                                           (|output_fifo_read_uncorrectable_error[1:0]);
+                     saved_read_uncorrectable_error1_wire = 1'b0;
+                      end
+                    else
+                      case(output_fifo_read_eop0_ptr[2:1])
+                      2'd0:
+                        begin
+                           if (output_fifo_read_sop1)
+                         case(output_fifo_read_sop1_ptr)
+                           2'd1:
+                             begin
+                                   if (output_fifo_read_eop1 | output_fifo_read_second_tlp)
+                              saved_read_uncorrectable_error_wire = |output_fifo_read_uncorrectable_error[1:0];
+                            else
+                              saved_read_uncorrectable_error_wire = 1'b0;
+                            saved_read_uncorrectable_error1_wire = 1'b0;
+                           end
+                         default:
+                           begin
+                                     if (output_fifo_read_eop1 | output_fifo_read_second_tlp)
+                            saved_read_uncorrectable_error_wire = output_fifo_read_uncorrectable_error[1];
+                              else
+                            saved_read_uncorrectable_error_wire = 1'b0;
+                              saved_read_uncorrectable_error1_wire = 1'b0;
+                           end
+                           endcase // case(output_fifo_read_sop1_ptr)
+                         else
+                           begin
+                          saved_read_uncorrectable_error_wire = 1'b0;
+                          saved_read_uncorrectable_error1_wire = 1'b0;
+                           end // else: !if(output_fifo_read_sop1)
+                        end // case: 2'd0
+                    2'd1:
+                      begin
+                         if (output_fifo_read_sop1)
+                           begin
+                                 if (output_fifo_read_eop1 | output_fifo_read_second_tlp)
+                            saved_read_uncorrectable_error_wire = output_fifo_read_uncorrectable_error[1];
+                          else
+                            saved_read_uncorrectable_error_wire = 1'b0;
+                          saved_read_uncorrectable_error1_wire = 1'b0;
+                           end
+                         else
+                           begin
+                          saved_read_uncorrectable_error_wire = 1'b0;
+                          saved_read_uncorrectable_error1_wire = 1'b0;
+                           end // else: !if(output_fifo_read_sop1)
+                      end // case: 2'd1
+                    2'd2:
+                      begin
+                         saved_read_uncorrectable_error_wire = saved_read_uncorrectable_error |
+                                           (|output_fifo_read_uncorrectable_error[1:0]);
+                         if (output_fifo_read_sop1 &
+                                output_fifo_read_second_tlp)
+                           saved_read_uncorrectable_error1_wire = output_fifo_read_uncorrectable_error[1];
+                         else
+                           saved_read_uncorrectable_error1_wire = 1'b0;
+                      end
+                    default:
+                      begin
+                         saved_read_uncorrectable_error_wire = 1'b0;
+                         saved_read_uncorrectable_error1_wire = 1'b0;
+                      end
+                      endcase // case(output_fifo_read_eop0_ptr[2:1])
+                 end // else: !if(saved_read_eop)
+                end // case: 2'd2
+              
+              default:
+                begin
+                    // saved data = DATA or SOP
+                    if (~output_fifo_read_eop0)
+                      begin
+                     saved_read_uncorrectable_error_wire = saved_read_uncorrectable_error |
+                                           (|output_fifo_read_uncorrectable_error[1:0]);
+                     saved_read_uncorrectable_error1_wire = 1'b0;
+                      end
+                    else
+                      case(output_fifo_read_eop0_ptr[2:1])
+                      2'd0:
+                        begin
+                           if (output_fifo_read_sop1)
+                         case(output_fifo_read_sop1_ptr)
+                           2'd1:
+                             begin
+                                   if (output_fifo_read_eop1 | output_fifo_read_second_tlp)
+                              saved_read_uncorrectable_error_wire = |output_fifo_read_uncorrectable_error[1:0];
+                            else
+                              saved_read_uncorrectable_error_wire = 1'b0;
+                            saved_read_uncorrectable_error1_wire = 1'b0;
+                           end
+                         default:
+                           begin
+                                     if (output_fifo_read_eop1 | output_fifo_read_second_tlp)
+                            saved_read_uncorrectable_error_wire = output_fifo_read_uncorrectable_error[1];
+                              else
+                            saved_read_uncorrectable_error_wire = 1'b0;
+                              saved_read_uncorrectable_error1_wire = 1'b0;
+                           end
+                           endcase // case(output_fifo_read_sop1_ptr)
+                         else
+                           begin
+                          saved_read_uncorrectable_error_wire = 1'b0;
+                          saved_read_uncorrectable_error1_wire = 1'b0;
+                           end // else: !if(output_fifo_read_sop1)
+                        end // case: 2'd0
+                      2'd1:
+                        begin
+                           if (output_fifo_read_sop1)
+                         begin
+                                   if (output_fifo_read_eop1 | output_fifo_read_second_tlp)
+                              saved_read_uncorrectable_error_wire = output_fifo_read_uncorrectable_error[1];
+                            else
+                              saved_read_uncorrectable_error_wire = 1'b0;
+                            saved_read_uncorrectable_error1_wire = 1'b0;
+                         end
+                           else
+                         begin
+                            saved_read_uncorrectable_error_wire = 1'b0;
+                            saved_read_uncorrectable_error1_wire = 1'b0;
+                         end // else: !if(output_fifo_read_sop1)
+                        end // case: 2'd1
+                    2'd2:
+                      begin
+                         if (output_fifo_read_sop1)
+                           begin
+                                 if (output_fifo_read_second_tlp)
+                            saved_read_uncorrectable_error_wire = output_fifo_read_uncorrectable_error[1];
+                          else
+                            saved_read_uncorrectable_error_wire = 1'b0;
+                          saved_read_uncorrectable_error1_wire = 1'b0;
+                           end
+                         else
+                           begin
+                          saved_read_uncorrectable_error_wire = 1'b0;
+                          saved_read_uncorrectable_error1_wire = 1'b0;
+                           end // else: !if(output_fifo_read_sop1)
+                      end // case: 2'd2
+                    default:
+                      begin
+                         saved_read_uncorrectable_error_wire = saved_read_uncorrectable_error |
+                                           (|output_fifo_read_uncorrectable_error[1:0]);
+                         saved_read_uncorrectable_error1_wire = 1'b0;
+                      end
+                      endcase // case(output_fifo_read_eop0_ptr[2:1])
+                end // case: default
+            endcase // case(out_tlp_alignment)
+             end // if (output_fifo_non_empty)
+          end // if (~out_data_valid_o | ccix_app_ready)
+        end // case: state[CONTINUE_TLP_WITH_STRADDLE]
+
+          state[SEND_LAST_WORD_WITH_STRADDLE]:
+        begin
+           // Send the last Qwords of a TLP.  If the TLP ends in the lower half, fill the upper half with a new TLP if possible.
+              if (ccix_app_ready)
+        begin
+          case(out_tlp_alignment)
+            2'd1:
+              begin
+             // 3 Qwords saved. Can be one of
+             // DATA DATA EOP
+             // EOP SOP EOP
+             // SOP DATA EOP
+            // out_data_wire[63:0] = saved_read_data[63:0];
+            // out_parity_wire[7:0] = saved_read_parity[7:0];
+             out_data_mux_sel0_wire = 2'b11;
+
+             if (saved_read_eop_ptr[2:1] == 2'd0)
+               // EOP SOP EOP
+               begin
+                 // out_data_wire[127:64] = 64'd0;
+                 // out_parity_wire[15:8] = 8'd0;
+                  out_data_mux_sel1_wire = 3'b000;
+
+                 // out_data_wire[255:128] = saved_read_data[191:64];
+                 // out_parity_wire[31:16] = saved_read_parity[23:8];
+                  out_data_mux_sel2_wire = 3'b100;
+                  out_data_mux_sel3_wire = 3'b100;
+               end // if (saved_read_eop_ptr[2:1] == 2'd0)
+             else
+               begin
+                  // DATA DATA EOP or
+                  // SOP DATA EOP
+                 // out_data_wire[255:64] = {64'd0, saved_read_data[191:64]};
+                 // out_parity_wire[31:8] = {8'd0, saved_read_parity[23:8]};
+                 out_data_mux_sel1_wire = 3'b100;
+                 out_data_mux_sel2_wire = 3'b101;
+                 out_data_mux_sel3_wire = 3'b000;
+               end // else: !if(saved_read_eop_ptr[2:1] == 2'd0)
+
+            out_eop0_wire = 1'b1;
+            out_eop0_ptr_wire = saved_read_eop_ptr;
+            out_err0_wire = saved_read_uncorrectable_error;
+
+            out_sop0_wire = saved_read_sop | saved_read_sop1;
+            out_sop0_ptr_wire = saved_read_sop1;
+
+            out_sop1_wire = 1'b0;
+            out_eop1_wire = saved_read_eop && (saved_read_eop_ptr[2:1] == 2'd0);// EOP SOP EOP
+            if (saved_read_eop && (saved_read_eop_ptr[2:1] == 2'd0))
+              out_eop1_ptr_wire = saved_read_eop1_ptr;
+            else
+              out_eop1_ptr_wire = 1'b0;
+            if (saved_read_eop && (saved_read_eop_ptr[2:1] == 2'd0))
+              out_err1_wire = saved_read_uncorrectable_error1;
+            else
+              out_err1_wire = 1'b0;
+              end // case: 2'd1
+
+            2'd2:
+              // 2 Qwords saved (SOP EOP or DATA EOP)
+              begin
+            // out_data_wire[127:0] = saved_read_data[127:0];
+            // out_parity_wire[15:0] = saved_read_parity[15:0];
+            out_data_mux_sel0_wire = 2'b11;
+            out_data_mux_sel1_wire = 3'b100;
+
+            case(output_fifo_read_sop0_ptr)
+               2'd0:
+                 begin
+                if (output_fifo_read_sop_prev)
+                  // TLP started in DW 6 of the previous word, so use the first two Qwords saved.
+                  begin
+                    // out_data_wire[191:128] = saved_read_data[191:128];
+                    // out_parity_wire[23:16] = saved_read_parity[23:16];
+                    // out_data_wire[255:192] = output_fifo_read_data[63:0];
+                    // out_parity_wire[31:24] = output_fifo_read_parity[7:0];
+                    out_data_mux_sel2_wire = 3'b101;
+                    out_data_mux_sel3_wire = 3'b000;
+                  end
+                else
+                  begin
+                    // out_data_wire[255:128] = output_fifo_read_data[127:0];
+                    // out_parity_wire[31:16] = output_fifo_read_parity[15:0];
+                    out_data_mux_sel2_wire = 3'b000;
+                    out_data_mux_sel3_wire = 3'b001;
+                  end // else: !if(output_fifo_read_sop_prev)
+                 end // case: 2'd0
+               2'd1:
+                 begin
+                   // out_data_wire[255:128] = output_fifo_read_data[191:64];
+                   // out_parity_wire[31:16] = output_fifo_read_parity[23:8];
+                   out_data_mux_sel2_wire = 3'b001;
+                   out_data_mux_sel3_wire = 3'b010;
+                 end
+               default:
+                 begin
+                   // out_data_wire[255:128] = output_fifo_read_data[255:128];
+                   // out_parity_wire[31:16] = output_fifo_read_parity[31:16];
+                   out_data_mux_sel2_wire = 3'b010;
+                   out_data_mux_sel3_wire = 3'b011;
+                 end
+             endcase // case(output_fifo_read_sop0_ptr)
+
+            out_eop0_wire = 1'b1;
+            out_eop0_ptr_wire = saved_read_eop_ptr;
+            out_err0_wire = saved_read_uncorrectable_error;
+
+            out_sop0_wire = saved_read_sop ||
+                    (output_fifo_non_empty && (output_fifo_read_sop0_ptr != 2'd3));
+            out_sop0_ptr_wire = ~saved_read_sop &&
+                        (output_fifo_non_empty && (output_fifo_read_sop0_ptr != 2'd3));
+                  
+            out_sop1_wire = saved_read_sop && output_fifo_non_empty &&
+                    (output_fifo_read_sop0_ptr != 2'd3);
+            
+            if (output_fifo_non_empty)
+              begin
+                 case(output_fifo_read_sop0_ptr)
+                2'd0:
+                  begin
+                     if (output_fifo_read_sop_prev)
+                       begin
+                      if (output_fifo_read_eop0 &&
+                          (output_fifo_read_eop0_ptr[2:1] == 2'd0))
+                        begin
+                           out_eop1_wire = 1'b1;
+                           out_eop1_ptr_wire = output_fifo_read_eop0_ptr[0];
+                           out_err1_wire = output_fifo_read_uncorrectable_error[0] |
+                                   saved_read_uncorrectable_error2;
+                        end
+                      else
+                        begin
+                           out_eop1_wire = 1'b0;
+                           out_eop1_ptr_wire = 1'b0;
+                           out_err1_wire = 1'b0;
+                        end
+                       end // if (output_fifo_read_sop_prev)
+                     else
+                       begin
+                      if (output_fifo_read_eop0 &
+                          ~output_fifo_read_eop0_ptr[2])
+                        begin
+                           out_eop1_wire = 1'b1;
+                           out_eop1_ptr_wire = output_fifo_read_eop0_ptr[0];
+                           out_err1_wire = output_fifo_read_uncorrectable_error[0];
+                        end
+                      else
+                        begin
+                           out_eop1_wire = 1'b0;
+                           out_eop1_ptr_wire = 1'b0;
+                           out_err1_wire = 1'b0;
+                        end                      
+                       end // else: !if(output_fifo_read_sop_prev)
+                  end // case: 2'd0
+                2'd1:
+                  begin
+                     if (output_fifo_read_eop0 &&
+                     (output_fifo_read_eop0_ptr[2:1] == 2'd2))
+                       begin
+                      out_eop1_wire = 1'b1;
+                      out_eop1_ptr_wire = output_fifo_read_eop0_ptr[0];
+                      out_err1_wire = |output_fifo_read_uncorrectable_error[1:0];
+                       end
+                     else
+                       begin
+                      out_eop1_wire = 1'b0;
+                      out_eop1_ptr_wire = 1'b0;
+                      out_err1_wire = 1'b0;
+                       end                      
+                  end // case: 2'd1
+                2'd2:
+                  begin
+                     if (output_fifo_read_eop0)
+                       begin
+                      out_eop1_wire = 1'b1;
+                      out_eop1_ptr_wire = output_fifo_read_eop0_ptr[0];
+                      out_err1_wire = output_fifo_read_uncorrectable_error[1];
+                       end
+                     else
+                       begin
+                      out_eop1_wire = 1'b0;
+                      out_eop1_ptr_wire = 1'b0;
+                      out_err1_wire = 1'b0;
+                       end                      
+                  end // case: 2'd2
+                default:
+                  begin
+                     out_eop1_wire = 1'b0;
+                     out_eop1_ptr_wire = 1'b0;
+                     out_err1_wire = 1'b0;
+                  end
+                  endcase // case(output_fifo_read_sop0_ptr)
+               end // if (output_fifo_non_empty)
+             else
+               begin
+                  out_eop1_wire = 1'b0;
+                  out_eop1_ptr_wire = 1'b0;
+                  out_err1_wire = 1'b0;
+               end // else: !if(output_fifo_non_empty)
+              end // case: 2'd2
+
+            default:
+              begin
+             // There is an EOP saved from last beat.  Send it in the lower half of the outgoing beat.
+             // Fill the upper half with a new TLP if possible.
+            // out_data_wire[63:0] = saved_read_data[63:0];
+            // out_parity_wire[7:0] = saved_read_parity[7:0];
+            out_data_mux_sel0_wire = 2'b11;
+
+            // out_data_wire[127:64] = 64'd0;
+            // out_parity_wire[15:8] = 8'd0;
+            out_data_mux_sel1_wire = 3'b000;
+
+             case(output_fifo_read_sop0_ptr)
+               2'd0:
+                 begin
+                if (output_fifo_read_sop_prev)
+                  // TLP started in DW 6 of the previous word, so use the first two Qwords saved.
+                  begin
+                    // out_data_wire[191:128] = saved_read_data[127:64];
+                    // out_parity_wire[23:16] = saved_read_parity[15:8];
+                    // out_data_wire[255:192] = output_fifo_read_data[63:0];
+                    // out_parity_wire[31:24] = output_fifo_read_parity[7:0];
+                     out_data_mux_sel2_wire = 3'b100;
+                     out_data_mux_sel3_wire = 3'b000;
+                  end
+                else
+                  begin
+                    // out_data_wire[255:128] = output_fifo_read_data[127:0];
+                    // out_parity_wire[31:16] = output_fifo_read_parity[15:0];
+                    out_data_mux_sel2_wire = 3'b000;
+                    out_data_mux_sel3_wire = 3'b001;
+                  end // else: !if(output_fifo_read_sop_prev)
+                 end // case: 2'd0
+               2'd1:
+                 begin
+                   // out_data_wire[255:128] = output_fifo_read_data[191:64];
+                   // out_parity_wire[31:16] = output_fifo_read_parity[23:8];
+                   out_data_mux_sel2_wire = 3'b001;
+                   out_data_mux_sel3_wire = 3'b010;
+                 end
+               default:
+                 begin
+                   // out_data_wire[255:128] = output_fifo_read_data[255:128];
+                   // out_parity_wire[31:16] = output_fifo_read_parity[31:16];
+                   out_data_mux_sel2_wire = 3'b010;
+                   out_data_mux_sel3_wire = 3'b011;
+                 end
+             endcase // case(output_fifo_read_sop0_ptr)
+             
+            out_eop0_wire = 1'b1;
+            out_eop0_ptr_wire = saved_read_eop_ptr;
+            out_err0_wire = saved_read_uncorrectable_error;
+
+            out_sop0_wire = output_fifo_non_empty && (output_fifo_read_sop0_ptr != 2'd3);
+            out_sop0_ptr_wire = output_fifo_non_empty && (output_fifo_read_sop0_ptr != 2'd3);
+
+            out_sop1_wire = 1'b0;
+
+            if (output_fifo_non_empty)
+              begin
+                case(output_fifo_read_sop0_ptr)
+                  2'd0:
+                begin
+                  if (output_fifo_read_sop_prev)
+                    begin
+                      if (output_fifo_read_eop0 &&
+                      (output_fifo_read_eop0_ptr[2:1] == 2'd0))
+                    begin
+                      out_eop1_wire = 1'b1;
+                      out_eop1_ptr_wire = output_fifo_read_eop0_ptr[0];
+                      out_err1_wire = output_fifo_read_uncorrectable_error[0] |
+                              saved_read_uncorrectable_error2;
+                    end
+                      else
+                    begin
+                      out_eop1_wire = 1'b0;
+                      out_eop1_ptr_wire = 1'b0;
+                      out_err1_wire = 1'b0;
+                    end
+                    end // if (output_fifo_read_sop_prev)
+                  else
+                    begin
+                      if (output_fifo_read_eop0 &
+                      ~output_fifo_read_eop0_ptr[2])
+                    begin
+                      out_eop1_wire = 1'b1;
+                      out_eop1_ptr_wire = output_fifo_read_eop0_ptr[0];
+                      out_err1_wire = output_fifo_read_uncorrectable_error[0];
+                    end
+                      else
+                    begin
+                      out_eop1_wire = 1'b0;
+                      out_eop1_ptr_wire = 1'b0;
+                      out_err1_wire = 1'b0;
+                    end                      
+                    end // else: !if(output_fifo_read_sop_prev)
+                end // case: 2'd0
+                  2'd1:
+                begin
+                  if (output_fifo_read_eop0 &&
+                      (output_fifo_read_eop0_ptr[2:1] == 2'd2))
+                    begin
+                      out_eop1_wire = 1'b1;
+                      out_eop1_ptr_wire = output_fifo_read_eop0_ptr[0];
+                      out_err1_wire = |output_fifo_read_uncorrectable_error[1:0];
+                    end
+                  else
+                    begin
+                      out_eop1_wire = 1'b0;
+                      out_eop1_ptr_wire = 1'b0;
+                      out_err1_wire = 1'b0;
+                    end                      
+                end // case: 2'd1
+                  2'd2:
+                begin
+                  if (output_fifo_read_eop0)
+                    begin
+                      out_eop1_wire = 1'b1;
+                      out_eop1_ptr_wire = output_fifo_read_eop0_ptr[0];
+                      out_err1_wire = output_fifo_read_uncorrectable_error[1];
+                    end
+                  else
+                    begin
+                      out_eop1_wire = 1'b0;
+                      out_eop1_ptr_wire = 1'b0;
+                      out_err1_wire = 1'b0;
+                    end                      
+                end // case: 2'd2
+                  default:
+                begin
+                  out_eop1_wire = 1'b0;
+                  out_eop1_ptr_wire = 1'b0;
+                  out_err1_wire = 1'b0;
+                end
+                endcase // case(output_fifo_read_sop0_ptr)
+              end // if (output_fifo_non_empty)
+            else
+              begin
+                out_eop1_wire = 1'b0;
+                out_eop1_ptr_wire = 1'b0;
+                out_err1_wire = 1'b0;
+              end // else: !if(output_fifo_non_empty)
+              end // case: default
+          endcase // case(out_tlp_alignment)
+
+           // Save the starting position of the current TLP in progress
+           if (~output_fifo_read_eop0)
+             begin
+            if (output_fifo_read_sop_prev &&
+                (output_fifo_read_sop0_ptr == 2'd0))
+              out_tlp_alignment_wire = 2'd1; // Save 3 Qwords
+            else
+              case(output_fifo_read_sop0_ptr)
+                2'd0: out_tlp_alignment_wire = 2'd2; // Save 2 Qwords
+                2'd1: out_tlp_alignment_wire = 2'd3; // Save 1 Qword
+                2'd2: out_tlp_alignment_wire = 2'd0; // Save no data
+                default: out_tlp_alignment_wire = 2'd3; // Save 1 Qword
+              endcase // case(output_fifo_read_sop0_ptr)
+             end // if (~output_fifo_read_eop0)
+           else
+             case(output_fifo_read_sop0_ptr)
+               2'd0:
+             begin
+                case(output_fifo_read_eop0_ptr[2:1])
+                  2'd0:
+                begin
+                   if (output_fifo_read_sop1 &&
+                       (output_fifo_read_eop1 | output_fifo_read_second_tlp))
+                     case(output_fifo_read_sop1_ptr)
+                       2'd1:
+                     begin
+                        if (~output_fifo_read_eop1)
+                          out_tlp_alignment_wire = 2'd1; // Save 3 Qwords
+                        else if (output_fifo_read_eop1_ptr[1])
+                          out_tlp_alignment_wire = 2'd1; // Save 3 Qwords
+                        else
+                          out_tlp_alignment_wire = 2'd2; // Save 2 Qwords
+                     end
+                       default: out_tlp_alignment_wire = 2'd2; // Save 2 Qwords
+                     endcase // case(output_fifo_read_sop1_ptr)
+                   else
+                     out_tlp_alignment_wire = 2'd0;
+                end // case: 2'd0
+                  2'd1:
+                begin
+                   if (output_fifo_read_sop_prev)
+                     begin
+                    if (output_fifo_read_sop1 &
+                        (output_fifo_read_eop1 | output_fifo_read_second_tlp))
+                      out_tlp_alignment_wire = 2'd1; // Save 3 Qwords
+                    else
+                      out_tlp_alignment_wire = 2'd3; // Save 1 Qword
+                     end
+                   else
+                     begin
+                    if (output_fifo_read_sop1 &
+                        (output_fifo_read_eop1 | output_fifo_read_second_tlp))
+                      out_tlp_alignment_wire = 2'd2; // Save 2 Qwords
+                    else
+                      out_tlp_alignment_wire = 2'd0; // Save no data
+                     end // else: !if(output_fifo_read_sop_prev)
+                end // case: 2'd1
+                  2'd2:
+                begin
+                   if (output_fifo_read_sop_prev)
+                     begin
+                    if (output_fifo_read_sop1 &
+                        output_fifo_read_second_tlp)
+                      out_tlp_alignment_wire = 2'd1; // Save 3 Qwords
+                    else
+                      out_tlp_alignment_wire = 2'd2; // Save 2 Qwords
+                     end
+                   else
+                     begin
+                    if (output_fifo_read_sop1 & 
+                        output_fifo_read_second_tlp)
+                      out_tlp_alignment_wire = 2'd2; // Save 2 Qwords
+                    else
+                      out_tlp_alignment_wire = 2'd3; // Save 1 Qword
+                     end // else: !if(output_fifo_read_sop_prev)
+                end // case: 2'd2
+                  2'd3:
+                begin
+                    if (output_fifo_read_sop_prev)
+                     out_tlp_alignment_wire = 2'd1; // Save 3 Qwords
+                   else
+                     out_tlp_alignment_wire = 2'd2; // Save 2 Qwords
+                end
+                endcase // case(output_fifo_read_eop0_ptr[2:1])
+             end // case: 2'd0
+               2'd1:
+             begin
+                out_tlp_alignment_wire = 2'd3; // Save 1 Qword
+             end
+               2'd2:
+             begin
+                out_tlp_alignment_wire = 2'd0; // Save no data
+             end
+               default:
+             begin
+                out_tlp_alignment_wire = 2'd3; // Save 1 Qword
+             end
+             endcase // case(output_fifo_read_sop0_ptr)
+
+           // Save data for next cycle
+               if (output_fifo_non_empty)
+             begin
+            // 2 Qwords saved from last beat or 1 QW saved from last beat.
+            // If there is a new word at the output of the FIFO, send its first 2 Qwords in the upper half
+            // and save the rest.
+            case(output_fifo_read_sop0_ptr)
+              2'd0:
+                begin
+                   if (output_fifo_read_sop_prev)
+                 begin
+                   if (output_fifo_read_eop0 &&
+                       output_fifo_read_sop1 &&
+                       (output_fifo_read_sop1_ptr[1]) &&
+                       (output_fifo_read_eop0_ptr[2:1] == 2'd0))
+                     // Data from FIFO = EOP GAP SOP X.
+                     // Save SOP X
+                     begin
+                       saved_read_data_wire[127:0] = output_fifo_read_data[255:128];
+                       saved_read_parity_wire[15:0] = output_fifo_read_parity[31:16];
+                     end
+                   else
+                     begin
+                       // Save 3 Qwords
+                       saved_read_data_wire[191:0] = output_fifo_read_data[255:64];
+                       saved_read_parity_wire[23:0] = output_fifo_read_parity[31:8];
+                     end // else: !if(output_fifo_read_sop1 &&...
+                 end // if (output_fifo_read_sop_prev)
+                   else
+                 begin
+                    saved_read_data_wire[127:0] = output_fifo_read_data[255:128];
+                    saved_read_parity_wire[15:0] = output_fifo_read_parity[31:16];
+                 end
+                end // case: 2'd0
+              default:
+                begin
+                   saved_read_data_wire[63:0] = output_fifo_read_data[255:192];
+                   saved_read_parity_wire[7:0] = output_fifo_read_parity[31:24];
+                end
+            endcase // case(output_fifo_read_sop0_ptr)
+             end // if (output_fifo_non_empty)
+           else
+             begin
+            // If the saved word has SOP EOP SOP, save the last SOP word for next cycle.
+               case(out_tlp_alignment)
+             2'd2:
+               begin
+                 saved_read_data_wire[63:0] = saved_read_data[191:128];
+                 saved_read_parity_wire[7:0] = saved_read_parity[23:16];
+               end
+             default: // 2'd3
+               begin
+                 saved_read_data_wire[63:0] = saved_read_data[127:64];
+                 saved_read_parity_wire[7:0] = saved_read_parity[15:8];
+               end
+               endcase // case(output_fifo_read_sop0_ptr)
+             end // else: !if(output_fifo_non_empty)
+                
+           // Save SOP pointer
+           if (output_fifo_non_empty)
+             begin
+            case(out_tlp_alignment)
+              2'd1:
+                begin
+                   // 3 Qwords saved from previous beat.  No data to be saved from current beat.
+                   saved_read_sop_wire = 1'b0; // No data to save
+                end
+              default:
+                // 1 or 2 Qwords saved.
+                begin
+                   if (output_fifo_read_sop0_ptr == 2'd3)
+                 saved_read_sop_wire = 1'b1;
+                   else
+                 if (output_fifo_read_eop0 & output_fifo_read_sop1)
+                   case (output_fifo_read_sop1_ptr)
+                     2'd1:
+                       begin
+                      saved_read_sop_wire = 1'b1;
+                       end
+                     2'd2:
+                       begin
+                      if (~output_fifo_read_sop_prev ||
+                          (output_fifo_read_eop0_ptr[2:1] == 2'd0))
+                        saved_read_sop_wire = 1'b1;
+                      else
+                        saved_read_sop_wire = 1'b0;
+                       end
+                     default:
+                       begin
+                      if (output_fifo_read_sop0_ptr == 2'd1)
+                        saved_read_sop_wire = 1'b1;
+                      else
+                        saved_read_sop_wire = 1'b0;
+                       end
+                   endcase // case(output_fifo_read_sop1_ptr)
+                 else
+                   saved_read_sop_wire = 1'b0;
+                end // case: default
+            endcase // case(out_tlp_alignment)
+
+            // Save SOP1 indication
+            if (output_fifo_read_eop0 & output_fifo_read_sop1)
+              begin
+                 case(output_fifo_read_sop1_ptr)
+                   2'd1:
+                 begin
+                    saved_read_sop1_wire = 1'b0;
+                    saved_read_sop1_ptr_wire = 2'd0;
+                 end
+                   2'd2:
+                 begin
+                    if ((output_fifo_read_sop0_ptr == 2'd0) &&
+                    output_fifo_read_sop_prev &&
+                    (output_fifo_read_eop0_ptr[2:1] == 2'd1) &&
+                    (output_fifo_read_eop1 | output_fifo_read_second_tlp))
+                      begin
+                    // Save EOP SOP
+                     saved_read_sop1_wire = 1'b1;
+                     saved_read_sop1_ptr_wire = 2'd1;
+                      end
+                    else
+                      begin
+                     saved_read_sop1_wire = 1'b0;
+                     saved_read_sop1_ptr_wire = 2'd0;
+                      end // else: !if((output_fifo_read_sop0_ptr == 2'd0) &&...
+                 end // case: 2'd2
+                   default:
+                 begin
+                   if (output_fifo_read_second_tlp)
+                     case(output_fifo_read_sop0_ptr)
+                       2'd0:
+                     begin
+                       case(output_fifo_read_eop0_ptr[2:1])
+                         2'd0:
+                           begin
+                         // Save SOP
+                         saved_read_sop1_wire = 1'b0;
+                         saved_read_sop1_ptr_wire = 2'd0;
+                           end
+                         2'd1:
+                           begin
+                         if (output_fifo_read_sop_prev)
+                           // Save EOP SOP
+                           begin
+                             saved_read_sop1_wire = 1'b1;
+                             saved_read_sop1_ptr_wire = 2'd1;
+                           end
+                         else
+                           begin
+                             // Save SOP
+                             saved_read_sop1_wire = 1'b0;
+                             saved_read_sop1_ptr_wire = 2'd0;
+                           end // else: !if(output_fifo_read_sop_prev)
+                           end
+                         default: // 2'd2
+                           begin
+                         if (output_fifo_read_sop_prev)
+                           // Save DATA EOP SOP
+                           begin
+                             saved_read_sop1_wire = 1'b1;
+                             saved_read_sop1_ptr_wire = 2'd2;
+                           end
+                         else
+                           begin
+                             // Save EOP SOP
+                             saved_read_sop1_wire = 1'b1;
+                             saved_read_sop1_ptr_wire = 2'd1;
+                           end // else: !if(output_fifo_read_sop_prev)
+                           end // case: default
+                       endcase // case(output_fifo_read_eop0_ptr[2:1])
+                     end // case: 2'd0
+                       
+                       default:
+                     begin
+                       saved_read_sop1_wire = 1'b0;
+                       saved_read_sop1_ptr_wire = 2'd0;
+                     end
+                     endcase // case(output_fifo_read_sop0_ptr)
+                   else
+                   begin
+                     saved_read_sop1_wire = 1'b0;
+                     saved_read_sop1_ptr_wire = 2'd0;
+                   end // else: !if(output_fifo_read_second_tlp)
+                 end // case: default
+                 endcase // case(output_fifo_read_sop1_ptr)
+              end // if (output_fifo_read_eop0 & output_fifo_read_sop1)
+            else
+              begin
+                saved_read_sop1_wire = 1'b0;
+                saved_read_sop1_ptr_wire = 2'd0;
+              end // else: !if(output_fifo_read_eop0 & output_fifo_read_sop1)
+
+            if (~output_fifo_read_eop0)
+              begin
+                 saved_read_eop_wire = 1'b0;
+                 saved_read_eop_ptr_wire = 3'd0;
+              end
+            else if (~output_fifo_read_eop1)
+              begin
+                 case(output_fifo_read_sop0_ptr)
+                   2'd0:
+                 begin
+                    if (output_fifo_read_sop_prev)
+                      begin
+                     if (output_fifo_read_eop0_ptr[2:1] != 2'd0)
+                       begin
+                          saved_read_eop_wire = 1'b1;
+                          saved_read_eop_ptr_wire = output_fifo_read_eop0_ptr - 3'd2;
+                       end
+                     else
+                       begin
+                          saved_read_eop_wire = 1'b0;
+                          saved_read_eop_ptr_wire = 3'd0;
+                       end
+                      end // if (output_fifo_read_sop_prev)
+                    else
+                      begin
+                     if (output_fifo_read_eop0_ptr[2])
+                       begin
+                          saved_read_eop_wire = 1'b1;
+                          saved_read_eop_ptr_wire = {1'b0, output_fifo_read_eop0_ptr[1:0]};
+                       end
+                     else
+                       begin
+                          saved_read_eop_wire = 1'b0;
+                          saved_read_eop_ptr_wire = 3'd0;
+                       end
+                      end // else: !if(output_fifo_read_sop_prev)
+                 end // case: 2'd0
+                   2'd1:
+                 begin
+                    if (output_fifo_read_eop0_ptr[2:1] == 2'd3)
+                      begin
+                     saved_read_eop_wire = 1'b1;
+                     saved_read_eop_ptr_wire = {2'b00, output_fifo_read_eop0_ptr[0]};
+                      end
+                    else
+                      begin
+                     saved_read_eop_wire = 1'b0;
+                     saved_read_eop_ptr_wire = 3'd0;
+                      end
+                 end // case: 2'd1
+                   default:
+                 begin
+                    saved_read_eop_wire = 1'b0;
+                    saved_read_eop_ptr_wire = 3'd0;
+                 end
+                 endcase // case(output_fifo_read_sop0_ptr)
+              end // if (~output_fifo_read_eop1)
+            else
+              begin
+                 case(output_fifo_read_sop1_ptr)
+                   2'd1:
+                 begin
+                   // Data from FIFO = EOP SOP DATA EOP or
+                   // EOP SOP EOP X.
+                   // There is also an SOP from previous beat.
+                   // Send out EOP GAP SOP EOP and save
+                   // 2 or 3 Qwords.
+                    saved_read_eop_wire = 1'b1;
+                    saved_read_eop_ptr_wire = {1'b0, output_fifo_read_eop1_ptr[1:0]} + 3'd2;
+                 end // case: 2'd1
+                   default: // 2'd2
+                 begin
+                   case(output_fifo_read_eop0_ptr[2:1])
+                     2'd0:
+                       // Data from FIFO = EOP GAP SOP EOP.
+                       // There is also an SOP from previous beat.
+                       // Send out EOP GAP SOP EOP and save SOP EOP.
+                       begin
+                     saved_read_eop_wire = 1'b1;
+                     saved_read_eop_ptr_wire = {1'b0, output_fifo_read_eop1_ptr[1:0]};
+                       end
+                     default: // 2'd1:
+                       begin
+                     if ((output_fifo_read_sop0_ptr == 2'd0) &&
+                         output_fifo_read_sop_prev)
+                       // Data from FIFO = DATA EOP SOP EOP
+                       // There is also an SOP from previous beat.
+                       // Send out EOP GAP SOP DATA and save EOP SOP EOP.
+                       begin
+                         saved_read_eop_wire = 1'b1;
+                         saved_read_eop_ptr_wire = {2'b00, output_fifo_read_eop0_ptr[0]};
+                       end
+                     else
+                       begin
+                         // Data from FIFO = SOP EOP SOP EOP
+                         // Send out EOP GAP SOP EOP and save SOP EOP.
+                         saved_read_eop_wire = 1'b1;
+                         saved_read_eop_ptr_wire = {1'b0, output_fifo_read_eop1_ptr[1:0]};
+                       end // else: !if((output_fifo_read_sop0_ptr == 2'd0) &&...
+                       end // case: default
+                   endcase // case(output_fifo_read_eop0_ptr[2:1])
+                 end // case: default
+                 endcase // case(output_fifo_read_sop1_ptr)
+              end // else: !if(~output_fifo_read_eop1)
+
+            saved_read_eop1_ptr_wire = output_fifo_read_eop1_ptr[0];
+
+             end // if (output_fifo_non_empty)
+
+           // Save ECC error from this cycle
+           if (output_fifo_non_empty)
+             begin
+            case(output_fifo_read_sop0_ptr)
+              2'd0:
+                begin
+                   if (output_fifo_read_sop_prev)
+                 begin
+                    if (~output_fifo_read_eop0)
+                      saved_read_uncorrectable_error_wire = saved_read_uncorrectable_error2 |
+                                        (|output_fifo_read_uncorrectable_error[1:0]);
+                    else 
+                      case(output_fifo_read_eop0_ptr[2:1])
+                    2'd0:
+                      begin
+                         if (output_fifo_read_sop1_ptr[1])
+                           saved_read_uncorrectable_error_wire = output_fifo_read_uncorrectable_error[1];
+                         else
+                           saved_read_uncorrectable_error_wire = (|output_fifo_read_uncorrectable_error[1:0]);
+                      end
+                    2'd1:
+                      begin
+                         saved_read_uncorrectable_error_wire = saved_read_uncorrectable_error2 |
+                                           output_fifo_read_uncorrectable_error[0];
+                      end
+                    default:
+                      begin
+                         saved_read_uncorrectable_error_wire = saved_read_uncorrectable_error2 |
+                                           (|output_fifo_read_uncorrectable_error[1:0]);
+                      end
+                      endcase // case(output_fifo_read_eop0_ptr[2:1])
+                 end // if (output_fifo_read_sop_prev)
+                   else
+                 if (~output_fifo_read_eop0)
+                      saved_read_uncorrectable_error_wire = (|output_fifo_read_uncorrectable_error[1:0]);
+                 else 
+                   case(output_fifo_read_eop0_ptr[2:1])
+                     2'd1:
+                       begin
+                      saved_read_uncorrectable_error_wire = output_fifo_read_uncorrectable_error[1];
+                       end
+                     default:
+                       begin
+                      saved_read_uncorrectable_error_wire = (|output_fifo_read_uncorrectable_error[1:0]);
+                       end
+                   endcase // case(output_fifo_read_eop0_ptr[2:1])
+                end // case: 2'd0
+              2'd1:
+                begin
+                   if (~output_fifo_read_eop0)
+                 saved_read_uncorrectable_error_wire = (|output_fifo_read_uncorrectable_error[1:0]);
+                   else
+                 saved_read_uncorrectable_error_wire = output_fifo_read_uncorrectable_error[1];
+                end
+              default:
+                begin
+                   saved_read_uncorrectable_error_wire = output_fifo_read_uncorrectable_error[1];
+                end
+            endcase // case(output_fifo_read_sop0_ptr)
+             end // if (output_fifo_non_empty)
+           
+           if (output_fifo_non_empty)
+             begin
+            if (output_fifo_read_eop0 & output_fifo_read_sop1 &
+                output_fifo_read_second_tlp)
+              begin
+                 case(output_fifo_read_sop1_ptr)
+                   2'd1:
+                 begin
+                    saved_read_uncorrectable_error1_wire = 1'b0;
+                 end
+                   default: // 2'd2
+                 begin
+                    if ((output_fifo_read_sop0_ptr == 2'd0) &&
+                    output_fifo_read_sop_prev &&
+                    (output_fifo_read_eop0_ptr[2:1] == 2'd1))
+                      saved_read_uncorrectable_error2_wire = output_fifo_read_uncorrectable_error[1];
+                    else
+                      saved_read_uncorrectable_error1_wire = 1'b0;
+                 end
+                 endcase // case(output_fifo_read_sop1_ptr)
+              end // if (output_fifo_read_eop0 & output_fifo_read_sop1 &...
+
+            if (output_fifo_read_sop2)
+              // Save last DW for use in a later beat.
+              saved_read_uncorrectable_error2_wire = output_fifo_read_uncorrectable_error[1];
+            else
+              saved_read_uncorrectable_error2_wire = 1'b0;
+             end // if (output_fifo_non_empty)
+        end // if (ccix_app_ready)
+	end // case: state[SEND_LAST_WORD_WITH_STRADDLE]
+      
+
+      default:
+        begin
+        end
+    endcase // case(1'b1)
+     end // always @ (*)
+
+   always @(*)
+     begin
+       out_data_wire = out_data_reg;
+       out_parity_wire = out_parity_reg;
+       saved_read_data_out_wire = saved_read_data_out;
+       saved_read_parity_out_wire = saved_read_parity_out;
+       if (ccix_app_ready)
+	 begin
+	   out_data_wire = output_fifo_non_empty? output_fifo_read_data: 256'd0;
+	   out_parity_wire = output_fifo_non_empty? output_fifo_read_parity: 32'd0;
+	   saved_read_data_out_wire = saved_read_data;
+	   saved_read_parity_out_wire = saved_read_parity;
+	 end
+
+     end // always @ (*)
+  
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, out_data_reg, out_data_wire, 256'd0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, out_parity_reg, out_parity_wire, 32'd0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, out_data_mux_sel0, out_data_mux_sel0_wire, 2'd0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, out_data_mux_sel1, out_data_mux_sel1_wire, 3'd0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, out_data_mux_sel2, out_data_mux_sel2_wire, 3'd0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, out_data_mux_sel3, out_data_mux_sel3_wire, 3'd0)
+
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, out_sop0_o, out_sop0_wire & out_data_valid_wire, 1'b0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, out_sop0_ptr_o, out_sop0_ptr_wire, 1'b0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, out_eop0_o, out_eop0_wire, 1'b0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, out_eop0_ptr_o, out_eop0_ptr_wire, 3'd0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, out_err0_o, out_err0_wire, 1'b0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, out_sop1_o, out_sop1_wire & out_data_valid_wire, 1'b0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, out_eop1_o, out_eop1_wire, 1'b0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, out_eop1_ptr_o, out_eop1_ptr_wire, 1'b0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, out_err1_o, out_err1_wire, 1'b0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, out_tlp_alignment, out_tlp_alignment_wire, 2'd0)
+
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, saved_read_uncorrectable_error, saved_read_uncorrectable_error_wire, 1'b0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, saved_read_uncorrectable_error1, saved_read_uncorrectable_error1_wire, 1'b0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, saved_read_uncorrectable_error2, saved_read_uncorrectable_error2_wire, 1'b0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, saved_read_data, saved_read_data_wire, 192'd0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, saved_read_parity, saved_read_parity_wire, 24'd0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, saved_read_data_out, saved_read_data_out_wire, 192'd0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, saved_read_parity_out, saved_read_parity_out_wire, 24'd0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, saved_read_sop, saved_read_sop_wire, 1'b0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, saved_read_sop1, saved_read_sop1_wire, 1'b0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, saved_read_sop1_ptr, saved_read_sop1_ptr_wire, 2'd0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, saved_read_eop, saved_read_eop_wire, 1'b0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, saved_read_eop_ptr, saved_read_eop_ptr_wire, 3'd0)
+   `XPREG(user_clk_ccix_i, reset_n_ccix_i, saved_read_eop1_ptr, saved_read_eop1_ptr_wire, 1'b0)
+
+     assign m_axis_ccix_rx_tdata_o[63:0] = (out_data_mux_sel0 == 2'd0)? out_data_reg[63:0]:
+                               (out_data_mux_sel0 == 2'd1)? out_data_reg[127:64]:
+                               (out_data_mux_sel0 == 2'd2)? out_data_reg[191:128]:
+			       saved_read_data_out[63:0];
+     assign m_axis_ccix_rx_tdata_o[127:64] = (out_data_mux_sel1 == 3'd0)? out_data_reg[63:0]:
+                               (out_data_mux_sel1 == 3'd1)? out_data_reg[127:64]:
+                               (out_data_mux_sel1 == 3'd2)? out_data_reg[191:128]:
+                               (out_data_mux_sel1 == 3'd3)? out_data_reg[255:192]:
+                               saved_read_data_out[127:64];
+     assign m_axis_ccix_rx_tdata_o[191:128] = (out_data_mux_sel2 == 3'd0)? out_data_reg[63:0]:
+                               (out_data_mux_sel2 == 3'd1)? out_data_reg[127:64]:
+                               (out_data_mux_sel2 == 3'd2)? out_data_reg[191:128]:
+                               (out_data_mux_sel2 == 3'd3)? out_data_reg[255:192]:
+                               (out_data_mux_sel2 == 3'd4)? saved_read_data_out[127:64]:
+                               saved_read_data_out[191:128];
+     assign m_axis_ccix_rx_tdata_o[255:192] = (out_data_mux_sel3 == 3'd0)? out_data_reg[63:0]:
+                               (out_data_mux_sel3 == 3'd1)? out_data_reg[127:64]:
+                               (out_data_mux_sel3 == 3'd2)? out_data_reg[191:128]:
+                               (out_data_mux_sel3 == 3'd3)? out_data_reg[255:192]:
+                               saved_read_data_out[191:128];
+  
+     assign out_parity_o[7:0] = (out_data_mux_sel0 == 2'd0)? out_parity_reg[7:0]:
+                               (out_data_mux_sel0 == 2'd1)? out_parity_reg[15:8]:
+                               (out_data_mux_sel0 == 2'd2)? out_parity_reg[23:16]:
+                   saved_read_parity_out[7:0];
+     assign out_parity_o[15:8] = (out_data_mux_sel1 == 3'd0)? out_parity_reg[7:0]:
+                               (out_data_mux_sel1 == 3'd1)? out_parity_reg[15:8]:
+                               (out_data_mux_sel1 == 3'd2)? out_parity_reg[23:16]:
+                               (out_data_mux_sel1 == 3'd3)? out_parity_reg[31:24]:
+                               saved_read_parity_out[15:8];
+     assign out_parity_o[23:16] = (out_data_mux_sel2 == 3'd0)? out_parity_reg[7:0]:
+                               (out_data_mux_sel2 == 3'd1)? out_parity_reg[15:8]:
+                               (out_data_mux_sel2 == 3'd2)? out_parity_reg[23:16]:
+                               (out_data_mux_sel2 == 3'd3)? out_parity_reg[31:24]:
+                               (out_data_mux_sel2 == 3'd4)? saved_read_parity_out[15:8]:
+                               saved_read_parity_out[23:16];
+     assign out_parity_o[31:24] = (out_data_mux_sel3 == 3'd0)? out_parity_reg[7:0]:
+                               (out_data_mux_sel3 == 3'd1)? out_parity_reg[15:8]:
+                               (out_data_mux_sel3 == 3'd2)? out_parity_reg[23:16]:
+                               (out_data_mux_sel3 == 3'd3)? out_parity_reg[31:24]:
+                               saved_read_parity_out[23:16];
+
+  // Gather outputs for the tuser bus
+
+  assign m_axis_ccix_rx_tuser_o[45:0] = {out_parity_o[31:0], // [45:14] = odd parity
+					 out_err1_o, out_err0_o, // // [13:12] = discontinue 
+					 out_eop1_o, out_eop1_o, out_eop1_ptr_o, // [11:9] = is_eop1_ptr
+					 out_eop1_o, // [8] = is_eop1 
+					 out_eop0_ptr_o[2:0], // [7:5] = is_eop0_ptr,
+					 out_eop0_o, // [4] = is_eop0 
+					 out_sop1_o, // [3] = is_sop1_ptr = is_sop1
+					 out_sop1_o, // [2] = is_sop1
+					 out_sop0_ptr_o, // [1] = is_sop0_ptr
+					 out_sop0_o // [0] = is_sop0
+					 };
+
+   always @(*)
+     begin
+       out_data_valid_wire = out_data_valid_o;
+    if (link_down_reset_i)
+      out_data_valid_wire = 1'b0;
+    else if (~ccix_app_ready)
+      out_data_valid_wire = 1'b0;
+    else
+      case(1'b1)
+        state[IDLE_ST_WITH_STRADDLE]:
+          begin
+            if (output_fifo_non_empty)
+              begin
+		if (output_fifo_read_eop0 || (output_fifo_read_sop0_ptr == 2'd0))
+                  out_data_valid_wire = 1'b1;
+		else
+                  out_data_valid_wire = 1'b0;
+              end // if (output_fifo_non_empty)
+            else
+              out_data_valid_wire = 1'b0;
+          end // case: state[IDLE_ST_WITH_STRADDLE]
+
+      state[CONTINUE_TLP_WITH_STRADDLE]:
+        begin
+          if (output_fifo_non_empty)
+            out_data_valid_wire = 1'b1;
+          else
+            out_data_valid_wire = 1'b0;
+        end
+
+        state[SEND_LAST_WORD_WITH_STRADDLE]:
+          begin
+            out_data_valid_wire = 1'b1;
+          end
+
+        default:
+          begin
+            out_data_valid_wire = out_data_valid_o;
+          end
+      endcase // case(1'b1)
+     end // always @ (*)
+   
+  `XPREG(user_clk_ccix_i, reset_n_ccix_i, out_data_valid_o, out_data_valid_wire, 1'b0)
+    assign m_axis_ccix_rx_tvalid_o = out_data_valid_o;
+
+   always @(*)
+     begin
+       next_state = {NUM_STATES{1'b0}};
+       if (link_down_reset_i)
+	 next_state = {NUM_STATES{1'b0}};
+    else
+      case(1'b1)
+        state[IDLE_ST_WITH_STRADDLE]:
+          begin
+         if (ccix_app_ready)
+           begin
+              if (output_fifo_non_empty)
+            begin
+               case(output_fifo_read_sop0_ptr)
+                 2'd0:
+                   begin
+                  if (output_fifo_read_eop0)
+                    begin
+                       if ((output_fifo_read_eop1 | output_fifo_read_second_tlp) &&
+                       output_fifo_read_sop1)
+                     begin
+                        // Second TLP starting
+                        case(output_fifo_read_sop1_ptr)
+                          2'd3:
+                        // Save the first Qword of the TLP and send in next cycle
+                        next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                          2'd2:
+                        begin
+                           if (output_fifo_read_sop_prev)
+                             begin
+                            if (output_fifo_read_eop0_ptr[2:1] == 2'd0)
+                              // Send the first two Qwords of the TLP in this cycle
+                              begin
+                                 if (output_fifo_read_eop1)
+                                   next_state[IDLE_ST_WITH_STRADDLE] = 1'b1;
+                                 else
+                                   next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                              end
+                            else
+                              begin
+                                 // Save the first two Qwords of the TLP and send in next cycle
+                                 if (output_fifo_read_eop1)
+                                   next_state[SEND_LAST_WORD_WITH_STRADDLE] = 1'b1;
+                                 else
+                                   next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                              end // else: !if(output_fifo_read_eop0_ptr[2:1] == 2'd0)
+                             end // if (output_fifo_read_sop_prev)
+                           else
+                             begin
+                            // Send the first two Qwords of the TLP in this cycle
+                              begin
+                                 if (output_fifo_read_eop1)
+                                   next_state[IDLE_ST_WITH_STRADDLE] = 1'b1;
+                                 else
+                                   next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                              end
+                             end // else: !if(output_fifo_read_sop_prev)
+                        end // case: 2'd2
+                          default: // 2'd1
+                        // Send the first two Qwords of the TLP in this cycle and the third QW in next cycle
+                        begin
+                           if (output_fifo_read_eop1)
+                             begin
+                            if (output_fifo_read_eop1_ptr[1])
+                              next_state[SEND_LAST_WORD_WITH_STRADDLE] = 1'b1;
+                            else
+                              next_state[IDLE_ST_WITH_STRADDLE] = 1'b1;
+                             end
+                           else
+                             next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                        end // case: default
+                        endcase // case(output_fifo_read_sop1_ptr)
+                     end // if ((output_fifo_read_eop1 | output_fifo_read_second_tlp) &&...
+                       else
+                     begin
+                        // No second TLP to send
+                        if (output_fifo_read_sop_prev)
+                          begin
+                         if (output_fifo_read_eop0_ptr[2:1] == 2'd3)
+                           next_state[SEND_LAST_WORD_WITH_STRADDLE] = 1'b1;
+                         else
+                           next_state[IDLE_ST_WITH_STRADDLE] = 1'b1;
+                          end
+                        else
+                          next_state[IDLE_ST_WITH_STRADDLE] = 1'b1;
+                     end // else: !if((output_fifo_read_eop1 | output_fifo_read_second_tlp) &&...
+                    end // if (output_fifo_read_eop0)
+                  else
+                    next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                   end // case: 2'd0
+
+                 2'd1:
+                   begin
+                  if (output_fifo_read_eop0)
+                    begin
+                       if (output_fifo_read_second_tlp &&
+                       output_fifo_read_sop1)
+                     // Second TLP starting in QW 3
+                     next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                       else
+                     next_state[IDLE_ST_WITH_STRADDLE] = 1'b1;
+                    end
+                  else
+                    next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                   end // case: 2'd1
+
+                 2'd2:
+                   begin
+                  if (output_fifo_read_eop0)
+                    next_state[IDLE_ST_WITH_STRADDLE] = 1'b1;
+                  else
+                    next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                   end
+
+                 default:
+                   begin
+                  next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                   end
+               endcase // case(output_fifo_read_sop0_ptr)
+            end // if (output_fifo_non_empty)
+              else
+            next_state[IDLE_ST_WITH_STRADDLE] = 1'b1;
+           end // if (~out_data_valid_o | ccix_app_ready)
+         else
+           next_state[IDLE_ST_WITH_STRADDLE] = 1'b1;
+          end // case: state[IDLE_ST_WITH_STRADDLE]
+
+        state[CONTINUE_TLP_WITH_STRADDLE]:
+          begin
+         if (ccix_app_ready)
+           begin
+             if (output_fifo_non_empty)
+               begin
+              case(out_tlp_alignment)
+                2'd0:
+                  begin
+                 if (~output_fifo_read_eop0)
+                   next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                 else
+                   case(output_fifo_read_eop0_ptr[2:1])
+                     2'd0:
+                       begin
+                      if (output_fifo_read_sop1 &&
+                          (output_fifo_read_eop1 | output_fifo_read_second_tlp))
+                        begin
+                           // Second TLP starting
+                           case(output_fifo_read_sop1_ptr)
+                         2'd1:
+                           begin
+                              // Second TLP starting in QW 1
+                              if (output_fifo_read_eop1)
+                            begin
+                               if (output_fifo_read_eop1_ptr[1])
+                                 // Send last QW of the TLP in next beat
+                                 next_state[SEND_LAST_WORD_WITH_STRADDLE] = 1'b1;
+                               else
+                                 next_state[IDLE_ST_WITH_STRADDLE] = 1'b1;
+                            end
+                              else
+                            next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                           end // case: 2'd1
+                         2'd2:
+                           begin
+                              if (output_fifo_read_eop1)
+                            next_state[IDLE_ST_WITH_STRADDLE] = 1'b1;
+                              else
+                            next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                           end
+                         default:
+                           begin
+                              next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                           end
+                           endcase // case(output_fifo_read_sop1_ptr)
+                        end // if (output_fifo_read_sop1 &&...
+                      else
+                        // No second TLP to send
+                        next_state[IDLE_ST_WITH_STRADDLE] = 1'b1;
+                       end // case: 2'd0
+
+                     2'd1:
+                       begin
+                      if (output_fifo_read_sop1 &&
+                          (output_fifo_read_eop1 | output_fifo_read_second_tlp))
+                        begin
+                           // Second TLP starting in QW 2
+                           if (output_fifo_read_eop1)
+                         next_state[IDLE_ST_WITH_STRADDLE] = 1'b1;
+                           else
+                         next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                        end // if (output_fifo_read_sop1 &&...
+                      else
+                        // No second TLP to send
+                        next_state[IDLE_ST_WITH_STRADDLE] = 1'b1;
+                       end // case: 2'd1
+
+                     2'd2:
+                       begin
+                      if (output_fifo_read_sop1 &
+                          output_fifo_read_second_tlp)
+                        // Second TLP starting
+                        next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                      else
+                        // No second TLP to send
+                        next_state[IDLE_ST_WITH_STRADDLE] = 1'b1;
+                       end
+
+                     default:
+                       begin
+                      next_state[IDLE_ST_WITH_STRADDLE] = 1'b1;
+                       end
+                   endcase // case(output_fifo_read_eop0_ptr[2:1])
+                  end // case: 2'd0
+                2'd1:
+                  begin
+                 // Three Qwords of data saved from last cycle.
+                 // The Qwords can be:
+                 // DATA DATA DATA
+                 // DATA EOP SOP
+                 // EOP SOP DATA
+                 // SOP DATA DATA
+                 // SOP EOP SOP
+                 if (saved_read_eop && (saved_read_eop_ptr[2:1] == 2'd0))
+                   begin
+                      // saved data = EOP SOP DATA                 
+                      // Send out EOP GAP SOP DATA.  De-assert ready.
+                      next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                   end
+                 else
+                   begin
+                      // saved data is one of
+                      // DATA DATA DATA
+                      // DATA EOP SOP
+                      // SOP DATA DATA
+                      // SOP EOP SOP
+                      if (~output_fifo_read_eop0)
+                    next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                      else
+                    case(output_fifo_read_eop0_ptr[2:1])
+                      2'd0:
+                        begin
+                           // Send saved data and EOP in this cycle.
+                           // If there is a second TLP, save it for next cycle.
+                           if (output_fifo_read_sop1 &&
+                           (output_fifo_read_eop1 | output_fifo_read_second_tlp))
+                         begin
+                            // Second TLP starting
+                            if (output_fifo_read_eop1)
+                              next_state[SEND_LAST_WORD_WITH_STRADDLE] = 1'b1;
+                            else
+                              next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                         end
+                           else
+                         next_state[IDLE_ST_WITH_STRADDLE] = 1'b1;
+                        end // case: 2'd0
+                      2'd1:
+                        begin
+                           // Data from FIFO = DATA EOP X X
+                           if (output_fifo_read_sop1 &&
+                           (output_fifo_read_eop1 | output_fifo_read_second_tlp))
+                         begin
+                            // Second TLP starting
+                            if (output_fifo_read_eop1)
+                              // Data from FIFO = DATA EOP SOP EOP
+                              // Save EOP SOP EOP for next cycle
+                              next_state[SEND_LAST_WORD_WITH_STRADDLE] = 1'b1;
+                            else
+                              // Data from FIFO = DATA EOP SOP DATA 
+                              next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                         end
+                           else
+                         next_state[SEND_LAST_WORD_WITH_STRADDLE] = 1'b1;
+                        end // case: 2'd1
+                      2'd2:
+                        begin
+                           if (output_fifo_read_sop1 &
+                           output_fifo_read_second_tlp)
+                         // Data from FIFO = DATA DATA EOP SOP
+                         next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                           else
+                         next_state[SEND_LAST_WORD_WITH_STRADDLE] = 1'b1;
+                        end
+                      default:
+                        begin
+                           // Data from FIFO = DATA DATA DATA EOP
+                           next_state[SEND_LAST_WORD_WITH_STRADDLE] = 1'b1;
+                        end
+                    endcase // case(output_fifo_read_eop0_ptr[2:1])
+                   end // else: !if(saved_read_eop && (saved_read_eop_ptr[2:1] == 2'd0))
+                  end // case: 2'd1
+
+                2'd2:
+                  begin
+                 // Two Qwords of data saved from last cycle.
+                 // The Qwords can be:
+                 // DATA DATA
+                 // EOP SOP
+                 // SOP DATA
+                 if (saved_read_eop)
+                   // saved data = EOP SOP
+                   begin
+                      if (~output_fifo_read_eop0)
+                    // Send out EOP GAP SOP DATA and save 3 Qwords
+                    next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                      else
+                    case(output_fifo_read_eop0_ptr[2:1])
+                      2'd0:
+                        begin
+                           // Send out EOP GAP SOP EOP in this cycle.
+                           // If there is a second TLP, save it for next cycle.
+                           if (output_fifo_read_sop1 &&
+                           (output_fifo_read_eop1 | output_fifo_read_second_tlp))
+                         begin
+                            // Second TLP starting
+                            if (output_fifo_read_eop1)
+                              next_state[SEND_LAST_WORD_WITH_STRADDLE] = 1'b1;
+                            else
+                              next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                         end
+                           else
+                         next_state[IDLE_ST_WITH_STRADDLE] = 1'b1;
+                        end // case: 2'd0
+                      2'd1:
+                        begin
+                           // Data from FIFO = DATA EOP X X
+                           if (output_fifo_read_sop1 &&
+                           (output_fifo_read_eop1 | output_fifo_read_second_tlp))
+                         begin
+                            // Second TLP starting
+                            if (output_fifo_read_eop1)
+                              // Data from FIFO = DATA EOP SOP EOP
+                              // Save EOP SOP EOP for next cycle
+                              next_state[SEND_LAST_WORD_WITH_STRADDLE] = 1'b1;
+                            else
+                              // Data from FIFO = DATA EOP SOP DATA 
+                              next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                         end
+                           else
+                         next_state[SEND_LAST_WORD_WITH_STRADDLE] = 1'b1;
+                        end // case: 2'd1
+                      2'd2:
+                        begin
+                           if (output_fifo_read_sop1 &
+                           output_fifo_read_second_tlp)
+                         // Data from FIFO = DATA DATA EOP SOP
+                         next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                           else
+                         next_state[SEND_LAST_WORD_WITH_STRADDLE] = 1'b1;
+                        end
+                      default:
+                        begin
+                           // Data from FIFO = DATA DATA DATA EOP
+                           next_state[SEND_LAST_WORD_WITH_STRADDLE] = 1'b1;
+                        end
+                    endcase // case(output_fifo_read_eop0_ptr[2:1])
+                   end // if (saved_read_eop)
+                 else
+                   begin
+                      // The saved Qwords can be:
+                      // DATA DATA or
+                      // SOP DATA
+                      if (~output_fifo_read_eop0)
+                    next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                      else
+                    case(output_fifo_read_eop0_ptr[2:1])
+                      2'd0:
+                        begin
+                           // If there is a second TLP, save it for next cycle.
+                           if (output_fifo_read_sop1 &&
+                           (output_fifo_read_eop1 | output_fifo_read_second_tlp))
+                         begin
+                            // Second TLP starting
+                            if (output_fifo_read_eop1)
+                              next_state[SEND_LAST_WORD_WITH_STRADDLE] = 1'b1;
+                            else
+                              next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                         end
+                           else
+                         next_state[IDLE_ST_WITH_STRADDLE] = 1'b1;
+                        end // case: 2'd0
+                      2'd1:
+                        begin
+                           // If there is a second TLP, save it for next cycle.
+                           if (output_fifo_read_sop1 &&
+                           (output_fifo_read_eop1 | output_fifo_read_second_tlp))
+                         begin
+                            // Second TLP starting
+                            if (output_fifo_read_eop1)
+                              next_state[SEND_LAST_WORD_WITH_STRADDLE] = 1'b1;
+                            else
+                              next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                         end
+                           else
+                         next_state[IDLE_ST_WITH_STRADDLE] = 1'b1;
+                        end // case: 2'd0
+                      2'd2:
+                        begin
+                           if (output_fifo_read_sop1 &
+                           output_fifo_read_second_tlp)
+                         // Data from FIFO = DATA DATA EOP SOP
+                         next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                           else
+                         next_state[SEND_LAST_WORD_WITH_STRADDLE] = 1'b1;
+                        end
+                      default:
+                        begin
+                           next_state[SEND_LAST_WORD_WITH_STRADDLE] = 1'b1;
+                        end
+                    endcase // case(output_fifo_read_eop0_ptr[2:1])
+                   end // else: !if(saved_read_eop)
+                  end // case: 2'd2
+                default:
+                  begin
+                 // One Qword of data saved from last cycle.
+                 // The Qword can be DATA or SOP.
+                 if (~output_fifo_read_eop0)
+                   next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                 else
+                   case(output_fifo_read_eop0_ptr[2:1])
+                     2'd0:
+                       begin
+                      if (output_fifo_read_sop1 &
+                          (output_fifo_read_eop1 | output_fifo_read_second_tlp))
+                        begin
+                           // Second TLP starting
+                           case(output_fifo_read_sop1_ptr)
+                         2'd1:
+                           begin
+                              if (output_fifo_read_eop1)
+                            begin
+                               // Data from FIFO = EOP SOP EOP X or EOP SOP DATA EOP
+                               if (output_fifo_read_eop1_ptr[1])
+                                 // Data from FIFO = EOP SOP DATA EOP
+                                 next_state[SEND_LAST_WORD_WITH_STRADDLE] = 1'b1;
+                               else
+                                 // Data from FIFO = EOP SOP EOP X
+                                        next_state[IDLE_ST_WITH_STRADDLE] = 1'b1;
+                            end
+                              else
+                            // Data from FIFO = EOP SOP DATA DATA
+                            next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                           end // case: 2'd1
+                         2'd2:
+                           begin
+                              // Data from FIFO = EOP GAP SOP EOP or EOP GAP SOP DATA
+                              if (output_fifo_read_eop1)
+                                   next_state[IDLE_ST_WITH_STRADDLE] = 1'b1;
+                              else
+                            next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                           end
+                         default:
+                           begin
+                              next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                           end
+                           endcase // case(output_fifo_read_sop1_ptr)
+                        end // if (output_fifo_read_sop1 &...
+                      else
+                        next_state[IDLE_ST_WITH_STRADDLE] = 1'b1;
+                       end // case: 2'd0
+
+                     2'd1:
+                       begin
+                      if (output_fifo_read_sop1 &
+                          (output_fifo_read_eop1 | output_fifo_read_second_tlp))
+                        begin
+                           // Second TLP starting in QW 2
+                           if (output_fifo_read_eop1)
+                         // Data from FIFO = DATA EOP SOP EOP
+                         next_state[SEND_LAST_WORD_WITH_STRADDLE] = 1'b1;
+                           else
+                         // Data from FIFO = DATA EOP SOP DATA
+                           next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                        end
+                      else
+                        next_state[IDLE_ST_WITH_STRADDLE] = 1'b1;
+                       end // case: 2'd1
+                     2'd2:
+                       begin
+                      if (output_fifo_read_sop1 &
+                          (output_fifo_read_eop1 | output_fifo_read_second_tlp))
+                        // Second TLP starting
+                        // Data from FIFO = DATA DATA EOP SOP
+                        next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                      else
+                        next_state[IDLE_ST_WITH_STRADDLE] = 1'b1;
+                       end
+                     default:
+                       begin
+                      // Data from FIFO = DATA DATA DATA EOP
+                      next_state[SEND_LAST_WORD_WITH_STRADDLE] = 1'b1;
+                       end
+                   endcase // case(output_fifo_read_eop0_ptr[2:1])
+                  end // case: default
+              endcase // case(out_tlp_alignment)
+               end // if (output_fifo_non_empty)
+             else
+               next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+	   end // if (ccix_app_ready)
+         else
+           next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+          end // case: state[CONTINUE_TLP_WITH_STRADDLE]
+
+        state[SEND_LAST_WORD_WITH_STRADDLE]:
+          begin
+         if (ccix_app_ready)
+           begin
+              case(out_tlp_alignment)
+            2'd1:
+              begin
+                 // 3 Qwords saved. Can be one of
+                 // DATA DATA EOP
+                 // EOP SOP EOP
+                 // SOP DATA EOP
+                 next_state[IDLE_ST_WITH_STRADDLE] = 1'b1;
+              end
+            default:
+              begin
+                 // 1 or 2 Qwords saved.
+                 if (output_fifo_non_empty)
+                   begin
+                  if (~output_fifo_read_eop0)
+                    next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                  else
+                    case(output_fifo_read_eop0_ptr[2:1])
+                      2'd0:
+                    begin
+                       if (output_fifo_read_sop1 &&
+                           (output_fifo_read_eop1 | output_fifo_read_second_tlp))
+                         begin
+                        // Second TLP starting
+                        if (output_fifo_read_eop1)
+                          next_state[SEND_LAST_WORD_WITH_STRADDLE] = 1'b1;
+                        else
+                          next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                         end
+                       else
+                         next_state[IDLE_ST_WITH_STRADDLE] = 1'b1;
+                    end // case: 2'd0
+                      2'd1:
+                    begin
+                       if ((output_fifo_read_sop0_ptr == 2'd0) && output_fifo_read_sop_prev)
+                         // 3 QW TLP
+                         begin
+                           if (output_fifo_read_sop1 &&
+                            (output_fifo_read_eop1 | output_fifo_read_second_tlp))
+                         begin
+                           // Second TLP starting
+                           if (output_fifo_read_eop1)
+                             next_state[SEND_LAST_WORD_WITH_STRADDLE] = 1'b1;
+                           else
+                             next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                         end
+                           else
+                         next_state[SEND_LAST_WORD_WITH_STRADDLE] = 1'b1;
+                         end // if ((output_fifo_read_sop0_ptr == 2'd0) && output_fifo_read_sop_prev)
+                       else
+                         begin
+                           if (output_fifo_read_sop1 &&
+                           (output_fifo_read_eop1 | output_fifo_read_second_tlp))
+                         begin
+                           // Second TLP starting
+                           if (output_fifo_read_eop1)
+                             next_state[SEND_LAST_WORD_WITH_STRADDLE] = 1'b1;
+                           else
+                             next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                         end
+                           else
+                         next_state[IDLE_ST_WITH_STRADDLE] = 1'b1;
+                         end // else: !if((output_fifo_read_sop0_ptr == 2'd0) && output_fifo_read_sop_prev)
+                    end // case: 2'd1
+                      2'd2:
+                    begin
+                       if (output_fifo_read_sop1 &
+                           output_fifo_read_second_tlp)
+                         next_state[CONTINUE_TLP_WITH_STRADDLE] = 1'b1;
+                       else
+                         case(output_fifo_read_sop0_ptr)
+                           2'd0: // TLP has 3 or 4 Qwords, only 2 can be sent in this beat
+                         next_state[SEND_LAST_WORD_WITH_STRADDLE] = 1'b1;
+                           default: // TLP has 2 Qwords, send them in this beat
+                         next_state[IDLE_ST_WITH_STRADDLE] = 1'b1;
+                         endcase // case(output_fifo_read_sop0_ptr)
+                    end // case: 2'd2
+                      default:
+                    begin
+                      case(output_fifo_read_sop0_ptr)
+                        2'd0: // TLP has 4 or 45Qwords, only 2 can be sent in this beat
+                          next_state[SEND_LAST_WORD_WITH_STRADDLE] = 1'b1;
+                        2'd1: // TLP has 3 Qwords, only 2 can be sent in this beat
+                          next_state[SEND_LAST_WORD_WITH_STRADDLE] = 1'b1;
+                        default: // TLP has 2 Qwords, send them in this beat
+                          next_state[IDLE_ST_WITH_STRADDLE] = 1'b1;
+                      endcase // case(output_fifo_read_sop0_ptr)
+                    end // case: default
+                    endcase // case(output_fifo_read_eop0_ptr[2:1])
+                   end // if (output_fifo_non_empty)
+                 else
+                   next_state[IDLE_ST_WITH_STRADDLE] = 1'b1;
+              end // case: default
+              endcase // case(out_tlp_alignment)
+           end // if (ccix_app_ready)
+         else
+           next_state[SEND_LAST_WORD_WITH_STRADDLE] = 1'b1;
+          end // case: state[SEND_LAST_WORD_WITH_STRADDLE]
+
+        default:
+          begin
+            next_state[IDLE_ST_WITH_STRADDLE] = 1'b1;
+          end
+      endcase // case(1'b1)
+  end 
+
+ `XPREG(user_clk_ccix_i, reset_n_ccix_i, state, next_state, {NUM_STATES{1'b0}})
+
+
+   always @(*)
+     begin
+       if (~output_fifo_non_empty)
+     output_fifo_read_active = 1'b0;
+       else
+    case(1'b1)
+      state[IDLE_ST_WITH_STRADDLE]:
+        begin
+           output_fifo_read_active = ccix_app_ready;
+        end
+
+      state[CONTINUE_TLP_WITH_STRADDLE]:
+        begin
+               if (ccix_app_ready)
+         case(out_tlp_alignment)
+           2'd1:
+             begin
+            // Three Qwords of data saved from last cycle.
+            // The Qwords can be:
+            // DATA DATA DATA
+            // DATA EOP SOP
+            // EOP SOP DATA
+            // SOP DATA DATA
+            // SOP EOP SOP
+            if (saved_read_eop && saved_read_sop1 && (saved_read_sop1_ptr == 2'd1))
+              // Saved data = EOP SOP DATA.
+              // Send saved data and de-assert ready.
+              output_fifo_read_active = 1'b0;
+            else
+              output_fifo_read_active = 1'b1;
+             end // case: 2'd1
+           default: output_fifo_read_active = 1'b1;
+         endcase // case(out_tlp_alignment)
+           else
+         output_fifo_read_active = 1'b0;
+        end // case: state[CONTINUE_TLP_WITH_STRADDLE]
+
+      state[SEND_LAST_WORD_WITH_STRADDLE]:
+        begin
+           if (ccix_app_ready)
+         begin
+            case(out_tlp_alignment)
+              2'd1:
+            begin
+               // 3 Qwords saved. Can be one of
+               // DATA DATA EOP
+               // EOP SOP EOP
+               // SOP DATA EOP
+               output_fifo_read_active = 1'b0;
+            end
+              default:
+            begin
+               output_fifo_read_active = 1'b1;
+            end
+            endcase // case(out_tlp_alignment)
+         end // if (ccix_app_ready)
+           else
+         output_fifo_read_active = 1'b0;
+        end // case: state[SEND_LAST_WORD_WITH_STRADDLE]
+
+      default:
+        output_fifo_read_active = 1'b0;
+    endcase // case(1'b1)
+     end // always @ (*)
+   
+   // ECC error reporting
+   always @(*)
+     begin
+    ecc_corr_err_detected_wire = 1'b0;
+    ecc_uncorr_err_detected_wire = 1'b0;
+    
+    case(1'b1)
+      state[IDLE_ST_WITH_STRADDLE]:
+        begin
+           if (ccix_app_ready)
+         begin
+            if (output_fifo_non_empty)
+              case(output_fifo_read_sop0_ptr)
+            2'd0:
+              begin
+                 if (output_fifo_read_eop0)
+                   begin
+                  if (output_fifo_read_eop0_ptr[2] ||
+                      (output_fifo_read_sop1 &&
+                       (output_fifo_read_eop1 | output_fifo_read_second_tlp)))
+                    begin
+                       ecc_corr_err_detected_wire = |output_fifo_read_correctable_error[1:0];
+                       ecc_uncorr_err_detected_wire = |output_fifo_read_uncorrectable_error[1:0];
+                    end
+                  else
+                    begin
+                       ecc_corr_err_detected_wire = output_fifo_read_correctable_error[0];
+                       ecc_uncorr_err_detected_wire = output_fifo_read_uncorrectable_error[0];
+                    end // else: !if(output_fifo_read_eop0_ptr[2] ||...
+                   end // if (output_fifo_read_eop0)
+                 else
+                   begin
+                  ecc_corr_err_detected_wire = |output_fifo_read_correctable_error[1:0];
+                  ecc_uncorr_err_detected_wire = |output_fifo_read_uncorrectable_error[1:0];
+                   end
+              end // case: 2'd0
+            2'd1:
+              begin
+                 ecc_corr_err_detected_wire = |output_fifo_read_correctable_error[1:0];
+                 ecc_uncorr_err_detected_wire = |output_fifo_read_uncorrectable_error[1:0];
+              end // case: 2'd1
+            default:
+              begin
+                 ecc_corr_err_detected_wire = output_fifo_read_correctable_error[1];
+                 ecc_uncorr_err_detected_wire = output_fifo_read_uncorrectable_error[1];
+              end
+              endcase // case(output_fifo_read_sop0_ptr)
+	 end // if (ccix_app_ready)
+        end // case: state[IDLE_ST_WITH_STRADDLE]
+      
+      state[CONTINUE_TLP_WITH_STRADDLE]:
+        begin
+           if (ccix_app_ready)
+         begin
+            if (output_fifo_non_empty)
+              begin
+             if ((out_tlp_alignment == 2'd1) &&
+                 saved_read_eop && saved_read_sop1 && (saved_read_sop1_ptr == 2'd1))
+               // Saved data = EOP SOP DATA.
+               // Send saved data and de-assert ready.  Do not report any errors in this cycle
+               begin
+                  ecc_corr_err_detected_wire = 1'b0;
+                  ecc_uncorr_err_detected_wire = 1'b0;
+               end
+             else
+               begin
+                  case(output_fifo_read_sop0_ptr)
+                2'd0:
+                  begin
+                     if (output_fifo_read_eop0)
+                       begin
+                      if (output_fifo_read_eop0_ptr[2] ||
+                          (output_fifo_read_sop1 &&
+                           (output_fifo_read_eop1 | output_fifo_read_second_tlp)))
+                        begin
+                           ecc_corr_err_detected_wire = |output_fifo_read_correctable_error[1:0];
+                           ecc_uncorr_err_detected_wire = |output_fifo_read_uncorrectable_error[1:0];
+                        end
+                      else
+                        begin
+                           ecc_corr_err_detected_wire = output_fifo_read_correctable_error[0];
+                           ecc_uncorr_err_detected_wire = output_fifo_read_uncorrectable_error[0];
+                        end // else: !if(output_fifo_read_eop0_ptr[2] ||...
+                       end // if (output_fifo_read_eop0)
+                     else
+                       begin
+                      ecc_corr_err_detected_wire = |output_fifo_read_correctable_error[1:0];
+                      ecc_uncorr_err_detected_wire = |output_fifo_read_uncorrectable_error[1:0];
+                       end
+                  end // case: 2'd0
+                2'd1:
+                  begin
+                     ecc_corr_err_detected_wire = |output_fifo_read_correctable_error[1:0];
+                     ecc_uncorr_err_detected_wire = |output_fifo_read_uncorrectable_error[1:0];
+                  end // case: 2'd1
+                default:
+                  begin
+                     ecc_corr_err_detected_wire = output_fifo_read_correctable_error[1];
+                     ecc_uncorr_err_detected_wire = output_fifo_read_uncorrectable_error[1];
+                  end
+                  endcase // case(output_fifo_read_sop0_ptr)
+               end // else: !if((out_tlp_alignment == 2'd1) &&...
+              end // if (output_fifo_non_empty)
+            else
+              begin
+             ecc_corr_err_detected_wire = 1'b0;
+             ecc_uncorr_err_detected_wire = 1'b0;
+              end
+	 end // if (ccix_app_ready)
+        end // case: state[CONTINUE_TLP_WITH_STRADDLE]
+
+      state[SEND_LAST_WORD_WITH_STRADDLE]:
+        begin
+           if (ccix_app_ready)
+         begin
+            case(out_tlp_alignment)
+              2'd1:
+            begin
+               // 3 Qwords saved. Can be one of
+               // DATA DATA EOP
+               // EOP SOP EOP
+               // SOP DATA EOP
+               ecc_corr_err_detected_wire = 1'b0;
+               ecc_uncorr_err_detected_wire = 1'b0;
+            end
+              default:
+            begin
+               if (output_fifo_non_empty)
+                 begin
+                case(output_fifo_read_sop0_ptr)
+                  2'd0:
+                    begin
+                       if (output_fifo_read_eop0)
+                     begin
+                        if (output_fifo_read_eop0_ptr[2] ||
+                        (output_fifo_read_sop1 &&
+                         (output_fifo_read_eop1 | output_fifo_read_second_tlp)))
+                          begin
+                         ecc_corr_err_detected_wire = |output_fifo_read_correctable_error[1:0];
+                         ecc_uncorr_err_detected_wire = |output_fifo_read_uncorrectable_error[1:0];
+                          end
+                        else
+                          begin
+                         ecc_corr_err_detected_wire = output_fifo_read_correctable_error[0];
+                         ecc_uncorr_err_detected_wire = output_fifo_read_uncorrectable_error[0];
+                          end // else: !if(output_fifo_read_eop0_ptr[2] ||...
+                     end // if (output_fifo_read_eop0)
+                       else
+                     begin
+                        ecc_corr_err_detected_wire = |output_fifo_read_correctable_error[1:0];
+                        ecc_uncorr_err_detected_wire = |output_fifo_read_uncorrectable_error[1:0];
+                     end
+                    end // case: 2'd0
+                  2'd1:
+                    begin
+                       ecc_corr_err_detected_wire = |output_fifo_read_correctable_error[1:0];
+                       ecc_uncorr_err_detected_wire = |output_fifo_read_uncorrectable_error[1:0];
+                    end // case: 2'd1
+                  default:
+                    begin
+                       ecc_corr_err_detected_wire = output_fifo_read_correctable_error[1];
+                       ecc_uncorr_err_detected_wire = output_fifo_read_uncorrectable_error[1];
+                    end
+                endcase // case(output_fifo_read_sop0_ptr)
+                 end // if (output_fifo_non_empty)
+               else
+                 begin
+                ecc_corr_err_detected_wire = 1'b0;
+                ecc_uncorr_err_detected_wire = 1'b0;
+                 end // else: !if(output_fifo_non_empty)
+            end // case: default
+            endcase // case(out_tlp_alignment)
+         end // if (ccix_app_ready)
+           else
+         begin
+            ecc_corr_err_detected_wire = 1'b0;
+            ecc_uncorr_err_detected_wire = 1'b0;
+         end // else: !if(output_fifo_non_empty)
+        end // case: state[SEND_LAST_WORD_WITH_STRADDLE]
+
+      default:
+        begin
+           ecc_corr_err_detected_wire = 1'b0;
+           ecc_uncorr_err_detected_wire = 1'b0;
+        end
+    endcase // case(1'b1)
+     end // always @ (*)
+
+ `XPREG(user_clk_ccix_i, reset_n_ccix_i, ccix_rx_correctable_error_detected_o, ecc_corr_err_detected_wire, 1'b0)
+ `XPREG(user_clk_ccix_i, reset_n_ccix_i, ccix_rx_uncorrectable_error_detected_o, ecc_uncorr_err_detected_wire, 1'b0)
+
+   // Maintain credit count on the egress interface
+   always @(*)
+     begin
+       available_credit_wire = ccix_rx_credit_av_o;
+       available_credit_zero_wire = available_credit_zero;
+       available_credit_one_wire = available_credit_one;
+
+       if (link_down_reset_i)
+	 begin
+	   available_credit_wire = ccix_rx_credit_av_o;
+	   available_credit_zero_wire = 1'b1;
+	   available_credit_one_wire = 1'b0;
+	 end
+       else
+	 case({m_axis_ccix_rx_tvalid_o, ccix_rx_credit_i})
+	   2'b01:
+	     begin
+	       // Credit received from downstream, increment count
+	       if (ccix_rx_credit_av_o != 8'hff)
+		 available_credit_wire = ccix_rx_credit_av_o + 8'd1;
+	       else
+		 available_credit_wire = ccix_rx_credit_av_o;
+	       available_credit_zero_wire = 1'b0;
+	       available_credit_one_wire = (ccix_rx_credit_av_o == 8'd0);
+	     end
+	   2'b10:
+	     begin
+	       // TLP forwarded downstream, decrement count
+	       if (ccix_rx_credit_av_o != 8'd0)
+		 available_credit_wire = ccix_rx_credit_av_o - 8'd1;
+	       else
+		 available_credit_wire = ccix_rx_credit_av_o;
+	       available_credit_zero_wire = (ccix_rx_credit_av_o == 8'd1);
+	       available_credit_one_wire = (ccix_rx_credit_av_o == 8'd2);
+	     end
+	   default:
+	     begin
+	       // No change in credit
+	       available_credit_wire = ccix_rx_credit_av_o;
+	       available_credit_zero_wire = available_credit_zero;
+	       available_credit_one_wire = available_credit_one;
+	     end
+	 endcase // case({m_axis_ccix_rx_tvalid_o, ccix_rx_credit_i})
+     end // always @ (*)
+  
+  `XPREG(user_clk_ccix_i, reset_n_ccix_i, ccix_rx_credit_av_o, available_credit_wire, 8'd0)
+  `XPREG(user_clk_ccix_i, reset_n_ccix_i, available_credit_zero, available_credit_zero_wire, 8'd0)
+  `XPREG(user_clk_ccix_i, reset_n_ccix_i, available_credit_one, available_credit_one_wire, 8'd0)
+
+    assign ccix_app_ready = ~(available_credit_zero | (available_credit_one & m_axis_ccix_rx_tvalid_o &
+						       ~ccix_rx_credit_i));
+
+    //-------------------------------------------------------------
+    // Credit Released indications
+    //-------------------------------------------------------------
+   always @(*)
+     begin
+       egress_tlp_in_progress_wire = egress_tlp_in_progress;
+       tlp_in_progress_payload_dw_count_wire = tlp_in_progress_payload_dw_count;
+       if (link_down_reset_i)
+	 begin
+	   egress_tlp_in_progress_wire = 1'b0;
+	   tlp_in_progress_payload_dw_count_wire = 8'd0;
+	 end
+       else if (out_data_valid_o)
+	 begin
+	   if (~egress_tlp_in_progress)
+	     begin
+	       egress_tlp_in_progress_wire = ((out_sop0_o & ~out_eop0_o)|
+					      (out_sop1_o & ~out_eop1_o));
+	       if (attr_ccix_direct_attach_mode_i & out_sop1_o & ~out_eop1_o)
+		 tlp_in_progress_payload_dw_count_wire = 8'd1;
+	       else if (attr_ccix_direct_attach_mode_i & out_sop0_o & ~out_eop0_o & ~out_sop0_ptr_o)
+		 tlp_in_progress_payload_dw_count_wire = 8'd5;
+	       else if (attr_ccix_direct_attach_mode_i & out_sop0_o & ~out_eop0_o & out_sop0_ptr_o)
+		 tlp_in_progress_payload_dw_count_wire = 8'd1;
+	       else if (~attr_ccix_direct_attach_mode_i & out_sop0_o & ~out_eop0_o & ~out_sop0_ptr_o)
+		 tlp_in_progress_payload_dw_count_wire = 8'd4;
+	       else
+		 tlp_in_progress_payload_dw_count_wire = 8'd0;
+	     end // if (~egress_tlp_in_progress)
+	   else
+	     begin
+	       egress_tlp_in_progress_wire = ~out_eop0_o |
+					     (out_sop0_o & ~out_eop1_o);
+	       if (~out_eop0_o)
+		 tlp_in_progress_payload_dw_count_wire = tlp_in_progress_payload_dw_count + 8'd8;
+	       else if (attr_ccix_direct_attach_mode_i & out_sop0_o & ~out_eop1_o)
+		 tlp_in_progress_payload_dw_count_wire = 8'd1;
+	       else
+		 tlp_in_progress_payload_dw_count_wire = 8'd0;
+	     end // else: !if(~egress_tlp_in_progress)
+	 end // if (out_data_valid_o)
+     end // always @ (*)
+  
+  `XPREG(user_clk_ccix_i, reset_n_ccix_i, egress_tlp_in_progress, egress_tlp_in_progress_wire, 1'b0)
+  `XPREG(user_clk_ccix_i, reset_n_ccix_i, tlp_in_progress_payload_dw_count, 
+	 tlp_in_progress_payload_dw_count_wire, 8'd0)
+
+    assign tlp_in_progress_payload_dw_count_plus = tlp_in_progress_payload_dw_count + 
+						    {5'd0, out_eop0_ptr_o[2:0]} + 8'd1;
+
+   always @(*)
+     begin
+       ccix_rx_tlp_forwarded0_wire = 1'b0;
+       ccix_rx_tlp_forwarded_length0_wire = 6'd0;
+       ccix_rx_tlp_forwarded1_wire = 1'b0;
+       ccix_rx_tlp_forwarded_length1_wire = 1'b0;
+       if (out_data_valid_o)
+	 begin
+	   if (egress_tlp_in_progress)
+	     begin
+	       if (out_eop0_o)
+		 begin
+		   ccix_rx_tlp_forwarded0_wire = 1'b1;
+		   if (tlp_in_progress_payload_dw_count_plus[1:0] != 2'd0)
+		     ccix_rx_tlp_forwarded_length0_wire = tlp_in_progress_payload_dw_count_plus[7:2] + 6'd1;
+		   else
+		     ccix_rx_tlp_forwarded_length0_wire = tlp_in_progress_payload_dw_count_plus[7:2];
+		 end
+	       ccix_rx_tlp_forwarded1_wire = out_sop0_o & out_eop1_o;
+	       ccix_rx_tlp_forwarded_length1_wire = attr_ccix_direct_attach_mode_i &
+						    out_sop0_o & out_eop1_o &
+						    out_eop1_ptr_o;
+	     end // if (egress_tlp_in_progress)
+	   else
+	     begin
+	       if (out_eop0_o)
+		 begin
+		   ccix_rx_tlp_forwarded0_wire = 1'b1;
+		   if (attr_ccix_direct_attach_mode_i)
+		     begin
+		       case(out_eop0_ptr_o)
+			 3'd3: ccix_rx_tlp_forwarded_length0_wire = 6'd1;
+			 3'd4: ccix_rx_tlp_forwarded_length0_wire = 6'd1;
+			 3'd5: ccix_rx_tlp_forwarded_length0_wire = 6'd1;
+			 3'd6: ccix_rx_tlp_forwarded_length0_wire = 6'd1;
+			 3'd7: ccix_rx_tlp_forwarded_length0_wire = 6'd2;
+			 default: ccix_rx_tlp_forwarded_length0_wire = 6'd0;
+		       endcase // case(out_eop0_ptr_o)
+		     end
+		   else
+		     begin
+		       if (out_eop0_ptr_o[2])
+			 ccix_rx_tlp_forwarded_length0_wire = 6'd1;
+		       else
+			 ccix_rx_tlp_forwarded_length0_wire = 6'd0;
+		     end
+		 end // if (out_eop0_o)
+	       ccix_rx_tlp_forwarded1_wire = out_sop1_o & out_eop1_o;
+	       ccix_rx_tlp_forwarded_length1_wire = attr_ccix_direct_attach_mode_i &
+						    out_sop1_o & out_eop1_o &
+						    out_eop1_ptr_o;
+	     end // else: !if(egress_tlp_in_progress)
+	 end // if (out_data_valid_o)
+     end // always @ (*)
+  
+  `XPREG(user_clk_ccix_i, reset_n_ccix_i, ccix_rx_tlp_forwarded0_o, ccix_rx_tlp_forwarded0_wire, 1'b0)
+  `XPREG(user_clk_ccix_i, reset_n_ccix_i, ccix_rx_tlp_forwarded_length0_o, 
+	 ccix_rx_tlp_forwarded_length0_wire, 6'd0)
+  `XPREG(user_clk_ccix_i, reset_n_ccix_i, ccix_rx_tlp_forwarded1_o, ccix_rx_tlp_forwarded1_wire, 1'b0)
+  `XPREG(user_clk_ccix_i, reset_n_ccix_i, ccix_rx_tlp_forwarded_length1_o, 
+	 ccix_rx_tlp_forwarded_length1_wire, 1'b0)
+
+    endmodule // pcie_4_c_tl_rx_ccix_fifo
+
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2023 AMD, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD, Inc. and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : UltraScale+ FPGA PCI Express v4.0 Integrated Block
+// File       : xp4_usp_smsw_phy_ff_chain.v
+// Version    : 1.1 
+//-----------------------------------------------------------------------------
+/*****************************************************************************
+** Description:
+**    Flop Chain
+**
+******************************************************************************/
+
+`timescale 1ps/1ps
+
+`define AS_PHYREG(clk, reset, q, d, rstval)  \
+   always @(posedge clk or posedge reset) begin \
+      if (reset) \
+         q  <= #(TCQ)   rstval;  \
+      else  \
+         q  <= #(TCQ)   d; \
+   end
+
+`define PHYREG(clk, reset, q, d, rstval)  \
+   always @(posedge clk) begin \
+      if (reset) \
+         q  <= #(TCQ)   rstval;  \
+      else  \
+         q  <= #(TCQ)   d; \
+   end
+
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_phy_ff_chain #(
+   // Parameters
+   parameter integer PIPELINE_STAGES   = 0,        // 0 = no pipeline; 1 = 1 stage; 2 = 2 stages; 3 = 3 stages
+   parameter         ASYNC             = "FALSE",
+   parameter integer FF_WIDTH          = 1,
+   parameter integer RST_VAL           = 0,
+   parameter integer TCQ               = 1
+)  (   
+   input  wire                         clock_i,          
+   input  wire                         reset_i,           
+   input  wire [FF_WIDTH-1:0]          ff_i,            
+   output wire [FF_WIDTH-1:0]          ff_o        
+   );
+
+   genvar   var_i;
+
+   reg   [FF_WIDTH-1:0]          ff_chain [PIPELINE_STAGES:0];
+
+   always @(*) ff_chain[0] = ff_i;
+
+generate
+   if (PIPELINE_STAGES > 0) begin:  with_ff_chain
+      for (var_i = 0; var_i < PIPELINE_STAGES; var_i = var_i + 1) begin: ff_chain_gen
+         if (ASYNC == "TRUE") begin: async_rst
+            `AS_PHYREG(clock_i, reset_i, ff_chain[var_i+1], ff_chain[var_i], RST_VAL)
+         end else begin: sync_rst
+            `PHYREG(clock_i, reset_i, ff_chain[var_i+1], ff_chain[var_i], RST_VAL)
+         end
+      end
+   end
+endgenerate
+
+   assign ff_o = ff_chain[PIPELINE_STAGES];
+
+endmodule
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2023 AMD, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD, Inc. and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : UltraScale+ FPGA PCI Express v4.0 Integrated Block
+// File       : xp4_usp_smsw_phy_pipeline.v
+// Version    : 1.1 
+//-----------------------------------------------------------------------------
+/*****************************************************************************
+** Description:
+**    Programmable stages for routing to PHY Lanes
+**
+******************************************************************************/
+
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_phy_pipeline #(
+   // Parameters
+   parameter integer PIPELINE_STAGES   = 0,        // 0 = no pipeline; 1 = 1 stage; 2 = 2 stages; 3 = 3 stages
+   parameter integer PHY_LANE          = 1,        // Valid settings: 1, 2, 4, 8, 16(only for Gen1/2/3)
+   parameter integer TCQ               = 1
+)  (   
+   // Clock & Reset
+   input  wire                         phy_pclk,          
+   input  wire                         phy_rst,           
+  
+   // TX Data 
+   input  wire [(PHY_LANE*64)-1:0]     phy_txdata_i,            
+   input  wire [(PHY_LANE* 2)-1:0]     phy_txdatak_i,    
+   input  wire [PHY_LANE-1:0]          phy_txdata_valid_i,
+   input  wire [PHY_LANE-1:0]          phy_txstart_block_i,      
+   input  wire [(PHY_LANE* 2)-1:0]     phy_txsync_header_i,      
+
+   output wire [(PHY_LANE*64)-1:0]     phy_txdata_o,            
+   output wire [(PHY_LANE* 2)-1:0]     phy_txdatak_o,    
+   output wire [PHY_LANE-1:0]          phy_txdata_valid_o,
+   output wire [PHY_LANE-1:0]          phy_txstart_block_o,      
+   output wire [(PHY_LANE* 2)-1:0]     phy_txsync_header_o,     
+
+   // RX Data
+   input  wire [(PHY_LANE*64)-1:0]     phy_rxdata_i,            
+   input  wire [(PHY_LANE* 2)-1:0]     phy_rxdatak_i,       
+   input  wire [PHY_LANE-1:0]          phy_rxdata_valid_i,         
+   input  wire [(PHY_LANE* 2)-1:0]     phy_rxstart_block_i,        
+   input  wire [(PHY_LANE* 2)-1:0]     phy_rxsync_header_i,        
+
+   output wire [(PHY_LANE*64)-1:0]     phy_rxdata_o,            
+   output wire [(PHY_LANE* 2)-1:0]     phy_rxdatak_o,       
+   output wire [PHY_LANE-1:0]          phy_rxdata_valid_o,         
+   output wire [(PHY_LANE* 2)-1:0]     phy_rxstart_block_o,        
+   output wire [(PHY_LANE* 2)-1:0]     phy_rxsync_header_o,        
+
+   // PHY Command
+   input  wire                         phy_txdetectrx_i,        
+   input  wire [PHY_LANE-1:0]          phy_txelecidle_i,        
+   input  wire [PHY_LANE-1:0]          phy_txcompliance_i,      
+   input  wire [PHY_LANE-1:0]          phy_rxpolarity_i,        
+   input  wire [1:0]                   phy_powerdown_i,         
+   input  wire [1:0]                   phy_rate_i,  
+
+   output wire                         phy_txdetectrx_o,        
+   output wire [PHY_LANE-1:0]          phy_txelecidle_o,        
+   output wire [PHY_LANE-1:0]          phy_txcompliance_o,      
+   output wire [PHY_LANE-1:0]          phy_rxpolarity_o,        
+   output wire [1:0]                   phy_powerdown_o,         
+   output wire [1:0]                   phy_rate_o,              
+    
+   // PHY Status
+   input  wire [PHY_LANE-1:0]          phy_rxvalid_i,               
+   input  wire [PHY_LANE-1:0]          phy_phystatus_i,          
+   input  wire [PHY_LANE-1:0]          phy_rxelecidle_i,         
+   input  wire [(PHY_LANE*3)-1:0]      phy_rxstatus_i,   
+
+   output wire [PHY_LANE-1:0]          phy_rxvalid_o,               
+   output wire [PHY_LANE-1:0]          phy_phystatus_o,          
+   output wire [PHY_LANE-1:0]          phy_rxelecidle_o,         
+   output wire [(PHY_LANE*3)-1:0]      phy_rxstatus_o,   
+
+   // TX Driver
+   input  wire [ 2:0]                  phy_txmargin_i,          
+   input  wire                         phy_txswing_i,           
+   input  wire                         phy_txdeemph_i,  
+
+   output wire [ 2:0]                  phy_txmargin_o,          
+   output wire                         phy_txswing_o,           
+   output wire                         phy_txdeemph_o,    
+    
+   // TX Equalization (Gen3/4)
+   input  wire [(PHY_LANE*2)-1:0]      phy_txeq_ctrl_i,      
+   input  wire [(PHY_LANE*4)-1:0]      phy_txeq_preset_i,       
+   input  wire [(PHY_LANE*6)-1:0]      phy_txeq_coeff_i,   
+
+   output wire [(PHY_LANE*2)-1:0]      phy_txeq_ctrl_o,      
+   output wire [(PHY_LANE*4)-1:0]      phy_txeq_preset_o,       
+   output wire [(PHY_LANE*6)-1:0]      phy_txeq_coeff_o,    
+
+   input  wire [ 5:0]                  phy_txeq_fs_i,           
+   input  wire [ 5:0]                  phy_txeq_lf_i,           
+   input  wire [(PHY_LANE*18)-1:0]     phy_txeq_new_coeff_i,        
+   input  wire [PHY_LANE-1:0]          phy_txeq_done_i,         
+
+   output wire [ 5:0]                  phy_txeq_fs_o,           
+   output wire [ 5:0]                  phy_txeq_lf_o,           
+   output wire [(PHY_LANE*18)-1:0]     phy_txeq_new_coeff_o,        
+   output wire [PHY_LANE-1:0]          phy_txeq_done_o,         
+
+   // RX Equalization (Gen3/4)
+   input  wire [(PHY_LANE*2)-1:0]      phy_rxeq_ctrl_i,     
+   input  wire [(PHY_LANE*4)-1:0]      phy_rxeq_txpreset_i,   
+
+   output wire [(PHY_LANE*2)-1:0]      phy_rxeq_ctrl_o,     
+   output wire [(PHY_LANE*4)-1:0]      phy_rxeq_txpreset_o,      
+
+   input  wire [PHY_LANE-1:0]          phy_rxeq_preset_sel_i,    
+   input  wire [(PHY_LANE*18)-1:0]     phy_rxeq_new_txcoeff_i,   
+   input  wire [PHY_LANE-1:0]          phy_rxeq_adapt_done_i,     
+   input  wire [PHY_LANE-1:0]          phy_rxeq_done_i,
+
+   output wire [PHY_LANE-1:0]          phy_rxeq_preset_sel_o,    
+   output wire [(PHY_LANE*18)-1:0]     phy_rxeq_new_txcoeff_o,   
+   output wire [PHY_LANE-1:0]          phy_rxeq_adapt_done_o,     
+   output wire [PHY_LANE-1:0]          phy_rxeq_done_o,
+
+   // Assist Signals
+   input  wire                         as_mac_in_detect_i,
+   input  wire                         as_cdr_hold_req_i,
+
+   output wire                         as_mac_in_detect_o,
+   output wire                         as_cdr_hold_req_o
+   );
+
+   genvar         lane;
+
+generate
+   for (lane = 0; lane < PHY_LANE; lane = lane + 1) begin: per_lane_ff_chain
+      `FF_CHAIN_MODEL(PIPELINE_STAGES, 64, 64'd0, phy_txdata_chain, phy_pclk, phy_rst, phy_txdata_o[(lane* 64)+:64], phy_txdata_i[(lane* 64)+:64])
+      `FF_CHAIN_MODEL(PIPELINE_STAGES, 2, 2'd0, phy_txdatak_chain, phy_pclk, phy_rst, phy_txdatak_o[(lane* 2)+:2], phy_txdatak_i[(lane* 2)+:2])
+      `FF_CHAIN_MODEL(PIPELINE_STAGES, 1, 1'd0, phy_txdata_valid_chain, phy_pclk, phy_rst, phy_txdata_valid_o[lane], phy_txdata_valid_i[lane])
+      `FF_CHAIN_MODEL(PIPELINE_STAGES, 1, 1'd0, phy_txstart_block_chain, phy_pclk, phy_rst, phy_txstart_block_o[lane], phy_txstart_block_i[lane])
+      `FF_CHAIN_MODEL(PIPELINE_STAGES, 2, 2'd0, phy_txsync_header_chain, phy_pclk, phy_rst, phy_txsync_header_o[(lane* 2)+:2], phy_txsync_header_i[(lane* 2)+:2])
+
+      `FF_CHAIN_MODEL(PIPELINE_STAGES, 64, 64'd0, phy_rxdata_chain, phy_pclk, phy_rst, phy_rxdata_o[(lane* 64)+:64], phy_rxdata_i[(lane* 64)+:64])
+      `FF_CHAIN_MODEL(PIPELINE_STAGES, 2, 2'd0, phy_rxdatak_chain, phy_pclk, phy_rst, phy_rxdatak_o[(lane* 2)+:2], phy_rxdatak_i[(lane* 2)+:2])
+      `FF_CHAIN_MODEL(PIPELINE_STAGES, 1, 1'd0, phy_rxdata_valid_chain, phy_pclk, phy_rst, phy_rxdata_valid_o[lane], phy_rxdata_valid_i[lane])
+      `FF_CHAIN_MODEL(PIPELINE_STAGES, 2, 2'd0, phy_rxstart_block_chain, phy_pclk, phy_rst, phy_rxstart_block_o[(lane* 2)+:2], phy_rxstart_block_i[(lane* 2)+:2])
+      `FF_CHAIN_MODEL(PIPELINE_STAGES, 2, 2'd0, phy_rxsync_header_chain, phy_pclk, phy_rst, phy_rxsync_header_o[(lane* 2)+:2], phy_rxsync_header_i[(lane* 2)+:2])
+
+      `FF_CHAIN_MODEL(PIPELINE_STAGES, 1, 1'd1, phy_txelecidle_chain, phy_pclk, phy_rst, phy_txelecidle_o[lane], phy_txelecidle_i[lane])
+      `FF_CHAIN_MODEL(PIPELINE_STAGES, 1, 1'd0, phy_txcompliance_chain, phy_pclk, phy_rst, phy_txcompliance_o[lane], phy_txcompliance_i[lane])
+      `FF_CHAIN_MODEL(PIPELINE_STAGES, 1, 1'd0, phy_rxpolarity_chain, phy_pclk, phy_rst, phy_rxpolarity_o[lane], phy_rxpolarity_i[lane])
+
+      `FF_CHAIN_MODEL(PIPELINE_STAGES, 1, 1'd0, phy_rxvalid_chain, phy_pclk, phy_rst, phy_rxvalid_o[lane], phy_rxvalid_i[lane])
+      `AS_FF_CHAIN_MODEL(PIPELINE_STAGES, 1, 1'd1, phy_phystatus_chain, phy_pclk, phy_rst, phy_phystatus_o[lane], phy_phystatus_i[lane])
+      `AS_FF_CHAIN_MODEL(PIPELINE_STAGES, 1, 1'd1, phy_rxelecidle_chain, phy_pclk, phy_rst, phy_rxelecidle_o[lane], phy_rxelecidle_i[lane])
+      `FF_CHAIN_MODEL(PIPELINE_STAGES, 3, 3'd0, phy_rxstatus_chain, phy_pclk, phy_rst, phy_rxstatus_o[(lane* 3)+:3], phy_rxstatus_i[(lane* 3)+:3])
+
+      `FF_CHAIN_MODEL(PIPELINE_STAGES, 2, 2'd0, phy_txeq_ctrl_chain, phy_pclk, phy_rst, phy_txeq_ctrl_o[(lane* 2)+:2], phy_txeq_ctrl_i[(lane* 2)+:2])
+      `FF_CHAIN_MODEL(PIPELINE_STAGES, 4, 6'd0, phy_txeq_preset_chain, phy_pclk, phy_rst, phy_txeq_preset_o[(lane* 4)+:4], phy_txeq_preset_i[(lane* 4)+:4])
+      `FF_CHAIN_MODEL(PIPELINE_STAGES, 6, 6'd0, phy_txeq_coeff_chain, phy_pclk, phy_rst, phy_txeq_coeff_o[(lane* 6)+:6], phy_txeq_coeff_i[(lane* 6)+:6])
+
+      `FF_CHAIN_MODEL(PIPELINE_STAGES,18,18'd0, phy_txeq_new_coeff_chain, phy_pclk, phy_rst, phy_txeq_new_coeff_o[(lane* 18)+:18], phy_txeq_new_coeff_i[(lane* 18)+:18])
+      `FF_CHAIN_MODEL(PIPELINE_STAGES, 1, 1'd0, phy_txeq_done_chain, phy_pclk, phy_rst, phy_txeq_done_o[lane], phy_txeq_done_i[lane])
+
+      `FF_CHAIN_MODEL(PIPELINE_STAGES, 2, 2'd0, phy_rxeq_ctrl_chain, phy_pclk, phy_rst, phy_rxeq_ctrl_o[(lane* 2)+:2], phy_rxeq_ctrl_i[(lane* 2)+:2])
+      `FF_CHAIN_MODEL(PIPELINE_STAGES, 4, 6'd0, phy_rxeq_txpreset_chain, phy_pclk, phy_rst, phy_rxeq_txpreset_o[(lane* 4)+:4], phy_rxeq_txpreset_i[(lane* 4)+:4])
+
+      `FF_CHAIN_MODEL(PIPELINE_STAGES, 1, 1'd0, phy_rxeq_preset_sel_chain, phy_pclk, phy_rst, phy_rxeq_preset_sel_o[lane], phy_rxeq_preset_sel_i[lane])
+      `FF_CHAIN_MODEL(PIPELINE_STAGES,18,18'd0, phy_rxeq_new_txcoeff_chain, phy_pclk, phy_rst, phy_rxeq_new_txcoeff_o[(lane* 18)+:18], phy_rxeq_new_txcoeff_i[(lane* 18)+:18])
+      `FF_CHAIN_MODEL(PIPELINE_STAGES, 1, 1'd0, phy_rxeq_adapt_done_chain, phy_pclk, phy_rst, phy_rxeq_adapt_done_o[lane], phy_rxeq_adapt_done_i[lane])
+      `FF_CHAIN_MODEL(PIPELINE_STAGES, 1, 1'd0, phy_rxeq_done_chain, phy_pclk, phy_rst, phy_rxeq_done_o[lane], phy_rxeq_done_i[lane])
+   end
+endgenerate
+
+   `FF_CHAIN_MODEL(PIPELINE_STAGES, 1, 1'd0, phy_txdetectrx_chain, phy_pclk, phy_rst, phy_txdetectrx_o, phy_txdetectrx_i)
+   `FF_CHAIN_MODEL(PIPELINE_STAGES, 2, 2'd2, phy_powerdown_chain, phy_pclk, phy_rst, phy_powerdown_o, phy_powerdown_i)
+   `FF_CHAIN_MODEL(PIPELINE_STAGES, 2, 2'd0, phy_rate_chain, phy_pclk, phy_rst, phy_rate_o, phy_rate_i)
+   `FF_CHAIN_MODEL(PIPELINE_STAGES, 3, 3'd0, phy_txmargin_chain, phy_pclk, phy_rst, phy_txmargin_o, phy_txmargin_i)
+   `FF_CHAIN_MODEL(PIPELINE_STAGES, 1, 1'd0, phy_txswing_chain, phy_pclk, phy_rst, phy_txswing_o, phy_txswing_i)
+   `FF_CHAIN_MODEL(PIPELINE_STAGES, 1, 1'd1, phy_txdeemph_chain, phy_pclk, phy_rst, phy_txdeemph_o, phy_txdeemph_i)
+   `FF_CHAIN_MODEL(PIPELINE_STAGES, 6, 6'd0, phy_txeq_fs_chain, phy_pclk, phy_rst, phy_txeq_fs_o, phy_txeq_fs_i) 
+   `FF_CHAIN_MODEL(PIPELINE_STAGES, 6, 6'd0, phy_txeq_lf_chain, phy_pclk, phy_rst, phy_txeq_lf_o, phy_txeq_lf_i)
+   `FF_CHAIN_MODEL(PIPELINE_STAGES, 1, 1'd1, as_mac_in_detect_chain, phy_pclk, phy_rst, as_mac_in_detect_o, as_mac_in_detect_i)
+   `FF_CHAIN_MODEL(PIPELINE_STAGES, 1, 1'd0, as_cdr_hold_req_chain, phy_pclk, phy_rst, as_cdr_hold_req_o, as_cdr_hold_req_i)
+
+endmodule
+
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2023 AMD, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD, Inc. and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : UltraScale+ FPGA PCI Express v4.0 Integrated Block
+// File       : xp4_usp_smsw_bram.v
+// Version    : 1.1 
+//-----------------------------------------------------------------------------
+//--------------------------------------------------------------------------------------------------
+`timescale 1ps/1ps
+
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_bram #(
+  parameter           TCQ = 100
+, parameter           AXISTEN_IF_MSIX_TO_RAM_PIPELINE="FALSE"
+, parameter           AXISTEN_IF_MSIX_FROM_RAM_PIPELINE="FALSE"
+, parameter           TPH_TO_RAM_PIPELINE="FALSE"
+, parameter           TPH_FROM_RAM_PIPELINE="FALSE"
+, parameter [1:0]     TL_COMPLETION_RAM_SIZE=2'b10
+, parameter           TL_RX_COMPLETION_TO_RAM_WRITE_PIPELINE="FALSE"
+, parameter           TL_RX_COMPLETION_TO_RAM_READ_PIPELINE="FALSE"
+, parameter           TL_RX_COMPLETION_FROM_RAM_READ_PIPELINE="FALSE"
+, parameter           TL_RX_POSTED_TO_RAM_WRITE_PIPELINE="FALSE"
+, parameter           TL_RX_POSTED_TO_RAM_READ_PIPELINE="FALSE"
+, parameter           TL_RX_POSTED_FROM_RAM_READ_PIPELINE="FALSE"
+, parameter           LL_REPLAY_TO_RAM_PIPELINE="FALSE"
+, parameter           LL_REPLAY_FROM_RAM_PIPELINE="FALSE"
+, parameter [1:0]     TL_PF_ENABLE_REG=2'h0
+, parameter [3:0]     SRIOV_CAP_ENABLE=4'h0
+, parameter [15:0]    PF0_SRIOV_CAP_TOTAL_VF=16'h0
+, parameter [15:0]    PF1_SRIOV_CAP_TOTAL_VF=16'h0
+, parameter [15:0]    PF2_SRIOV_CAP_TOTAL_VF=16'h0
+, parameter [15:0]    PF3_SRIOV_CAP_TOTAL_VF=16'h0
+, parameter           PF0_TPHR_CAP_ENABLE="FALSE"
+, parameter           MSIX_CAP_TABLE_SIZE=11'h0
+, parameter           MSIX_TABLE_RAM_ENABLE="FALSE"
+
+  ) (
+  input  wire         core_clk_i,
+  input  wire         user_clk_i,
+  input  wire         reset_i,
+
+  input  wire   [8:0] mi_rep_addr_i,
+  input  wire [255:0] mi_rep_wdata_i,
+  input  wire         mi_rep_wen_i,
+  output wire [255:0] mi_rep_rdata_o,
+  input  wire         mi_rep_rden_i,
+
+  output wire   [3:0] mi_rep_err_cor_o,
+  output wire   [3:0] mi_rep_err_uncor_o,
+
+  input  wire   [8:0] mi_req_waddr0_i,
+  input  wire [143:0] mi_req_wdata0_i,
+  input  wire         mi_req_wen0_i,
+  input  wire   [8:0] mi_req_waddr1_i,
+  input  wire [143:0] mi_req_wdata1_i,
+  input  wire         mi_req_wen1_i,
+
+  input  wire   [8:0] mi_req_raddr0_i,
+  input  wire         mi_req_ren0_i,
+  output wire [143:0] mi_req_rdata0_o,
+  input  wire   [8:0] mi_req_raddr1_i,
+  input  wire         mi_req_ren1_i,
+  output wire [143:0] mi_req_rdata1_o,
+
+  output wire   [5:0] mi_req_err_cor_o,
+  output wire   [5:0] mi_req_err_uncor_o,
+
+  input  wire   [8:0] mi_cpl_waddr0_i,
+  input  wire [143:0] mi_cpl_wdata0_i,
+  input  wire   [1:0] mi_cpl_wen0_i,
+  input  wire   [8:0] mi_cpl_waddr1_i,
+  input  wire [143:0] mi_cpl_wdata1_i,
+  input  wire   [1:0] mi_cpl_wen1_i,
+
+  input  wire   [8:0] mi_cpl_raddr0_i,
+  input  wire   [1:0] mi_cpl_ren0_i,
+  output wire [143:0] mi_cpl_rdata0_o,
+  input  wire   [8:0] mi_cpl_raddr1_i,
+  input  wire   [1:0] mi_cpl_ren1_i,
+  output wire [143:0] mi_cpl_rdata1_o,
+
+  output wire  [11:0] mi_cpl_err_cor_o,
+  output wire  [11:0] mi_cpl_err_uncor_o,
+
+  input  wire  [12:0] cfg_msix_waddr_i,
+  input  wire  [31:0] cfg_msix_wdata_i,
+  input  wire   [3:0] cfg_msix_wdip_i,
+  input  wire   [3:0] cfg_msix_wen_i,
+  output wire  [31:0] cfg_msix_rdata_o,
+  output wire   [3:0] cfg_msix_rdop_o,
+  input  wire         cfg_msix_ren_i,
+
+  input  wire   [7:0] user_tph_stt_func_num_i,
+  input  wire   [5:0] user_tph_stt_index_i,
+  input  wire         user_tph_stt_rd_en_i,
+  output wire   [7:0] user_tph_stt_rd_data_o,
+
+  input  wire  [11:0] cfg_tph_waddr_i,
+  input  wire  [31:0] cfg_tph_wdata_i,
+  input  wire   [3:0] cfg_tph_wdip_i,
+  input  wire   [3:0] cfg_tph_wen_i,
+  output wire  [31:0] cfg_tph_rdata_o,
+  output wire   [3:0] cfg_tph_rdop_o,
+  input  wire         cfg_tph_ren_i
+
+  );
+
+  xp4_usp_smsw_bram_rep #(
+
+    .TCQ (TCQ),
+    .TO_RAM_PIPELINE(LL_REPLAY_TO_RAM_PIPELINE),
+    .FROM_RAM_PIPELINE(LL_REPLAY_FROM_RAM_PIPELINE)
+
+  )
+  bram_repl_inst (
+
+    .clk_i (core_clk_i),
+    .reset_i (reset_i),
+
+    .addr_i(mi_rep_addr_i[8:0]),
+    .wdata_i(mi_rep_wdata_i[255:0]),
+    .wen_i(mi_rep_wen_i),
+    .rdata_o(mi_rep_rdata_o[255:0]),
+    .ren_i(mi_rep_rden_i),
+    .err_cor_o(mi_rep_err_cor_o[3:0]),
+    .err_uncor_o(mi_rep_err_uncor_o[3:0])
+
+  );
+
+  xp4_usp_smsw_bram_16k #(
+
+    .TCQ (TCQ),
+    .TO_RAM_WRITE_PIPELINE(TL_RX_POSTED_TO_RAM_WRITE_PIPELINE),
+    .TO_RAM_READ_PIPELINE(TL_RX_POSTED_TO_RAM_READ_PIPELINE),
+    .FROM_RAM_READ_PIPELINE(TL_RX_POSTED_FROM_RAM_READ_PIPELINE)
+
+  )
+  bram_post_inst (
+
+    .clk_i (core_clk_i),
+    .reset_i (reset_i),
+
+    .waddr0_i(mi_req_waddr0_i[8:0]),
+    .wdata0_i(mi_req_wdata0_i[143:0]),
+    .wen0_i(mi_req_wen0_i),
+    .waddr1_i(mi_req_waddr1_i[8:0]),
+    .wdata1_i(mi_req_wdata1_i[143:0]),
+    .wen1_i(mi_req_wen1_i),
+    .raddr0_i(mi_req_raddr0_i[8:0]),
+    .rdata0_o(mi_req_rdata0_o[143:0]),
+    .ren0_i(mi_req_ren0_i),
+    .raddr1_i(mi_req_raddr1_i[8:0]),
+    .rdata1_o(mi_req_rdata1_o[143:0]),
+    .ren1_i(mi_req_ren1_i),
+    .err_cor_o(mi_req_err_cor_o[5:0]),
+    .err_uncor_o(mi_req_err_uncor_o[5:0])
+
+  );
+
+  generate 
+
+  if (TL_COMPLETION_RAM_SIZE == 2'b10) begin : RAM32K
+
+    xp4_usp_smsw_bram_32k #(
+
+      .TCQ (TCQ),
+      .TO_RAM_WRITE_PIPELINE(TL_RX_COMPLETION_TO_RAM_WRITE_PIPELINE),
+      .TO_RAM_READ_PIPELINE(TL_RX_COMPLETION_TO_RAM_READ_PIPELINE),
+      .FROM_RAM_READ_PIPELINE(TL_RX_COMPLETION_FROM_RAM_READ_PIPELINE)
+
+    )
+    bram_comp_inst (
+
+      .clk_i (core_clk_i),
+      .reset_i (reset_i),
+  
+      .waddr0_i(mi_cpl_waddr0_i[8:0]),
+      .wdata0_i(mi_cpl_wdata0_i[143:0]),
+      .wen0_i(mi_cpl_wen0_i[1:0]),
+      .waddr1_i(mi_cpl_waddr1_i[8:0]),
+      .wdata1_i(mi_cpl_wdata1_i[143:0]),
+      .wen1_i(mi_cpl_wen1_i[1:0]),
+      .raddr0_i(mi_cpl_raddr0_i[8:0]),
+      .rdata0_o(mi_cpl_rdata0_o[143:0]),
+      .ren0_i(mi_cpl_ren0_i[1:0]),
+      .raddr1_i(mi_cpl_raddr1_i[8:0]),
+      .rdata1_o(mi_cpl_rdata1_o[143:0]),
+      .ren1_i(mi_cpl_ren1_i[1:0]),
+      .err_cor_o(mi_cpl_err_cor_o[11:0]),
+      .err_uncor_o(mi_cpl_err_uncor_o[11:0])
+
+    );
+
+  end else begin : RAM16K
+
+    xp4_usp_smsw_bram_16k #(
+
+      .TCQ (TCQ),
+      .TO_RAM_WRITE_PIPELINE(TL_RX_COMPLETION_TO_RAM_WRITE_PIPELINE),
+      .TO_RAM_READ_PIPELINE(TL_RX_COMPLETION_TO_RAM_READ_PIPELINE),
+      .FROM_RAM_READ_PIPELINE(TL_RX_COMPLETION_FROM_RAM_READ_PIPELINE)
+
+    )
+    bram_comp_inst (
+
+      .clk_i (core_clk_i),
+      .reset_i (reset_i),
+  
+      .waddr0_i(mi_cpl_waddr0_i[8:0]),
+      .wdata0_i(mi_cpl_wdata0_i[143:0]),
+      .wen0_i(mi_cpl_wen0_i[0]),
+      .waddr1_i(mi_cpl_waddr1_i[8:0]),
+      .wdata1_i(mi_cpl_wdata1_i[143:0]),
+      .wen1_i(mi_cpl_wen1_i[0]),
+      .raddr0_i(mi_cpl_raddr0_i[8:0]),
+      .rdata0_o(mi_cpl_rdata0_o[143:0]),
+      .ren0_i(mi_cpl_ren0_i[0]),
+      .raddr1_i(mi_cpl_raddr1_i[8:0]),
+      .rdata1_o(mi_cpl_rdata1_o[143:0]),
+      .ren1_i(mi_cpl_ren1_i[0]),
+      .err_cor_o(mi_cpl_err_cor_o[5:0]),
+      .err_uncor_o(mi_cpl_err_uncor_o[5:0])
+
+    );
+
+    assign mi_cpl_err_cor_o[11:6] = 6'b0;
+    assign mi_cpl_err_uncor_o[11:6] = 6'b0;
+
+  end
+
+  endgenerate 
+
+  xp4_usp_smsw_bram_msix #(
+
+    .TCQ (TCQ),
+    .TO_RAM_PIPELINE(AXISTEN_IF_MSIX_TO_RAM_PIPELINE),
+    .FROM_RAM_PIPELINE(AXISTEN_IF_MSIX_FROM_RAM_PIPELINE),
+    .MSIX_CAP_TABLE_SIZE(MSIX_CAP_TABLE_SIZE),
+    .MSIX_TABLE_RAM_ENABLE(MSIX_TABLE_RAM_ENABLE)
+
+  )
+  bram_msix_inst (
+
+    .clk_i(user_clk_i),
+    .reset_i(reset_i),
+
+    .addr_i(cfg_msix_waddr_i[12:0]),
+    .wdata_i(cfg_msix_wdata_i[31:0]),
+    .wdip_i(cfg_msix_wdip_i[3:0]),
+    .wen_i(cfg_msix_wen_i[3:0]),
+    .rdata_o(cfg_msix_rdata_o[31:0]),
+    .rdop_o(cfg_msix_rdop_o[3:0])
+
+  );
+
+  xp4_usp_smsw_bram_tph #(
+
+    .TCQ (TCQ),
+    .TO_RAM_PIPELINE(TPH_TO_RAM_PIPELINE),
+    .FROM_RAM_PIPELINE(TPH_FROM_RAM_PIPELINE),
+    .TL_PF_ENABLE_REG(TL_PF_ENABLE_REG),
+    .SRIOV_CAP_ENABLE(SRIOV_CAP_ENABLE),
+    .PF0_SRIOV_CAP_TOTAL_VF(PF0_SRIOV_CAP_TOTAL_VF),
+    .PF1_SRIOV_CAP_TOTAL_VF(PF1_SRIOV_CAP_TOTAL_VF),
+    .PF2_SRIOV_CAP_TOTAL_VF(PF2_SRIOV_CAP_TOTAL_VF),
+    .PF3_SRIOV_CAP_TOTAL_VF(PF3_SRIOV_CAP_TOTAL_VF),
+    .PF0_TPHR_CAP_ENABLE(PF0_TPHR_CAP_ENABLE)
+
+  )
+  bram_tph_inst (
+
+    .clk_i(user_clk_i),
+    .reset_i(reset_i),
+
+    .user_tph_stt_func_num_i(user_tph_stt_func_num_i[7:0]),
+    .user_tph_stt_index_i(user_tph_stt_index_i[5:0]),
+    .user_tph_stt_rd_en_i(user_tph_stt_rd_en_i),
+    .user_tph_stt_rd_data_o(user_tph_stt_rd_data_o[7:0]),
+
+    .addr_i(cfg_tph_waddr_i[11:0]),
+    .wdata_i(cfg_tph_wdata_i[31:0]),
+    .wdip_i(cfg_tph_wdip_i[3:0]),
+    .wen_i(cfg_tph_wen_i[3:0]),
+    .rdata_o(cfg_tph_rdata_o[31:0]),
+    .rdop_o(cfg_tph_rdop_o[3:0])
+
+  );
+
+endmodule
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2023 AMD, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD, Inc. and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : UltraScale+ FPGA PCI Express v4.0 Integrated Block
+// File       : xp4_usp_smsw_bram_16k_int.v
+// Version    : 1.1 
+//-----------------------------------------------------------------------------
+//--------------------------------------------------------------------------------------------------
+`timescale 1ps/1ps
+
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_bram_16k_int #(
+
+  parameter TCQ = 100
+
+  ) (
+
+  input  wire         clk_i,
+  input  wire         reset_i,
+
+  input  wire   [8:0] waddr0_i,
+  input  wire   [0:0] wen0_i,
+  input  wire [143:0] wdata0_i,
+  input  wire   [8:0] waddr1_i,
+  input  wire   [0:0] wen1_i,
+  input  wire [143:0] wdata1_i,
+
+  input  wire   [8:0] raddr0_i,
+  input  wire   [0:0] ren0_i,
+  output wire [143:0] rdata0_o,
+  input  wire   [8:0] raddr1_i,
+  input  wire   [0:0] ren1_i,
+  output wire [143:0] rdata1_o,
+
+  output wire   [5:0] err_cor_o,
+  output wire   [5:0] err_uncor_o
+
+  );
+
+  genvar              i;
+
+  wire [383:0]        rdata_w;
+  wire [383:0]        wdata_w = {48'b0, wdata1_i[143:0], 48'b0, wdata0_i};
+
+  generate begin : ECC_RAM
+
+   for (i = 0; i < 6; i = i + 1)
+   begin : RAMB36E2
+        RAMB36E2 #(
+          .DOA_REG (1),
+          .DOB_REG (1),
+          .EN_ECC_READ ("FALSE"),
+          .EN_ECC_WRITE ("FALSE"),
+          .INIT_A (36'h000000000),
+          .INIT_B (36'h000000000),
+          .INIT_FILE ("NONE"),
+          .READ_WIDTH_A (72),
+          .READ_WIDTH_B (0),
+          .RSTREG_PRIORITY_A ("REGCE"),
+          .RSTREG_PRIORITY_B ("REGCE"),
+          .SIM_COLLISION_CHECK("ALL"),
+          .SRVAL_A (36'h000000000),
+          .SRVAL_B (36'h000000000),
+          .WRITE_MODE_A ("WRITE_FIRST"),
+          .WRITE_MODE_B ("WRITE_FIRST"),
+          .WRITE_WIDTH_A (0),
+          .WRITE_WIDTH_B (72))
+        ramb36e2_inst (
+          .ADDRENA (1'b1),
+          .ADDRENB (1'b1),
+          .CASDIMUXA (1'b0),
+          .CASDIMUXB (1'b0),
+          .CASDOMUXA (1'b0),
+          .CASDOMUXB (1'b0),
+          .CASDOMUXEN_A (1'b0),
+          .CASDOMUXEN_B (1'b0),
+          .CASINDBITERR (1'b0),
+          .CASINSBITERR (1'b0),
+          .CASOREGIMUXA (1'b0),
+          .CASOREGIMUXB (1'b0),
+          .CASOREGIMUXEN_A (1'b0),
+          .CASOREGIMUXEN_B (1'b0),
+          .ECCPIPECE (1'b0),
+          .SLEEP (1'b0),
+          .CASDINA (32'b0),
+          .CASDINB (32'b0),
+          .CASDINPA(4'b0),
+          .CASDINPB(4'b0),
+          .CASDOUTA (),
+          .CASDOUTB (),
+          .CASDOUTPA (),
+          .CASDOUTPB (),
+          .CASOUTDBITERR (),
+          .CASOUTSBITERR (),
+          .CLKARDCLK (clk_i),
+          .CLKBWRCLK (clk_i),
+          .DBITERR (err_uncor_o[i]),
+          .ENARDEN ((i > 2) ? ren1_i : ren0_i),
+          .ENBWREN ((i > 2) ? wen1_i : wen0_i),
+          .INJECTDBITERR (1'b0),
+          .INJECTSBITERR (1'b0),
+          .REGCEAREGCE (1'b1),
+          .REGCEB (1'b0),
+          .RSTRAMARSTRAM (1'b0),
+          .RSTRAMB (1'b0),
+          .RSTREGARSTREG (1'b0),
+          .RSTREGB (1'b0),
+          .SBITERR (err_cor_o[i]),
+          .ADDRARDADDR ({(i>2) ? raddr1_i[8:0] : raddr0_i[8:0], 6'b0}),
+          .ADDRBWRADDR ({(i>2) ? waddr1_i[8:0] : waddr0_i[8:0], 6'b0}),
+          .DINADIN (wdata_w[(2*32*i)+31:(2*32*i)+0]),
+          .DINBDIN (wdata_w[(2*32*i)+63:(2*32*i)+32]),
+          .DINPADINP (4'b0),
+          .DINPBDINP (4'b0),
+          .DOUTADOUT (rdata_w[(2*32*i)+31:(2*32*i)+0]),
+          .DOUTBDOUT (rdata_w[(2*32*i)+63:(2*32*i)+32]),
+          .DOUTPADOUTP (),
+          .DOUTPBDOUTP (),
+          .ECCPARITY (),
+          .RDADDRECC (),
+          .WEA (4'h0),
+          .WEBWE (8'hFF)
+        );
+      end
+    end
+  endgenerate
+
+  assign rdata1_o =  rdata_w[335:192];
+  assign rdata0_o =  rdata_w[143:000];
+
+endmodule
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2023 AMD, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD, Inc. and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : UltraScale+ FPGA PCI Express v4.0 Integrated Block
+// File       : xp4_usp_smsw_bram_16k.v
+// Version    : 1.1 
+//-----------------------------------------------------------------------------
+//--------------------------------------------------------------------------------------------------
+`timescale 1ps/1ps
+
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_bram_16k #(
+
+  parameter           TCQ = 100
+, parameter           TO_RAM_WRITE_PIPELINE="FALSE"
+, parameter           TO_RAM_READ_PIPELINE="FALSE"
+, parameter           FROM_RAM_READ_PIPELINE="FALSE"
+
+  ) (
+
+  input  wire         clk_i,
+  input  wire         reset_i,
+
+  input  wire   [8:0] waddr0_i,
+  input  wire   [0:0] wen0_i,
+  input  wire [143:0] wdata0_i,
+  input  wire   [8:0] waddr1_i,
+  input  wire   [0:0] wen1_i,
+  input  wire [143:0] wdata1_i,
+
+  input  wire   [8:0] raddr0_i,
+  input  wire   [0:0] ren0_i,
+  output wire [143:0] rdata0_o,
+  input  wire   [8:0] raddr1_i,
+  input  wire   [0:0] ren1_i,
+  output wire [143:0] rdata1_o,
+
+  output wire   [5:0] err_cor_o,
+  output wire   [5:0] err_uncor_o
+
+  );
+
+  reg           [8:0] waddr0;
+  reg           [0:0] wen0;
+  reg         [143:0] wdata0;
+  reg           [8:0] waddr1;
+  reg           [0:0] wen1;
+  reg         [143:0] wdata1;
+  reg           [8:0] raddr0;
+  reg           [0:0] ren0;
+  reg           [8:0] raddr1;
+  reg           [0:0] ren1;
+  wire        [143:0] rdata0;
+  wire        [143:0] rdata1;
+  wire          [5:0] err_cor;
+  wire          [5:0] err_uncor;
+  reg         [143:0] reg_rdata0;
+  reg         [143:0] reg_rdata1;
+  reg           [5:0] reg_err_cor;
+  reg           [5:0] reg_err_uncor;
+
+  //
+  // Optional input pipe stages
+  //
+  generate
+
+    if (TO_RAM_WRITE_PIPELINE == "TRUE") begin : TOWRPIPELINE
+
+      always @(posedge clk_i) begin
+     
+        if (reset_i) begin
+
+          waddr0 <= #(TCQ) 9'b0;
+          wen0 <= #(TCQ) 1'b0;
+          wdata0 <= #(TCQ) 144'b0;
+          waddr1 <= #(TCQ) 9'b0;
+          wen1 <= #(TCQ) 1'b0;
+          wdata1 <= #(TCQ) 144'b0;
+
+        end else begin
+
+          waddr0 <= #(TCQ) waddr0_i;
+          wen0 <= #(TCQ) wen0_i;
+          wdata0 <= #(TCQ) wdata0_i;
+          waddr1 <= #(TCQ) waddr1_i;
+          wen1 <= #(TCQ) wen1_i;
+          wdata1 <= #(TCQ) wdata1_i;
+
+        end
+
+      end
+
+    end else begin : NOTOWRPIPELINE
+
+      always @(*) begin
+
+        waddr0 = waddr0_i;
+        wen0 = wen0_i;
+        wdata0 = wdata0_i;
+        waddr1 = waddr1_i;
+        wen1 = wen1_i;
+        wdata1 = wdata1_i;
+
+      end
+
+    end
+
+    if (TO_RAM_READ_PIPELINE == "TRUE") begin : TORDPIPELINE
+
+      always @(posedge clk_i) begin
+     
+        if (reset_i) begin
+
+          raddr0 <= #(TCQ) 9'b0;
+          ren0 <= #(TCQ) 1'b0;
+          raddr1 <= #(TCQ) 9'b0;
+          ren1 <= #(TCQ) 1'b0;
+
+        end else begin
+
+          raddr0 <= #(TCQ) raddr0_i;
+          ren0 <= #(TCQ) ren0_i;
+          raddr1 <= #(TCQ) raddr1_i;
+          ren1 <= #(TCQ) ren1_i;
+
+        end
+
+      end
+
+    end else begin : NOTORDPIPELINE
+
+      always @(*) begin
+
+        raddr0 = raddr0_i;
+        ren0 = ren0_i;
+        raddr1 = raddr1_i;
+        ren1 = ren1_i;
+
+      end
+
+    end
+  
+  endgenerate
+
+  //
+  // Optional output pipe stages
+  //
+  generate
+
+    if (FROM_RAM_READ_PIPELINE == "TRUE") begin : FRMRDPIPELINE
+
+
+      always @(posedge clk_i) begin
+     
+        if (reset_i) begin
+
+          reg_rdata0 <= #(TCQ) 144'b0;
+          reg_rdata1 <= #(TCQ) 144'b0;
+          reg_err_cor <= #(TCQ) 6'b0;
+          reg_err_uncor <= #(TCQ) 6'b0;
+
+         end else begin
+
+          reg_rdata0 <= #(TCQ) rdata0;
+          reg_rdata1 <= #(TCQ) rdata1;
+          reg_err_cor <= #(TCQ) err_cor;
+          reg_err_uncor <= #(TCQ) err_uncor;
+
+        end
+
+      end
+
+    end else begin : NOFRMRDPIPELINE
+
+      always @(*) begin
+
+          reg_rdata0 = rdata0;
+          reg_rdata1 = rdata1;
+          reg_err_cor = err_cor;
+          reg_err_uncor = err_uncor;
+
+      end
+
+    end
+  
+  endgenerate
+
+  assign rdata0_o = reg_rdata0;
+  assign rdata1_o = reg_rdata1;
+  assign err_cor_o = reg_err_cor;
+  assign err_uncor_o = reg_err_uncor;
+
+  xp4_usp_smsw_bram_16k_int #(
+      .TCQ(TCQ)
+    )
+    bram_16k_int (
+
+      .clk_i (clk_i),
+      .reset_i (reset_i),
+
+      .waddr0_i(waddr0[8:0]),
+      .wdata0_i(wdata0[143:0]),
+      .wen0_i(wen0),
+      .waddr1_i(waddr1[8:0]),
+      .wdata1_i(wdata1[143:0]),
+      .wen1_i(wen1),
+      .raddr0_i(raddr0[8:0]),
+      .rdata0_o(rdata0[143:0]),
+      .ren0_i(ren0),
+      .raddr1_i(raddr1[8:0]),
+      .rdata1_o(rdata1[143:0]),
+      .ren1_i(ren1),
+      .err_cor_o(err_cor[5:0]),
+      .err_uncor_o(err_uncor[5:0])
+
+  );
+
+
+endmodule
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2023 AMD, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD, Inc. and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : UltraScale+ FPGA PCI Express v4.0 Integrated Block
+// File       : xp4_usp_smsw_bram_32k.v
+// Version    : 1.1 
+//-----------------------------------------------------------------------------
+//--------------------------------------------------------------------------------------------------
+`timescale 1ps/1ps
+
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_bram_32k #(
+
+  parameter           TCQ = 100
+, parameter           TO_RAM_WRITE_PIPELINE="FALSE"
+, parameter           TO_RAM_READ_PIPELINE="FALSE"
+, parameter           FROM_RAM_READ_PIPELINE="FALSE"
+
+  ) (
+
+  input  wire         clk_i,
+  input  wire         reset_i,
+
+  input  wire   [8:0] waddr0_i,
+  input  wire   [1:0] wen0_i,
+  input  wire [143:0] wdata0_i,
+  input  wire   [8:0] waddr1_i,
+  input  wire   [1:0] wen1_i,
+  input  wire [143:0] wdata1_i,
+
+  input  wire   [8:0] raddr0_i,
+  input  wire   [1:0] ren0_i,
+  output wire [143:0] rdata0_o,
+  input  wire   [8:0] raddr1_i,
+  input  wire   [1:0] ren1_i,
+  output wire [143:0] rdata1_o,
+
+  output wire   [11:0] err_cor_o,
+  output wire   [11:0] err_uncor_o
+
+  );
+
+  wire [143:0] rdata0_0;
+  wire [143:0] rdata0_1;
+  wire [143:0] rdata1_0;
+  wire [143:0] rdata1_1;
+
+  wire  [11:0] err_cor;
+  wire  [11:0] err_uncor;
+
+  reg  [143:0] reg_rdata0;
+  reg  [143:0] reg_rdata1;
+  reg   [11:0] reg_err_cor;
+  reg   [11:0] reg_err_uncor;
+
+  reg    [0:0] reg_raddr0_10_p0;
+  reg    [0:0] reg_raddr1_10_p0;
+  (* keep = "true", max_fanout = 32 *) reg    [0:0] reg_raddr0_10_p1;
+  (* keep = "true", max_fanout = 32 *) reg    [0:0] reg_raddr1_10_p1;
+  wire   [0:0] raddr0_10_p0;
+  wire   [0:0] raddr1_10_p0;
+
+  reg    [8:0] raddr0;
+  reg    [1:0] ren0;
+  reg    [8:0] raddr1;
+  reg    [1:0] ren1;
+
+  reg    [8:0] waddr0;
+  reg    [1:0] wen0;
+  reg  [143:0] wdata0;
+  reg    [8:0] waddr1;
+  reg    [1:0] wen1;
+  reg  [143:0] wdata1;
+  
+  //
+  // Optional input pipe stages
+  //
+  generate
+
+    if (TO_RAM_WRITE_PIPELINE == "TRUE") begin : TOWRPIPELINE
+
+      always @(posedge clk_i) begin
+     
+        if (reset_i) begin
+
+          waddr0 <= #(TCQ) 9'b0;
+          wen0 <= #(TCQ) 2'b0;
+          wdata0 <= #(TCQ) 144'b0;
+          waddr1 <= #(TCQ) 9'b0;
+          wen1 <= #(TCQ) 2'b0;
+          wdata1 <= #(TCQ) 144'b0;
+
+	end else begin
+
+          waddr0 <= #(TCQ) waddr0_i;
+          wen0 <= #(TCQ) wen0_i;
+          wdata0 <= #(TCQ) wdata0_i;
+          waddr1 <= #(TCQ) waddr1_i;
+          wen1 <= #(TCQ) wen1_i;
+          wdata1 <= #(TCQ) wdata1_i;
+
+	end
+
+     end
+
+    end else begin : NOTOWRPIPELINE
+
+      always @(*) begin
+
+        waddr0 = waddr0_i;
+        wen0 = wen0_i;
+        wdata0 = wdata0_i;
+        waddr1 = waddr1_i;
+        wen1 = wen1_i;
+        wdata1 = wdata1_i;
+    
+      end
+  
+    end
+
+    if (TO_RAM_READ_PIPELINE == "TRUE") begin : TORDPIPELINE
+
+      always @(posedge clk_i) begin
+     
+        if (reset_i) begin
+
+          raddr0 <= #(TCQ) 9'b0;
+          ren0 <= #(TCQ) 1'b0;
+          raddr1 <= #(TCQ) 9'b0;
+          ren1 <= #(TCQ) 1'b0;
+
+	end else begin
+
+          raddr0 <= #(TCQ) raddr0_i;
+          ren0 <= #(TCQ) ren0_i;
+          raddr1 <= #(TCQ) raddr1_i;
+          ren1 <= #(TCQ) ren1_i;
+
+	end
+
+      end
+
+    end else begin : NOTORDPIPELINE
+
+      always @(*) begin
+
+        raddr0 = raddr0_i;
+        ren0 = ren0_i;
+        raddr1 = raddr1_i;
+        ren1 = ren1_i;
+
+      end
+
+    end
+  
+  endgenerate
+ 
+  //
+  // output pipe stage
+  //
+
+  generate
+
+    if (FROM_RAM_READ_PIPELINE == "TRUE") begin : FRMRDPIPELINE
+
+      always @(posedge clk_i) begin
+     
+        if (reset_i) begin
+
+          reg_rdata0 <= #(TCQ) 144'b0;
+          reg_rdata1 <= #(TCQ) 144'b0;
+          reg_err_cor <= #(TCQ) 12'b0;
+          reg_err_uncor <= #(TCQ) 12'b0;
+    
+        end else begin
+    
+          reg_rdata0 <= #(TCQ) raddr0_10_p0 ? rdata1_0 : rdata0_0;
+          reg_rdata1 <= #(TCQ) raddr1_10_p0 ? rdata1_1 : rdata0_1;
+          reg_err_cor <= #(TCQ) err_cor;
+          reg_err_uncor <= #(TCQ) err_uncor;
+    
+        end
+    
+      end
+
+   end else begin : NOFRMRDPIPELINE
+
+      always @(*) begin
+
+        reg_rdata0 = raddr0_10_p0 ? rdata1_0 : rdata0_0;
+        reg_rdata1 = raddr1_10_p0 ? rdata1_1 : rdata0_1;
+        reg_err_cor = err_cor;
+        reg_err_uncor = err_uncor;
+
+      end
+
+   end
+
+  endgenerate
+
+  always @(posedge clk_i) begin
+     
+    if (reset_i) begin
+
+      reg_raddr0_10_p0 <= #(TCQ) 1'b0;
+      reg_raddr1_10_p0 <= #(TCQ) 1'b0;
+      reg_raddr0_10_p1 <= #(TCQ) 1'b0;
+      reg_raddr1_10_p1 <= #(TCQ) 1'b0;
+    
+    end else begin
+    
+      reg_raddr0_10_p0 <= #(TCQ) ren0[1];
+      reg_raddr1_10_p0 <= #(TCQ) ren1[1];
+      reg_raddr0_10_p1 <= #(TCQ) reg_raddr0_10_p0;
+      reg_raddr1_10_p1 <= #(TCQ) reg_raddr1_10_p0;
+    
+    end
+    
+  end
+
+  assign rdata0_o = reg_rdata0;
+  assign rdata1_o = reg_rdata1;
+  assign err_cor_o = reg_err_cor;
+  assign err_uncor_o = reg_err_uncor;
+  assign raddr0_10_p0 = reg_raddr0_10_p1;
+  assign raddr1_10_p0 = reg_raddr1_10_p1;
+
+  // Upper 512 Words
+  xp4_usp_smsw_bram_16k_int #( 
+	.TCQ(TCQ)) 
+  bram_16k_0_int (
+    .clk_i (clk_i),
+    .reset_i (reset_i),
+
+    .waddr0_i(waddr0[8:0]),
+    .wdata0_i(wdata0[143:0]),
+    .wen0_i(wen0[0]),
+    .waddr1_i(waddr1[8:0]),
+    .wdata1_i(wdata1[143:0]),
+    .wen1_i(wen1[0]),
+    .raddr0_i(raddr0[8:0]),
+    .rdata0_o(rdata0_0[143:0]),
+    .ren0_i(ren0[0]),
+    .raddr1_i(raddr1[8:0]),
+    .rdata1_o(rdata0_1[143:0]),
+    .ren1_i(ren1[0]),
+    .err_cor_o(err_cor[5:0]),
+    .err_uncor_o(err_uncor[5:0])
+
+  );
+  
+  // Lower 512 Words
+  xp4_usp_smsw_bram_16k_int #( 
+	.TCQ(TCQ)) 
+  bram_16k_1_int (
+    .clk_i (clk_i),
+    .reset_i (reset_i),
+
+    .waddr0_i(waddr0[8:0]),
+    .wdata0_i(wdata0[143:0]),
+    .wen0_i(wen0[1]),
+    .waddr1_i(waddr1[8:0]),
+    .wdata1_i(wdata1[143:0]),
+    .wen1_i(wen1[1]),
+    .raddr0_i(raddr0[8:0]),
+    .rdata0_o(rdata1_0[143:0]),
+    .ren0_i(ren0[1]),
+    .raddr1_i(raddr1[8:0]),
+    .rdata1_o(rdata1_1[143:0]),
+    .ren1_i(ren1[1]),
+    .err_cor_o(err_cor[11:6]),
+    .err_uncor_o(err_uncor[11:6])
+
+  );
+
+endmodule
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2023 AMD, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD, Inc. and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : UltraScale+ FPGA PCI Express v4.0 Integrated Block
+// File       : xp4_usp_smsw_bram_4k_int.v
+// Version    : 1.1 
+//-----------------------------------------------------------------------------
+//--------------------------------------------------------------------------------------------------
+`timescale 1ps/1ps
+
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_bram_4k_int #(
+  parameter TCQ = 100
+  ) (
+  input  wire         clk_i,
+  input  wire         reset_i,
+  input  wire   [9:0] addr_i,
+  input  wire  [31:0] wdata_i,
+  input  wire   [3:0] wdip_i,
+  input  wire   [3:0] wen_i,
+  output wire  [31:0] rdata_o,
+  output wire   [3:0] rdop_o,
+  input  wire   [9:0] baddr_i,
+  output wire  [31:0] brdata_o
+  );
+
+  genvar              i;
+
+  RAMB36E2 #(
+        .DOA_REG (1),
+        .DOB_REG (1),
+        .EN_ECC_READ ("FALSE"),
+        .EN_ECC_WRITE ("FALSE"),
+        .INIT_A (36'h000000000),
+        .INIT_B (36'h000000000),
+        .INIT_FILE ("NONE"),
+        .READ_WIDTH_A (36),
+        .READ_WIDTH_B (36),
+        .RSTREG_PRIORITY_A ("REGCE"),
+        .RSTREG_PRIORITY_B ("REGCE"),
+        .SIM_COLLISION_CHECK("GENERATE_X_ONLY"),
+        .SRVAL_A (36'h000000000),
+        .SRVAL_B (36'h000000000),
+        .WRITE_MODE_A ("WRITE_FIRST"),
+        .WRITE_MODE_B ("WRITE_FIRST"),
+        .WRITE_WIDTH_A (36),
+        .WRITE_WIDTH_B (36))
+  ramb36e2_inst (
+        .ADDRENA (1'b1),
+        .ADDRENB (1'b1),
+        .CASDIMUXA (1'b0),
+        .CASDIMUXB (1'b0),
+        .CASDOMUXA (1'b0),
+        .CASDOMUXB (1'b0),
+        .CASDOMUXEN_A (1'b0),
+        .CASDOMUXEN_B (1'b0),
+        .CASINDBITERR (1'b0),
+        .CASINSBITERR (1'b0),
+        .CASOREGIMUXA (1'b0),
+        .CASOREGIMUXB (1'b0),
+        .CASOREGIMUXEN_A (1'b0),
+        .CASOREGIMUXEN_B (1'b0),
+        .ECCPIPECE (1'b0),
+        .SLEEP (1'b0),
+        .CASDINA (32'b0),
+        .CASDINB (32'b0),
+        .CASDINPA(4'b0),
+        .CASDINPB(4'b0),
+        .CASDOUTA (),
+        .CASDOUTB (),
+        .CASDOUTPA (),
+        .CASDOUTPB (),
+        .CASOUTDBITERR (),
+        .CASOUTSBITERR (),
+        .CLKARDCLK (clk_i),
+        .CLKBWRCLK (clk_i),
+        .DBITERR (),
+        .ENARDEN (1'b1),
+        .ENBWREN (1'b1),
+        .INJECTDBITERR (1'b0),
+        .INJECTSBITERR (1'b0),
+        .REGCEAREGCE (1'b1),
+        .REGCEB (1'b1),
+        .RSTRAMARSTRAM (1'b0),
+        .RSTRAMB (1'b0),
+        .RSTREGARSTREG (1'b0),
+        .RSTREGB (1'b0),
+        .SBITERR (),
+        .ADDRARDADDR ({addr_i[9:0], 5'b0}),
+        .ADDRBWRADDR ({baddr_i[9:0], 5'b0}),
+        .DINADIN (wdata_i[31:0]),
+        .DINBDIN (32'b0),
+        .DINPADINP (wdip_i[3:0]),
+        .DINPBDINP (4'b0),
+        .DOUTADOUT (rdata_o[31:0]),
+        .DOUTBDOUT (brdata_o[31:0]),
+        .DOUTPADOUTP (rdop_o[3:0]),
+        .DOUTPBDOUTP (),
+        .ECCPARITY (),
+        .RDADDRECC (),
+        .WEA (wen_i[3:0]),
+        .WEBWE (8'b0)
+      );
+
+endmodule
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2023 AMD, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD, Inc. and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : UltraScale+ FPGA PCI Express v4.0 Integrated Block
+// File       : xp4_usp_smsw_bram_msix.v
+// Version    : 1.1 
+//-----------------------------------------------------------------------------
+//--------------------------------------------------------------------------------------------------
+`timescale 1ps/1ps
+
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_bram_msix #(
+
+  parameter           TCQ = 100
+, parameter           TO_RAM_PIPELINE="FALSE"
+, parameter           FROM_RAM_PIPELINE="FALSE"
+, parameter           MSIX_CAP_TABLE_SIZE=11'h0
+, parameter           MSIX_TABLE_RAM_ENABLE="FALSE"
+
+  ) (
+
+  input  wire         clk_i,
+  input  wire         reset_i,
+
+  input  wire  [12:0] addr_i,
+  input  wire  [31:0] wdata_i,
+  input  wire   [3:0] wdip_i,
+  input  wire   [3:0] wen_i,
+  output wire  [31:0] rdata_o,
+  output wire   [3:0] rdop_o
+
+  );
+
+  // WIP : Use Total number of functions (PFs + VFs) to calculate the NUM_BRAM_4K
+  localparam integer NUM_BRAM_4K = (MSIX_TABLE_RAM_ENABLE == "TRUE") ? 8 : 0 ;
+ 
+
+  reg          [12:0] addr;
+  reg          [12:0] addr_p0;
+  reg          [12:0] addr_p1;
+  reg          [31:0] wdata;
+  reg           [3:0] wdip;
+  reg           [3:0] wen;
+  reg          [31:0] reg_rdata;
+  reg           [3:0] reg_rdop;
+  wire         [31:0] rdata;
+  wire          [3:0] rdop;
+  genvar              i;
+  wire    [(8*4)-1:0] bram_4k_wen;
+  wire   [(8*32)-1:0] rdata_t;
+  wire    [(8*4)-1:0] rdop_t;
+
+  //
+  // Optional input pipe stages
+  //
+  generate
+
+    if (TO_RAM_PIPELINE == "TRUE") begin : TORAMPIPELINE
+
+      always @(posedge clk_i) begin
+     
+        if (reset_i) begin
+
+          addr <= #(TCQ) 13'b0;
+          wdata <= #(TCQ) 32'b0;
+          wdip <= #(TCQ) 4'b0;
+          wen <= #(TCQ) 4'b0;
+
+        end else begin
+
+          addr <= #(TCQ) addr_i;
+          wdata <= #(TCQ) wdata_i;
+          wdip <= #(TCQ) wdip_i;
+          wen <= #(TCQ) wen_i;
+
+        end
+
+      end
+
+    end else begin : NOTORAMPIPELINE
+
+      always @(*) begin
+
+          addr = addr_i;
+          wdata = wdata_i;
+          wdip = wdip_i;
+          wen = wen_i;
+
+      end
+
+
+    end
+
+  endgenerate
+
+  // 
+  // Address pipeline
+  //
+  always @(posedge clk_i) begin
+     
+    if (reset_i) begin
+
+      addr_p0 <= #(TCQ) 13'b0;
+      addr_p1 <= #(TCQ) 13'b0;
+
+    end else begin
+
+      addr_p0 <= #(TCQ) addr;
+      addr_p1 <= #(TCQ) addr_p0;
+
+    end
+
+  end
+
+  //
+  // Optional output pipe stages
+  //
+  generate
+
+    if (FROM_RAM_PIPELINE == "TRUE") begin : FRMRAMPIPELINE
+
+
+      always @(posedge clk_i) begin
+     
+        if (reset_i) begin
+
+          reg_rdata <= #(TCQ) 32'b0;
+          reg_rdop <= #(TCQ) 4'b0;
+
+        end else begin
+
+          case (addr_p1[12:10]) 
+            3'b000 : begin
+              reg_rdata <= #(TCQ) rdata_t[(32*(0))+31:(32*(0))+0];
+              reg_rdop <= #(TCQ) rdop_t[(4*(0))+3:(4*(0))+0];
+            end
+            3'b001 : begin
+              reg_rdata <= #(TCQ) rdata_t[(32*(1))+31:(32*(1))+0];
+              reg_rdop <= #(TCQ) rdop_t[(4*(1))+3:(4*(1))+0];
+            end
+            3'b010 : begin
+              reg_rdata <= #(TCQ) rdata_t[(32*(2))+31:(32*(2))+0];
+              reg_rdop <= #(TCQ) rdop_t[(4*(2))+3:(4*(2))+0];
+            end
+            3'b011 : begin
+              reg_rdata <= #(TCQ) rdata_t[(32*(3))+31:(32*(3))+0];
+              reg_rdop <= #(TCQ) rdop_t[(4*(3))+3:(4*(3))+0];
+            end
+            3'b100 : begin
+              reg_rdata <= #(TCQ) rdata_t[(32*(4))+31:(32*(4))+0];
+              reg_rdop <= #(TCQ) rdop_t[(4*(4))+3:(4*(4))+0];
+            end
+            3'b101 : begin
+              reg_rdata <= #(TCQ) rdata_t[(32*(5))+31:(32*(5))+0];
+              reg_rdop <= #(TCQ) rdop_t[(4*(5))+3:(4*(5))+0];
+            end
+            3'b110 : begin
+              reg_rdata <= #(TCQ) rdata_t[(32*(6))+31:(32*(6))+0];
+              reg_rdop <= #(TCQ) rdop_t[(4*(6))+3:(4*(6))+0];
+            end
+            3'b111 : begin
+              reg_rdata <= #(TCQ) rdata_t[(32*(7))+31:(32*(7))+0];
+              reg_rdop <= #(TCQ) rdop_t[(4*(7))+3:(4*(7))+0];
+            end
+          endcase
+
+        end
+
+      end
+
+    end else begin : NOFRMRAMPIPELINE
+
+      always @(*) begin
+
+          case (addr_p1[12:10]) 
+            3'b000 : begin
+              reg_rdata <= #(TCQ) rdata_t[(32*(0))+31:(32*(0))+0];
+              reg_rdop <= #(TCQ) rdop_t[(4*(0))+3:(4*(0))+0];
+            end
+            3'b001 : begin
+              reg_rdata <= #(TCQ) rdata_t[(32*(1))+31:(32*(1))+0];
+              reg_rdop <= #(TCQ) rdop_t[(4*(1))+3:(4*(1))+0];
+            end
+            3'b010 : begin
+              reg_rdata <= #(TCQ) rdata_t[(32*(2))+31:(32*(2))+0];
+              reg_rdop <= #(TCQ) rdop_t[(4*(2))+3:(4*(2))+0];
+            end
+            3'b011 : begin
+              reg_rdata <= #(TCQ) rdata_t[(32*(3))+31:(32*(3))+0];
+              reg_rdop <= #(TCQ) rdop_t[(4*(3))+3:(4*(3))+0];
+            end
+            3'b100 : begin
+              reg_rdata <= #(TCQ) rdata_t[(32*(4))+31:(32*(4))+0];
+              reg_rdop <= #(TCQ) rdop_t[(4*(4))+3:(4*(4))+0];
+            end
+            3'b101 : begin
+              reg_rdata <= #(TCQ) rdata_t[(32*(5))+31:(32*(5))+0];
+              reg_rdop <= #(TCQ) rdop_t[(4*(5))+3:(4*(5))+0];
+            end
+            3'b110 : begin
+              reg_rdata <= #(TCQ) rdata_t[(32*(6))+31:(32*(6))+0];
+              reg_rdop <= #(TCQ) rdop_t[(4*(6))+3:(4*(6))+0];
+            end
+            3'b111 : begin
+              reg_rdata <= #(TCQ) rdata_t[(32*(7))+31:(32*(7))+0];
+              reg_rdop <= #(TCQ) rdop_t[(4*(7))+3:(4*(7))+0];
+            end
+          endcase
+
+      end
+
+    end
+  
+  endgenerate
+
+  assign rdata_o = (MSIX_TABLE_RAM_ENABLE == "TRUE") ?  reg_rdata : 32'h0;
+  assign rdop_o = (MSIX_TABLE_RAM_ENABLE == "TRUE") ? reg_rdop : 4'h0;
+
+  generate 
+  
+    for (i=0; i<NUM_BRAM_4K; i=i+1) begin : BRAM4K
+
+      xp4_usp_smsw_bram_4k_int #(
+          .TCQ(TCQ)
+        )
+        bram_4k_int (
+    
+          .clk_i (clk_i),
+          .reset_i (reset_i),
+    
+          .addr_i(addr[9:0]),
+          .wdata_i(wdata),
+          .wdip_i(wdip),
+          .wen_i(bram_4k_wen[(4*(i))+3:(4*(i))+0]),
+          .rdata_o(rdata_t[(32*i)+31:(32*i)+0]),
+          .rdop_o(rdop_t[(4*i)+3:(4*i)+0]),
+          .baddr_i(10'b0),
+          .brdata_o()
+
+      );
+      assign bram_4k_wen[(4*(i))+3:(4*(i))+0] = wen & {4{(i == addr[12:10])}};  
+      
+    end
+
+  endgenerate
+
+endmodule
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2023 AMD, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD, Inc. and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : UltraScale+ FPGA PCI Express v4.0 Integrated Block
+// File       : xp4_usp_smsw_bram_rep_int.v
+// Version    : 1.1 
+//-----------------------------------------------------------------------------
+//--------------------------------------------------------------------------------------------------
+`timescale 1ps/1ps
+
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_bram_rep_int #(
+
+  parameter TCQ = 100
+
+  ) (
+
+  input  wire         clk_i,
+  input  wire         reset_i,
+
+  input  wire   [8:0] addr_i,
+  input  wire   [0:0] wen_i,
+  input  wire [255:0] wdata_i,
+  input  wire   [0:0] ren_i,
+  output wire [255:0] rdata_o,
+
+  output wire   [3:0] err_cor_o,
+  output wire   [3:0] err_uncor_o
+
+  );
+
+  genvar              i;
+
+  wire [255:0]        rdata_w;
+  wire [255:0]        wdata_w = wdata_i;
+
+  generate begin : ECC_RAM
+
+   for (i = 0; i < 4; i = i + 1)
+   begin : RAMB36E2
+        RAMB36E2 #(
+          .DOA_REG (1),
+          .DOB_REG (1),
+          .EN_ECC_READ ("FALSE"),
+          .EN_ECC_WRITE ("FALSE"),
+          .INIT_A (36'h000000000),
+          .INIT_B (36'h000000000),
+          .INIT_FILE ("NONE"),
+          .READ_WIDTH_A (72),
+          .READ_WIDTH_B (0),
+          .RSTREG_PRIORITY_A ("REGCE"),
+          .RSTREG_PRIORITY_B ("REGCE"),
+          .SIM_COLLISION_CHECK ("ALL"),
+          .SRVAL_A (36'h000000000),
+          .SRVAL_B (36'h000000000),
+          .WRITE_MODE_A ("WRITE_FIRST"),
+          .WRITE_MODE_B ("WRITE_FIRST"),
+          .WRITE_WIDTH_A (0),
+          .WRITE_WIDTH_B (72))
+        ramb36e2_inst (
+          .ADDRENA (1'b1),
+          .ADDRENB (1'b1),
+          .CASDIMUXA (1'b0),
+          .CASDIMUXB (1'b0),
+          .CASDOMUXA (1'b0),
+          .CASDOMUXB (1'b0),
+          .CASDOMUXEN_A (1'b0),
+          .CASDOMUXEN_B (1'b0),
+          .CASINDBITERR (1'b0),
+          .CASINSBITERR (1'b0),
+          .CASOREGIMUXA (1'b0),
+          .CASOREGIMUXB (1'b0),
+          .CASOREGIMUXEN_A (1'b0),
+          .CASOREGIMUXEN_B (1'b0),
+          .ECCPIPECE (1'b0),
+          .SLEEP (1'b0),
+          .CASDINA (32'b0),
+          .CASDINB (32'b0),
+          .CASDINPA(4'b0),
+          .CASDINPB(4'b0),
+          .CASDOUTA (),
+          .CASDOUTB (),
+          .CASDOUTPA (),
+          .CASDOUTPB (),
+          .CASOUTDBITERR (),
+          .CASOUTSBITERR (),
+          .CLKARDCLK (clk_i),
+          .CLKBWRCLK (clk_i),
+          .DBITERR (err_uncor_o[i]),
+          .ENARDEN (ren_i),
+          .ENBWREN (wen_i),
+          .INJECTDBITERR (1'b0),
+          .INJECTSBITERR (1'b0),
+          .REGCEAREGCE (1'b1),
+          .REGCEB (1'b0),
+          .RSTRAMARSTRAM (1'b0),
+          .RSTRAMB (1'b0),
+          .RSTREGARSTREG (1'b0),
+          .RSTREGB (1'b0),
+          .SBITERR (err_cor_o[i]),
+          .ADDRARDADDR ({addr_i[8:0], 6'b0}),
+          .ADDRBWRADDR ({addr_i[8:0], 6'b0}),
+          .DINADIN (wdata_w[(2*32*i)+31:(2*32*i)+0]),
+          .DINBDIN (wdata_w[(2*32*i)+63:(2*32*i)+32]),
+          .DINPADINP (4'b0),
+          .DINPBDINP (4'b0),
+          .DOUTADOUT (rdata_w[(2*32*i)+31:(2*32*i)+0]),
+          .DOUTBDOUT (rdata_w[(2*32*i)+63:(2*32*i)+32]),
+          .DOUTPADOUTP (),
+          .DOUTPBDOUTP (),
+          .ECCPARITY (),
+          .RDADDRECC (),
+          .WEA (4'h0),
+          .WEBWE (8'hFF)
+        );
+      end
+    end
+  endgenerate
+
+  assign rdata_o =  rdata_w;
+
+endmodule
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2023 AMD, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD, Inc. and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : UltraScale+ FPGA PCI Express v4.0 Integrated Block
+// File       : xp4_usp_smsw_bram_rep.v
+// Version    : 1.1 
+//-----------------------------------------------------------------------------
+//--------------------------------------------------------------------------------------------------
+`timescale 1ps/1ps
+
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_bram_rep #(
+  parameter           TCQ = 100
+, parameter           TO_RAM_PIPELINE="FALSE"
+, parameter           FROM_RAM_PIPELINE="FALSE"
+
+  ) (
+
+  input  wire         clk_i,
+  input  wire         reset_i,
+
+  input  wire   [8:0] addr_i,
+  input  wire   [0:0] wen_i,
+  input  wire [255:0] wdata_i,
+
+  output wire [255:0] rdata_o,
+  input  wire   [0:0] ren_i,
+
+  output wire   [3:0] err_cor_o,
+  output wire   [3:0] err_uncor_o
+
+  );
+
+  reg           [8:0] addr;
+  reg           [0:0] wen;
+  reg           [0:0] ren;
+  reg         [255:0] wdata;
+
+  wire        [255:0] rdata;
+  wire          [3:0] err_cor;
+  wire          [3:0] err_uncor;
+
+  reg         [255:0] reg_rdata;
+  reg           [3:0] reg_err_cor;
+  reg           [3:0] reg_err_uncor;
+
+  //
+  // Optional input pipe stages
+  //
+  
+  generate
+
+    if (TO_RAM_PIPELINE == "TRUE") begin : TORAMPIPELINE
+
+      always @(posedge clk_i) begin
+     
+        if (reset_i) begin
+
+          addr <= #(TCQ) 9'b0;
+          wen <= #(TCQ) 1'b0;
+          wdata <= #(TCQ) 256'b0;
+          ren <= #(TCQ) 1'b0;
+
+        end else begin
+
+          addr <= #(TCQ) addr_i;
+          wen <= #(TCQ) wen_i;
+          wdata <= #(TCQ) wdata_i;
+          ren <= #(TCQ) ren_i;
+
+        end
+
+      end
+
+    end else begin : NOTORAMPIPELINE
+
+      always @(*) begin
+
+        addr = addr_i;
+        wen = wen_i;
+        wdata = wdata_i;
+        ren = ren_i;
+
+      end
+
+    end
+
+  endgenerate
+
+  //
+  // Optional output pipe stages
+  //
+  
+  generate
+
+    if (FROM_RAM_PIPELINE == "TRUE") begin : FRMRAMPIPELINE
+
+
+      always @(posedge clk_i) begin
+     
+        if (reset_i) begin
+
+          reg_rdata <= #(TCQ) 256'b0;
+          reg_err_cor <= #(TCQ) 4'b0;
+          reg_err_uncor <= #(TCQ) 4'b0;
+
+        end else begin
+
+          reg_rdata <= #(TCQ) rdata;
+          reg_err_cor <= #(TCQ) err_cor;
+          reg_err_uncor <= #(TCQ) err_uncor;
+
+        end
+
+      end
+
+    end else begin : NOFRMRAMPIPELINE
+
+      always @(*) begin
+
+        reg_rdata = rdata;
+        reg_err_cor = err_cor;
+        reg_err_uncor = err_uncor;
+
+      end
+
+    end
+  
+  endgenerate
+
+  assign rdata_o = reg_rdata;
+
+  assign err_cor_o = reg_err_cor;
+  assign err_uncor_o = reg_err_uncor;
+
+  xp4_usp_smsw_bram_rep_int #(
+      .TCQ(TCQ)
+    )
+    bram_rep_int_0 (
+
+      .clk_i (clk_i),
+      .reset_i (reset_i),
+
+      .addr_i(addr[8:0]),
+      .wdata_i(wdata[255:0]),
+      .wen_i(wen),
+      .ren_i(ren),
+      .rdata_o(rdata[255:0]),
+      .err_cor_o(err_cor[3:0]),
+      .err_uncor_o(err_uncor[3:0])
+
+  );
+
+
+endmodule
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2023 AMD, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD, Inc. and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : UltraScale+ FPGA PCI Express v4.0 Integrated Block
+// File       : xp4_usp_smsw_bram_tph.v
+// Version    : 1.1 
+//-----------------------------------------------------------------------------
+//--------------------------------------------------------------------------------------------------
+`timescale 1ps/1ps
+
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_bram_tph #(
+  parameter           TCQ = 100
+, parameter           TO_RAM_PIPELINE="FALSE"
+, parameter           FROM_RAM_PIPELINE="FALSE"
+, parameter [1:0]     TL_PF_ENABLE_REG=2'h0
+, parameter [3:0]     SRIOV_CAP_ENABLE=4'h0
+, parameter [15:0]    PF0_SRIOV_CAP_TOTAL_VF=16'h0
+, parameter [15:0]    PF1_SRIOV_CAP_TOTAL_VF=16'h0
+, parameter [15:0]    PF2_SRIOV_CAP_TOTAL_VF=16'h0
+, parameter [15:0]    PF3_SRIOV_CAP_TOTAL_VF=16'h0
+, parameter           PF0_TPHR_CAP_ENABLE="FALSE"
+
+  ) (
+
+  input  wire         clk_i,
+  input  wire         reset_i,
+
+  input  wire   [7:0] user_tph_stt_func_num_i,     // 0-255
+  input  wire   [5:0] user_tph_stt_index_i,        // 0-63
+  input  wire         user_tph_stt_rd_en_i,
+  output wire   [7:0] user_tph_stt_rd_data_o,
+
+  input  wire  [11:0] addr_i,
+  input  wire  [31:0] wdata_i,
+  input  wire   [3:0] wdip_i,
+  input  wire   [3:0] wen_i,
+  output wire  [31:0] rdata_o,
+  output wire   [3:0] rdop_o
+
+  );
+  localparam integer NUM_VFUNCTIONS = (SRIOV_CAP_ENABLE == 4'h0) ? 0 : 
+                              (SRIOV_CAP_ENABLE == 4'h1) ? PF0_SRIOV_CAP_TOTAL_VF : 
+                              (SRIOV_CAP_ENABLE == 4'h3) ? (PF0_SRIOV_CAP_TOTAL_VF + PF1_SRIOV_CAP_TOTAL_VF) : 
+                              (SRIOV_CAP_ENABLE == 4'h7) ? (PF0_SRIOV_CAP_TOTAL_VF + PF1_SRIOV_CAP_TOTAL_VF + PF2_SRIOV_CAP_TOTAL_VF) : 
+                              (PF0_SRIOV_CAP_TOTAL_VF + PF1_SRIOV_CAP_TOTAL_VF + PF2_SRIOV_CAP_TOTAL_VF + PF3_SRIOV_CAP_TOTAL_VF);
+
+  localparam integer NUM_FUNCTIONS = (TL_PF_ENABLE_REG == 2'h0) ? (NUM_VFUNCTIONS + 1) :
+                             (TL_PF_ENABLE_REG == 2'h1) ? (NUM_VFUNCTIONS + 2) :
+                             (TL_PF_ENABLE_REG == 2'h2) ? (NUM_VFUNCTIONS + 3) : (NUM_VFUNCTIONS + 4);
+
+  localparam integer NUM_BRAM_4K = (PF0_TPHR_CAP_ENABLE == "TRUE") ?  
+                                   ((NUM_FUNCTIONS  <= 64) ? 1 : 
+                                   ((NUM_FUNCTIONS  > 64) && (NUM_FUNCTIONS  <= 128)) ? 2 : 
+                                   ((NUM_FUNCTIONS  > 128) && (NUM_FUNCTIONS  <= 192)) ? 3 : 4) : 4;
+ 
+
+  reg          [11:0] addr;
+  reg          [11:0] addr_p0;
+  reg          [11:0] addr_p1;
+  reg          [31:0] wdata;
+  reg           [3:0] wdip;
+  reg           [3:0] wen;
+  reg          [31:0] reg_rdata;
+  reg           [3:0] reg_rdop;
+  wire         [31:0] rdata;
+  wire          [3:0] rdop;
+  genvar              i;
+  wire         [13:0] baddr; 
+  reg          [13:0] baddr_p0; 
+  reg          [13:0] baddr_p1; 
+  reg          [31:0] brdata_w;
+  wire   [(4*32)-1:0] rdata_t;
+  wire    [(4*4)-1:0] rdop_t;
+  wire   [(4*32)-1:0] brdata;
+  wire    [(4*4)-1:0] bram_4k_wen;
+
+  generate
+
+    if (PF0_TPHR_CAP_ENABLE == "TRUE") begin : TPHR_CAP_PRESENT
+
+      //
+      // Optional input pipe stages
+      //
+
+      if (TO_RAM_PIPELINE == "TRUE") begin : TORAMPIPELINE
+
+        always @(posedge clk_i) begin
+     
+          if (reset_i) begin
+
+            addr <= #(TCQ) 12'b0;
+            wdata <= #(TCQ) 32'b0;
+            wdip <= #(TCQ) 4'b0;
+            wen <= #(TCQ) 4'b0;
+    
+          end else begin
+    
+            addr <= #(TCQ) addr_i;
+            wdata <= #(TCQ) wdata_i;
+            wdip <= #(TCQ) wdip_i;
+            wen <= #(TCQ) wen_i;
+    
+          end
+
+        end
+
+      end else begin : NOTORAMPIPELINE
+
+        always @(*) begin
+
+          addr = addr_i;
+          wdata = wdata_i;
+          wdip = wdip_i;
+          wen = wen_i;
+    
+      end
+
+    end
+
+
+    // 
+    // Address pipeline
+    //
+
+    always @(posedge clk_i) begin
+     
+      if (reset_i) begin
+
+        addr_p0 <= #(TCQ) 12'b0;
+        addr_p1 <= #(TCQ) 12'b0;
+        baddr_p0 <= #(TCQ) 2'b0;
+        baddr_p1 <= #(TCQ) 2'b0;
+    
+      end else begin
+    
+        addr_p0 <= #(TCQ) addr;
+        addr_p1 <= #(TCQ) addr_p0;
+        baddr_p0 <= #(TCQ) baddr;
+        baddr_p1 <= #(TCQ) baddr_p0;
+    
+      end
+    
+    end
+
+    //
+    // Optional output pipe stages
+    //
+
+    if (FROM_RAM_PIPELINE == "TRUE") begin : FRMRAMPIPELINE
+    
+    
+      always @(posedge clk_i) begin
+         
+        if (reset_i) begin
+    
+          reg_rdata <= #(TCQ) 32'b0;
+          reg_rdop <= #(TCQ) 4'b0;
+    
+         end else begin
+    
+           case (addr_p1[11:10]) 
+             2'b00 : begin
+               reg_rdata <= #(TCQ) rdata_t[(32*(0))+31:(32*(0))+0];
+               reg_rdop <= #(TCQ) rdop_t[(4*(0))+3:(4*(0))+0];
+             end
+             2'b01 : begin
+               reg_rdata <= #(TCQ) rdata_t[(32*(1))+31:(32*(1))+0];
+               reg_rdop <= #(TCQ) rdop_t[(4*(1))+3:(4*(1))+0];
+             end
+             2'b10 : begin
+               reg_rdata <= #(TCQ) rdata_t[(32*(2))+31:(32*(2))+0];
+               reg_rdop <= #(TCQ) rdop_t[(4*(2))+3:(4*(2))+0];
+             end
+             2'b11 : begin
+               reg_rdata <= #(TCQ) rdata_t[(32*(3))+31:(32*(3))+0];
+               reg_rdop <= #(TCQ) rdop_t[(4*(3))+3:(4*(3))+0];
+             end
+           endcase
+    
+          end
+
+        end // always
+
+      end else begin : NOFRMRAMPIPELINE
+    
+        always @(*) begin
+
+          case (addr_p1[11:10]) 
+            2'b00 : begin
+              reg_rdata <= #(TCQ) rdata_t[(32*(0))+31:(32*(0))+0];
+              reg_rdop <= #(TCQ) rdop_t[(4*(0))+3:(4*(0))+0];
+            end
+            2'b01 : begin
+              reg_rdata <= #(TCQ) rdata_t[(32*(1))+31:(32*(1))+0];
+              reg_rdop <= #(TCQ) rdop_t[(4*(1))+3:(4*(1))+0];
+            end
+            2'b10 : begin
+              reg_rdata <= #(TCQ) rdata_t[(32*(2))+31:(32*(2))+0];
+              reg_rdop <= #(TCQ) rdop_t[(4*(2))+3:(4*(2))+0];
+            end
+            2'b11 : begin
+              reg_rdata <= #(TCQ) rdata_t[(32*(3))+31:(32*(3))+0];
+              reg_rdop <= #(TCQ) rdop_t[(4*(3))+3:(4*(3))+0];
+            end
+          endcase
+    
+        end // always
+
+      end // (FROM_RAM_PIPELINE == "TRUE") begin : FRMRAMPIPELINE
+  
+      assign rdata_o = reg_rdata;
+      assign rdop_o = reg_rdop;
+      assign baddr = {user_tph_stt_func_num_i[7:0], user_tph_stt_index_i[5:0]};
+
+      always @ (*) begin
+    
+        if (baddr_p1[13:12] == 2'b00)
+          brdata_w = brdata[(32*(0))+31:(32*(0))+0];
+        else if (baddr_p1[13:12] == 2'b01)
+          brdata_w = brdata[(32*(1))+31:(32*(1))+0];
+        else if (baddr_p1[13:12] == 2'b10)
+          brdata_w = brdata[(32*(2))+31:(32*(2))+0];
+        else
+          brdata_w = brdata[(32*(3))+31:(32*(3))+0];
+    
+      end
+    
+      assign user_tph_stt_rd_data_o = (baddr_p1[1:0] == 2'b00) ? brdata_w[7:0] : 
+                                      (baddr_p1[1:0] == 2'b01) ? brdata_w[15:8] :  
+                                      (baddr_p1[1:0] == 2'b10) ? brdata_w[23:16] : brdata_w[31:24];
+    
+      //
+      // BRAM instances
+      //
+
+      for (i=0; i<4; i=i+1) begin : BRAM4K
+
+      xp4_usp_smsw_bram_4k_int #(
+
+          .TCQ(TCQ)
+
+        )
+        bram_4k_int (
+        
+          .clk_i (clk_i),
+          .reset_i (reset_i),
+          .addr_i(addr[9:0]),
+          .wdata_i(wdata),
+          .wdip_i(wdip),
+          .wen_i(bram_4k_wen[(4*i)+3:(4*i)+0]),
+          .rdata_o(rdata_t[(32*i)+31:(32*i)+0]),
+          .rdop_o(rdop_t[(4*i)+3:(4*i)+0]),
+          .baddr_i(baddr[11:2]),
+          .brdata_o(brdata[(32*i)+31:(32*i)+0])
+
+        );
+        assign bram_4k_wen[(4*i)+3:(4*i)+0] = (i == addr[11:10]) ? wen : 4'h0;
+      
+      end
+
+    end else begin : TPHR_CAP_NOT_PRESENT 
+
+      assign rdata_o = 32'h0;
+      assign rdop_o = 4'h0;
+      assign user_tph_stt_rd_data_o = 8'h0;
+
+    end // (PF0_TPHR_CAP_ENABLE == "TRUE") begin : TPHR_CAP_PRESENT
+
+  endgenerate
+
+endmodule
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2023 AMD, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD, Inc. and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : UltraScale+ FPGA PCI Express v4.0 Integrated Block
+// File       : xp4_usp_smsw_512b_intfc.v
+// Version    : 1.1 
+//-----------------------------------------------------------------------------
+//--------------------------------------------------------------------------------------------------
+`timescale 1ps/1ps
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_512b_intfc #(
+     parameter           TCQ = 100
+   , parameter           IMPL_TARGET = "SOFT"
+   , parameter           AXISTEN_IF_EXT_512_INTFC_RAM_STYLE = "BRAM"
+   , parameter           AXISTEN_IF_RQ_CC_REGISTERED_TREADY = "TRUE"
+   , parameter           AXI4_USER_DATA_WIDTH = 512
+   , parameter           AXI4_CORE_DATA_WIDTH = 256
+   , parameter           AXI4_USER_CQ_TUSER_WIDTH = 183
+   , parameter           AXI4_USER_CC_TUSER_WIDTH = 81
+   , parameter           AXI4_USER_RQ_TUSER_WIDTH = 137
+   , parameter           AXI4_USER_RC_TUSER_WIDTH = 161
+   , parameter           AXI4_CORE_CQ_TUSER_WIDTH = 88
+   , parameter           AXI4_CORE_CC_TUSER_WIDTH = 33
+   , parameter           AXI4_CORE_RQ_TUSER_WIDTH = 62
+   , parameter           AXI4_CORE_RC_TUSER_WIDTH = 75
+   , parameter           AXI4_USER_CQ_TKEEP_WIDTH = 16
+   , parameter           AXI4_USER_CC_TKEEP_WIDTH = 16
+   , parameter           AXI4_USER_RQ_TKEEP_WIDTH = 16
+   , parameter           AXI4_USER_RC_TKEEP_WIDTH = 16
+   , parameter           AXI4_CORE_CQ_TKEEP_WIDTH = 8
+   , parameter           AXI4_CORE_CC_TKEEP_WIDTH = 8
+   , parameter           AXI4_CORE_RQ_TKEEP_WIDTH = 8
+   , parameter           AXI4_CORE_RC_TKEEP_WIDTH = 8
+   , parameter           AXI4_CORE_CQ_TREADY_WIDTH = 22  
+   , parameter           AXI4_CORE_RC_TREADY_WIDTH = 22  
+   , parameter           AXISTEN_IF_EXT_512_CQ_STRADDLE="FALSE"
+   , parameter           AXISTEN_IF_EXT_512_CC_STRADDLE="FALSE"
+   , parameter           AXISTEN_IF_EXT_512_RQ_STRADDLE="FALSE"
+   , parameter           AXISTEN_IF_EXT_512_RC_STRADDLE="FALSE"
+   , parameter           AXISTEN_IF_EXT_512_RC_4TLP_STRADDLE="TRUE"
+   , parameter [1:0]     AXISTEN_IF_CQ_ALIGNMENT_MODE=2'b00
+   , parameter [1:0]     AXISTEN_IF_CC_ALIGNMENT_MODE=2'b00
+   , parameter [1:0]     AXISTEN_IF_RQ_ALIGNMENT_MODE=2'b00
+   , parameter [1:0]     AXISTEN_IF_RC_ALIGNMENT_MODE=2'b00
+   , parameter           AXISTEN_IF_RX_PARITY_EN="TRUE"
+   , parameter           AXISTEN_IF_TX_PARITY_EN="TRUE"
+   ) 
+  (
+    input  wire           user_clk2_i // 500 MHz clock for core-facing interfaces
+   ,input  wire           user_clk_i // 250 MHz clock for client-facing interfaces
+   ,input  wire           user_clk_en_i // User clock enable for clock domain crossing
+   ,input  wire           reset_n_user_clk_i // Reset in the user clock domain
+   ,input  wire           reset_n_user_clk2_i // Reset in the user clock2 domain
+   ,input  wire           link_down_reset_i // Link went down
+   //-----------------------------------------------------------------------------------------------
+   // Client-side interfaces
+   //-----------------------------------------------------------------------------------------------
+   // CQ Interface
+   ,output wire [511:0]   m_axis_cq_tdata_o
+   ,output wire           m_axis_cq_tvalid_o
+   ,output wire [182:0]   m_axis_cq_tuser_o
+   ,output wire           m_axis_cq_tlast_o
+   ,output wire [15:0]    m_axis_cq_tkeep_o
+   ,input  wire           m_axis_cq_tready_i
+   ,input  wire [1:0]     pcie_cq_np_req_i // Client request to deliver NP TLP
+   ,output wire [5:0]      pcie_cq_np_req_count_o // Current value of interface credit count for NP TLPs
+   // CC Interface
+   ,input wire [511:0]    s_axis_cc_tdata_i
+   ,input wire            s_axis_cc_tvalid_i
+   ,input wire [80:0]     s_axis_cc_tuser_i
+   ,input wire            s_axis_cc_tlast_i
+   ,input wire [15:0]     s_axis_cc_tkeep_i
+   ,output wire            s_axis_cc_tready_o   
+   // RQ Interface
+   ,input wire [511:0]    s_axis_rq_tdata_i
+   ,input wire            s_axis_rq_tvalid_i
+   ,input wire [136:0]    s_axis_rq_tuser_i
+   ,input wire            s_axis_rq_tlast_i
+   ,input wire [15:0]     s_axis_rq_tkeep_i
+   ,output wire            s_axis_rq_tready_o   
+   // RC Interface
+   ,output wire [511:0]   m_axis_rc_tdata_o
+   ,output wire           m_axis_rc_tvalid_o
+   ,output wire [160:0]   m_axis_rc_tuser_o
+   ,output wire           m_axis_rc_tlast_o
+   ,output wire [15:0]    m_axis_rc_tkeep_o
+   ,input  wire           m_axis_rc_tready_i
+   //-----------------------------------------------------------------------------------------------
+   // Core-side interfaces
+   //-----------------------------------------------------------------------------------------------
+   // CQ Interface
+   ,input  wire [255:0]   core_cq_tdata_i
+   ,input  wire           core_cq_tvalid_i
+   ,input  wire [87:0]    core_cq_tuser_i
+   ,input  wire           core_cq_tlast_i
+   ,input  wire [7:0]     core_cq_tkeep_i
+   ,output wire [21:0]     core_cq_tready_o
+   ,output wire            posted_req_delivered_o // Signals the delivery of a Posted Req on the CQ interface
+   ,output wire            cq_pipeline_empty_o // Indicates that the entire CQ pipeline of the bridge is empty.
+   ,output wire            cq_np_user_credit_rcvd_o // Indicates that the user issued one NP credit
+   // CC Interface
+   ,output wire [255:0]    core_cc_tdata_o
+   ,output wire            core_cc_tvalid_o
+   ,output wire [32:0]     core_cc_tuser_o
+   ,output wire            core_cc_tlast_o
+   ,output wire [7:0]      core_cc_tkeep_o
+   ,input wire [3:0]      core_cc_tready_i
+   // RQ Interface
+   ,output wire [255:0]    core_rq_tdata_o
+   ,output wire            core_rq_tvalid_o
+   ,output wire [61:0]     core_rq_tuser_o
+   ,output wire            core_rq_tlast_o
+   ,output wire [7:0]      core_rq_tkeep_o
+   ,input wire [3:0]      core_rq_tready_i
+   // RC Interface
+   ,input  wire [255:0]   core_rc_tdata_i
+   ,input  wire           core_rc_tvalid_i
+   ,input  wire [74:0]    core_rc_tuser_i
+   ,input  wire           core_rc_tlast_i
+   ,input  wire [7:0]     core_rc_tkeep_i
+   ,output wire [21:0]     core_rc_tready_o
+   // Completion delivered indications
+   ,output wire [1:0]      compl_delivered_o // Completions delivered to user
+                                            // 00 = No Compl, 01 = 1 Compl, 11 = 2 Completions
+   ,output wire [7:0]      compl_delivered_tag0_o// Tag associated with first delivered Completion
+   ,output wire [7:0]      compl_delivered_tag1_o// Tag associated with second delivered Completion
+   );
+
+  wire        attr_axisten_if_ext_512_cq_straddle;
+  wire        attr_axisten_if_ext_512_cc_straddle;
+  wire        attr_axisten_if_ext_512_rq_straddle;
+  wire        attr_axisten_if_ext_512_rc_straddle;
+  wire        attr_axisten_if_ext_512_rc_4tlp_straddle;
+  wire [1:0] attr_axisten_if_cq_alignment_mode;
+  wire [1:0] attr_axisten_if_cc_alignment_mode;
+  wire [1:0] attr_axisten_if_rq_alignment_mode;
+  wire [1:0] attr_axisten_if_rc_alignment_mode;
+  wire     attr_axisten_if_rq_cc_registered_tready;
+  wire        spare_bit0;
+  
+  generate
+    if (AXISTEN_IF_EXT_512_CQ_STRADDLE == "TRUE")
+      assign attr_axisten_if_ext_512_cq_straddle = 1'b1;
+    else
+      assign attr_axisten_if_ext_512_cq_straddle = 1'b0;
+  endgenerate
+  
+  generate
+    if (AXISTEN_IF_EXT_512_CC_STRADDLE == "TRUE")
+      assign attr_axisten_if_ext_512_cc_straddle = 1'b1;
+    else
+      assign attr_axisten_if_ext_512_cc_straddle = 1'b0;
+  endgenerate
+
+  generate
+    if (AXISTEN_IF_EXT_512_RQ_STRADDLE == "TRUE")
+      assign attr_axisten_if_ext_512_rq_straddle = 1'b1;
+    else
+      assign attr_axisten_if_ext_512_rq_straddle = 1'b0;
+  endgenerate
+
+  generate
+    if (AXISTEN_IF_EXT_512_RC_STRADDLE == "TRUE")
+      assign attr_axisten_if_ext_512_rc_straddle = 1'b1;
+    else
+      assign attr_axisten_if_ext_512_rc_straddle = 1'b0;
+  endgenerate
+
+  generate
+    if (AXISTEN_IF_EXT_512_RC_4TLP_STRADDLE == "TRUE")
+      assign attr_axisten_if_ext_512_rc_4tlp_straddle = 1'b1;
+    else
+      assign attr_axisten_if_ext_512_rc_4tlp_straddle = 1'b0;
+  endgenerate
+
+  generate
+    if (AXISTEN_IF_RQ_CC_REGISTERED_TREADY == "TRUE")
+      assign spare_bit0 = 1'b1; 
+    else
+      assign spare_bit0 = 1'b0; 
+  endgenerate
+  assign     attr_axisten_if_rq_cc_registered_tready = spare_bit0;
+
+  assign     attr_axisten_if_cq_alignment_mode = AXISTEN_IF_CQ_ALIGNMENT_MODE;
+  assign     attr_axisten_if_cc_alignment_mode = AXISTEN_IF_CC_ALIGNMENT_MODE;
+  assign     attr_axisten_if_rq_alignment_mode = AXISTEN_IF_RQ_ALIGNMENT_MODE;
+  assign     attr_axisten_if_rc_alignment_mode = AXISTEN_IF_RC_ALIGNMENT_MODE;
+
+  xp4_usp_smsw_512b_intfc_int #
+    (
+     .TCQ(TCQ),
+     .IMPL_TARGET(IMPL_TARGET),
+     .AXISTEN_IF_EXT_512_INTFC_RAM_STYLE("SRL"),
+     .AXI4_USER_DATA_WIDTH(AXI4_USER_DATA_WIDTH),
+     .AXI4_CORE_DATA_WIDTH(AXI4_CORE_DATA_WIDTH),
+     .AXI4_USER_CQ_TUSER_WIDTH(AXI4_USER_CQ_TUSER_WIDTH),
+     .AXI4_USER_CC_TUSER_WIDTH(AXI4_USER_CC_TUSER_WIDTH),
+     .AXI4_USER_RQ_TUSER_WIDTH(AXI4_USER_RQ_TUSER_WIDTH),
+     .AXI4_USER_RC_TUSER_WIDTH(AXI4_USER_RC_TUSER_WIDTH),
+     .AXI4_CORE_CQ_TUSER_WIDTH(AXI4_CORE_CQ_TUSER_WIDTH),
+     .AXI4_CORE_CC_TUSER_WIDTH(AXI4_CORE_CC_TUSER_WIDTH),
+     .AXI4_CORE_RQ_TUSER_WIDTH(AXI4_CORE_RQ_TUSER_WIDTH),
+     .AXI4_CORE_RC_TUSER_WIDTH(AXI4_CORE_RC_TUSER_WIDTH),
+     .AXI4_USER_CQ_TKEEP_WIDTH(AXI4_USER_CQ_TKEEP_WIDTH),
+     .AXI4_USER_CC_TKEEP_WIDTH(AXI4_USER_CC_TKEEP_WIDTH),
+     .AXI4_USER_RQ_TKEEP_WIDTH(AXI4_USER_RQ_TKEEP_WIDTH),
+     .AXI4_USER_RC_TKEEP_WIDTH(AXI4_USER_RC_TKEEP_WIDTH),
+     .AXI4_CORE_CQ_TKEEP_WIDTH(AXI4_CORE_CQ_TKEEP_WIDTH),
+     .AXI4_CORE_CC_TKEEP_WIDTH(AXI4_CORE_CC_TKEEP_WIDTH),
+     .AXI4_CORE_RQ_TKEEP_WIDTH(AXI4_CORE_RQ_TKEEP_WIDTH),
+     .AXI4_CORE_RC_TKEEP_WIDTH(AXI4_CORE_RC_TKEEP_WIDTH),
+     .AXI4_CORE_CQ_TREADY_WIDTH(AXI4_CORE_CQ_TREADY_WIDTH),
+     .AXI4_CORE_RC_TREADY_WIDTH(AXI4_CORE_RC_TREADY_WIDTH),
+     .AXISTEN_IF_RX_PARITY_EN(AXISTEN_IF_RX_PARITY_EN),
+     .AXISTEN_IF_TX_PARITY_EN(AXISTEN_IF_TX_PARITY_EN)
+     )
+    pcie_4_0_512b_intfc_int_mod
+  (
+   .user_clk_i         (user_clk_i),
+   .user_clk2_i        (user_clk2_i),
+   .user_clk_en_i      (user_clk_en_i),
+   .reset_n_user_clk_i (reset_n_user_clk_i),
+   .reset_n_user_clk2_i(reset_n_user_clk2_i),
+   .link_down_reset_i  (link_down_reset_i),
+   // Attributes
+   .attr_axisten_if_ext_512_cq_straddle_i(attr_axisten_if_ext_512_cq_straddle),
+   .attr_axisten_if_ext_512_cc_straddle_i(attr_axisten_if_ext_512_cc_straddle),
+   .attr_axisten_if_ext_512_rq_straddle_i(attr_axisten_if_ext_512_rq_straddle),
+   .attr_axisten_if_ext_512_rc_straddle_i(attr_axisten_if_ext_512_rc_straddle),
+   .attr_axisten_if_ext_512_rc_4tlp_straddle_i(attr_axisten_if_ext_512_rc_4tlp_straddle),
+   .attr_axisten_if_cq_alignment_mode_i(attr_axisten_if_cq_alignment_mode),
+   .attr_axisten_if_cc_alignment_mode_i(attr_axisten_if_cc_alignment_mode),
+   .attr_axisten_if_rq_alignment_mode_i(attr_axisten_if_rq_alignment_mode),
+   .attr_axisten_if_rc_alignment_mode_i(attr_axisten_if_rc_alignment_mode),
+   .attr_axisten_if_rq_cc_registered_tready_i(attr_axisten_if_rq_cc_registered_tready),
+   //-----------------------------------
+   // Client-side signals
+   //-----------------------------------
+   // CQ Interface
+   .m_axis_cq_tdata_o  (m_axis_cq_tdata_o),
+   .m_axis_cq_tvalid_o (m_axis_cq_tvalid_o),
+   .m_axis_cq_tuser_o  (m_axis_cq_tuser_o),
+   .m_axis_cq_tlast_o  (m_axis_cq_tlast_o),
+   .m_axis_cq_tkeep_o  (m_axis_cq_tkeep_o),
+   .m_axis_cq_tready_i (m_axis_cq_tready_i),
+   .pcie_cq_np_req_i   (pcie_cq_np_req_i),
+   .pcie_cq_np_req_count_o(pcie_cq_np_req_count_o),
+   // CC Interface
+   .s_axis_cc_tdata_i  (s_axis_cc_tdata_i),
+   .s_axis_cc_tvalid_i (s_axis_cc_tvalid_i),
+   .s_axis_cc_tuser_i  (s_axis_cc_tuser_i),
+   .s_axis_cc_tlast_i  (s_axis_cc_tlast_i),
+   .s_axis_cc_tkeep_i  (s_axis_cc_tkeep_i),
+   .s_axis_cc_tready_o (s_axis_cc_tready_o),
+   // RQ Interface
+   .s_axis_rq_tdata_i  (s_axis_rq_tdata_i),
+   .s_axis_rq_tvalid_i (s_axis_rq_tvalid_i),
+   .s_axis_rq_tuser_i  (s_axis_rq_tuser_i),
+   .s_axis_rq_tlast_i  (s_axis_rq_tlast_i),
+   .s_axis_rq_tkeep_i  (s_axis_rq_tkeep_i),
+   .s_axis_rq_tready_o (s_axis_rq_tready_o),
+   // RC Interface
+   .m_axis_rc_tdata_o  (m_axis_rc_tdata_o),
+   .m_axis_rc_tvalid_o (m_axis_rc_tvalid_o),
+   .m_axis_rc_tuser_o  (m_axis_rc_tuser_o),
+   .m_axis_rc_tlast_o  (m_axis_rc_tlast_o),
+   .m_axis_rc_tkeep_o  (m_axis_rc_tkeep_o),
+   .m_axis_rc_tready_i (m_axis_rc_tready_i),
+   //-----------------------------------
+   // Core-side signals
+   //-----------------------------------
+   // CQ Interface
+   .core_cq_tdata_i    (core_cq_tdata_i),
+   .core_cq_tvalid_i   (core_cq_tvalid_i),
+   .core_cq_tuser_i    (core_cq_tuser_i),
+   .core_cq_tlast_i    (core_cq_tlast_i),
+   .core_cq_tkeep_i    (core_cq_tkeep_i),
+   .core_cq_tready_o   (core_cq_tready_o),
+   .posted_req_delivered_o(posted_req_delivered_o),
+   .cq_pipeline_empty_o(cq_pipeline_empty_o),
+   .cq_np_user_credit_rcvd_o(cq_np_user_credit_rcvd_o),
+   // CC Interface
+   .core_cc_tdata_o    (core_cc_tdata_o),
+   .core_cc_tvalid_o   (core_cc_tvalid_o),
+   .core_cc_tuser_o    (core_cc_tuser_o),
+   .core_cc_tlast_o    (core_cc_tlast_o),
+   .core_cc_tkeep_o    (core_cc_tkeep_o),
+   .core_cc_tready_i   (core_cc_tready_i),
+   // RQ Interface
+   .core_rq_tdata_o    (core_rq_tdata_o),
+   .core_rq_tvalid_o   (core_rq_tvalid_o),
+   .core_rq_tuser_o    (core_rq_tuser_o),
+   .core_rq_tlast_o    (core_rq_tlast_o),
+   .core_rq_tkeep_o    (core_rq_tkeep_o),
+   .core_rq_tready_i   (core_rq_tready_i),
+   // RC Interface
+   .core_rc_tdata_i    (core_rc_tdata_i),
+   .core_rc_tvalid_i   (core_rc_tvalid_i),
+   .core_rc_tuser_i    (core_rc_tuser_i),
+   .core_rc_tlast_i    (core_rc_tlast_i),
+   .core_rc_tkeep_i    (core_rc_tkeep_i),
+   .core_rc_tready_o   (core_rc_tready_o),
+   .compl_delivered_o  (compl_delivered_o),
+   .compl_delivered_tag0_o(compl_delivered_tag0_o),
+   .compl_delivered_tag1_o(compl_delivered_tag1_o)
+   );
+endmodule // pcie_4_0_512b_intfc
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2023 AMD, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD, Inc. and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : UltraScale+ FPGA PCI Express v4.0 Integrated Block
+// File       : xp4_usp_smsw_512b_intfc_int.v
+// Version    : 1.1 
+//-----------------------------------------------------------------------------
+//--------------------------------------------------------------------------------------------------
+`timescale 1ps/1ps
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_512b_intfc_int #(
+   parameter TCQ = 100,
+   parameter IMPL_TARGET = "SOFT",
+   parameter AXISTEN_IF_EXT_512_INTFC_RAM_STYLE = "BRAM",
+   parameter AXI4_USER_DATA_WIDTH = 512,
+   parameter AXI4_CORE_DATA_WIDTH = 256,
+   parameter AXI4_USER_CQ_TUSER_WIDTH = 183,
+   parameter AXI4_USER_CC_TUSER_WIDTH = 81,
+   parameter AXI4_USER_RQ_TUSER_WIDTH = 137,
+   parameter AXI4_USER_RC_TUSER_WIDTH = 161,
+   parameter AXI4_CORE_CQ_TUSER_WIDTH = 88,
+   parameter AXI4_CORE_CC_TUSER_WIDTH = 33,
+   parameter AXI4_CORE_RQ_TUSER_WIDTH = 62,
+   parameter AXI4_CORE_RC_TUSER_WIDTH = 75,
+   parameter AXI4_USER_CQ_TKEEP_WIDTH = 16,
+   parameter AXI4_USER_CC_TKEEP_WIDTH = 16,
+   parameter AXI4_USER_RQ_TKEEP_WIDTH = 16,
+   parameter AXI4_USER_RC_TKEEP_WIDTH = 16,
+   parameter AXI4_CORE_CQ_TKEEP_WIDTH = 8,
+   parameter AXI4_CORE_CC_TKEEP_WIDTH = 8,
+   parameter AXI4_CORE_RQ_TKEEP_WIDTH = 8,
+   parameter AXI4_CORE_RC_TKEEP_WIDTH = 8,
+   parameter AXI4_CORE_CQ_TREADY_WIDTH = 22,   
+   parameter AXI4_CORE_RC_TREADY_WIDTH = 22,
+   parameter AXISTEN_IF_RX_PARITY_EN="TRUE",
+   parameter AXISTEN_IF_TX_PARITY_EN="TRUE"
+   ) 
+  (
+    input  wire           user_clk2_i // 500 MHz clock for core-facing interfaces
+   ,input  wire           user_clk_i // 250 MHz clock for client-facing interfaces
+   ,input  wire           user_clk_en_i // User clock enable for clock domain crossing
+   ,input  wire           reset_n_user_clk_i // Reset in the user clock domain
+   ,input  wire           reset_n_user_clk2_i // Reset in the user clock2 domain
+   ,input  wire           link_down_reset_i // Link went down
+   // Attributes
+   ,input wire            attr_axisten_if_ext_512_cq_straddle_i // Enable straddle on CQ interface
+   ,input wire            attr_axisten_if_ext_512_cc_straddle_i // Enable straddle on CC interface
+   ,input wire            attr_axisten_if_ext_512_rq_straddle_i // Enable straddle on RQ interface
+   ,input wire            attr_axisten_if_ext_512_rc_straddle_i // Enable straddle on RC interface
+   ,input wire            attr_axisten_if_ext_512_rc_4tlp_straddle_i // Enable 4-TLP straddle on RC interface
+   ,input wire [1:0]      attr_axisten_if_cq_alignment_mode_i // Alignment mode on CQ interface 
+                                                            // (00= Dword-aligned, 10 = 128b address-aligned)
+   ,input wire [1:0]      attr_axisten_if_cc_alignment_mode_i // Alignment mode on CC interface 
+                                                            // (00 = Dword-aligned, 10 = 128b address-aligned)
+   ,input wire [1:0]      attr_axisten_if_rq_alignment_mode_i // Alignment mode on RQ interface 
+                                                            // (00 = Dword-aligned, 10 = 128b address-aligned)
+   ,input wire [1:0]      attr_axisten_if_rc_alignment_mode_i // Alignment mode on RC interface 
+                                                            // (00= Dword-aligned, 10 = 128b address-aligned)
+   ,input wire            attr_axisten_if_rq_cc_registered_tready_i // 0 = registered_tready enabled, 1 = registered_tready disabled
+
+   //-----------------------------------------------------------------------------------------------
+   // Client-side interfaces
+   //-----------------------------------------------------------------------------------------------
+   // CQ Interface
+   ,output wire [511:0]   m_axis_cq_tdata_o
+   ,output wire           m_axis_cq_tvalid_o
+   ,output wire [182:0]   m_axis_cq_tuser_o
+   ,output wire           m_axis_cq_tlast_o
+   ,output wire [15:0]    m_axis_cq_tkeep_o
+   ,input  wire           m_axis_cq_tready_i
+   ,input  wire [1:0]     pcie_cq_np_req_i // Client request to deliver NP TLP
+   ,output wire [5:0]      pcie_cq_np_req_count_o // Current value of interface credit count for NP TLPs
+   // CC Interface
+   ,input wire [511:0]    s_axis_cc_tdata_i
+   ,input wire            s_axis_cc_tvalid_i
+   ,input wire [80:0]     s_axis_cc_tuser_i
+   ,input wire            s_axis_cc_tlast_i
+   ,input wire [15:0]     s_axis_cc_tkeep_i
+   ,output wire            s_axis_cc_tready_o   
+   // RQ Interface
+   ,input wire [511:0]    s_axis_rq_tdata_i
+   ,input wire            s_axis_rq_tvalid_i
+   ,input wire [136:0]    s_axis_rq_tuser_i
+   ,input wire            s_axis_rq_tlast_i
+   ,input wire [15:0]     s_axis_rq_tkeep_i
+   ,output wire            s_axis_rq_tready_o   
+   // RC Interface
+   ,output wire [511:0]   m_axis_rc_tdata_o
+   ,output wire           m_axis_rc_tvalid_o
+   ,output wire [160:0]   m_axis_rc_tuser_o
+   ,output wire           m_axis_rc_tlast_o
+   ,output wire [15:0]    m_axis_rc_tkeep_o
+   ,input  wire           m_axis_rc_tready_i
+   //-----------------------------------------------------------------------------------------------
+   // Core-side interfaces
+   //-----------------------------------------------------------------------------------------------
+   // CQ Interface
+   ,input  wire [255:0]   core_cq_tdata_i
+   ,input  wire           core_cq_tvalid_i
+   ,input  wire [87:0]    core_cq_tuser_i
+   ,input  wire           core_cq_tlast_i
+   ,input  wire [7:0]     core_cq_tkeep_i
+   ,output wire [21:0]     core_cq_tready_o
+   ,output wire            posted_req_delivered_o // Signals the delivery of a Posted Req on the CQ interface
+   ,output wire            cq_pipeline_empty_o // Indicates that the entire CQ pipeline of the bridge is empty.
+   ,output wire            cq_np_user_credit_rcvd_o // Indicates that the user issued one NP credit
+   // CC Interface
+   ,output wire [255:0]    core_cc_tdata_o
+   ,output wire            core_cc_tvalid_o
+   ,output wire [32:0]     core_cc_tuser_o
+   ,output wire            core_cc_tlast_o
+   ,output wire [7:0]      core_cc_tkeep_o
+   ,input wire [3:0]       core_cc_tready_i
+   // RQ Interface
+   ,output wire [255:0]    core_rq_tdata_o
+   ,output wire            core_rq_tvalid_o
+   ,output wire [61:0]     core_rq_tuser_o
+   ,output wire            core_rq_tlast_o
+   ,output wire [7:0]      core_rq_tkeep_o
+   ,input wire [3:0]       core_rq_tready_i
+   // RC Interface
+   ,input  wire [255:0]   core_rc_tdata_i
+   ,input  wire           core_rc_tvalid_i
+   ,input  wire [74:0]    core_rc_tuser_i
+   ,input  wire           core_rc_tlast_i
+   ,input  wire [7:0]     core_rc_tkeep_i
+   ,output wire [21:0]     core_rc_tready_o
+   // Completion delivered indications
+   ,output wire [1:0]      compl_delivered_o // Completions delivered to user
+                                            // 00 = No Compl, 01 = 1 Compl, 11 = 2 Completions
+   ,output wire [7:0]      compl_delivered_tag0_o// Tag associated with first delivered Completion
+   ,output wire [7:0]      compl_delivered_tag1_o// Tag associated with second delivered Completion
+   );
+
+  // CQ Module
+  xp4_usp_smsw_512b_cq_intfc #
+    (
+     .TCQ(TCQ),
+     .IMPL_TARGET(IMPL_TARGET),
+     .AXISTEN_IF_EXT_512_INTFC_RAM_STYLE(AXISTEN_IF_EXT_512_INTFC_RAM_STYLE),
+     .AXI4_USER_DATA_WIDTH(AXI4_USER_DATA_WIDTH),
+     .AXI4_CORE_DATA_WIDTH(AXI4_CORE_DATA_WIDTH),
+     .AXI4_USER_CQ_TUSER_WIDTH(AXI4_USER_CQ_TUSER_WIDTH),
+     .AXI4_CORE_CQ_TUSER_WIDTH(AXI4_CORE_CQ_TUSER_WIDTH),
+     .AXI4_USER_CQ_TKEEP_WIDTH(AXI4_USER_CQ_TKEEP_WIDTH),
+     .AXI4_CORE_CQ_TKEEP_WIDTH(AXI4_CORE_CQ_TKEEP_WIDTH),
+     .AXI4_CORE_CQ_TREADY_WIDTH(AXI4_CORE_CQ_TREADY_WIDTH),
+     .PARITY_ENABLE(1)
+     ) 
+    pcie_4_0_512b_cq_intfc_mod
+   (
+    .user_clk2_i        (user_clk2_i),
+    .user_clk_i         (user_clk_i),
+    .user_clk_en_i      (user_clk_en_i),
+    .reset_n_user_clk_i (reset_n_user_clk_i),
+    .reset_n_user_clk2_i(reset_n_user_clk2_i),
+    .link_down_reset_i  (link_down_reset_i),
+   // Attributes
+    .attr_straddle_en_i (attr_axisten_if_ext_512_cq_straddle_i),
+    .attr_alignment_mode_i(attr_axisten_if_cq_alignment_mode_i),
+   //-----------------------------------------------------------------------------------------------
+   // Client-side signals
+   //-----------------------------------------------------------------------------------------------
+    .m_axis_cq_tdata_o  (m_axis_cq_tdata_o),
+    .m_axis_cq_tvalid_o (m_axis_cq_tvalid_o),
+    .m_axis_cq_tuser_o  (m_axis_cq_tuser_o),
+    .m_axis_cq_tlast_o  (m_axis_cq_tlast_o),
+    .m_axis_cq_tkeep_o  (m_axis_cq_tkeep_o),
+    .m_axis_cq_tready_i (m_axis_cq_tready_i),
+    .pcie_cq_np_req_i   (pcie_cq_np_req_i), 
+    .pcie_cq_np_req_count_o(pcie_cq_np_req_count_o),
+   //-----------------------------------------------------------------------------------------------
+   // Core-side signals
+   //-----------------------------------------------------------------------------------------------
+    .core_cq_tdata_i    (core_cq_tdata_i),
+    .core_cq_tvalid_i   (core_cq_tvalid_i),
+    .core_cq_tuser_i    (core_cq_tuser_i),
+    .core_cq_tlast_i    (core_cq_tlast_i),
+    .core_cq_tkeep_i    (core_cq_tkeep_i),
+    .core_cq_tready_o   (core_cq_tready_o),
+    .posted_req_delivered_o(posted_req_delivered_o),
+    .cq_pipeline_empty_o(cq_pipeline_empty_o),
+    .cq_np_user_credit_rcvd_o(cq_np_user_credit_rcvd_o)
+    );
+  
+  // CC Module
+  xp4_usp_smsw_512b_cc_intfc #
+    (
+     .TCQ(TCQ),
+     .IMPL_TARGET(IMPL_TARGET),
+     .AXI4_USER_DATA_WIDTH(AXI4_USER_DATA_WIDTH),
+     .AXI4_CORE_DATA_WIDTH(AXI4_CORE_DATA_WIDTH),
+     .AXI4_USER_CC_TUSER_WIDTH(AXI4_USER_CC_TUSER_WIDTH),
+     .AXI4_CORE_CC_TUSER_WIDTH(AXI4_CORE_CC_TUSER_WIDTH),
+     .AXI4_USER_CC_TKEEP_WIDTH(AXI4_USER_CC_TKEEP_WIDTH),
+     .AXI4_CORE_CC_TKEEP_WIDTH(AXI4_CORE_CC_TKEEP_WIDTH),
+     .PARITY_ENABLE(1)
+     ) 
+    pcie_4_0_512b_cc_intfc_mod
+   (
+    .user_clk2_i        (user_clk2_i),
+    .user_clk_i         (user_clk_i),
+    .user_clk_en_i      (user_clk_en_i),
+    .reset_n_user_clk_i (reset_n_user_clk_i),
+    .reset_n_user_clk2_i(reset_n_user_clk2_i),
+    .link_down_reset_i  (link_down_reset_i),
+   // Attributes
+    .attr_straddle_en_i (attr_axisten_if_ext_512_cc_straddle_i),
+    .attr_alignment_mode_i(attr_axisten_if_cc_alignment_mode_i),
+    .attr_axisten_if_rq_cc_registered_tready_i(attr_axisten_if_rq_cc_registered_tready_i),
+   //-----------------------------------------------------------------------------------------------
+   // Client-side signals
+   //-----------------------------------------------------------------------------------------------
+    .s_axis_cc_tdata_i  (s_axis_cc_tdata_i),
+    .s_axis_cc_tvalid_i (s_axis_cc_tvalid_i),
+    .s_axis_cc_tuser_i  (s_axis_cc_tuser_i),
+    .s_axis_cc_tlast_i  (s_axis_cc_tlast_i),
+    .s_axis_cc_tkeep_i  (s_axis_cc_tkeep_i),
+    .s_axis_cc_tready_o (s_axis_cc_tready_o),   
+   //-----------------------------------------------------------------------------------------------
+   // Core-side signals
+   //-----------------------------------------------------------------------------------------------
+    .core_cc_tdata_o  (core_cc_tdata_o),
+    .core_cc_tvalid_o (core_cc_tvalid_o),
+    .core_cc_tuser_o  (core_cc_tuser_o),
+    .core_cc_tlast_o  (core_cc_tlast_o),
+    .core_cc_tkeep_o  (core_cc_tkeep_o),
+    .core_cc_tready_i (core_cc_tready_i)
+    );
+
+  // RQ Module
+  xp4_usp_smsw_512b_rq_intfc #
+    (
+     .TCQ(TCQ),
+     .IMPL_TARGET(IMPL_TARGET),
+     .AXI4_USER_DATA_WIDTH(AXI4_USER_DATA_WIDTH),
+     .AXI4_CORE_DATA_WIDTH(AXI4_CORE_DATA_WIDTH),
+     .AXI4_USER_RQ_TUSER_WIDTH(AXI4_USER_RQ_TUSER_WIDTH),
+     .AXI4_CORE_RQ_TUSER_WIDTH(AXI4_CORE_RQ_TUSER_WIDTH),
+     .AXI4_USER_RQ_TKEEP_WIDTH(AXI4_USER_RQ_TKEEP_WIDTH),
+     .AXI4_CORE_RQ_TKEEP_WIDTH(AXI4_CORE_RQ_TKEEP_WIDTH),
+     .PARITY_ENABLE(1)
+     ) 
+    pcie_4_0_512b_rq_intfc_mod
+   (
+    .user_clk2_i        (user_clk2_i),
+    .user_clk_i         (user_clk_i),
+    .user_clk_en_i      (user_clk_en_i),
+    .reset_n_user_clk_i (reset_n_user_clk_i),
+    .reset_n_user_clk2_i(reset_n_user_clk2_i),
+    .link_down_reset_i  (link_down_reset_i),
+   // Attributes
+    .attr_straddle_en_i (attr_axisten_if_ext_512_rq_straddle_i),
+    .attr_alignment_mode_i(attr_axisten_if_rq_alignment_mode_i),
+    .attr_axisten_if_rq_cc_registered_tready_i(attr_axisten_if_rq_cc_registered_tready_i),
+   //-----------------------------------------------------------------------------------------------
+   // Client-side signals
+   //-----------------------------------------------------------------------------------------------
+    .s_axis_rq_tdata_i  (s_axis_rq_tdata_i),
+    .s_axis_rq_tvalid_i (s_axis_rq_tvalid_i),
+    .s_axis_rq_tuser_i  (s_axis_rq_tuser_i),
+    .s_axis_rq_tlast_i  (s_axis_rq_tlast_i),
+    .s_axis_rq_tkeep_i  (s_axis_rq_tkeep_i),
+    .s_axis_rq_tready_o (s_axis_rq_tready_o),   
+   //-----------------------------------------------------------------------------------------------
+   // Core-side signals
+   //-----------------------------------------------------------------------------------------------
+    .core_rq_tdata_o  (core_rq_tdata_o),
+    .core_rq_tvalid_o (core_rq_tvalid_o),
+    .core_rq_tuser_o  (core_rq_tuser_o),
+    .core_rq_tlast_o  (core_rq_tlast_o),
+    .core_rq_tkeep_o  (core_rq_tkeep_o),
+    .core_rq_tready_i  (core_rq_tready_i)
+    );
+
+  // RC Module
+  xp4_usp_smsw_512b_rc_intfc #
+    (
+     .TCQ(TCQ),
+     .IMPL_TARGET(IMPL_TARGET),
+     .AXI4_USER_DATA_WIDTH(AXI4_USER_DATA_WIDTH),
+     .AXI4_CORE_DATA_WIDTH(AXI4_CORE_DATA_WIDTH),
+     .AXI4_USER_RC_TUSER_WIDTH(AXI4_USER_RC_TUSER_WIDTH),
+     .AXI4_CORE_RC_TUSER_WIDTH(AXI4_CORE_RC_TUSER_WIDTH),
+     .AXI4_USER_RC_TKEEP_WIDTH(AXI4_USER_RC_TKEEP_WIDTH),
+     .AXI4_CORE_RC_TKEEP_WIDTH(AXI4_CORE_RC_TKEEP_WIDTH),
+     .AXI4_CORE_RC_TREADY_WIDTH(AXI4_CORE_RC_TREADY_WIDTH),
+     .PARITY_ENABLE(1)
+     ) 
+    pcie_4_0_512b_rc_intfc_mod
+   (
+    .user_clk2_i        (user_clk2_i),
+    .user_clk_i         (user_clk_i),
+    .user_clk_en_i      (user_clk_en_i),
+    .reset_n_user_clk_i (reset_n_user_clk_i),
+    .reset_n_user_clk2_i(reset_n_user_clk2_i),
+    .link_down_reset_i  (link_down_reset_i),
+   // Attributes
+    .attr_straddle_en_i (attr_axisten_if_ext_512_rc_straddle_i),
+    .attr_4tlp_straddle_en_i (attr_axisten_if_ext_512_rc_4tlp_straddle_i),
+    .attr_alignment_mode_i(attr_axisten_if_rc_alignment_mode_i),
+   //-----------------------------------------------------------------------------------------------
+   // Client-side signals
+   //-----------------------------------------------------------------------------------------------
+    .m_axis_rc_tdata_o  (m_axis_rc_tdata_o),
+    .m_axis_rc_tvalid_o (m_axis_rc_tvalid_o),
+    .m_axis_rc_tuser_o  (m_axis_rc_tuser_o),
+    .m_axis_rc_tlast_o  (m_axis_rc_tlast_o),
+    .m_axis_rc_tkeep_o  (m_axis_rc_tkeep_o),
+    .m_axis_rc_tready_i (m_axis_rc_tready_i),
+   //-----------------------------------------------------------------------------------------------
+   // Core-side signals
+   //-----------------------------------------------------------------------------------------------
+    .core_rc_tdata_i    (core_rc_tdata_i),
+    .core_rc_tvalid_i   (core_rc_tvalid_i),
+    .core_rc_tuser_i    (core_rc_tuser_i),
+    .core_rc_tlast_i    (core_rc_tlast_i),
+    .core_rc_tkeep_i    (core_rc_tkeep_i),
+    .core_rc_tready_o   (core_rc_tready_o),
+   // Completion delivered indications
+    .compl_delivered_o  (compl_delivered_o),
+    .compl_delivered_tag0_o(compl_delivered_tag0_o),
+    .compl_delivered_tag1_o(compl_delivered_tag1_o)
+    );
+
+endmodule // pcie_4_0_512b_intfc_int
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2023 AMD, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD, Inc. and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : UltraScale+ FPGA PCI Express v4.0 Integrated Block
+// File       : xp4_usp_smsw_512b_async_fifo.v
+// Version    : 1.1 
+//-----------------------------------------------------------------------------
+//--------------------------------------------------------------------------------------------------
+`timescale 1ps/1ps
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_512b_async_fifo #(
+   parameter TCQ = 100,
+   parameter IMPL_TARGET = "SOFT",
+   parameter IN_DATA_WIDTH = 512,
+   parameter FIFO_WIDTH = 256,
+   parameter FIFO_DEPTH = 16,
+   parameter FIFO_ALMOST_FULL_THRESHOLD = 7
+   ) 
+  (
+   // Write side
+    input  wire           clk_i // clock
+   ,input  wire           clk_en_i // clock enable, valid in alternate cycles
+   ,input  wire           reset_n_i // Reset 
+   ,input  wire           link_down_reset_i // Reset FIFO on link down
+   ,input wire [IN_DATA_WIDTH-1:0] write_data_i
+   ,input wire [1:0]       write_en_i
+   ,output wire            fifo_almost_full_o
+   // Read side
+   ,input                 read_en_i
+   ,output wire [FIFO_WIDTH-1:0] read_data_o
+   ,output wire           read_data_valid_o
+   );
+   
+  reg [3:0]    read_ptr;
+  reg [3:0]    fifo_occupancy;
+  reg            fifo_empty;
+
+  integer    i;
+
+  reg [FIFO_WIDTH-1:0]  ram_array[FIFO_DEPTH-1:0];
+  reg [FIFO_WIDTH-1:0]     write_data_reg;
+  reg             write_data_valid_reg;
+
+  // Convert input data to core clock domain by registering it.
+  // Serialize writes of lower and upper halves.
+  
+  always @(posedge clk_i)
+    if (~reset_n_i)
+      write_data_reg <= #TCQ {FIFO_WIDTH{1'b0}};
+    else
+      begin
+    if (~clk_en_i & write_en_i[0])
+      write_data_reg[FIFO_WIDTH-1:0] <= #TCQ write_data_i[IN_DATA_WIDTH/2-1:0];
+    else if (clk_en_i & write_en_i[1])
+      write_data_reg[FIFO_WIDTH-1:0] <= #TCQ write_data_i[IN_DATA_WIDTH-1:IN_DATA_WIDTH/2];
+      end
+
+  always @(posedge clk_i)
+    if (~reset_n_i)
+      write_data_valid_reg <= #TCQ 1'b0;
+    else
+      begin
+    if (~clk_en_i)
+      write_data_valid_reg <= #TCQ  write_en_i[0];
+    else
+      write_data_valid_reg <= #TCQ  write_en_i[1];
+      end
+
+  // synthesis translate_off
+  initial
+  begin
+    for (i=0; i < FIFO_WIDTH; i=i+1)
+      begin
+    ram_array[i] = 0;
+      end
+  end
+  // synthesis translate_on
+
+  //Write to SRL inputs, and shift SRL
+  always @(posedge clk_i)
+    if (write_data_valid_reg)
+      begin
+    for (i= (FIFO_DEPTH-1); i>0; i=i-1)
+      ram_array[i] <= #TCQ ram_array[i-1];
+     ram_array[0]   <= #TCQ write_data_reg[FIFO_WIDTH-1:0];
+      end
+    
+   // Read pointer
+   always @(posedge clk_i)
+     if (~reset_n_i)
+       read_ptr <= #(TCQ) 4'd0;
+     else if (link_down_reset_i)
+       read_ptr <= #(TCQ) 4'd0;
+     else if ((read_en_i & ~fifo_empty) &
+          (~write_data_valid_reg))
+       // Read but no write in this cycle
+       begin
+     if (read_ptr != 4'd0)
+       read_ptr <= #TCQ read_ptr - 4'd1;
+       end
+       else if (~(read_en_i & ~fifo_empty) &
+          write_data_valid_reg)
+     // Write but no read in this cycle
+     begin
+       if (~fifo_empty)
+         read_ptr <= #TCQ read_ptr + 4'd1;
+     end
+  
+   // Maintain FIFO occupancy
+   always @(posedge clk_i)
+     if (~reset_n_i)
+       begin
+     fifo_occupancy <= #TCQ 4'd0;
+     fifo_empty <= #TCQ 1'b1;
+       end
+     else if (link_down_reset_i)
+       begin
+     fifo_occupancy <= #TCQ 4'd0;
+     fifo_empty <= #TCQ 1'b1;
+       end
+     else if ((read_en_i & ~fifo_empty) &
+          (~write_data_valid_reg))
+       // Read but no write in this cycle
+       begin
+     fifo_occupancy <= #TCQ fifo_occupancy - 4'd1;
+     fifo_empty <= #TCQ (fifo_occupancy == 4'd1);
+       end
+     else if (~(read_en_i & ~fifo_empty) &
+          write_data_valid_reg)
+       // Write but no read in this cycle
+       begin
+     fifo_occupancy <= #TCQ fifo_occupancy + 4'd1;
+     fifo_empty <= #TCQ 1'b0;
+       end
+  
+  assign fifo_almost_full_o = (fifo_occupancy >= FIFO_ALMOST_FULL_THRESHOLD);
+
+   assign    read_data_o = ram_array[read_ptr[3:0]];
+   assign    read_data_valid_o = ~fifo_empty;
+
+endmodule // pcie_4_0_512b_async_fifo
+
+
+
+
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2023 AMD, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD, Inc. and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : UltraScale+ FPGA PCI Express v4.0 Integrated Block
+// File       : xp4_usp_smsw_512b_cc_intfc.v
+// Version    : 1.1 
+//-----------------------------------------------------------------------------
+//--------------------------------------------------------------------------------------------------
+`timescale 1ps/1ps
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_512b_cc_intfc #(
+   parameter TCQ = 100,
+   parameter IMPL_TARGET = "SOFT",
+   parameter AXI4_USER_DATA_WIDTH = 512,
+   parameter AXI4_CORE_DATA_WIDTH = 256,
+   parameter AXI4_USER_CC_TUSER_WIDTH = 81,
+   parameter AXI4_CORE_CC_TUSER_WIDTH = 33,
+   parameter AXI4_USER_CC_TKEEP_WIDTH = 16,
+   parameter AXI4_CORE_CC_TKEEP_WIDTH = 8,
+   parameter AXI4_CORE_CC_TREADY_WIDTH = 4,
+   parameter PARITY_ENABLE = 0
+   ) 
+  (
+    input  wire           user_clk2_i // 500 MHz clock for core-facing interfaces
+   ,input  wire           user_clk_i // 250 MHz clock for client-facing interfaces
+   ,input  wire           user_clk_en_i // User clock enable for clock domain crossing
+   ,input  wire           reset_n_user_clk_i // Reset in the user clock domain
+   ,input  wire           reset_n_user_clk2_i // Reset in the user clock2 domain
+   ,input  wire           link_down_reset_i // Link went down
+   // Attributes
+   ,input  wire           attr_straddle_en_i // Enable straddle
+   ,input wire [1:0]      attr_alignment_mode_i // Payload alignment mode
+                                                // (00= Dword-aligned, 10 = 128b address-aligned)
+   ,input wire            attr_axisten_if_rq_cc_registered_tready_i // 0 = registered_tready enabled, 1 = registered_tready disabled
+   //-----------------------------------------------------------------------------------------------
+   // Client-side signals
+   //-----------------------------------------------------------------------------------------------
+   ,input wire [AXI4_USER_DATA_WIDTH-1:0]    s_axis_cc_tdata_i
+   ,input wire            s_axis_cc_tvalid_i
+   ,input wire [AXI4_USER_CC_TUSER_WIDTH-1:0]     s_axis_cc_tuser_i
+   ,input wire            s_axis_cc_tlast_i
+   ,input wire [AXI4_USER_CC_TKEEP_WIDTH-1:0]     s_axis_cc_tkeep_i
+   ,output reg            s_axis_cc_tready_o   
+   //-----------------------------------------------------------------------------------------------
+   // Core-side signals
+   //-----------------------------------------------------------------------------------------------
+   ,output wire [AXI4_CORE_DATA_WIDTH-1:0]    core_cc_tdata_o
+   ,output wire            core_cc_tvalid_o
+   ,output wire [AXI4_CORE_CC_TUSER_WIDTH-1:0]   core_cc_tuser_o
+   ,output wire            core_cc_tlast_o
+   ,output wire [AXI4_CORE_CC_TKEEP_WIDTH-1:0]   core_cc_tkeep_o
+   ,input wire [AXI4_CORE_CC_TREADY_WIDTH-1:0] core_cc_tready_i
+   );
+
+   localparam FIFO_IN_DATA_WIDTH = AXI4_USER_DATA_WIDTH + AXI4_USER_CC_TKEEP_WIDTH + AXI4_CORE_CC_TUSER_WIDTH*2 +
+                   2;
+   localparam FIFO_OUT_DATA_WIDTH = FIFO_IN_DATA_WIDTH/2;
+
+   localparam OUTPUT_MUX_IN_DATA_WIDTH = AXI4_CORE_DATA_WIDTH + AXI4_CORE_CC_TKEEP_WIDTH + AXI4_CORE_CC_TUSER_WIDTH + 1;
+
+   reg [AXI4_USER_DATA_WIDTH-1:0] s_axis_cc_tdata_reg;
+   reg                   s_axis_cc_tvalid_reg_lower;
+   reg                   s_axis_cc_tvalid_reg_upper;
+   reg [AXI4_USER_CC_TKEEP_WIDTH-1:0] s_axis_cc_tkeep_reg;
+   reg                       s_axis_cc_tlast_reg_lower;
+   reg                       s_axis_cc_tlast_reg_upper;
+   reg [AXI4_USER_CC_TUSER_WIDTH-1:0] s_axis_cc_tuser_reg;
+
+   wire [1:0]                   s_axis_cc_sop;
+   wire [1:0]                   s_axis_cc_eop;
+   wire [1:0]                   s_axis_cc_sop0_ptr;
+   wire [3:0]                   s_axis_cc_eop0_ptr;
+   wire [3:0]                   s_axis_cc_eop1_ptr;
+   wire [63:0]                   s_axis_cc_parity;
+
+   wire [AXI4_CORE_CC_TUSER_WIDTH*2-1:0] fifo_in_data_tuser;
+   wire [1:0]                  fifo_in_data_tlast;
+
+  wire [FIFO_IN_DATA_WIDTH-1:0]      fifo_in_data;
+   wire [1:0]                 fifo_in_data_valid;
+   wire                  fifo_almost_full_user_clk;
+
+   reg                      s_axis_cc_tuser_discontinue_reg_lower;
+   reg                      s_axis_cc_tuser_discontinue_reg_upper;
+
+  wire [FIFO_OUT_DATA_WIDTH-1:0]      fifo_read_data;
+   wire                  fifo_read_data_valid;
+   wire                  output_mux_ready;
+
+  reg [AXI4_CORE_CC_TREADY_WIDTH-1:0]      core_cc_tready_reg;
+  wire [AXI4_CORE_CC_TREADY_WIDTH-1:0]      core_cc_tready_int;
+
+   // Register input data
+
+  assign                  s_axis_cc_sop[1:0] =  s_axis_cc_tuser_i[1:0];
+  assign                  s_axis_cc_sop0_ptr[1:0] =  s_axis_cc_tuser_i[3:2];
+  assign                  s_axis_cc_eop[1:0] =  s_axis_cc_tuser_i[7:6];
+  assign                  s_axis_cc_eop0_ptr[3:0] =  s_axis_cc_tuser_i[11:8];
+  assign                  s_axis_cc_eop1_ptr[3:0] =  s_axis_cc_tuser_i[15:12];
+
+   always @(posedge user_clk_i)
+     if (~reset_n_user_clk_i)
+       begin
+      s_axis_cc_tdata_reg <= {AXI4_USER_DATA_WIDTH{1'b0}};
+      s_axis_cc_tvalid_reg_lower <= 1'b0;
+      s_axis_cc_tvalid_reg_upper <= 1'b0;
+      s_axis_cc_tkeep_reg <= {AXI4_USER_CC_TKEEP_WIDTH{1'b0}};
+      s_axis_cc_tuser_reg <= {AXI4_USER_CC_TUSER_WIDTH{1'b0}};
+     s_axis_cc_tuser_discontinue_reg_lower <= 1'b0;
+     s_axis_cc_tuser_discontinue_reg_upper <= 1'b0;
+     s_axis_cc_tlast_reg_lower <= 1'b0;
+     s_axis_cc_tlast_reg_upper <= 1'b0;
+       end
+     else
+       begin
+      s_axis_cc_tdata_reg <= s_axis_cc_tdata_i;
+      s_axis_cc_tvalid_reg_lower <= s_axis_cc_tvalid_i & s_axis_cc_tready_o;
+      s_axis_cc_tvalid_reg_upper <= attr_straddle_en_i? s_axis_cc_tvalid_i & s_axis_cc_tready_o &
+                    (~s_axis_cc_eop[0] | s_axis_cc_eop0_ptr[3] |
+                     (s_axis_cc_sop[0] & s_axis_cc_sop0_ptr[1]) |
+                     s_axis_cc_sop[1]):
+                    s_axis_cc_tvalid_i & s_axis_cc_tready_o &
+                    (~s_axis_cc_tlast_i | s_axis_cc_tkeep_i[8]);
+     // Generate tkeep settings for core side
+     if (~attr_straddle_en_i)
+       s_axis_cc_tkeep_reg[7:0] <= s_axis_cc_tkeep_i[7:0];
+     else if (s_axis_cc_tvalid_i & s_axis_cc_tready_o)
+       begin
+         if (~s_axis_cc_eop[0] | s_axis_cc_eop0_ptr[3])
+           s_axis_cc_tkeep_reg[7:0] <= 8'hff;
+         else
+           case(s_axis_cc_eop0_ptr[2:0])
+         3'd0: s_axis_cc_tkeep_reg[7:0] <= 8'h01;
+         3'd1: s_axis_cc_tkeep_reg[7:0] <= 8'h03;
+         3'd2: s_axis_cc_tkeep_reg[7:0] <= 8'h07;
+         3'd3: s_axis_cc_tkeep_reg[7:0] <= 8'h0f;
+         3'd4: s_axis_cc_tkeep_reg[7:0] <= 8'h1f;
+         3'd5: s_axis_cc_tkeep_reg[7:0] <= 8'h3f;
+         3'd6: s_axis_cc_tkeep_reg[7:0] <= 8'h7f;
+         default: s_axis_cc_tkeep_reg[7:0] <= 8'hff;
+           endcase // case(s_axis_cc_eop0_ptr[2:0])
+       end // if (s_axis_cc_tvalid_i & s_axis_cc_tready_o)
+     else
+       s_axis_cc_tkeep_reg[7:0] <= 8'd0;
+         
+     if (~attr_straddle_en_i)
+       s_axis_cc_tkeep_reg[15:8] <= s_axis_cc_tkeep_i[15:8];
+     else if (s_axis_cc_tvalid_i & s_axis_cc_tready_o)
+       begin
+         if (~s_axis_cc_eop[0])
+           s_axis_cc_tkeep_reg[15:8] <= 8'hff;
+         else if (s_axis_cc_eop0_ptr[3])
+           case(s_axis_cc_eop0_ptr[2:0])
+         3'd0: s_axis_cc_tkeep_reg[15:8] <= 8'h01;
+         3'd1: s_axis_cc_tkeep_reg[15:8] <= 8'h03;
+         3'd2: s_axis_cc_tkeep_reg[15:8] <= 8'h07;
+         3'd3: s_axis_cc_tkeep_reg[15:8] <= 8'h0f;
+         3'd4: s_axis_cc_tkeep_reg[15:8] <= 8'h1f;
+         3'd5: s_axis_cc_tkeep_reg[15:8] <= 8'h3f;
+         3'd6: s_axis_cc_tkeep_reg[15:8] <= 8'h7f;
+         default: s_axis_cc_tkeep_reg[15:8] <= 8'hff;
+           endcase // case(s_axis_cc_eop0_ptr[2:0])
+         else if ((s_axis_cc_sop[0] && (s_axis_cc_sop0_ptr[1]))||
+              s_axis_cc_sop[1])
+           // Packet starting in second half
+           begin
+         if (~s_axis_cc_eop[1])
+           s_axis_cc_tkeep_reg[15:8] <= 8'hff;
+         else
+           case(s_axis_cc_eop1_ptr[2:0])
+             3'd2: s_axis_cc_tkeep_reg[15:8] <= 8'h07;
+             3'd3: s_axis_cc_tkeep_reg[15:8] <= 8'h0f;
+             3'd4: s_axis_cc_tkeep_reg[15:8] <= 8'h1f;
+             3'd5: s_axis_cc_tkeep_reg[15:8] <= 8'h3f;
+             3'd6: s_axis_cc_tkeep_reg[15:8] <= 8'h7f;
+             default: s_axis_cc_tkeep_reg[15:8] <= 8'hff;
+           endcase // case(s_axis_cc_eop1_ptr[2:0])
+           end // if ((s_axis_cc_sop[0] && (s_axis_cc_sop0_ptr[1]))||...
+         else
+           s_axis_cc_tkeep_reg[15:8] <= 8'd0;
+       end // if (s_axis_cc_tvalid_i & s_axis_cc_tready_o)
+     else
+       s_axis_cc_tkeep_reg[15:8] <= 8'd0;
+
+      s_axis_cc_tuser_reg <= s_axis_cc_tuser_i;
+     // Generate discontinue for lower and upper halves
+     if (~attr_straddle_en_i) 
+       begin
+         s_axis_cc_tuser_discontinue_reg_lower <= s_axis_cc_tuser_i[16] &
+                              (~s_axis_cc_tlast_i |
+                               ~s_axis_cc_tkeep_i[8]);
+         s_axis_cc_tuser_discontinue_reg_upper <= s_axis_cc_tuser_i[16] &
+                              (~s_axis_cc_tlast_i |
+                               s_axis_cc_tkeep_i[8]);
+       end // if (~attr_straddle_en_i)
+     else
+       begin
+         s_axis_cc_tuser_discontinue_reg_lower <= s_axis_cc_tuser_i[16] &
+                              (~s_axis_cc_eop[0] |
+                               ~s_axis_cc_eop0_ptr[3]);
+         s_axis_cc_tuser_discontinue_reg_upper <= s_axis_cc_tuser_i[16] &
+                              (~s_axis_cc_eop[0] |
+                               s_axis_cc_eop0_ptr[3]);
+       end // else: !if(~attr_straddle_en_i)
+
+     // Generate tlast for lower and upper halves
+     s_axis_cc_tlast_reg_lower <= attr_straddle_en_i? (s_axis_cc_eop[0] & ~s_axis_cc_eop0_ptr[3]):
+                      s_axis_cc_tlast_i & ~s_axis_cc_tkeep_i[8];
+     s_axis_cc_tlast_reg_upper <= attr_straddle_en_i? (s_axis_cc_eop[0] & s_axis_cc_eop0_ptr[3]) |
+                      s_axis_cc_eop[1]:
+                      s_axis_cc_tlast_i & s_axis_cc_tkeep_i[8];
+       end // else: !if(~reset_n_user_clk_i)
+
+  assign  s_axis_cc_parity[63:0] =  PARITY_ENABLE? s_axis_cc_tuser_reg[80:17] : 64'd0;
+
+   // Generate the tuser signals for the core side
+   // discontinue
+  assign  fifo_in_data_tuser[0] = s_axis_cc_tuser_discontinue_reg_lower;
+  assign  fifo_in_data_tuser[AXI4_CORE_CC_TUSER_WIDTH+0] = s_axis_cc_tuser_discontinue_reg_upper;
+   // parity
+   assign fifo_in_data_tuser[32:1] = s_axis_cc_parity[31:0];
+   assign fifo_in_data_tuser[AXI4_CORE_CC_TUSER_WIDTH+32:AXI4_CORE_CC_TUSER_WIDTH+1] = s_axis_cc_parity[63:32];
+   
+   // Generate tlast for lower and upper halves
+  assign fifo_in_data_tlast[0] = s_axis_cc_tlast_reg_lower;
+  assign fifo_in_data_tlast[1] = s_axis_cc_tlast_reg_upper;
+   
+   // Generate valid for upper half
+  assign fifo_in_data_valid[0] = s_axis_cc_tvalid_reg_lower;
+  assign fifo_in_data_valid[1] = s_axis_cc_tvalid_reg_upper;
+
+   assign fifo_in_data[AXI4_CORE_DATA_WIDTH-1:0] = s_axis_cc_tdata_reg[AXI4_CORE_DATA_WIDTH-1:0];
+   assign fifo_in_data[FIFO_IN_DATA_WIDTH/2+AXI4_CORE_DATA_WIDTH-1:FIFO_IN_DATA_WIDTH/2] =
+      s_axis_cc_tdata_reg[AXI4_CORE_DATA_WIDTH*2-1:AXI4_CORE_DATA_WIDTH];
+
+   assign fifo_in_data[AXI4_CORE_DATA_WIDTH + AXI4_CORE_CC_TKEEP_WIDTH-1: AXI4_CORE_DATA_WIDTH] =
+      s_axis_cc_tkeep_reg[AXI4_CORE_CC_TKEEP_WIDTH-1:0];
+  assign  fifo_in_data[FIFO_IN_DATA_WIDTH/2 + AXI4_CORE_DATA_WIDTH + AXI4_CORE_CC_TKEEP_WIDTH-1:
+               FIFO_IN_DATA_WIDTH/2 + AXI4_CORE_DATA_WIDTH] =
+      s_axis_cc_tkeep_reg[AXI4_CORE_CC_TKEEP_WIDTH*2-1:AXI4_CORE_CC_TKEEP_WIDTH];
+
+   assign fifo_in_data[AXI4_CORE_DATA_WIDTH + AXI4_CORE_CC_TKEEP_WIDTH +  AXI4_CORE_CC_TUSER_WIDTH-1:
+               AXI4_CORE_DATA_WIDTH + AXI4_CORE_CC_TKEEP_WIDTH] = 
+      fifo_in_data_tuser[AXI4_CORE_CC_TUSER_WIDTH-1:0];
+   assign fifo_in_data[FIFO_IN_DATA_WIDTH/2 + AXI4_CORE_DATA_WIDTH + AXI4_CORE_CC_TKEEP_WIDTH +  AXI4_CORE_CC_TUSER_WIDTH-1:
+               FIFO_IN_DATA_WIDTH/2 + AXI4_CORE_DATA_WIDTH + AXI4_CORE_CC_TKEEP_WIDTH] = 
+      fifo_in_data_tuser[AXI4_CORE_CC_TUSER_WIDTH*2-1:AXI4_CORE_CC_TUSER_WIDTH];
+
+   assign fifo_in_data[AXI4_CORE_DATA_WIDTH + AXI4_CORE_CC_TKEEP_WIDTH +  AXI4_CORE_CC_TUSER_WIDTH] =
+      fifo_in_data_tlast[0];
+   assign fifo_in_data[FIFO_IN_DATA_WIDTH/2 + AXI4_CORE_DATA_WIDTH + AXI4_CORE_CC_TKEEP_WIDTH +  AXI4_CORE_CC_TUSER_WIDTH] =
+      fifo_in_data_tlast[1];
+
+   // De-assert ready when FIFO is almost full
+   always @(posedge user_clk_i)
+     if (~reset_n_user_clk_i)
+       s_axis_cc_tready_o <= 1'b0;
+     else
+       s_axis_cc_tready_o <= #(TCQ) ~fifo_almost_full_user_clk;
+
+  // Register tready from hard block
+   always @(posedge user_clk2_i)
+     if (~reset_n_user_clk2_i)
+       core_cc_tready_reg <= {AXI4_CORE_CC_TREADY_WIDTH{1'b0}};
+     else
+       core_cc_tready_reg <= core_cc_tready_i;
+
+  assign  core_cc_tready_int = attr_axisten_if_rq_cc_registered_tready_i?
+      core_cc_tready_reg : core_cc_tready_i;
+
+   // Async FIFO
+   xp4_usp_smsw_512b_async_fifo #
+     (
+      .TCQ(TCQ),
+      .IMPL_TARGET(IMPL_TARGET),
+      .IN_DATA_WIDTH(FIFO_IN_DATA_WIDTH),
+      .FIFO_WIDTH(FIFO_OUT_DATA_WIDTH),
+      .FIFO_DEPTH(16),
+      .FIFO_ALMOST_FULL_THRESHOLD(7)
+      )
+     pcie_4_0_512b_async_fifo_blk
+       (
+    // Write side
+    .clk_i(user_clk2_i),
+    .clk_en_i(user_clk_en_i),
+        .reset_n_i(reset_n_user_clk2_i),
+        .link_down_reset_i(link_down_reset_i),
+    .write_data_i(fifo_in_data),
+    .write_en_i(fifo_in_data_valid),
+    .fifo_almost_full_o(fifo_almost_full_user_clk),
+    // Read side
+    .read_en_i(output_mux_ready),
+    .read_data_o(fifo_read_data),
+    .read_data_valid_o(fifo_read_data_valid)
+    );
+
+   // Instance of output MUX
+   xp4_usp_smsw_512b_cc_output_mux #
+     (
+      .TCQ(TCQ),
+      .IMPL_TARGET(IMPL_TARGET),
+      .IN_DATA_WIDTH(OUTPUT_MUX_IN_DATA_WIDTH),
+      .OUT_DATA_WIDTH(AXI4_CORE_DATA_WIDTH),
+      .TUSER_WIDTH(AXI4_CORE_CC_TUSER_WIDTH),
+      .TKEEP_WIDTH(AXI4_CORE_CC_TKEEP_WIDTH),
+      .TREADY_WIDTH(AXI4_CORE_CC_TREADY_WIDTH)
+      )
+     pcie_4_0_512b_cc_output_mux_blk
+       (
+        .clk_i(user_clk2_i),
+        .reset_n_i(reset_n_user_clk2_i),
+        .link_down_reset_i(link_down_reset_i),
+    .in_data_i(fifo_read_data),
+    .in_data_valid_i(fifo_read_data_valid),
+    .upstream_ready_o(output_mux_ready),
+
+    .out_data_o(core_cc_tdata_o),
+        .out_data_valid_o(core_cc_tvalid_o),
+    .out_tuser_o(core_cc_tuser_o),
+    .out_tlast_o(core_cc_tlast_o),
+    .out_tkeep_o(core_cc_tkeep_o),
+    .downstream_ready_i(core_cc_tready_int)
+    );
+
+
+endmodule // pcie4_0_512b_cc_intfc
+
+
+
+
+
+
+
+   
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2023 AMD, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD, Inc. and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : UltraScale+ FPGA PCI Express v4.0 Integrated Block
+// File       : xp4_usp_smsw_512b_cc_output_mux.v
+// Version    : 1.1 
+//-----------------------------------------------------------------------------
+//--------------------------------------------------------------------------------------------------
+`timescale 1ps/1ps
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_512b_cc_output_mux #(
+   parameter TCQ = 100,
+   parameter IMPL_TARGET = "SOFT",
+   parameter IN_DATA_WIDTH = 256+33+8+1,    
+   parameter OUT_DATA_WIDTH = 256,
+   parameter TUSER_WIDTH = 33,
+   parameter TKEEP_WIDTH = 8,
+   parameter TREADY_WIDTH = 4
+   )
+  (
+    input  wire           clk_i // 500 MHz clock for core-facing interfaces
+   ,input  wire           reset_n_i // Reset in the user clock domain
+   ,input  wire           link_down_reset_i // Link went down
+
+   ,input wire[IN_DATA_WIDTH-1:0] in_data_i
+   ,input wire in_data_valid_i
+   ,output wire upstream_ready_o
+
+   ,output reg [OUT_DATA_WIDTH-1:0]  out_data_o
+   ,output reg           out_data_valid_o
+   ,output reg [TUSER_WIDTH-1:0] out_tuser_o
+   ,output reg          out_tlast_o
+   ,output reg [TKEEP_WIDTH-1:0] out_tkeep_o
+   ,input  wire [TREADY_WIDTH-1:0]  downstream_ready_i
+   );
+
+
+   reg [1:0] output_fifo_occupancy;
+  reg          output_fifo_write_ptr;
+  reg          output_fifo_read_ptr;
+   wire      output_fifo_full;
+   wire      output_fifo_empty;
+
+   reg [OUT_DATA_WIDTH-1:0] m_axis_cc_tdata_first_reg;
+   reg [TKEEP_WIDTH-1:0]    m_axis_cc_tkeep_first_reg;
+   reg [TUSER_WIDTH-1:0]    m_axis_cc_tuser_first_reg;
+   reg                 m_axis_cc_tlast_first_reg;
+   
+   reg [OUT_DATA_WIDTH-1:0] m_axis_cc_tdata_second_reg;
+   reg [TKEEP_WIDTH-1:0]    m_axis_cc_tkeep_second_reg;
+   reg [TUSER_WIDTH-1:0]    m_axis_cc_tuser_second_reg;
+   reg                 m_axis_cc_tlast_second_reg;
+   
+   wire             output_reg_mux_sel;
+   //---------------------------------------------------------------------------------------------
+   // Output FIFO.
+   // The main FIFO feeds into two read registers in the core clock domain, which are configured
+   // as a 2-entry FIFO.
+   // This can be thought of as logical extensions of the main FIFO.
+   //---------------------------------------------------------------------------------------------
+
+   assign    upstream_ready_o = ~output_fifo_full;
+
+   // Maintain write and read pointers
+   always @(posedge clk_i)
+     if (~reset_n_i)
+       output_fifo_write_ptr <= #(TCQ)  1'b0;
+     else if (link_down_reset_i)
+       output_fifo_write_ptr <= #(TCQ)  1'b0;
+     else
+       if (in_data_valid_i & ~output_fifo_full)
+     output_fifo_write_ptr <= #(TCQ) ~output_fifo_write_ptr;
+   
+   always @(posedge clk_i)
+     if (~reset_n_i)
+       output_fifo_read_ptr <= #(TCQ) 2'd0;
+     else if (link_down_reset_i)
+       output_fifo_read_ptr <= #(TCQ) 2'd0;
+     else
+       if ((downstream_ready_i[3] | ~out_data_valid_o) &
+       ~output_fifo_empty)
+     output_fifo_read_ptr <= #(TCQ) ~output_fifo_read_ptr;
+
+      // Maintain FIFO occupancy
+   always @(posedge clk_i)
+     if (~reset_n_i)
+       output_fifo_occupancy <= #(TCQ)  2'd0;
+     else if (link_down_reset_i)
+       output_fifo_occupancy <= #(TCQ)  2'd0;
+     else
+       if ((in_data_valid_i & ~output_fifo_full) &
+       ~((downstream_ready_i[3] | ~out_data_valid_o) &
+         ~output_fifo_empty))
+     output_fifo_occupancy <= #(TCQ) output_fifo_occupancy + 2'd1;
+       else
+     if (~(in_data_valid_i & ~output_fifo_full) &
+         ((downstream_ready_i[3] | ~out_data_valid_o) &
+          ~output_fifo_empty))
+       output_fifo_occupancy <= #(TCQ) output_fifo_occupancy - 2'd1;
+   
+   assign output_fifo_full = output_fifo_occupancy[1];
+   assign output_fifo_empty = (output_fifo_occupancy == 2'b00);
+
+   // Write data into the Output registers
+   always @(posedge clk_i)
+     if (~reset_n_i)
+       begin
+          m_axis_cc_tdata_first_reg <= #(TCQ) {OUT_DATA_WIDTH{1'b0}};
+          m_axis_cc_tdata_second_reg <= #(TCQ) {OUT_DATA_WIDTH{1'b0}};
+          m_axis_cc_tkeep_first_reg <= #(TCQ) {TKEEP_WIDTH{1'b0}};
+          m_axis_cc_tkeep_second_reg <= #(TCQ) {TKEEP_WIDTH{1'b0}};
+          m_axis_cc_tuser_first_reg <= #(TCQ) {TUSER_WIDTH{1'b0}};
+          m_axis_cc_tuser_second_reg <= #(TCQ) {TUSER_WIDTH{1'b0}};
+          m_axis_cc_tlast_first_reg <= #(TCQ) 1'b0;
+          m_axis_cc_tlast_second_reg <= #(TCQ) 1'b0;
+       end
+     else
+        if (in_data_valid_i & ~output_fifo_full)
+      begin
+        case(output_fifo_write_ptr)
+          1'b0:
+         begin
+            m_axis_cc_tdata_first_reg <= #(TCQ) in_data_i[OUT_DATA_WIDTH-1:0];
+            m_axis_cc_tkeep_first_reg <= #(TCQ) in_data_i[OUT_DATA_WIDTH+TKEEP_WIDTH-1:OUT_DATA_WIDTH];
+            m_axis_cc_tuser_first_reg <= #(TCQ) in_data_i[OUT_DATA_WIDTH+TKEEP_WIDTH+TUSER_WIDTH-1:OUT_DATA_WIDTH+TKEEP_WIDTH];
+            m_axis_cc_tlast_first_reg <= #(TCQ) in_data_i[IN_DATA_WIDTH-1];
+         end
+           default:
+         begin
+            m_axis_cc_tdata_second_reg <= #(TCQ) in_data_i[OUT_DATA_WIDTH-1:0];
+            m_axis_cc_tkeep_second_reg <= #(TCQ) in_data_i[OUT_DATA_WIDTH+TKEEP_WIDTH-1:OUT_DATA_WIDTH];
+            m_axis_cc_tuser_second_reg <= #(TCQ) in_data_i[OUT_DATA_WIDTH+TKEEP_WIDTH+TUSER_WIDTH-1:OUT_DATA_WIDTH+TKEEP_WIDTH];
+            m_axis_cc_tlast_second_reg <= #(TCQ) in_data_i[IN_DATA_WIDTH-1];
+         end
+         endcase // case(output_fifo_write_ptr)
+        end // if (in_data_valid_i & ~output_fifo_full)
+   
+   // Output registers
+
+   assign output_reg_mux_sel = output_fifo_read_ptr;
+
+   always @(posedge clk_i)
+     if (~reset_n_i)
+       begin
+      out_data_o <= #(TCQ)  {OUT_DATA_WIDTH{1'b0}};
+      out_tuser_o <= #(TCQ)  {TUSER_WIDTH{1'b0}};
+      out_tkeep_o <= #(TCQ)  {TKEEP_WIDTH{1'b0}};
+      out_tlast_o <= #(TCQ)  1'b0;
+       end
+     else
+       begin
+      if (~out_data_valid_o | downstream_ready_i[0])
+        begin
+           case(output_reg_mux_sel)
+         1'b0:
+           begin
+              out_data_o[127:0] <= #(TCQ)  m_axis_cc_tdata_first_reg[127:0];
+           end
+         default:
+           begin
+              out_data_o[127:0] <= #(TCQ)  m_axis_cc_tdata_second_reg[127:0];
+           end
+           endcase // case(output_reg_mux_sel)
+        end // if (~out_data_valid_o | downstream_ready_i[0])
+
+      if (~out_data_valid_o | downstream_ready_i[1])
+        begin
+           case(output_reg_mux_sel)
+         1'b0:
+           begin
+              out_data_o[255:128] <= #(TCQ)  m_axis_cc_tdata_first_reg[255:128];
+           end
+         default:
+           begin
+              out_data_o[255:128] <= #(TCQ)  m_axis_cc_tdata_second_reg[255:128];
+           end
+           endcase // case(output_reg_mux_sel)
+        end // if (~out_data_valid_o | downstream_ready_i[1])
+      
+      if (~out_data_valid_o | downstream_ready_i[2])
+        begin
+           case(output_reg_mux_sel)
+         1'b0:
+           begin
+              out_tuser_o <= #(TCQ)  m_axis_cc_tuser_first_reg;
+           end
+         default:
+           begin
+              out_tuser_o <= #(TCQ)  m_axis_cc_tuser_second_reg;
+           end
+           endcase // case(output_reg_mux_sel)
+        end // if (~out_data_valid_o | downstream_ready_i[2])
+      
+      if (~out_data_valid_o | downstream_ready_i[3])
+        begin
+           case(output_reg_mux_sel)
+         1'b0:         
+           begin
+              out_tkeep_o <= #(TCQ)  m_axis_cc_tkeep_first_reg;
+              out_tlast_o <= #(TCQ)  m_axis_cc_tlast_first_reg;
+           end
+         default:
+           begin
+              out_tkeep_o <= #(TCQ)  m_axis_cc_tkeep_second_reg;
+              out_tlast_o <= #(TCQ)  m_axis_cc_tlast_second_reg;
+           end
+           endcase // case(output_reg_mux_sel)
+        end // if (~out_data_valid_o | downstream_ready_i[3])
+       end // else: !if(~reset_n_i)
+
+   always @(posedge clk_i)
+     if (~reset_n_i)
+       out_data_valid_o <= #(TCQ) 1'b0;
+     else
+       if (~out_data_valid_o | downstream_ready_i[0])
+     out_data_valid_o <= #(TCQ) ~output_fifo_empty;
+
+endmodule // pcie_4_0_512b_cc_output_mux
+
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2023 AMD, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD, Inc. and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : UltraScale+ FPGA PCI Express v4.0 Integrated Block
+// File       : xp4_usp_smsw_512b_cq_intfc.v
+// Version    : 1.1 
+//-----------------------------------------------------------------------------
+//--------------------------------------------------------------------------------------------------
+`timescale 1ps/1ps
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_512b_cq_intfc #(
+   parameter TCQ = 100,
+   parameter IMPL_TARGET = "SOFT",
+   parameter AXISTEN_IF_EXT_512_INTFC_RAM_STYLE = "SRL",
+   parameter AXI4_USER_DATA_WIDTH = 512,
+   parameter AXI4_CORE_DATA_WIDTH = 256,
+   parameter AXI4_USER_CQ_TUSER_WIDTH = 183,
+   parameter AXI4_CORE_CQ_TUSER_WIDTH = 88,
+   parameter AXI4_USER_CQ_TKEEP_WIDTH = 16,
+   parameter AXI4_CORE_CQ_TKEEP_WIDTH = 8,
+   parameter AXI4_CORE_CQ_TREADY_WIDTH = 22,
+   parameter PARITY_ENABLE = 0
+   ) 
+  (
+    input  wire           user_clk2_i // 500 MHz clock for core-facing interfaces
+   ,input  wire           user_clk_i // 250 MHz clock for client-facing interfaces
+   ,input  wire           user_clk_en_i // User clock enable for clock domain crossing
+   ,input  wire           reset_n_user_clk_i // Reset in the user clock domain
+   ,input  wire           reset_n_user_clk2_i // Reset in the user clock2 domain
+   ,input  wire           link_down_reset_i // Link went down
+   // Attributes
+   ,input  wire           attr_straddle_en_i // Enable straddle
+   ,input wire [1:0]      attr_alignment_mode_i // Payload alignment mode
+                                                // (00= Dword-aligned, 10 = 128b address-aligned)
+   //-----------------------------------------------------------------------------------------------
+   // Client-side signals
+   //-----------------------------------------------------------------------------------------------
+   ,output wire [AXI4_USER_DATA_WIDTH-1:0]   m_axis_cq_tdata_o
+   ,output wire           m_axis_cq_tvalid_o
+   ,output wire [AXI4_USER_CQ_TUSER_WIDTH-1:0]   m_axis_cq_tuser_o
+   ,output wire           m_axis_cq_tlast_o
+   ,output wire [AXI4_USER_CQ_TKEEP_WIDTH-1:0]    m_axis_cq_tkeep_o
+   ,input  wire           m_axis_cq_tready_i
+   ,input  wire [1:0]     pcie_cq_np_req_i // Client request to deliver NP TLP
+   ,output wire [5:0]     pcie_cq_np_req_count_o // Current value of interface credit count for NP TLPs
+   //-----------------------------------------------------------------------------------------------
+   // Core-side signals
+   //-----------------------------------------------------------------------------------------------
+   ,input  wire [AXI4_CORE_DATA_WIDTH-1:0] core_cq_tdata_i
+   ,input  wire           core_cq_tvalid_i
+   ,input  wire [AXI4_CORE_CQ_TUSER_WIDTH-1:0] core_cq_tuser_i
+   ,input  wire           core_cq_tlast_i
+   ,input  wire [AXI4_CORE_CQ_TKEEP_WIDTH-1:0] core_cq_tkeep_i
+   ,output wire [AXI4_CORE_CQ_TREADY_WIDTH-1:0] core_cq_tready_o
+   ,output reg            posted_req_delivered_o // Signals the delivery of a Posted Req on the CQ interface
+   ,output reg            cq_pipeline_empty_o // Indicates that the entire CQ pipeline of the bridge is empty.
+   ,output reg            cq_np_user_credit_rcvd_o // Indicates that the user issued one NP credit
+   );
+
+   localparam FIFO_WIDTH = PARITY_ENABLE? (AXI4_CORE_DATA_WIDTH + AXI4_CORE_CQ_TUSER_WIDTH + 
+                       AXI4_CORE_CQ_TKEEP_WIDTH + 1)*2 +2 :
+               (AXI4_CORE_DATA_WIDTH + AXI4_CORE_CQ_TUSER_WIDTH + 
+                AXI4_CORE_CQ_TKEEP_WIDTH + 1)*2 +2 -64;
+
+   localparam TUSER_LOWER_OFFSET = AXI4_CORE_DATA_WIDTH + AXI4_CORE_CQ_TKEEP_WIDTH;
+   localparam TUSER_UPPER_OFFSET = PARITY_ENABLE? AXI4_CORE_DATA_WIDTH*2 + AXI4_CORE_CQ_TKEEP_WIDTH*2 +
+                   AXI4_CORE_CQ_TUSER_WIDTH +2:
+                   AXI4_CORE_DATA_WIDTH*2 + AXI4_CORE_CQ_TKEEP_WIDTH*2 +
+                   AXI4_CORE_CQ_TUSER_WIDTH +2 -32;
+   
+  localparam FIFO_READ_DATA_UPPER_OFFSET = PARITY_ENABLE?
+                   AXI4_CORE_DATA_WIDTH + AXI4_CORE_CQ_TKEEP_WIDTH + AXI4_CORE_CQ_TUSER_WIDTH +2:
+                   AXI4_CORE_DATA_WIDTH + AXI4_CORE_CQ_TKEEP_WIDTH + AXI4_CORE_CQ_TUSER_WIDTH +2 -32;
+  
+  localparam FIFO_READ_TKEEP_UPPER_OFFSET = PARITY_ENABLE?
+                    AXI4_CORE_DATA_WIDTH*2 + AXI4_CORE_CQ_TKEEP_WIDTH + AXI4_CORE_CQ_TUSER_WIDTH +2:
+                                    AXI4_CORE_DATA_WIDTH*2 + AXI4_CORE_CQ_TKEEP_WIDTH + AXI4_CORE_CQ_TUSER_WIDTH +2 -32;
+
+   localparam OUTPUT_MUX_IN_DATA_WIDTH = AXI4_USER_DATA_WIDTH +
+                     AXI4_USER_CQ_TKEEP_WIDTH +
+                     AXI4_USER_CQ_TUSER_WIDTH + 1;
+
+   (* KEEP = "true" *) reg [AXI4_CORE_CQ_TREADY_WIDTH-1:0] core_cq_tready_reg;
+   (* KEEP = "true" *) reg core_cq_tready_user_clk2;
+
+   reg [AXI4_CORE_DATA_WIDTH-1:0] core_cq_tdata_reg_upper;
+   reg [AXI4_CORE_DATA_WIDTH-1:0] core_cq_tdata_reg_lower;
+   reg [AXI4_CORE_CQ_TUSER_WIDTH-1:0] core_cq_tuser_reg_upper;
+   reg [AXI4_CORE_CQ_TUSER_WIDTH-1:0] core_cq_tuser_reg_lower;
+   reg                       core_cq_tlast_reg_upper;
+   reg                       core_cq_tlast_reg_lower;
+   reg [AXI4_CORE_CQ_TKEEP_WIDTH-1:0] core_cq_tkeep_reg_upper;
+   reg [AXI4_CORE_CQ_TKEEP_WIDTH-1:0] core_cq_tkeep_reg_lower;
+   reg                       core_cq_tvalid_reg_upper;
+   reg                       core_cq_tvalid_reg_lower;
+
+   wire                   fifo_almost_full_user_clk;
+
+   wire [FIFO_WIDTH-1:0]           fifo_in_data;
+   reg [FIFO_WIDTH-1:0]           fifo_in_data_reg;
+   reg                       fifo_in_data_valid_reg;
+   reg                       fifo_read_en;
+   wire                   fifo_read_data_valid;
+   wire [FIFO_WIDTH-1:0]           fifo_read_data;
+
+   wire [3:0]                   read_first_be_lower;
+   wire [3:0]                   read_last_be_lower;
+   wire [31:0]                   read_byte_en_lower;
+   wire                   read_sop_lower;
+   wire                   read_discontinue_lower;
+   wire                   read_tph_present_lower;
+   wire [1:0]                   read_tph_type_lower;
+   wire [7:0]                   read_tph_st_tag_lower;
+   wire [2:0]                   read_eop_ptr_lower;
+   wire                   read_tlast_lower;
+   wire                   read_tlast_upper;
+   wire                   read_data_valid_lower;
+   wire                   read_data_valid_upper;
+
+   wire [3:0]                   read_first_be_upper;
+   wire [3:0]                   read_last_be_upper;
+   wire [31:0]                   read_byte_en_upper;
+   wire                   read_sop_upper;
+   wire                   read_discontinue_upper;
+   wire                   read_tph_present_upper;
+   wire [1:0]                   read_tph_type_upper;
+   wire [7:0]                   read_tph_st_tag_upper;
+   wire [2:0]                   read_eop_ptr_upper;
+
+   reg [1:0]                   read_data_valid_reg;
+   reg [FIFO_WIDTH-1:0]           read_data_reg;
+   reg [FIFO_WIDTH/2-1:0]           saved_data_reg;
+   reg                       saved_eop;
+   reg                       saved_err;
+   
+   wire [3:0]                   read_data_reg_first_be_lower;
+   wire [3:0]                   read_data_reg_last_be_lower;
+   wire [31:0]                   read_data_reg_byte_en_lower;
+   wire                    read_data_reg_sop_lower;
+   wire                    read_data_reg_discontinue_lower;
+   wire                    read_data_reg_tph_present_lower;
+   wire [1:0]                   read_data_reg_tph_type_lower;
+   wire [7:0]                   read_data_reg_tph_st_tag_lower;
+   wire [31:0]                   read_data_reg_parity_lower;
+   wire [2:0]                   read_data_reg_eop_ptr_lower;
+   wire [3:0]                   read_data_reg_first_be_upper;
+   wire [3:0]                   read_data_reg_last_be_upper;
+   wire [31:0]                   read_data_reg_byte_en_upper;
+   wire                    read_data_reg_sop_upper;
+   wire                    read_data_reg_discontinue_upper;
+   wire                    read_data_reg_tph_present_upper;
+   wire [1:0]                   read_data_reg_tph_type_upper;
+   wire [7:0]                   read_data_reg_tph_st_tag_upper;
+   wire [31:0]                   read_data_reg_parity_upper;
+   wire [2:0]                   read_data_reg_eop_ptr_upper;
+  wire                       read_data_reg_tlast_lower;
+  wire                       read_data_reg_tlast_upper;
+   wire                   sop_in_lower_half;
+   wire                   sop_in_upper_half;
+   wire                   eop_in_lower_half;
+   wire                   eop_in_upper_half;
+
+   wire [7:0]                   read_data_out_first_be;
+   wire [7:0]                   read_data_out_last_be;
+   wire [63:0]                   read_data_out_byte_en;
+   wire [1:0]                   read_data_out_is_sop;
+   wire [1:0]                   read_data_out_is_sop0_ptr;
+   wire [1:0]                   read_data_out_is_sop1_ptr;
+   wire [1:0]                   read_data_out_is_eop;
+   wire [3:0]                   read_data_out_is_eop0_ptr;
+   wire [3:0]                   read_data_out_is_eop1_ptr;
+   wire                   read_data_out_discontinue;
+   wire [1:0]                   read_data_out_tph_present;
+   wire [3:0]                   read_data_out_tph_type;
+   wire [15:0]                   read_data_out_tph_st_tag;
+   wire [63:0]                   read_data_out_parity;
+   
+   wire [ AXI4_USER_CQ_TUSER_WIDTH-1:0] read_data_out_tuser;
+   wire [ AXI4_USER_DATA_WIDTH-1:0]     read_data_out_tdata;
+   wire [ AXI4_USER_CQ_TKEEP_WIDTH-1:0] read_data_out_tkeep;
+   wire                 read_data_out_tlast;
+   
+   wire [OUTPUT_MUX_IN_DATA_WIDTH-1:0]     output_mux_in_data;
+
+   wire                 output_mux_ready;
+   
+   wire [1:0]                 cq_np_user_credit_rcvd_user_clk;
+   wire [1:0]                 posted_req_delivered_user_clk;
+
+   wire                 pipeline_empty_user_clk;
+   wire                 out_mux_pipeline_empty;
+   reg                     pipeline_empty_core_clk;
+   reg [2:0]                 cq_pipeline_empty_reg;
+
+   // Read State Machine states
+   localparam                           IDLE = 2'd0;
+   localparam                           EXPECT_NEW_WORD = 2'd1;
+   localparam                           SEND_SAVED_HALF_WORD = 2'd2;
+   localparam                           WAIT_FOR_UPPER_HALF = 2'd3;
+   reg [1:0]                 read_state;
+
+   // Capture incoming data from core at 500 MHz into upper and lower registers
+   always @(posedge user_clk2_i)
+     if (~reset_n_user_clk2_i)
+       begin
+      core_cq_tdata_reg_upper <= #TCQ {AXI4_CORE_DATA_WIDTH{1'b0}};
+      core_cq_tdata_reg_lower <= #TCQ {AXI4_CORE_DATA_WIDTH{1'b0}};
+      core_cq_tuser_reg_upper <= #TCQ {AXI4_CORE_CQ_TUSER_WIDTH{1'b0}};
+      core_cq_tuser_reg_lower <= #TCQ {AXI4_CORE_CQ_TUSER_WIDTH{1'b0}};
+      core_cq_tkeep_reg_upper <= #TCQ {AXI4_CORE_CQ_TKEEP_WIDTH{1'b0}};
+      core_cq_tkeep_reg_lower <= #TCQ {AXI4_CORE_CQ_TKEEP_WIDTH{1'b0}};
+      core_cq_tlast_reg_upper <= #TCQ 1'b0;
+      core_cq_tlast_reg_lower <= #TCQ 1'b0;
+       core_cq_tvalid_reg_upper <= #TCQ 1'b0;
+      core_cq_tvalid_reg_lower <= #TCQ 1'b0;
+       end // if (~reset_n_user_clk_i)
+     else
+       if (user_clk_en_i)
+     begin
+        core_cq_tdata_reg_lower <= #TCQ core_cq_tdata_i;
+        core_cq_tuser_reg_lower <= #TCQ core_cq_tuser_i;
+        core_cq_tkeep_reg_lower <= #TCQ core_cq_tkeep_i;
+        core_cq_tlast_reg_lower <= #TCQ core_cq_tlast_i;
+        core_cq_tvalid_reg_lower <= #TCQ core_cq_tvalid_i & core_cq_tready_user_clk2;
+     end
+       else
+     begin
+        core_cq_tdata_reg_upper <= #TCQ core_cq_tdata_i;
+        core_cq_tuser_reg_upper <= #TCQ core_cq_tuser_i;
+        core_cq_tkeep_reg_upper <= #TCQ core_cq_tkeep_i;
+        core_cq_tlast_reg_upper <= #TCQ core_cq_tlast_i;
+        core_cq_tvalid_reg_upper <= #TCQ core_cq_tvalid_i & core_cq_tready_user_clk2;
+     end // else: !if(user_clk_en_i)
+
+   // Write data into FIFO using 250 MHz user_clk
+
+  generate
+    if (PARITY_ENABLE)
+      assign fifo_in_data =
+          {
+       core_cq_tvalid_reg_upper,
+       core_cq_tlast_reg_upper,
+       core_cq_tuser_reg_upper,
+       core_cq_tkeep_reg_upper,
+       core_cq_tdata_reg_upper,
+       core_cq_tvalid_reg_lower,
+       core_cq_tlast_reg_lower,
+       core_cq_tuser_reg_lower,
+       core_cq_tkeep_reg_lower,
+       core_cq_tdata_reg_lower
+       };
+    else
+      assign fifo_in_data =
+          {
+       core_cq_tvalid_reg_upper,
+       core_cq_tlast_reg_upper,
+       core_cq_tuser_reg_upper[87:85],
+       core_cq_tuser_reg_upper[52:0],
+       core_cq_tkeep_reg_upper,
+       core_cq_tdata_reg_upper,
+       core_cq_tvalid_reg_lower,
+       core_cq_tlast_reg_lower,
+       core_cq_tuser_reg_lower[87:85],
+       core_cq_tuser_reg_lower[52:0],
+       core_cq_tkeep_reg_lower,
+       core_cq_tdata_reg_lower
+       };
+  endgenerate
+
+   always @(posedge user_clk_i)
+     if (~reset_n_user_clk_i)
+       begin
+      fifo_in_data_reg <= #TCQ {FIFO_WIDTH{1'b0}};      
+      fifo_in_data_valid_reg <= #TCQ 1'b0;
+       end
+     else
+       begin
+      fifo_in_data_reg <= #TCQ fifo_in_data;
+         fifo_in_data_valid_reg <= #TCQ (core_cq_tvalid_reg_lower |
+                     core_cq_tvalid_reg_upper);
+       end // else: !if(~reset_n_user_clk_i)
+
+   // Generate ready to core in the user_clk2 domain
+   always @(posedge user_clk2_i)
+     if (~reset_n_user_clk2_i)
+       begin
+      core_cq_tready_user_clk2 <= #TCQ 1'b0;
+      core_cq_tready_reg <= #TCQ {AXI4_CORE_CQ_TREADY_WIDTH{1'b0}};
+       end
+     else
+       begin
+             core_cq_tready_user_clk2 <= #TCQ ~fifo_almost_full_user_clk;
+      core_cq_tready_reg <= #TCQ {AXI4_CORE_CQ_TREADY_WIDTH{~fifo_almost_full_user_clk}};
+       end
+
+   assign core_cq_tready_o = core_cq_tready_reg;
+   
+   // Main FIFO instance
+   xp4_usp_smsw_512b_sync_fifo #
+     (
+      .TCQ(TCQ),
+      .IMPL_TARGET(IMPL_TARGET),
+      .AXISTEN_IF_EXT_512_INTFC_RAM_STYLE(AXISTEN_IF_EXT_512_INTFC_RAM_STYLE),
+      .FIFO_WIDTH(FIFO_WIDTH),
+      .FIFO_DEPTH(8),
+      .FIFO_ALMOST_FULL_THRESHOLD(5)
+      )
+     pcie_4_0_512b_sync_fifo_blk
+       (
+        .clk_i(user_clk_i),
+        .reset_n_i(reset_n_user_clk_i),
+        .link_down_reset_i(link_down_reset_i),
+    .write_data_i(fifo_in_data_reg),
+    .write_en_i(fifo_in_data_valid_reg),
+    .read_en_i(fifo_read_en),
+    .read_data_o(fifo_read_data),
+    .read_data_valid_o(fifo_read_data_valid),
+    .fifo_almost_full(fifo_almost_full_user_clk)
+    );
+   
+   // Read-side logic
+   
+   assign read_first_be_lower = fifo_read_data[TUSER_LOWER_OFFSET +3:
+                           TUSER_LOWER_OFFSET];
+   assign read_last_be_lower = fifo_read_data[TUSER_LOWER_OFFSET +7:
+                          TUSER_LOWER_OFFSET +4];
+   assign read_byte_en_lower = fifo_read_data[TUSER_LOWER_OFFSET +39:
+                             TUSER_LOWER_OFFSET +8];
+   assign read_sop_lower = fifo_read_data[TUSER_LOWER_OFFSET + 40];
+   assign read_discontinue_lower = fifo_read_data[TUSER_LOWER_OFFSET + 41];
+   assign read_tph_present_lower = fifo_read_data[TUSER_LOWER_OFFSET + 42];  
+   assign read_tph_type_lower = fifo_read_data[TUSER_LOWER_OFFSET + 44:
+                        TUSER_LOWER_OFFSET + 43];
+   assign read_tph_st_tag_lower = fifo_read_data[TUSER_LOWER_OFFSET + 52:   
+                            TUSER_LOWER_OFFSET + 45];
+  generate
+    if (PARITY_ENABLE)
+      assign read_eop_ptr_lower = fifo_read_data[TUSER_LOWER_OFFSET + 87:
+                         TUSER_LOWER_OFFSET + 85];
+    else
+      assign read_eop_ptr_lower = fifo_read_data[TUSER_LOWER_OFFSET + 55:
+                         TUSER_LOWER_OFFSET + 53];
+  endgenerate
+
+
+  assign     read_first_be_upper = fifo_read_data[TUSER_UPPER_OFFSET +3:
+                           TUSER_UPPER_OFFSET];
+   assign read_last_be_upper = fifo_read_data[TUSER_UPPER_OFFSET +7:
+                          TUSER_UPPER_OFFSET +4];
+   assign read_byte_en_upper = fifo_read_data[TUSER_UPPER_OFFSET +39:
+                             TUSER_UPPER_OFFSET +8];
+   assign read_sop_upper = fifo_read_data[TUSER_UPPER_OFFSET + 40];
+   assign read_discontinue_upper = fifo_read_data[TUSER_UPPER_OFFSET + 41];
+   assign read_tph_present_upper = fifo_read_data[TUSER_UPPER_OFFSET + 42];  
+   assign read_tph_type_upper = fifo_read_data[TUSER_UPPER_OFFSET + 44:
+                        TUSER_UPPER_OFFSET + 43];
+   assign read_tph_st_tag_upper = fifo_read_data[TUSER_UPPER_OFFSET + 52:   
+                            TUSER_UPPER_OFFSET + 45];
+  generate
+    if (PARITY_ENABLE)
+      assign read_eop_ptr_upper = fifo_read_data[TUSER_UPPER_OFFSET + 87:
+                         TUSER_UPPER_OFFSET + 85];
+    else
+      assign read_eop_ptr_upper = fifo_read_data[TUSER_UPPER_OFFSET + 55:
+                           TUSER_UPPER_OFFSET + 53];
+  endgenerate
+
+  generate
+    if (PARITY_ENABLE)
+      begin
+    assign     read_tlast_lower = fifo_read_data[AXI4_CORE_DATA_WIDTH + AXI4_CORE_CQ_TKEEP_WIDTH +
+                             AXI4_CORE_CQ_TUSER_WIDTH];
+    assign     read_tlast_upper = fifo_read_data[AXI4_CORE_DATA_WIDTH*2 + AXI4_CORE_CQ_TKEEP_WIDTH*2 +
+                             AXI4_CORE_CQ_TUSER_WIDTH*2 +2];
+      end
+    else
+      begin
+    assign     read_tlast_lower = fifo_read_data[AXI4_CORE_DATA_WIDTH + AXI4_CORE_CQ_TKEEP_WIDTH +
+                             AXI4_CORE_CQ_TUSER_WIDTH -32];
+    assign     read_tlast_upper = fifo_read_data[AXI4_CORE_DATA_WIDTH*2 + AXI4_CORE_CQ_TKEEP_WIDTH*2 +
+                             AXI4_CORE_CQ_TUSER_WIDTH*2 +2 -64];
+      end // else: !if(PARITY_ENABLE)
+  endgenerate
+
+    assign        read_data_valid_lower = fifo_read_data[FIFO_WIDTH/2-1] & fifo_read_data_valid;
+    assign        read_data_valid_upper = fifo_read_data[FIFO_WIDTH-1] & fifo_read_data_valid;
+
+
+   // Read State Machine States
+   //
+   // IDLE: Currently not forwarding a packet.  Read data register is either empty, or contains the last beat of a packet.
+   // EXPECT_NEW_WORD: Currently forwarding a packet, and there is no data saved from a previous beat
+   // SEND_SAVED_HALF_WORD: There is a half-word saved from a previous beat in the saved data register.
+   // WAIT_FOR_UPPER_HALF: There is a half-word saved from a previous beat in the read data register which does not end with an EOP.
+   
+   always @(posedge user_clk_i)
+     if (~reset_n_user_clk_i)
+       begin
+      read_data_valid_reg <= #TCQ 2'b00;
+      read_state <= #TCQ IDLE;
+       end
+     else if (link_down_reset_i)
+       begin
+      read_data_valid_reg <= #TCQ 2'b00;
+      read_state <= #TCQ IDLE;
+       end
+     else
+    case(read_state)
+      IDLE:
+        begin
+           // IDLE: Currently not forwarding a packet.  Read data register is either empty, or contains the last beat of a packet.
+           if ((read_data_valid_reg == 2'b00) | output_mux_ready)
+         begin
+            if (read_data_valid_lower)
+              // New TLP starting in the lower half of the incoming word.
+              // Update the lower half of the data register with the lower half of the incoming word.
+              begin
+             if (read_data_valid_upper)
+               // Both halves of the incoming word have valid data in them.
+               begin
+                  // If straddle is not enabled and the packet in the upper half is a new one,
+                  // Save it for next cycle.
+                  // Also, if the packet in the lower half ends with an error, do not fill the upper half.
+                  if ((~attr_straddle_en_i & read_sop_upper)|
+                  read_discontinue_lower)
+                begin
+                   read_data_valid_reg <= #TCQ 2'b01;
+                   read_state <= #TCQ SEND_SAVED_HALF_WORD;
+                end
+                  else
+                begin
+                   read_data_valid_reg <= #TCQ 2'b11;
+                   if (read_tlast_upper)
+                     read_state <= #TCQ IDLE;
+                   else
+                     read_state <= #TCQ EXPECT_NEW_WORD;
+                end // else: !if(~attr_straddle_en_i & read_sop_upper)
+               end // if (read_data_valid_upper)
+             else
+               begin
+                  // New TLP started in the lower half, but there is no valid data in the upper half.
+                  if (read_tlast_lower)
+                // We have a complete TLP in the lower half, send it.
+                begin
+                   read_data_valid_reg <= #TCQ 2'b01;
+                   read_state <= #TCQ IDLE;
+                end
+                  else
+                begin
+                   // Wait for more data to fill upper half of read data register.
+                   read_data_valid_reg <= #TCQ 2'b00;
+                   read_state <= #TCQ WAIT_FOR_UPPER_HALF;
+                end // else: !if(read_tlast_lower)
+               end // else: !if(read_data_valid_upper)
+              end // if (read_data_valid_lower)
+            else
+              if (read_data_valid_upper)
+            begin
+               // No valid data in the lower half of the incoming word, but there is a packet starting in the upper half.
+               if (read_tlast_upper)
+                 // We have a complete packet, send it in the lower half.
+                 begin
+                read_data_valid_reg <= #TCQ 2'b01;
+                read_state <= #TCQ IDLE;
+                 end
+               else
+                 begin
+                // Save the upper half of the incoming word
+                // and wait for more data.
+                read_data_valid_reg <= #TCQ 2'b00;
+                read_state <= #TCQ WAIT_FOR_UPPER_HALF;
+                 end // else: !if(read_tlast_upper)
+            end // if (read_data_valid_upper)
+              else
+            // No valid data from FIFO
+            begin
+               if (output_mux_ready)
+                 read_data_valid_reg <= #TCQ 2'b00;
+               read_state <= #TCQ IDLE;
+            end // else: !if(read_data_valid_upper)
+         end // if ((read_data_valid_reg == 2'b00) | output_mux_ready)
+        end // case: IDLE
+      
+      EXPECT_NEW_WORD:
+        begin
+           // Currently forwarding a packet.  There is no saved data.
+           if ((read_data_valid_reg == 2'b00) | output_mux_ready)
+         begin
+            if (read_data_valid_lower)
+              // New data starting in the lower half of the incoming word.
+              // Update the lower half of the data register with the lower half of the incoming word.
+              begin
+             if (read_data_valid_upper)
+               // Both halves of the incoming word have valid data in them.
+               begin
+                  // If straddle is not enabled and the packet in the upper half is a new one,
+                  // Save it for next cycle.
+                  // Also, if the packet in the lower half ends with an error, do not fill the upper half.
+                  if ((~attr_straddle_en_i & read_sop_upper)|
+                  read_discontinue_lower)
+                begin
+                   read_data_valid_reg <= #TCQ 2'b01;
+                   read_state <= #TCQ SEND_SAVED_HALF_WORD;
+                end
+                  else
+                begin
+                   read_data_valid_reg <= #TCQ 2'b11;
+                   if (read_tlast_upper)
+                     read_state <= #TCQ IDLE;
+                   else
+                     read_state <= #TCQ EXPECT_NEW_WORD;
+                end // else: !if(~attr_straddle_en_i & read_sop_upper)
+               end // if (read_data_valid_upper)
+             else
+               begin
+                  // Valid data in the lower half, but no valid data in the upper half.
+                  if (read_tlast_lower)
+                // We have the packet ending in the lower half, send it.
+                begin
+                   read_data_valid_reg <= #TCQ 2'b01;
+                   read_state <= #TCQ IDLE;
+                end
+                  else
+                begin
+                   // Wait for more data to fill upper half of read data register.
+                   read_data_valid_reg <= #TCQ 2'b00;
+                   read_state <= #TCQ WAIT_FOR_UPPER_HALF;
+                end // else: !if(read_tlast_lower)
+               end // else: !if(read_data_valid_upper)
+              end // if (read_data_valid_lower)
+            else
+              if (read_data_valid_upper)
+            begin
+               // No valid data in the lower half of the incoming word, but there is data in the upper half.
+               if (read_tlast_upper)
+                 // We have a complete packet, send it in the lower half.
+                 begin
+                read_data_valid_reg <= #TCQ 2'b01;
+                read_state <= #TCQ IDLE;
+                 end
+               else
+                 begin
+                // Save the upper half of the incoming word
+                // and wait for more data.
+                read_data_valid_reg <= #TCQ 2'b00;
+                read_state <= #TCQ WAIT_FOR_UPPER_HALF;
+                 end // else: !if(read_tlast_upper)
+            end // if (read_data_valid_upper)
+              else
+            // No valid data from FIFO
+            begin
+               if (output_mux_ready)
+                 read_data_valid_reg <= #TCQ 2'b00;
+               read_state <= #TCQ EXPECT_NEW_WORD;
+            end // else: !if(read_data_valid_upper)
+         end // if ((read_data_valid_reg == 2'b00) | output_mux_ready)
+        end // case: EXPECT_NEW_WORD
+
+      SEND_SAVED_HALF_WORD:
+        begin
+           // There is a half-word saved from a previous beat in the saved data register.
+           if ((read_data_valid_reg == 2'b00) | output_mux_ready)
+         begin
+            if ((~attr_straddle_en_i & saved_eop) | saved_err)
+              // Saved data is the last beat of a packet and straddle is disabled.
+              // Do not fill the upper half of read data register.
+              begin
+            read_data_valid_reg <= #TCQ 2'b01;
+            read_state <= #TCQ IDLE;
+              end
+            else
+              if (read_data_valid_lower)
+            // New data starting in the lower half of the incoming word.
+            // Update the upper half of the data register with the lower half of the incoming word.
+            begin
+               if (read_data_valid_upper)
+                 // Both halves of the incoming word have valid data in them.
+                 begin
+                read_data_valid_reg <= #TCQ 2'b11;
+                read_state <= #TCQ SEND_SAVED_HALF_WORD;
+                 end
+               else
+                 begin
+                read_data_valid_reg <= #TCQ 2'b11;
+                if (read_tlast_lower)
+                  read_state <= #TCQ IDLE;
+                else
+                  read_state <= #TCQ EXPECT_NEW_WORD;
+                 end // else: !if(read_data_valid_upper)
+            end // if (read_data_valid_lower)
+              else
+            if (read_data_valid_upper)
+              begin
+                 // No valid data in the lower half of the incoming word, but there is data in the upper half.
+                 if (read_tlast_upper)
+                   // We have a complete packet, send it in the upper half.
+                   begin
+                  read_data_valid_reg <= #TCQ 2'b11;
+                  read_state <= #TCQ IDLE;
+                   end
+                 else
+                   begin
+                  read_data_valid_reg <= #TCQ 2'b11;
+                  read_state <= #TCQ EXPECT_NEW_WORD;
+                   end // else: !if(read_tlast_upper)
+              end // if (read_data_valid_upper)
+            else
+              // No valid data from FIFO
+              begin
+                read_data_valid_reg <= #TCQ 2'b01;
+                read_state <= #TCQ IDLE;
+              end // else: !if(read_data_valid_upper)
+         end // if ((read_data_valid_reg == 2'b00) | output_mux_ready)
+        end // case: SEND_SAVED_HALF_WORD
+
+      WAIT_FOR_UPPER_HALF:
+        begin
+           // There is a half-word saved from a previous beat in the read data register which does not end with an EOP.
+           if ((read_data_valid_reg == 2'b00) | output_mux_ready)
+         begin
+            if (read_data_valid_lower)
+              // New data starting in the lower half of the incoming word.
+              // Update the upper half of the data register with the lower half of the incoming word.
+              begin
+             read_data_valid_reg <= #TCQ 2'b11;
+             if (read_data_valid_upper)
+               // Both halves of the incoming word have valid data in them.
+               begin
+                 if (read_tlast_upper)
+                   read_state <= #TCQ SEND_SAVED_HALF_WORD;
+                 else
+                   read_state <= #TCQ WAIT_FOR_UPPER_HALF;
+               end
+             else
+               begin
+                 if (read_tlast_lower)
+                   read_state <= #TCQ IDLE;
+                 else
+                   read_state <= #TCQ EXPECT_NEW_WORD;
+               end // else: !if(read_data_valid_upper)
+              end // if (read_data_valid_lower)
+            else
+              if (read_data_valid_upper)
+            begin
+               // No valid data in the lower half of the incoming word, but there is data in the upper half.
+               read_data_valid_reg <= #TCQ 2'b11;
+               if (read_tlast_upper)
+                 read_state <= #TCQ IDLE;
+               else
+                 read_state <= #TCQ EXPECT_NEW_WORD;
+            end // if (read_data_valid_upper)
+              else
+            begin
+               read_data_valid_reg <= #TCQ 2'b00;
+               read_state <= #TCQ WAIT_FOR_UPPER_HALF;
+            end // else: !if(read_data_valid_upper)
+         end // if ((read_data_valid_reg == 2'b00) | output_mux_ready)
+        end // case: WAIT_FOR_UPPER_HALF
+    endcase // case(read_state)
+
+   always @(posedge user_clk_i)
+     if (~reset_n_user_clk_i)
+       begin
+      read_data_reg <= #TCQ {FIFO_WIDTH{1'b0}};
+      saved_data_reg <= #TCQ {FIFO_WIDTH/2{1'b0}};
+      saved_eop <= #TCQ 1'b0;
+      saved_err <= #TCQ 1'b0;
+       end
+     else
+    case(read_state)
+      IDLE:
+        begin
+           // IDLE: Currently not forwarding a packet.  Read data register is either empty, or contains the last beat of a packet.
+           if ((read_data_valid_reg == 2'b00) | output_mux_ready)
+         begin
+            if (read_data_valid_lower)
+              read_data_reg[FIFO_WIDTH/2-1:0] <= #TCQ fifo_read_data[FIFO_WIDTH/2-1:0];
+            else
+              read_data_reg[FIFO_WIDTH/2-1:0] <= #TCQ fifo_read_data[FIFO_WIDTH-1: FIFO_WIDTH/2];
+            read_data_reg[FIFO_WIDTH-1: FIFO_WIDTH/2] <= #TCQ fifo_read_data[FIFO_WIDTH-1: FIFO_WIDTH/2];
+            saved_data_reg <= #TCQ fifo_read_data[FIFO_WIDTH-1:FIFO_WIDTH/2];
+            saved_eop <= #TCQ read_tlast_upper;
+            saved_err <= #TCQ read_discontinue_upper;
+         end
+        end // case: IDLE
+
+      EXPECT_NEW_WORD:
+        begin
+           // Currently not forwarding a packet.  
+           // Read data register is either empty, or contains the last beat of a packet.           
+           if ((read_data_valid_reg == 2'b00) | output_mux_ready)
+         begin
+            if (read_data_valid_lower)
+              read_data_reg[FIFO_WIDTH/2-1:0] <= #TCQ fifo_read_data[FIFO_WIDTH/2-1:0];
+            else
+              read_data_reg[FIFO_WIDTH/2-1:0] <= #TCQ fifo_read_data[FIFO_WIDTH-1: FIFO_WIDTH/2];
+            read_data_reg[FIFO_WIDTH-1: FIFO_WIDTH/2] <= #TCQ fifo_read_data[FIFO_WIDTH-1: FIFO_WIDTH/2];
+            saved_data_reg <= #TCQ fifo_read_data[FIFO_WIDTH-1:FIFO_WIDTH/2];
+            saved_eop <= #TCQ read_tlast_upper;
+            saved_err <= #TCQ read_discontinue_upper;
+         end
+        end // case: EXPECT_NEW_WORD
+      
+      SEND_SAVED_HALF_WORD:
+        begin
+           // There is a half-word saved from a previous beat in the saved data register.
+           if ((read_data_valid_reg == 2'b00) | output_mux_ready)
+         begin
+            read_data_reg[FIFO_WIDTH/2-1:0] <= #TCQ saved_data_reg[FIFO_WIDTH/2-1: 0];
+            if (read_data_valid_lower)
+              read_data_reg[FIFO_WIDTH-1: FIFO_WIDTH/2] <= #TCQ fifo_read_data[FIFO_WIDTH/2-1: 0];
+            else
+              read_data_reg[FIFO_WIDTH-1: FIFO_WIDTH/2] <= #TCQ fifo_read_data[FIFO_WIDTH-1: FIFO_WIDTH/2];
+            
+
+            if ((~attr_straddle_en_i & saved_eop) | saved_err)
+              // Save incoming data for next cycle.
+              begin
+             if (read_data_valid_lower)
+               begin
+                  saved_data_reg <= #TCQ fifo_read_data[FIFO_WIDTH/2-1: 0];
+                  saved_eop <= #TCQ read_tlast_lower;
+                  saved_err <= #TCQ read_discontinue_lower;
+               end
+             else
+               begin
+                  saved_data_reg <= #TCQ fifo_read_data[FIFO_WIDTH-1: FIFO_WIDTH/2];
+                  saved_eop <= #TCQ read_tlast_upper;
+                  saved_err <= #TCQ read_discontinue_upper;
+               end
+              end
+            else
+              begin
+             saved_data_reg <= #TCQ fifo_read_data[FIFO_WIDTH-1: FIFO_WIDTH/2];
+             saved_eop <= #TCQ read_tlast_upper;
+             saved_err <= #TCQ read_discontinue_upper;
+              end // else: !if((~attr_straddle_en_i & saved_eop) | saved_err)
+         end // if ((read_data_valid_reg == 2'b00) | output_mux_ready)
+        end // case: SEND_SAVED_HALF_WORD
+      WAIT_FOR_UPPER_HALF:
+        begin
+           // There is a half-word saved from a previous beat in the read data register which does not end with an EOP.
+           if ((read_data_valid_reg == 2'b00) | output_mux_ready)
+         begin
+           read_data_reg[FIFO_WIDTH/2-1:0] <= #TCQ saved_data_reg[FIFO_WIDTH/2-1:0];
+           if (read_data_valid_lower)
+             read_data_reg[FIFO_WIDTH-1: FIFO_WIDTH/2] <= #TCQ fifo_read_data[FIFO_WIDTH/2-1: 0];
+           else
+             read_data_reg[FIFO_WIDTH-1: FIFO_WIDTH/2] <= #TCQ {FIFO_WIDTH/2{1'b0}};
+             // Save incoming data for next cycle.
+           saved_data_reg <= #TCQ fifo_read_data[FIFO_WIDTH-1: FIFO_WIDTH/2];
+           saved_eop <= #TCQ read_tlast_upper;
+           saved_err <= #TCQ read_discontinue_upper;
+         end
+        end // case: WAIT_FOR_UPPER_HALF
+    endcase // case(read_state)
+         
+   // Generate upstream ready
+   always @(*)
+     begin
+    case(read_state)
+      IDLE:
+        begin
+           fifo_read_en = (read_data_valid_reg == 2'b00) | output_mux_ready;
+        end
+      
+      EXPECT_NEW_WORD:
+        begin
+           fifo_read_en = (read_data_valid_reg == 2'b00) | output_mux_ready;
+        end
+
+      SEND_SAVED_HALF_WORD:
+        begin
+           // There is a half-word saved from a previous beat in the saved data register.
+           if ((read_data_valid_reg == 2'b00) | output_mux_ready)
+         begin
+            if ((~attr_straddle_en_i & saved_eop) | saved_err)
+              // Saved data is the last beat of a packet and straddle is disabled.
+              // Do not fill the upper half of read data register.
+              fifo_read_en = 1'b0;
+            else
+              fifo_read_en = 1'b1;
+         end
+           else
+         fifo_read_en = 1'b0;
+        end // case: SEND_SAVED_HALF_WORD
+
+      WAIT_FOR_UPPER_HALF:
+        begin
+           // There is a half-word saved from a previous beat in the read data register which does not end with an EOP.
+           fifo_read_en = (read_data_valid_reg == 2'b00) | output_mux_ready;
+        end
+    endcase // case(read_state)
+     end // always @ (*)
+   
+
+   assign read_data_reg_first_be_lower = read_data_reg[TUSER_LOWER_OFFSET +3:
+                               TUSER_LOWER_OFFSET];
+   assign read_data_reg_last_be_lower = read_data_reg[TUSER_LOWER_OFFSET +7:
+                              TUSER_LOWER_OFFSET +4];
+   assign read_data_reg_byte_en_lower = read_data_reg[TUSER_LOWER_OFFSET +39:
+                                 TUSER_LOWER_OFFSET +8];
+   assign read_data_reg_sop_lower = read_data_reg[TUSER_LOWER_OFFSET + 40];
+   assign read_data_reg_discontinue_lower = read_data_reg[TUSER_LOWER_OFFSET + 41];
+   assign read_data_reg_tph_present_lower = read_data_reg[TUSER_LOWER_OFFSET + 42];  
+   assign read_data_reg_tph_type_lower = read_data_reg[TUSER_LOWER_OFFSET + 44:
+                                  TUSER_LOWER_OFFSET + 43];
+   assign read_data_reg_tph_st_tag_lower = read_data_reg[TUSER_LOWER_OFFSET + 52:   
+                                  TUSER_LOWER_OFFSET + 45];
+  generate
+    if (PARITY_ENABLE)
+      begin
+    assign read_data_reg_parity_lower = read_data_reg[TUSER_LOWER_OFFSET + 84:   
+                                   TUSER_LOWER_OFFSET + 53];
+    assign read_data_reg_eop_ptr_lower = read_data_reg[TUSER_LOWER_OFFSET + 87:
+                                    TUSER_LOWER_OFFSET + 85];
+      end
+    else
+      begin
+    assign read_data_reg_parity_lower = 32'd0;
+    assign read_data_reg_eop_ptr_lower = read_data_reg[TUSER_LOWER_OFFSET + 55:
+                                    TUSER_LOWER_OFFSET + 53];
+      end // else: !if(PARITY_ENABLE)
+  endgenerate
+      
+   assign read_data_reg_first_be_upper = read_data_reg[TUSER_UPPER_OFFSET +3:
+                               TUSER_UPPER_OFFSET];
+   assign read_data_reg_last_be_upper = read_data_reg[TUSER_UPPER_OFFSET +7:
+                              TUSER_UPPER_OFFSET +4];
+   assign read_data_reg_byte_en_upper = read_data_reg[TUSER_UPPER_OFFSET +39:
+                                 TUSER_UPPER_OFFSET +8];
+   assign read_data_reg_sop_upper = read_data_reg[TUSER_UPPER_OFFSET + 40];
+   assign read_data_reg_discontinue_upper = read_data_reg[TUSER_UPPER_OFFSET + 41];
+   assign read_data_reg_tph_present_upper = read_data_reg[TUSER_UPPER_OFFSET + 42];  
+   assign read_data_reg_tph_type_upper = read_data_reg[TUSER_UPPER_OFFSET + 44:
+                                  TUSER_UPPER_OFFSET + 43];
+   assign read_data_reg_tph_st_tag_upper = read_data_reg[TUSER_UPPER_OFFSET + 52:   
+                                  TUSER_UPPER_OFFSET + 45];
+  generate
+    if (PARITY_ENABLE)
+      begin
+    assign read_data_reg_parity_upper = read_data_reg[TUSER_UPPER_OFFSET + 84:   
+                                   TUSER_UPPER_OFFSET + 53];
+    assign read_data_reg_eop_ptr_upper = read_data_reg[TUSER_UPPER_OFFSET + 87:
+                               TUSER_UPPER_OFFSET + 85];
+      end
+    else
+      begin
+    assign read_data_reg_parity_upper = 32'd0;
+
+    assign read_data_reg_eop_ptr_upper = read_data_reg[TUSER_UPPER_OFFSET + 55:
+                               TUSER_UPPER_OFFSET + 53];
+      end
+  endgenerate
+
+  generate
+    if (PARITY_ENABLE)
+      begin
+    assign  read_data_reg_tlast_lower = read_data_reg[AXI4_CORE_DATA_WIDTH + AXI4_CORE_CQ_TKEEP_WIDTH +
+                              AXI4_CORE_CQ_TUSER_WIDTH];
+    assign     read_data_reg_tlast_upper = read_data_reg[AXI4_CORE_DATA_WIDTH*2 + AXI4_CORE_CQ_TKEEP_WIDTH*2 +
+                              AXI4_CORE_CQ_TUSER_WIDTH*2 +2];
+      end
+    else
+      begin
+    assign  read_data_reg_tlast_lower = read_data_reg[AXI4_CORE_DATA_WIDTH + AXI4_CORE_CQ_TKEEP_WIDTH +
+                              AXI4_CORE_CQ_TUSER_WIDTH -32];
+    assign     read_data_reg_tlast_upper = read_data_reg[AXI4_CORE_DATA_WIDTH*2 + AXI4_CORE_CQ_TKEEP_WIDTH*2 +
+                              AXI4_CORE_CQ_TUSER_WIDTH*2 +2 -64];
+      end // else: !if(PARITY_ENABLE)
+  endgenerate
+
+   assign sop_in_lower_half = read_data_valid_reg[0] & read_data_reg_sop_lower;
+   assign sop_in_upper_half = attr_straddle_en_i & read_data_valid_reg[1] & read_data_reg_sop_upper;
+
+   assign eop_in_lower_half = read_data_valid_reg[0] & read_data_reg_tlast_lower;
+   assign eop_in_upper_half = read_data_valid_reg[1] & read_data_reg_tlast_upper;
+   
+   assign read_data_out_first_be[3:0] = sop_in_lower_half? read_data_reg_first_be_lower: 
+      sop_in_upper_half? read_data_reg_first_be_upper: 4'd0;
+   assign read_data_out_first_be[7:4] = (sop_in_lower_half & sop_in_upper_half)?
+      read_data_reg_first_be_upper: 4'd0;
+   assign read_data_out_last_be[3:0] = sop_in_lower_half? read_data_reg_last_be_lower: 
+      sop_in_upper_half? read_data_reg_last_be_upper: 4'd0;
+   assign read_data_out_last_be[7:4] = (sop_in_lower_half & sop_in_upper_half)?
+      read_data_reg_last_be_upper: 4'd0;
+   assign read_data_out_byte_en[31:0] = read_data_valid_reg[0]? read_data_reg_byte_en_lower: 32'd0;
+   assign read_data_out_byte_en[63:32] = read_data_valid_reg[1]? read_data_reg_byte_en_upper: 32'd0;
+   
+   assign read_data_out_is_sop[0] = sop_in_lower_half | sop_in_upper_half;
+   assign read_data_out_is_sop[1] = sop_in_lower_half & sop_in_upper_half;
+
+   assign read_data_out_is_sop0_ptr[1] = ~sop_in_lower_half & sop_in_upper_half;
+   assign read_data_out_is_sop0_ptr[0] = 1'b0;
+   assign read_data_out_is_sop1_ptr[1] = read_data_out_is_sop[1];
+   assign read_data_out_is_sop1_ptr[0] = 1'b0;
+   assign read_data_out_is_eop[0] = eop_in_lower_half | eop_in_upper_half;
+   assign read_data_out_is_eop[1] = attr_straddle_en_i & eop_in_lower_half & eop_in_upper_half;
+   assign read_data_out_is_eop0_ptr[3:0] = eop_in_lower_half? {1'b0, read_data_reg_eop_ptr_lower}:
+      eop_in_upper_half? {1'b1, read_data_reg_eop_ptr_upper}: 4'd0;
+   assign read_data_out_is_eop1_ptr[3:0] = (attr_straddle_en_i & eop_in_lower_half & eop_in_upper_half)?
+      {1'b1, read_data_reg_eop_ptr_upper}: 4'd0;
+   assign read_data_out_discontinue = (read_data_valid_reg[0] & read_data_reg_discontinue_lower) |
+      (read_data_valid_reg[1] & read_data_reg_discontinue_upper);      
+
+   assign read_data_out_tph_present[0] = sop_in_lower_half? read_data_reg_tph_present_lower:
+      sop_in_upper_half? read_data_reg_tph_present_upper: 1'b0;
+   assign read_data_out_tph_present[1] = (sop_in_lower_half & sop_in_upper_half)? read_data_reg_tph_present_upper: 1'b0;
+
+   assign read_data_out_tph_type[1:0] = sop_in_lower_half? read_data_reg_tph_type_lower[1:0]:
+      sop_in_upper_half? read_data_reg_tph_type_upper[1:0]: 2'd0;
+   assign read_data_out_tph_type[3:2] = (sop_in_lower_half & sop_in_upper_half)? read_data_reg_tph_type_upper[1:0]: 2'd0;
+
+   assign read_data_out_tph_st_tag[7:0] = sop_in_lower_half? read_data_reg_tph_st_tag_lower[7:0]:
+      sop_in_upper_half? read_data_reg_tph_st_tag_upper[7:0]: 8'd0;
+   assign read_data_out_tph_st_tag[15:8] = (sop_in_lower_half & sop_in_upper_half)? read_data_reg_tph_st_tag_upper[7:0]: 8'd0;
+
+   assign read_data_out_parity[31:0] = read_data_valid_reg[0]? read_data_reg_parity_lower: 32'd0;
+   assign read_data_out_parity[63:32] = read_data_valid_reg[1]? read_data_reg_parity_upper: 32'd0;
+
+   assign read_data_out_tuser = {
+                 read_data_out_parity[63:0],
+                 read_data_out_tph_st_tag[15:0],
+                 read_data_out_tph_type[3:0],
+                 read_data_out_tph_present[1:0],
+                 read_data_out_discontinue,
+                 read_data_out_is_eop1_ptr[3:0],
+                 read_data_out_is_eop0_ptr[3:0],
+                 read_data_out_is_eop[1:0],
+                 read_data_out_is_sop1_ptr[1:0],
+                 read_data_out_is_sop0_ptr[1:0],
+                 read_data_out_is_sop[1:0],
+                 read_data_out_byte_en[63:0],
+                 read_data_out_last_be[7:0],
+                 read_data_out_first_be[7:0]
+                 };
+
+
+   assign read_data_out_tdata[AXI4_USER_DATA_WIDTH/2-1:0] = read_data_valid_reg[0]? read_data_reg[AXI4_CORE_DATA_WIDTH-1:0]:
+      {AXI4_USER_DATA_WIDTH/2{1'b0}};
+   assign read_data_out_tdata[AXI4_USER_DATA_WIDTH-1:AXI4_USER_DATA_WIDTH/2] = read_data_valid_reg[1]?
+      read_data_reg[FIFO_READ_DATA_UPPER_OFFSET+AXI4_CORE_DATA_WIDTH-1:FIFO_READ_DATA_UPPER_OFFSET]: {AXI4_USER_DATA_WIDTH/2{1'b0}};
+   
+  assign  read_data_out_tkeep[AXI4_USER_CQ_TKEEP_WIDTH/2-1:0] = attr_straddle_en_i? {AXI4_USER_CQ_TKEEP_WIDTH/2{1'b1}}:
+      read_data_valid_reg[0]? 
+      read_data_reg[AXI4_CORE_DATA_WIDTH+AXI4_CORE_CQ_TKEEP_WIDTH-1:AXI4_CORE_DATA_WIDTH]: {AXI4_USER_CQ_TKEEP_WIDTH/2{1'b0}};
+   assign read_data_out_tkeep[AXI4_USER_CQ_TKEEP_WIDTH-1:AXI4_USER_CQ_TKEEP_WIDTH/2] = attr_straddle_en_i? {AXI4_USER_CQ_TKEEP_WIDTH/2{1'b1}}:
+      read_data_valid_reg[1]? 
+      read_data_reg[FIFO_READ_TKEEP_UPPER_OFFSET+AXI4_CORE_CQ_TKEEP_WIDTH-1:FIFO_READ_TKEEP_UPPER_OFFSET]:
+      {AXI4_USER_CQ_TKEEP_WIDTH/2{1'b0}};
+
+   assign read_data_out_tlast = attr_straddle_en_i? 1'b0: (eop_in_lower_half | eop_in_upper_half);
+
+   assign output_mux_in_data = {
+                read_data_out_tlast,
+                read_data_out_tuser,
+                read_data_out_tkeep,
+                read_data_out_tdata
+                };
+
+   // Instance of output MUX
+   xp4_usp_smsw_512b_cq_output_mux #
+     (
+      .TCQ(TCQ),
+      .IMPL_TARGET(IMPL_TARGET),
+      .IN_DATA_WIDTH(OUTPUT_MUX_IN_DATA_WIDTH),
+      .OUT_DATA_WIDTH(AXI4_USER_DATA_WIDTH),
+      .TUSER_WIDTH(AXI4_USER_CQ_TUSER_WIDTH),
+      .TKEEP_WIDTH(AXI4_USER_CQ_TKEEP_WIDTH)
+      )
+     pcie_4_0_512b_cq_output_mux_blk
+       (
+        .clk_i(user_clk_i),
+        .reset_n_i(reset_n_user_clk_i),
+        .link_down_reset_i(link_down_reset_i),
+    .in_data_i(output_mux_in_data),
+    .in_data_valid_i(read_data_valid_reg[0]),
+        .attr_straddle_en_i(attr_straddle_en_i),
+
+    .upstream_ready_o(output_mux_ready),
+    .out_data_o(m_axis_cq_tdata_o),
+        .out_data_valid_o(m_axis_cq_tvalid_o),
+    .out_tuser_o(m_axis_cq_tuser_o),
+    .out_tlast_o(m_axis_cq_tlast_o),
+    .out_tkeep_o(m_axis_cq_tkeep_o),
+    .downstream_ready_i(m_axis_cq_tready_i),
+    
+    .pcie_cq_np_req_i(pcie_cq_np_req_i),
+    .pcie_cq_np_req_count_o(pcie_cq_np_req_count_o),
+    .np_credit_received_o(cq_np_user_credit_rcvd_user_clk),
+    .posted_req_delivered_o(posted_req_delivered_user_clk),
+    .pipeline_empty_o(out_mux_pipeline_empty)
+    );
+
+   // Change clock domain for np_user_credit_rcvd signal
+   always @(posedge user_clk2_i)
+     if (~reset_n_user_clk2_i)
+       cq_np_user_credit_rcvd_o <= #TCQ 1'b0;
+     else
+       if (user_clk_en_i)
+     cq_np_user_credit_rcvd_o <= #TCQ cq_np_user_credit_rcvd_user_clk[0];
+       else
+     cq_np_user_credit_rcvd_o <= #TCQ cq_np_user_credit_rcvd_user_clk[1];
+
+   // Change clock domain for posted_req_delivered signal
+   always @(posedge user_clk2_i)
+     if (~reset_n_user_clk2_i)
+       posted_req_delivered_o <= #TCQ 1'b0;
+     else
+       if (user_clk_en_i)
+     posted_req_delivered_o <= #TCQ posted_req_delivered_user_clk[0];
+       else
+     posted_req_delivered_o <= #TCQ posted_req_delivered_user_clk[1];
+
+   assign pipeline_empty_user_clk = out_mux_pipeline_empty &&
+      (read_data_valid_reg == 2'b00) &&
+      ~fifo_read_data_valid &&
+      ~fifo_in_data_valid_reg;
+
+   always @(posedge user_clk2_i)
+     if (~reset_n_user_clk2_i)
+       pipeline_empty_core_clk <= #TCQ 1'b0;
+     else
+       pipeline_empty_core_clk <= #TCQ pipeline_empty_user_clk;
+
+   always @(posedge user_clk2_i)
+     if (~reset_n_user_clk2_i)
+       cq_pipeline_empty_reg <= #TCQ 3'b111;
+     else
+       begin
+      // Wait for pipeline empty signals to stay asserted for 3 cycles before signaling the output.
+      cq_pipeline_empty_reg[0] <= #TCQ pipeline_empty_core_clk &
+                      ~core_cq_tvalid_i &
+                      ~core_cq_tvalid_reg_lower &
+                      ~core_cq_tvalid_reg_upper;
+         cq_pipeline_empty_reg[1] <= #TCQ cq_pipeline_empty_reg[0];
+         cq_pipeline_empty_reg[2] <= #TCQ cq_pipeline_empty_reg[1];
+      cq_pipeline_empty_o <= #TCQ &cq_pipeline_empty_reg;
+       end // else: !if(~reset_n_user_clk2_i)
+         
+
+endmodule // pcie_4_0_512b_cq_intfc
+
+
+
+
+
+
+
+
+   
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2023 AMD, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD, Inc. and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : UltraScale+ FPGA PCI Express v4.0 Integrated Block
+// File       : xp4_usp_smsw_512b_cq_output_mux.v
+// Version    : 1.1 
+//-----------------------------------------------------------------------------
+//--------------------------------------------------------------------------------------------------
+`timescale 1ps/1ps
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_512b_cq_output_mux #(
+   parameter TCQ = 100,
+   parameter IMPL_TARGET = "SOFT",
+   parameter IN_DATA_WIDTH = 512+183+16+1,    
+   parameter OUT_DATA_WIDTH = 512,
+   parameter TUSER_WIDTH = 183,
+   parameter TKEEP_WIDTH = 16
+   )
+  (
+    input  wire           clk_i // 250 MHz clock for client-facing interfaces
+   ,input  wire           reset_n_i // Reset in the user clock domain
+   ,input  wire           link_down_reset_i // Link went down
+
+   ,input  wire           attr_straddle_en_i // Enable straddle
+
+   ,input wire[IN_DATA_WIDTH-1:0] in_data_i
+   ,input wire in_data_valid_i
+   ,output wire upstream_ready_o
+
+   ,output reg [OUT_DATA_WIDTH-1:0]  out_data_o
+   ,output reg           out_data_valid_o
+   ,output reg [TUSER_WIDTH-1:0] out_tuser_o
+   ,output wire          out_tlast_o
+   ,output wire [TKEEP_WIDTH-1:0] out_tkeep_o
+   ,input  wire           downstream_ready_i
+
+   ,input  wire [1:0]     pcie_cq_np_req_i // Client request to deliver NP TLP
+   ,output reg [5:0]      pcie_cq_np_req_count_o // Current value of interface credit count for NP TLPs
+   ,output reg [1:0]      np_credit_received_o // NP credit to TL
+   ,output reg [1:0]      posted_req_delivered_o // Signals the delivery of a Posted Req on the CQ interface
+   ,output wire           pipeline_empty_o // Indicates that the entire pipeline of the mux is empty
+   );
+
+
+   localparam MAX_CREDIT = 32;
+
+   reg [1:0] output_fifo_occupancy;
+   reg          output_fifo_write_ptr;
+   reg          output_fifo_read_ptr;
+   wire      output_fifo_full;
+   wire      output_fifo_empty;
+
+   reg [OUT_DATA_WIDTH-1:0] m_axis_cq_tdata_first_reg;
+   reg [TKEEP_WIDTH-1:0]    m_axis_cq_tkeep_first_reg;
+   reg [TUSER_WIDTH-1:0]    m_axis_cq_tuser_first_reg;
+   reg                 m_axis_cq_tlast_first_reg;
+   
+   reg [OUT_DATA_WIDTH-1:0] m_axis_cq_tdata_second_reg;
+   reg [TKEEP_WIDTH-1:0]    m_axis_cq_tkeep_second_reg;
+   reg [TUSER_WIDTH-1:0]    m_axis_cq_tuser_second_reg;
+   reg                 m_axis_cq_tlast_second_reg;
+   
+   wire             output_reg_mux_sel;
+
+   wire [3:0]              output_reg_in_req_type0;
+   wire [3:0]              output_reg_in_req_type1;
+   
+   wire              output_reg_in_req_type0_np;
+   wire              output_reg_in_req_type1_np;
+
+   wire              output_reg_in_sop0;
+   wire              output_reg_in_sop1;
+   wire              output_reg_in_eop0;
+   wire              output_reg_in_eop1;
+   wire              output_reg_in_error;
+
+   reg [1:0]             pcie_cq_np_req_reg;
+   reg                 tlp_in_progress;
+   reg                 tlp_in_progress_type;
+
+   reg [1:0]             np_tlp_count;
+   
+   wire [3:0]             out_req_type0;
+   wire [3:0]             out_req_type1;
+   reg                 m_axis_cq_tvalid_last;
+   reg                 m_axis_cq_sop0_last;
+   reg                 m_axis_cq_sop1_last;
+   reg                 m_axis_cq_eop0_last;
+   reg                 m_axis_cq_eop1_last;
+   reg                 m_axis_cq_posted_type0_last;
+   reg                 m_axis_cq_posted_type1_last;
+   reg                 out_ready_reg;
+   reg                 posted_tlp_in_progress;
+   reg                 posted_tlp_in_progress_type;
+
+  reg                 out_tlast_reg;
+  reg [TKEEP_WIDTH-1:0]     out_tkeep_reg;
+
+   //---------------------------------------------------------------------------------------------
+   // Output FIFO
+   // The main FIFO feeds into two read registers in the user clock domain, which are configured
+   // as a 2-entry FIFO.
+   // These are termed m_axis_cq_*_reg_first and m_axis_cq_*_reg_second.
+   // These can be thought of as logical extensions of the main FIFO.
+   //---------------------------------------------------------------------------------------------
+
+   // Send signal to read from main FIFO into the output FIFO when the latter is not full.
+   assign    upstream_ready_o = ~output_fifo_full;
+
+   // Maintain write and read pointers
+   always @(posedge clk_i)
+     if (~reset_n_i)
+       output_fifo_write_ptr <= #(TCQ) 1'b0;
+     else if (link_down_reset_i)
+       output_fifo_write_ptr <= #(TCQ) 1'b0;
+     else
+       if (in_data_valid_i & ~output_fifo_full)
+	 output_fifo_write_ptr <= #(TCQ) ~output_fifo_write_ptr;
+
+   always @(posedge clk_i)
+     if (~reset_n_i)
+       output_fifo_read_ptr <= #(TCQ) 1'b0;
+     else if (link_down_reset_i)
+       output_fifo_read_ptr <= #(TCQ) 1'b0;
+     else
+       if ((downstream_ready_i | ~out_data_valid_o) &
+	   ~output_fifo_empty)
+	 output_fifo_read_ptr <= #(TCQ) ~output_fifo_read_ptr;
+
+    // Maintain FIFO occupancy
+   always @(posedge clk_i)
+     if (~reset_n_i)
+       output_fifo_occupancy <= #(TCQ) 2'd0;
+     else if (link_down_reset_i)
+       output_fifo_occupancy <= #(TCQ) 2'd0;
+     else
+       if ((in_data_valid_i & ~output_fifo_full) &
+       ~((downstream_ready_i | ~out_data_valid_o) &
+         ~output_fifo_empty))
+     output_fifo_occupancy <= #(TCQ) output_fifo_occupancy + 2'd1;
+       else
+     if (~(in_data_valid_i & ~output_fifo_full) &
+         ((downstream_ready_i | ~out_data_valid_o) &
+          ~output_fifo_empty))
+       output_fifo_occupancy <= #(TCQ) output_fifo_occupancy - 2'd1;
+   
+
+   assign output_fifo_full = output_fifo_occupancy[1];
+   assign output_fifo_empty = (output_fifo_occupancy == 2'b00);
+
+   // Write data into the Output FIFO.                                                                                    
+   always @(posedge clk_i)
+     if (~reset_n_i)
+       begin
+          m_axis_cq_tdata_first_reg <= #(TCQ) {OUT_DATA_WIDTH{1'b0}};
+          m_axis_cq_tdata_second_reg <= #(TCQ) {OUT_DATA_WIDTH{1'b0}};
+          m_axis_cq_tkeep_first_reg <= #(TCQ) {TKEEP_WIDTH{1'b0}};
+          m_axis_cq_tkeep_second_reg <= #(TCQ) {TKEEP_WIDTH{1'b0}};
+          m_axis_cq_tuser_first_reg <= #(TCQ) {TUSER_WIDTH{1'b0}};
+          m_axis_cq_tuser_second_reg <= #(TCQ) {TUSER_WIDTH{1'b0}};
+          m_axis_cq_tlast_first_reg <= #(TCQ) 1'b0;
+          m_axis_cq_tlast_second_reg <= #(TCQ) 1'b0;
+       end
+     else
+        if (in_data_valid_i & ~output_fifo_full)
+      begin
+         case(output_fifo_write_ptr)
+           1'b0:
+         begin
+            m_axis_cq_tdata_first_reg <= #(TCQ) in_data_i[OUT_DATA_WIDTH-1:0];
+            m_axis_cq_tkeep_first_reg <= #(TCQ) in_data_i[OUT_DATA_WIDTH+TKEEP_WIDTH-1:OUT_DATA_WIDTH];
+            m_axis_cq_tuser_first_reg <= #(TCQ) in_data_i[OUT_DATA_WIDTH+TKEEP_WIDTH+TUSER_WIDTH-1:OUT_DATA_WIDTH+TKEEP_WIDTH];
+            m_axis_cq_tlast_first_reg <= #(TCQ) in_data_i[IN_DATA_WIDTH-1];
+         end
+           default:
+         begin
+            m_axis_cq_tdata_second_reg <= #(TCQ) in_data_i[OUT_DATA_WIDTH-1:0];
+            m_axis_cq_tkeep_second_reg <= #(TCQ) in_data_i[OUT_DATA_WIDTH+TKEEP_WIDTH-1:OUT_DATA_WIDTH];
+            m_axis_cq_tuser_second_reg <= #(TCQ) in_data_i[OUT_DATA_WIDTH+TKEEP_WIDTH+TUSER_WIDTH-1:OUT_DATA_WIDTH+TKEEP_WIDTH];
+            m_axis_cq_tlast_second_reg <= #(TCQ) in_data_i[IN_DATA_WIDTH-1];
+         end
+         endcase // case(output_fifo_write_ptr)
+      end // if (in_data_valid_i & ~output_fifo_full)
+   
+   // Output registers
+
+   assign output_reg_mux_sel = output_fifo_read_ptr;
+
+   always @(posedge clk_i)
+     if (~reset_n_i)
+       begin
+      out_data_o <= #(TCQ) {OUT_DATA_WIDTH-1{1'b0}};
+      out_tuser_o <= #(TCQ) {TUSER_WIDTH-1{1'b0}};
+      out_tkeep_reg <= #(TCQ) {TKEEP_WIDTH-1{1'b0}};
+      out_tlast_reg <= #(TCQ) 1'b0;
+       end
+     else
+       if (~out_data_valid_o | downstream_ready_i)
+     begin
+        case(output_reg_mux_sel)
+          1'b0:
+        begin
+           out_data_o <= #(TCQ) m_axis_cq_tdata_first_reg;
+           out_tkeep_reg <= #(TCQ) m_axis_cq_tkeep_first_reg;
+           out_tuser_o <= #(TCQ) m_axis_cq_tuser_first_reg;
+           out_tlast_reg <= #(TCQ) m_axis_cq_tlast_first_reg;
+        end
+          default:
+        begin
+           out_data_o <= #(TCQ) m_axis_cq_tdata_second_reg;
+           out_tkeep_reg <= #(TCQ) m_axis_cq_tkeep_second_reg;
+           out_tuser_o <= #(TCQ) m_axis_cq_tuser_second_reg;
+           out_tlast_reg <= #(TCQ) m_axis_cq_tlast_second_reg;
+        end
+        endcase // case(output_reg_mux_sel)
+     end // if (~out_data_o | downstream_ready_i)
+
+   always @(posedge clk_i)
+     if (~reset_n_i)
+       out_data_valid_o <= #(TCQ) 1'b0;
+     else
+       if (~out_data_valid_o | downstream_ready_i)
+     out_data_valid_o <= #(TCQ) ~output_fifo_empty;
+
+  assign out_tkeep_o =  attr_straddle_en_i? {TKEEP_WIDTH{1'b1}}: out_tkeep_reg;
+  assign out_tlast_o =  attr_straddle_en_i? 1'b0: out_tlast_reg;
+
+   //--------------------------------------------------------------------
+   // NP credit management
+   //-----------------------------------------------------------------------------------                
+
+   // Decode packet Req Type as Posted/Non-Posted
+   assign output_reg_in_req_type0 = in_data_i[78:75];
+   assign output_reg_in_req_type1 = in_data_i[256+78:256+75];
+   
+   assign output_reg_in_req_type0_np = (output_reg_in_req_type0[3:0] != 4'd1) &&
+	  (output_reg_in_req_type0[3:2] != 2'b11);
+   assign output_reg_in_req_type1_np = (output_reg_in_req_type1[3:0] != 4'd1) &&
+	  (output_reg_in_req_type1[3:2] != 2'b11);
+  
+   assign output_reg_in_sop0 = in_data_i[OUT_DATA_WIDTH+TKEEP_WIDTH+80];
+   assign output_reg_in_sop1 = in_data_i[OUT_DATA_WIDTH+TKEEP_WIDTH+81];
+   assign output_reg_in_eop0 = in_data_i[OUT_DATA_WIDTH+TKEEP_WIDTH+86];
+   assign output_reg_in_eop1 = in_data_i[OUT_DATA_WIDTH+TKEEP_WIDTH+87];
+   assign output_reg_in_error = in_data_i[OUT_DATA_WIDTH+TKEEP_WIDTH+95];  // discontinue  
+
+   // Register the user input pcie_cq_np_req_i
+   always @(posedge clk_i)
+     if (~reset_n_i)
+       pcie_cq_np_req_reg <= #(TCQ) 2'b00;
+     else
+       pcie_cq_np_req_reg <= #(TCQ) pcie_cq_np_req_i;
+
+   // If a TLP is in progress from last beat, record its type.
+  always @(posedge clk_i)
+    if (~reset_n_i)
+      begin
+	tlp_in_progress <= 1'b0;
+	tlp_in_progress_type <= 1'b0;
+      end
+  else if (in_data_valid_i & ~output_fifo_full)
+    begin
+      if (~tlp_in_progress)
+	begin
+	  if (output_reg_in_sop0 & ~output_reg_in_eop0)
+            begin
+              tlp_in_progress <= 1'b1;
+              tlp_in_progress_type <= output_reg_in_req_type0_np;
+            end
+          else if (output_reg_in_sop1 & ~output_reg_in_eop1)
+            begin
+              tlp_in_progress <= 1'b1;
+              tlp_in_progress_type <= output_reg_in_req_type1_np;
+            end
+          else
+            begin
+              tlp_in_progress <= 1'b0;
+              tlp_in_progress_type <= 1'b0;
+            end
+	end // if (~tlp_in_progress)
+      else
+	begin
+          if ((output_reg_in_eop0 & ~output_reg_in_sop0)|
+	      output_reg_in_eop1)
+	    tlp_in_progress <= 1'b0;
+          if (output_reg_in_sop0)
+	    tlp_in_progress_type <= output_reg_in_req_type1_np;
+	end // else: !if(~tlp_in_progress)
+    end // if (in_data_valid_i & ~output_fifo_full)
+   
+   // Determine number of NP TLPs being sent to user
+   always @(*)
+     begin
+    case({output_reg_in_eop1, output_reg_in_eop0})
+      2'd0: np_tlp_count = 2'd0;
+      2'd1:
+        begin
+           if (~tlp_in_progress)
+             begin
+               if (output_reg_in_req_type0_np & ~output_reg_in_error)
+		 np_tlp_count = 2'd1;
+               else
+		 np_tlp_count = 2'd0;
+             end
+           else
+             begin
+               if (tlp_in_progress_type & ~output_reg_in_error)
+		 np_tlp_count = 2'd1;
+               else
+		 np_tlp_count = 2'd0;
+             end // else: !if(~tlp_in_progress)
+	end // case: 2'd1
+      
+      default: //2'd3
+        begin
+           if (~tlp_in_progress)
+             begin
+               if (output_reg_in_req_type0_np & output_reg_in_req_type1_np)
+		 np_tlp_count = 2'd2;
+               else if (output_reg_in_req_type0_np | output_reg_in_req_type1_np)
+		 np_tlp_count = 2'd1;
+               else
+		 np_tlp_count = 2'd0;
+             end
+           else
+             begin
+               if (tlp_in_progress_type & output_reg_in_req_type1_np)
+		 np_tlp_count = 2'd2;
+               else if (tlp_in_progress_type | output_reg_in_req_type1_np)
+		 np_tlp_count = 2'd1;
+               else
+		 np_tlp_count = 2'd0;
+             end // else: !if(~tlp_in_progress)
+        end // case: default
+    endcase // case({output_reg_in_eop1, output_reg_in_eop0})
+     end // always @ (*)
+
+   // Maintain current NP credit
+   always @(posedge clk_i)
+     if (~reset_n_i)
+       begin
+      pcie_cq_np_req_count_o <= 6'd0;
+       end
+     else if (link_down_reset_i)
+       begin
+      pcie_cq_np_req_count_o <= 6'd0;
+       end
+     else
+       if (in_data_valid_i & ~output_fifo_full)
+     begin
+        casez({np_tlp_count, pcie_cq_np_req_reg})
+          4'b00_01:
+        begin
+           // No TLPs being delivered, user provided 1 credit
+           if (pcie_cq_np_req_count_o != MAX_CREDIT[5:0])
+             pcie_cq_np_req_count_o <= pcie_cq_np_req_count_o + 6'd1;
+        end
+          4'b00_1?:
+        begin
+           // No TLPs being delivered, user provided 2 credits
+           if (pcie_cq_np_req_count_o <= (MAX_CREDIT-2))
+             pcie_cq_np_req_count_o <= pcie_cq_np_req_count_o + 6'd2;
+           else
+             pcie_cq_np_req_count_o <= MAX_CREDIT[5:0];
+        end
+          4'b01_00:
+        begin
+           // One NP TLP being delivered, user provided no credit
+           if (pcie_cq_np_req_count_o != 6'd0)
+             pcie_cq_np_req_count_o <= pcie_cq_np_req_count_o - 6'd1;
+        end
+          4'b01_1?:
+        begin
+           // One NP TLP being delivered, user provided 2 credits
+           if (pcie_cq_np_req_count_o != MAX_CREDIT[5:0])
+             pcie_cq_np_req_count_o <= pcie_cq_np_req_count_o + 6'd1;
+        end
+          4'b1?_00:
+        begin
+           // Two NP TLP being delivered, user provided no credit.
+           // Decrement by 2.
+           if (pcie_cq_np_req_count_o[5:1] != 5'd0)
+             pcie_cq_np_req_count_o <= pcie_cq_np_req_count_o - 6'd2;
+           else
+             pcie_cq_np_req_count_o[0] <= 1'b0;
+        end          
+          4'b1?_01:
+        begin
+           // Two NP TLP being delivered, user provided 1 credit.
+           // Decrement by 1.
+           if (pcie_cq_np_req_count_o != 6'd0)
+             pcie_cq_np_req_count_o <= pcie_cq_np_req_count_o - 6'd1;
+        end
+        endcase // casez({np_tlp_count, pcie_cq_np_req_reg})
+     end // if (in_data_valid_i & ~output_fifo_full)
+       else
+     begin
+       casez(pcie_cq_np_req_reg)
+         2'b01:
+           begin
+         // No TLPs being delivered, user provided 1 credit
+         if (pcie_cq_np_req_count_o != MAX_CREDIT[5:0])
+           pcie_cq_np_req_count_o <= pcie_cq_np_req_count_o + 6'd1;
+           end
+         2'b1?:
+           begin
+         // No TLPs being delivered, user provided 2 credits
+         if (pcie_cq_np_req_count_o <= (MAX_CREDIT-2))
+           pcie_cq_np_req_count_o <= pcie_cq_np_req_count_o + 6'd2;
+         else
+           pcie_cq_np_req_count_o <= MAX_CREDIT[5:0];
+           end
+         default:
+           begin
+           end
+       endcase // casez(pcie_cq_np_req_reg)
+     end // else: !if(in_data_valid_i & ~output_fifo_full)
+
+  // Send indication to Transaction Layer when user issues more credit
+   always @(posedge clk_i)
+     if (~reset_n_i)
+       np_credit_received_o <= 2'b00;
+     else
+       if (in_data_valid_i & ~output_fifo_full)
+     begin
+        casez({np_tlp_count, pcie_cq_np_req_reg})
+          4'b00_01:
+        // No TLPs being delivered, user provided 1 credit
+        begin
+           // Provide credit to TL when credit count has not saturated
+           if (pcie_cq_np_req_count_o == MAX_CREDIT[5:0])
+             np_credit_received_o <= 2'b00;
+           else
+             np_credit_received_o <= 2'b01;
+        end
+          4'b00_1?:
+        // No TLPs being delivered, user provided 2 credits
+        begin
+           // Provide credit to TL when credit count has not saturated
+           if (pcie_cq_np_req_count_o == MAX_CREDIT[5:0])
+             np_credit_received_o <= 2'b00;
+           else if (pcie_cq_np_req_count_o == (MAX_CREDIT -1))
+             // Provide 1 credit.
+             np_credit_received_o <= 2'b01;
+           else
+             // Provide 2 credits.
+             np_credit_received_o <= 2'b11;
+        end // case: 4'b00_1x
+          4'b01_01:
+        // 1 TLP being delivered, user provided 1 credit
+        begin
+           // Always provide 1 credit to TL
+           np_credit_received_o <= 2'b01;
+        end
+          4'b01_1?:
+        // 1 TLP being delivered, user provided 2 credits
+        begin
+           // Provide 1 credit to TL when credit count has not saturated
+           if (pcie_cq_np_req_count_o == MAX_CREDIT[5:0])
+             np_credit_received_o <= 2'b01;
+           else
+             np_credit_received_o <= 2'b11;
+        end
+          4'b1?_01:
+        // 2 TLPs being delivered, user provided 1 credit
+        begin
+           // Always provide 1 credit to TL
+           np_credit_received_o <= 2'b01;
+        end
+          4'b1?_1?:
+        // 2 TLPs being delivered, user provided 2 credits
+        begin
+           // Always provide 2 credits to TL
+           np_credit_received_o <= 2'b11;
+        end
+          default:
+        begin
+           np_credit_received_o <= 2'b00;
+        end
+        endcase // casez({np_tlp_count, pcie_cq_np_req_reg})
+     end // if (in_data_valid_i & ~output_fifo_full)
+       else
+     begin
+       casez(pcie_cq_np_req_reg)
+         2'b01:
+           begin
+         // No TLPs being delivered, user provided 1 credit
+         if (pcie_cq_np_req_count_o != MAX_CREDIT[5:0])
+           np_credit_received_o <= 2'b01;
+         else
+           np_credit_received_o <= 2'b00;
+           end
+         2'b1?:
+           begin
+         // No TLPs being delivered, user provided 2 credits.
+         // Provide credit to TL when credit count has not saturated
+         if (pcie_cq_np_req_count_o == MAX_CREDIT[5:0])
+           np_credit_received_o <= 2'b00;
+         else if (pcie_cq_np_req_count_o == (MAX_CREDIT -1))
+           // Provide 1 credit.
+           np_credit_received_o <= 2'b01;
+         else
+           // Provide 2 credits.
+           np_credit_received_o <= 2'b11;
+           end // case: 4'b00_1?
+         default:
+           begin
+         np_credit_received_o <= 2'b00;
+           end
+       endcase // casez(pcie_cq_np_req_reg)
+     end // else: !if(in_data_valid_i & ~output_fifo_full)
+
+ //-------------------------------------------------------------------------------------------
+   // Generate indication when a Posted request is delivered to the user
+
+   assign out_req_type0 = out_data_o[78:75];
+   assign out_req_type1 = out_data_o[256+78:256+75];
+
+   always @(posedge clk_i)
+     if (~reset_n_i)
+       begin
+      m_axis_cq_tvalid_last <= 1'b0;
+      m_axis_cq_sop0_last <= 1'b0;
+      m_axis_cq_sop1_last <= 1'b0;
+      m_axis_cq_eop0_last <= 1'b0;
+      m_axis_cq_eop1_last <= 1'b0;
+      m_axis_cq_posted_type0_last <= 1'b0;
+      m_axis_cq_posted_type1_last <= 1'b0;
+       end
+     else
+       begin
+      m_axis_cq_tvalid_last <= out_data_valid_o;
+      m_axis_cq_sop0_last <= out_tuser_o[80];
+      m_axis_cq_sop1_last <= out_tuser_o[81];
+      m_axis_cq_eop0_last <= out_tuser_o[86];
+      m_axis_cq_eop1_last <= out_tuser_o[87];
+      m_axis_cq_posted_type0_last <= (out_req_type0[3:0] == 4'd1) || (out_req_type0[3:2] == 2'b11);
+      m_axis_cq_posted_type1_last <= (out_req_type1[3:0] == 4'd1) || (out_req_type1[3:2] == 2'b11);
+       end // else: !if(~reset_n_i)
+
+   // Register ready
+   always @(posedge clk_i)
+     if (~reset_n_i)
+       out_ready_reg <= 1'b0;
+     else
+       out_ready_reg <= downstream_ready_i;
+
+   always @(posedge clk_i)
+     if (~reset_n_i)
+       begin
+      posted_tlp_in_progress <= 1'b0;
+      posted_tlp_in_progress_type <= 1'b0;
+       end
+     else if (link_down_reset_i)
+       posted_tlp_in_progress <= 1'b0;
+     else if (m_axis_cq_tvalid_last & out_ready_reg)
+       begin
+          if (~posted_tlp_in_progress)
+        begin
+           if (m_axis_cq_sop0_last & ~m_axis_cq_eop0_last)
+         begin
+            posted_tlp_in_progress <= 1'b1;
+            posted_tlp_in_progress_type <=  m_axis_cq_posted_type0_last;
+         end
+           else if (m_axis_cq_sop1_last & ~m_axis_cq_eop1_last)
+         begin
+            posted_tlp_in_progress <= 1'b1;
+            posted_tlp_in_progress_type <=  m_axis_cq_posted_type1_last;
+         end
+           else
+         posted_tlp_in_progress <= 1'b0;
+        end // if (~posted_tlp_in_progress)
+      else
+        begin
+           if ((m_axis_cq_eop0_last & ~m_axis_cq_sop0_last) |
+           m_axis_cq_eop1_last)
+         posted_tlp_in_progress <= 1'b0;
+
+           if (m_axis_cq_sop0_last)
+         posted_tlp_in_progress_type <= m_axis_cq_posted_type1_last;
+        end // else: !if(~posted_tlp_in_progress)
+       end // if (m_axis_cq_tvalid_last & out_ready_reg)
+
+   always @(posedge clk_i)
+     if (~reset_n_i)
+       posted_req_delivered_o <= 2'b00;
+     else if (m_axis_cq_tvalid_last & out_ready_reg)
+       begin
+          if (~posted_tlp_in_progress)
+        begin
+          if ((m_axis_cq_sop0_last & m_axis_cq_posted_type0_last & m_axis_cq_eop0_last) &
+          (m_axis_cq_sop1_last & m_axis_cq_posted_type1_last & m_axis_cq_eop1_last))
+        // Two Complete TLPs in this beat.
+        posted_req_delivered_o <= 2'b11;
+          else if ((m_axis_cq_sop0_last & m_axis_cq_posted_type0_last & m_axis_cq_eop0_last) |
+               (m_axis_cq_sop1_last & m_axis_cq_posted_type1_last & m_axis_cq_eop1_last))
+        // Single TLP beginning and ending in this beat.
+        posted_req_delivered_o <= 2'b01;
+          else
+        // No Posted TLP ending in this beat
+        posted_req_delivered_o <= 2'b00;
+        end // if (~tlp_in_progress)
+      else
+        begin
+               if ((posted_tlp_in_progress_type & m_axis_cq_eop0_last) &
+           (m_axis_cq_sop0_last & m_axis_cq_posted_type1_last & m_axis_cq_eop1_last))
+         // TLP in progress ended in this cycle, and a new TLP started and ended.
+         posted_req_delivered_o <= 2'b11;
+               else if ((posted_tlp_in_progress_type & m_axis_cq_eop0_last) |
+            (m_axis_cq_sop0_last & m_axis_cq_posted_type1_last & m_axis_cq_eop1_last))
+         posted_req_delivered_o <= 2'b01;
+           else
+         posted_req_delivered_o <= 2'b00;
+        end // else: !if(~posted_tlp_in_progress)
+       end // if (m_axis_cq_tvalid_last & out_ready_reg)
+     else
+       posted_req_delivered_o <= 2'b00;
+
+  assign pipeline_empty_o = output_fifo_empty && ~out_data_valid_o && ~m_axis_cq_tvalid_last && (posted_req_delivered_o == 2'b00);
+
+
+endmodule // pcie_4_0_512b_cq_output_mux
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2023 AMD, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD, Inc. and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : UltraScale+ FPGA PCI Express v4.0 Integrated Block
+// File       : xp4_usp_smsw_512b_rc_intfc.v
+// Version    : 1.1 
+//-----------------------------------------------------------------------------
+//--------------------------------------------------------------------------------------------------
+`timescale 1ps/1ps
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_512b_rc_intfc #(
+   parameter TCQ = 100,
+   parameter IMPL_TARGET = "SOFT",
+   parameter AXISTEN_IF_EXT_512_INTFC_RAM_STYLE = "SRL",
+   parameter AXI4_USER_DATA_WIDTH = 512,
+   parameter AXI4_CORE_DATA_WIDTH = 256,
+   parameter AXI4_USER_RC_TUSER_WIDTH = 161,                
+   parameter AXI4_CORE_RC_TUSER_WIDTH = 75,
+   parameter AXI4_USER_RC_TKEEP_WIDTH = 16,
+   parameter AXI4_CORE_RC_TKEEP_WIDTH = 8,                
+   parameter AXI4_CORE_RC_TREADY_WIDTH = 22,
+   parameter PARITY_ENABLE = 0                
+     ) 
+  (
+    input  wire           user_clk2_i // 500 MHz clock for core-facing interfaces
+   ,input  wire           user_clk_i // 250 MHz clock for client-facing interfaces
+   ,input  wire           user_clk_en_i // User clock enable for clock domain crossing
+   ,input  wire           reset_n_user_clk_i // Reset in the user clock domain
+   ,input  wire           reset_n_user_clk2_i // Reset in the user clock2 domain
+   ,input  wire           link_down_reset_i // Link went down
+   // Attributes
+   ,input  wire           attr_straddle_en_i // Enable straddle
+   ,input  wire           attr_4tlp_straddle_en_i  // Enable 4-tlp straddle
+   ,input wire [1:0]      attr_alignment_mode_i // Payload alignment mode
+                                                // (00= Dword-aligned, 10 = 128b address-aligned)
+   //-----------------------------------------------------------------------------------------------
+   // Client-side signals
+   //-----------------------------------------------------------------------------------------------
+   ,output wire [511:0]   m_axis_rc_tdata_o
+   ,output wire           m_axis_rc_tvalid_o
+   ,output wire [160:0]   m_axis_rc_tuser_o
+   ,output wire           m_axis_rc_tlast_o
+   ,output wire [15:0]    m_axis_rc_tkeep_o
+   ,input  wire           m_axis_rc_tready_i
+   //-----------------------------------------------------------------------------------------------
+   // Core-side signals
+   //-----------------------------------------------------------------------------------------------
+   ,input  wire [255:0]   core_rc_tdata_i
+   ,input  wire           core_rc_tvalid_i
+   ,input  wire [74:0]    core_rc_tuser_i
+   ,input  wire           core_rc_tlast_i
+   ,input  wire [7:0]     core_rc_tkeep_i
+   ,output wire [21:0]     core_rc_tready_o
+   // Completion delivered indications
+   ,output reg [1:0]      compl_delivered_o // Completions delivered to user
+                                            // 00 = No Compl, 01 = 1 Compl, 11 = 2 Completions
+   ,output reg [7:0]      compl_delivered_tag0_o// Tag associated with first delivered Completion
+   ,output reg [7:0]      compl_delivered_tag1_o// Tag associated with second delivered Completion
+   );
+
+   localparam FIFO_WIDTH = PARITY_ENABLE? (AXI4_CORE_DATA_WIDTH + (AXI4_CORE_RC_TUSER_WIDTH+1) +
+                       AXI4_CORE_RC_TKEEP_WIDTH + 1)*2 +2 :
+               (AXI4_CORE_DATA_WIDTH + (AXI4_CORE_RC_TUSER_WIDTH+1) + 
+                AXI4_CORE_RC_TKEEP_WIDTH + 1)*2 +2 -64;
+
+   localparam TUSER_LOWER_OFFSET = AXI4_CORE_DATA_WIDTH + AXI4_CORE_RC_TKEEP_WIDTH;
+   localparam TUSER_UPPER_OFFSET = PARITY_ENABLE? AXI4_CORE_DATA_WIDTH*2 + AXI4_CORE_RC_TKEEP_WIDTH*2 +
+                   (AXI4_CORE_RC_TUSER_WIDTH+1) +2:
+                   AXI4_CORE_DATA_WIDTH*2 + AXI4_CORE_RC_TKEEP_WIDTH*2 +
+                   (AXI4_CORE_RC_TUSER_WIDTH+1) +2 -32;
+   
+  localparam FIFO_READ_DATA_UPPER_OFFSET = PARITY_ENABLE?
+                   AXI4_CORE_DATA_WIDTH + AXI4_CORE_RC_TKEEP_WIDTH + (AXI4_CORE_RC_TUSER_WIDTH+1) +2:
+                   AXI4_CORE_DATA_WIDTH + AXI4_CORE_RC_TKEEP_WIDTH + (AXI4_CORE_RC_TUSER_WIDTH+1) +2 -32;
+  
+  localparam FIFO_READ_TKEEP_UPPER_OFFSET = PARITY_ENABLE?
+                    AXI4_CORE_DATA_WIDTH*2 + AXI4_CORE_RC_TKEEP_WIDTH + (AXI4_CORE_RC_TUSER_WIDTH+1) +2:
+                                    AXI4_CORE_DATA_WIDTH*2 + AXI4_CORE_RC_TKEEP_WIDTH + (AXI4_CORE_RC_TUSER_WIDTH+1) +2 -32;
+
+   localparam OUTPUT_MUX_IN_DATA_WIDTH = AXI4_USER_DATA_WIDTH +
+                     AXI4_USER_RC_TKEEP_WIDTH +
+                     AXI4_USER_RC_TUSER_WIDTH + 1;
+
+
+   (* KEEP = "true" *) reg [AXI4_CORE_RC_TREADY_WIDTH-1:0] core_rc_tready_reg;
+   (* KEEP = "true" *) reg core_rc_tready_user_clk2;
+
+   reg [AXI4_CORE_DATA_WIDTH-1:0] core_rc_tdata_reg_upper;
+   reg [AXI4_CORE_DATA_WIDTH-1:0] core_rc_tdata_reg_lower;
+   reg [AXI4_CORE_RC_TUSER_WIDTH-1:0] core_rc_tuser_reg_upper;
+   reg [AXI4_CORE_RC_TUSER_WIDTH-1:0] core_rc_tuser_reg_lower;
+   reg                       core_rc_tlast_reg_upper;
+   reg                       core_rc_tlast_reg_lower;
+   reg [AXI4_CORE_RC_TKEEP_WIDTH-1:0] core_rc_tkeep_reg_upper;
+   reg [AXI4_CORE_RC_TKEEP_WIDTH-1:0] core_rc_tkeep_reg_lower;
+   reg                       core_rc_tvalid_reg_upper;
+   reg                       core_rc_tvalid_reg_lower;
+
+   reg [AXI4_CORE_DATA_WIDTH-1:0] core_rc_tdata_reg_upper_user_clk;
+   reg [AXI4_CORE_DATA_WIDTH-1:0] core_rc_tdata_reg_lower_user_clk;
+   reg [AXI4_CORE_RC_TUSER_WIDTH-1:0] core_rc_tuser_reg_upper_user_clk;
+   reg [AXI4_CORE_RC_TUSER_WIDTH-1:0] core_rc_tuser_reg_lower_user_clk;
+   reg                       core_rc_tlast_reg_upper_user_clk;
+   reg                       core_rc_tlast_reg_lower_user_clk;
+   reg [AXI4_CORE_RC_TKEEP_WIDTH-1:0] core_rc_tkeep_reg_upper_user_clk;
+   reg [AXI4_CORE_RC_TKEEP_WIDTH-1:0] core_rc_tkeep_reg_lower_user_clk;
+   reg                       core_rc_tvalid_reg_upper_user_clk;
+   reg                       core_rc_tvalid_reg_lower_user_clk;
+   wire [2:0]                core_rc_eop_ptr_upper;
+   wire [2:0]                core_rc_eop_ptr_lower;
+   wire [AXI4_CORE_RC_TUSER_WIDTH-1:0] core_rc_tuser_reg_upper_user_clk_int;
+   wire [AXI4_CORE_RC_TUSER_WIDTH-1:0] core_rc_tuser_reg_lower_user_clk_int;
+
+
+   wire                   fifo_almost_full_user_clk;
+
+  reg                       core_rc_pkt_in_progress;
+  wire                       core_rc_pkt_in_progress_upper;
+  wire                       core_rc_tuser_sop0_lower;
+  wire                       core_rc_tuser_sop1_lower;
+  wire                       core_rc_tuser_eop0_lower;
+  wire                       core_rc_tuser_eop1_lower;
+  wire                       core_rc_tuser_sop0_upper;
+  wire                       core_rc_tuser_sop1_upper;
+  wire                       core_rc_tuser_eop0_upper;
+  wire                       core_rc_tuser_eop1_upper;
+  
+  wire                       core_rc_tuser_reg_sop0_ptr_lower;
+  wire                       core_rc_tuser_reg_sop0_ptr_upper;
+
+   wire [FIFO_WIDTH-1:0]           fifo_in_data;
+   reg                       fifo_in_data_valid;
+   reg                       fifo_read_en;
+   wire                   fifo_read_data_valid;
+   wire [FIFO_WIDTH-1:0]           fifo_read_data;
+
+   wire                   read_sop0_lower;
+   wire                    read_sop0_ptr_lower;
+   wire                   read_sop1_lower;
+   wire                   read_discontinue_lower;
+   wire                    read_eop0_lower;
+   wire                    read_eop1_lower;
+   wire                    read_eop_lower;
+   wire                   read_tlast_lower;
+   wire                   read_tlast_upper;
+   wire                   read_data_valid_lower;
+   wire                   read_data_valid_upper;
+
+   wire                   read_sop0_upper;
+   wire                    read_sop0_ptr_upper;
+   wire                   read_sop1_upper;
+   wire                   read_sop_upper;
+   wire                   read_discontinue_upper;
+   wire                    read_eop0_upper;
+   wire                    read_eop1_upper;
+   wire                    read_eop_upper;
+
+   reg [1:0]                   read_data_valid_reg;
+   reg [FIFO_WIDTH-1:0]           read_data_reg;
+   reg [FIFO_WIDTH/2-1:0]           saved_data_reg;
+   reg                       saved_eop;
+   reg                       saved_err;
+   
+   wire [31:0]                   read_data_reg_byte_en_lower;
+   wire                    read_data_reg_sop0_lower;
+   wire                    read_data_reg_sop0_ptr_lower;
+   wire                    read_data_reg_sop1_lower;
+   wire                    read_data_reg_discontinue_lower;
+   wire [31:0]                   read_data_reg_parity_lower;
+   wire                    read_data_reg_eop0_lower;
+   wire [2:0]                   read_data_reg_eop0_ptr_lower;
+   wire                    read_data_reg_eop1_lower;
+   wire [2:0]                   read_data_reg_eop1_ptr_lower;
+
+   wire [31:0]                   read_data_reg_byte_en_upper;
+   wire                    read_data_reg_sop0_upper;
+   wire                    read_data_reg_sop0_ptr_upper;
+   wire                    read_data_reg_sop1_upper;
+   wire                    read_data_reg_discontinue_upper;
+   wire [31:0]                   read_data_reg_parity_upper;
+   wire                    read_data_reg_eop0_upper;
+   wire [2:0]                   read_data_reg_eop0_ptr_upper;
+   wire                    read_data_reg_eop1_upper;
+   wire [2:0]                   read_data_reg_eop1_ptr_upper;
+
+  wire                       read_data_reg_tlast_lower;
+  wire                       read_data_reg_tlast_upper;
+
+   wire [63:0]                   read_data_out_byte_en;
+   wire [3:0]                   read_data_out_is_sop;
+   wire [1:0]                   read_data_out_is_sop0_ptr;
+   wire [1:0]                   read_data_out_is_sop1_ptr;
+   wire [1:0]                   read_data_out_is_sop2_ptr;
+   wire [1:0]                   read_data_out_is_sop3_ptr;
+   wire [3:0]                   read_data_out_is_eop;
+   wire [3:0]                   read_data_out_is_eop0_ptr;
+   wire [3:0]                   read_data_out_is_eop1_ptr;
+   wire [3:0]                   read_data_out_is_eop2_ptr;
+   wire [3:0]                   read_data_out_is_eop3_ptr;
+   wire                   read_data_out_discontinue;
+   wire [63:0]                   read_data_out_parity;
+   
+   wire [ AXI4_USER_RC_TUSER_WIDTH-1:0] read_data_out_tuser;
+   wire [ AXI4_USER_DATA_WIDTH-1:0]     read_data_out_tdata;
+   wire [ AXI4_USER_RC_TKEEP_WIDTH-1:0] read_data_out_tkeep;
+   wire                 read_data_out_tlast;
+   
+   wire [OUTPUT_MUX_IN_DATA_WIDTH-1:0]     output_mux_in_data;
+
+   wire                 output_mux_ready;
+   
+  wire [3:0]                 pcie_compl_delivered_user_clk;
+  wire [7:0]                 pcie_compl_delivered_tag0_user_clk;
+  wire [7:0]                 pcie_compl_delivered_tag1_user_clk;
+  wire [7:0]                 pcie_compl_delivered_tag2_user_clk;
+  wire [7:0]                 pcie_compl_delivered_tag3_user_clk;
+
+   // Read State Machine states
+   localparam                           IDLE = 2'd0;
+   localparam                           EXPECT_NEW_WORD = 2'd1;
+   localparam                           SEND_SAVED_HALF_WORD = 2'd2;
+   localparam                           WAIT_FOR_UPPER_HALF = 2'd3;
+   reg [1:0]                 read_state;
+
+   // Capture incoming data from core at 500 MHz into upper and lower registers
+   always @(posedge user_clk2_i)
+     if (~reset_n_user_clk2_i)
+       begin
+      core_rc_tdata_reg_upper <= #TCQ {AXI4_CORE_DATA_WIDTH{1'b0}};
+      core_rc_tdata_reg_lower <= #TCQ {AXI4_CORE_DATA_WIDTH{1'b0}};
+      core_rc_tuser_reg_upper <= #TCQ {AXI4_CORE_RC_TUSER_WIDTH{1'b0}};
+      core_rc_tuser_reg_lower <= #TCQ {AXI4_CORE_RC_TUSER_WIDTH{1'b0}};
+      core_rc_tkeep_reg_upper <= #TCQ {AXI4_CORE_RC_TKEEP_WIDTH{1'b0}};
+      core_rc_tkeep_reg_lower <= #TCQ {AXI4_CORE_RC_TKEEP_WIDTH{1'b0}};
+      core_rc_tlast_reg_upper <= #TCQ 1'b0;
+      core_rc_tlast_reg_lower <= #TCQ 1'b0;
+       core_rc_tvalid_reg_upper <= #TCQ 1'b0;
+      core_rc_tvalid_reg_lower <= #TCQ 1'b0;
+       end // if (~reset_n_user_clk_i)
+     else
+       if (user_clk_en_i)
+     begin
+        core_rc_tdata_reg_lower <= #TCQ core_rc_tdata_i;
+        core_rc_tuser_reg_lower <= #TCQ core_rc_tuser_i;
+        core_rc_tkeep_reg_lower <= #TCQ core_rc_tkeep_i;
+        core_rc_tlast_reg_lower <= #TCQ core_rc_tlast_i;
+        core_rc_tvalid_reg_lower <= #TCQ core_rc_tvalid_i & core_rc_tready_user_clk2;
+     end
+       else
+     begin
+        core_rc_tdata_reg_upper <= #TCQ core_rc_tdata_i;
+        core_rc_tuser_reg_upper <= #TCQ core_rc_tuser_i;
+        core_rc_tkeep_reg_upper <= #TCQ core_rc_tkeep_i;
+        core_rc_tlast_reg_upper <= #TCQ core_rc_tlast_i;
+        core_rc_tvalid_reg_upper <= #TCQ core_rc_tvalid_i & core_rc_tready_user_clk2;
+     end // else: !if(user_clk_en_i)
+
+  // Transfer to 250 MHz user_clk domain
+     always @(posedge user_clk_i)
+     if (~reset_n_user_clk_i)
+       begin
+     core_rc_tdata_reg_upper_user_clk <= #TCQ {AXI4_CORE_DATA_WIDTH{1'b0}};
+     core_rc_tdata_reg_lower_user_clk <= #TCQ {AXI4_CORE_DATA_WIDTH{1'b0}};
+     core_rc_tuser_reg_upper_user_clk <= #TCQ {AXI4_CORE_RC_TUSER_WIDTH{1'b0}};
+     core_rc_tuser_reg_lower_user_clk <= #TCQ {AXI4_CORE_RC_TUSER_WIDTH{1'b0}};
+     core_rc_tkeep_reg_upper_user_clk <= #TCQ {AXI4_CORE_RC_TKEEP_WIDTH{1'b0}};
+     core_rc_tkeep_reg_lower_user_clk <= #TCQ {AXI4_CORE_RC_TKEEP_WIDTH{1'b0}};
+     core_rc_tlast_reg_upper_user_clk <= #TCQ 1'b0;
+     core_rc_tlast_reg_lower_user_clk <= #TCQ 1'b0;
+      core_rc_tvalid_reg_upper_user_clk <= #TCQ 1'b0;
+     core_rc_tvalid_reg_lower_user_clk <= #TCQ 1'b0;
+     fifo_in_data_valid <= #TCQ 1'b0;
+       end // if (~reset_n_user_clk_i)
+     else
+       begin
+            core_rc_tdata_reg_upper_user_clk <= #TCQ core_rc_tdata_reg_upper;
+     core_rc_tdata_reg_lower_user_clk <= #TCQ core_rc_tdata_reg_lower;
+     core_rc_tuser_reg_upper_user_clk <= #TCQ core_rc_tuser_reg_upper;
+     core_rc_tuser_reg_lower_user_clk <= #TCQ core_rc_tuser_reg_lower;
+     core_rc_tkeep_reg_upper_user_clk <= #TCQ core_rc_tkeep_reg_upper;
+     core_rc_tkeep_reg_lower_user_clk <= #TCQ core_rc_tkeep_reg_lower;
+     core_rc_tlast_reg_upper_user_clk <= #TCQ core_rc_tlast_reg_upper;
+     core_rc_tlast_reg_lower_user_clk <= #TCQ core_rc_tlast_reg_lower;
+      core_rc_tvalid_reg_upper_user_clk <= #TCQ core_rc_tvalid_reg_upper;
+     core_rc_tvalid_reg_lower_user_clk <= #TCQ core_rc_tvalid_reg_lower;
+     fifo_in_data_valid <= #TCQ core_rc_tvalid_reg_upper | core_rc_tvalid_reg_lower;
+       end // else: !if(~reset_n_user_clk_i)
+  
+  assign core_rc_eop_ptr_lower   = (core_rc_tkeep_reg_lower_user_clk[7])? 3'd7:
+                                   (core_rc_tkeep_reg_lower_user_clk[6])? 3'd6:
+                                   (core_rc_tkeep_reg_lower_user_clk[5])? 3'd5:
+                                   (core_rc_tkeep_reg_lower_user_clk[4])? 3'd4:
+                                   (core_rc_tkeep_reg_lower_user_clk[3])? 3'd3:
+                                   (core_rc_tkeep_reg_lower_user_clk[2])? 3'd2:
+                                   (core_rc_tkeep_reg_lower_user_clk[1])? 3'd1: 3'd0;
+  assign core_rc_eop_ptr_upper   = (core_rc_tkeep_reg_upper_user_clk[7])? 3'd7:
+                                   (core_rc_tkeep_reg_upper_user_clk[6])? 3'd6:
+                                   (core_rc_tkeep_reg_upper_user_clk[5])? 3'd5:
+                                   (core_rc_tkeep_reg_upper_user_clk[4])? 3'd4:
+                                   (core_rc_tkeep_reg_upper_user_clk[3])? 3'd3:
+                                   (core_rc_tkeep_reg_upper_user_clk[2])? 3'd2:
+                                   (core_rc_tkeep_reg_upper_user_clk[1])? 3'd1: 3'd0;
+  assign core_rc_tuser_reg_lower_user_clk_int   = (~attr_4tlp_straddle_en_i)? {core_rc_tuser_reg_lower_user_clk[AXI4_CORE_RC_TUSER_WIDTH-1:42],
+                                                                               4'd0,   // [41:38], is_eop_1[3:0]
+                                                                               core_rc_eop_ptr_lower, // [37:35]
+                                                                               core_rc_tlast_reg_lower_user_clk,  // [34]
+                                                                               1'b0,   // [33], is_sop_1
+                                                                               core_rc_tuser_reg_lower_user_clk[32:0]}:
+                                                                              core_rc_tuser_reg_lower_user_clk;
+  assign core_rc_tuser_reg_upper_user_clk_int   = (~attr_4tlp_straddle_en_i)? {core_rc_tuser_reg_upper_user_clk[AXI4_CORE_RC_TUSER_WIDTH-1:42],
+                                                                               4'd0,   // [41:38], is_eop_1[3:0]
+                                                                               core_rc_eop_ptr_upper, // [37:35]
+                                                                               core_rc_tlast_reg_upper_user_clk,  // [34]
+                                                                               1'b0,   // [33], is_sop_1
+                                                                               core_rc_tuser_reg_upper_user_clk[32:0]}:
+                                                                              core_rc_tuser_reg_upper_user_clk;
+  // Generate SOP0 Pointer for lower and upper halves.
+  // This requires keeping track of whether a packet is continuing from the last beat.
+  assign core_rc_tuser_sop0_lower = core_rc_tuser_reg_lower_user_clk_int[32];
+  assign core_rc_tuser_sop1_lower = core_rc_tuser_reg_lower_user_clk_int[33];
+  assign core_rc_tuser_eop0_lower = core_rc_tuser_reg_lower_user_clk_int[34];
+  assign core_rc_tuser_eop1_lower = core_rc_tuser_reg_lower_user_clk_int[38];
+
+  assign core_rc_tuser_sop0_upper = core_rc_tuser_reg_upper_user_clk_int[32];
+  assign core_rc_tuser_sop1_upper = core_rc_tuser_reg_upper_user_clk_int[33];
+  assign core_rc_tuser_eop0_upper = core_rc_tuser_reg_upper_user_clk_int[34];
+  assign core_rc_tuser_eop1_upper = core_rc_tuser_reg_upper_user_clk_int[38];
+
+  always @(posedge user_clk_i)
+    if (~reset_n_user_clk_i)
+      core_rc_pkt_in_progress <= #TCQ 1'b0;
+    else if (link_down_reset_i)
+      core_rc_pkt_in_progress <= #TCQ 1'b0;
+    else
+      if (~core_rc_pkt_in_progress)
+    begin
+      case({core_rc_tvalid_reg_upper_user_clk, core_rc_tvalid_reg_lower_user_clk})
+        2'b00:
+          begin
+          end
+        2'b01:
+          begin
+        core_rc_pkt_in_progress <= #TCQ 1'b0;
+          end
+        2'b10:
+          begin
+        core_rc_pkt_in_progress <= #TCQ ~core_rc_tuser_eop0_upper |
+                       (core_rc_tuser_sop1_upper & ~core_rc_tuser_eop1_upper);
+          end
+        2'b11:
+          begin
+        core_rc_pkt_in_progress <= #TCQ ((~core_rc_tuser_eop0_lower |
+                          (core_rc_tuser_sop1_lower & ~core_rc_tuser_eop1_lower)) &
+                          (~core_rc_tuser_eop0_upper |
+                           (core_rc_tuser_sop0_upper & ~core_rc_tuser_eop1_upper))) |
+                       (((core_rc_tuser_eop0_lower & ~core_rc_tuser_sop1_lower) |
+                         core_rc_tuser_eop1_lower) &
+                        (~core_rc_tuser_eop0_upper |
+                         (core_rc_tuser_sop1_upper & ~core_rc_tuser_eop1_upper)));
+          end // case: 2'b11
+      endcase // case({core_rc_tvalid_reg_upper_user_clk, core_rc_tvalid_reg_lower_user_clk})
+    end // if (~core_rc_pkt_in_progress)
+      else
+      begin      
+      case({core_rc_tvalid_reg_upper_user_clk, core_rc_tvalid_reg_lower_user_clk})
+        2'b00:
+          begin
+          end
+        2'b01:
+          begin
+        core_rc_pkt_in_progress <= #TCQ 1'b0;
+          end
+        2'b10:
+          begin
+        // Invalid case
+        core_rc_pkt_in_progress <= #TCQ 1'b0;
+          end
+         2'b11:
+           begin
+         core_rc_pkt_in_progress <= #TCQ ((~core_rc_tuser_eop0_lower |
+                           (core_rc_tuser_sop0_lower & ~core_rc_tuser_eop1_lower)) &
+                          (~core_rc_tuser_eop0_upper |
+                           (core_rc_tuser_sop0_upper & ~core_rc_tuser_eop1_upper))) |
+                        (((core_rc_tuser_eop0_lower & ~core_rc_tuser_sop0_lower) |
+                          core_rc_tuser_eop1_lower) &
+                         (~core_rc_tuser_eop0_upper |
+                          (core_rc_tuser_sop1_upper & ~core_rc_tuser_eop1_upper)));
+           end // case: 2'b11
+      endcase // case({core_rc_tvalid_reg_upper_user_clk, core_rc_tvalid_reg_lower_user_clk})
+    end // else: !if(~core_rc_pkt_in_progress)
+
+  assign core_rc_pkt_in_progress_upper = ~core_rc_tvalid_reg_lower_user_clk? 1'b0:
+                     core_rc_pkt_in_progress? (~core_rc_tuser_eop0_lower |
+                                   (core_rc_tuser_sop0_lower & ~core_rc_tuser_eop1_lower)):
+                     (~core_rc_tuser_eop0_lower |
+                      (core_rc_tuser_sop1_lower & ~core_rc_tuser_eop1_lower));
+
+  assign core_rc_tuser_reg_sop0_ptr_lower = ~attr_straddle_en_i? 1'b0:
+     core_rc_pkt_in_progress? 
+     core_rc_tvalid_reg_lower_user_clk & core_rc_tuser_sop0_lower : 1'b0;
+
+  assign core_rc_tuser_reg_sop0_ptr_upper = ~attr_straddle_en_i? 1'b0:
+     core_rc_pkt_in_progress_upper? 
+         core_rc_tvalid_reg_upper_user_clk & core_rc_tuser_sop0_upper : 1'b0;
+  
+   // Write data into FIFO using 250 MHz user_clk
+
+  generate
+    if (PARITY_ENABLE)
+      assign fifo_in_data =
+          {
+       core_rc_tvalid_reg_upper_user_clk,
+       core_rc_tlast_reg_upper_user_clk,
+       core_rc_tuser_reg_sop0_ptr_upper, 
+       core_rc_tuser_reg_upper_user_clk_int,
+       core_rc_tkeep_reg_upper_user_clk,
+       core_rc_tdata_reg_upper_user_clk,
+       core_rc_tvalid_reg_lower_user_clk,
+       core_rc_tlast_reg_lower_user_clk,
+       core_rc_tuser_reg_sop0_ptr_lower, 
+       core_rc_tuser_reg_lower_user_clk_int,
+       core_rc_tkeep_reg_lower_user_clk,
+       core_rc_tdata_reg_lower_user_clk
+       };
+    else
+      assign fifo_in_data =
+          {
+       core_rc_tvalid_reg_upper_user_clk,
+       core_rc_tlast_reg_upper_user_clk,
+       core_rc_tuser_reg_sop0_ptr_upper, 
+       core_rc_tuser_reg_upper_user_clk_int[42:0],
+       core_rc_tkeep_reg_upper_user_clk,
+       core_rc_tdata_reg_upper_user_clk,
+       core_rc_tvalid_reg_lower_user_clk,
+       core_rc_tlast_reg_lower_user_clk,
+       core_rc_tuser_reg_sop0_ptr_lower, 
+       core_rc_tuser_reg_lower_user_clk_int[42:0],
+       core_rc_tkeep_reg_lower_user_clk,
+       core_rc_tdata_reg_lower_user_clk
+       };
+  endgenerate
+
+   // Generate ready to core in the user_clk2 domain
+   always @(posedge user_clk2_i)
+     if (~reset_n_user_clk2_i)
+       begin
+      core_rc_tready_user_clk2 <= #TCQ 1'b0;
+      core_rc_tready_reg <= #TCQ {AXI4_CORE_RC_TREADY_WIDTH{1'b0}};
+       end
+     else
+       begin
+             core_rc_tready_user_clk2 <= #TCQ ~fifo_almost_full_user_clk;
+      core_rc_tready_reg <= #TCQ {AXI4_CORE_RC_TREADY_WIDTH{~fifo_almost_full_user_clk}};
+       end
+
+   assign core_rc_tready_o = core_rc_tready_reg;
+ 
+
+   // Main FIFO instance
+   xp4_usp_smsw_512b_sync_fifo #
+     (
+      .TCQ(TCQ),
+      .IMPL_TARGET(IMPL_TARGET),
+      .AXISTEN_IF_EXT_512_INTFC_RAM_STYLE(AXISTEN_IF_EXT_512_INTFC_RAM_STYLE),
+      .FIFO_WIDTH(FIFO_WIDTH),
+      .FIFO_DEPTH(8),
+      .FIFO_ALMOST_FULL_THRESHOLD(5)
+      )
+     pcie_4_0_512b_sync_fifo_blk
+       (
+        .clk_i(user_clk_i),
+        .reset_n_i(reset_n_user_clk_i),
+        .link_down_reset_i(link_down_reset_i),
+    .write_data_i(fifo_in_data),
+    .write_en_i(fifo_in_data_valid),
+    .read_en_i(fifo_read_en),
+    .read_data_o(fifo_read_data),
+    .read_data_valid_o(fifo_read_data_valid),
+    .fifo_almost_full(fifo_almost_full_user_clk)
+    );
+   
+   // Read-side logic
+
+   assign read_sop0_lower = fifo_read_data[TUSER_LOWER_OFFSET + 32];
+   assign read_sop1_lower = fifo_read_data[TUSER_LOWER_OFFSET + 33];
+   assign  read_eop0_lower = fifo_read_data[TUSER_LOWER_OFFSET + 34];
+   assign  read_eop1_lower = fifo_read_data[TUSER_LOWER_OFFSET + 38];
+   assign read_discontinue_lower = fifo_read_data[TUSER_LOWER_OFFSET + 42];
+
+   assign read_sop0_upper = fifo_read_data[TUSER_UPPER_OFFSET + 32];
+   assign read_sop1_upper = fifo_read_data[TUSER_UPPER_OFFSET + 33];
+   assign  read_eop0_upper = fifo_read_data[TUSER_UPPER_OFFSET + 34];
+   assign  read_eop1_upper = fifo_read_data[TUSER_UPPER_OFFSET + 38];
+   assign read_discontinue_upper = fifo_read_data[TUSER_UPPER_OFFSET + 42];
+
+  generate
+    if (PARITY_ENABLE)
+      begin
+    assign read_sop0_ptr_lower = fifo_read_data[TUSER_LOWER_OFFSET + AXI4_CORE_RC_TUSER_WIDTH];
+    assign read_sop0_ptr_upper = fifo_read_data[TUSER_UPPER_OFFSET + AXI4_CORE_RC_TUSER_WIDTH];
+    assign read_tlast_lower = fifo_read_data[AXI4_CORE_DATA_WIDTH + AXI4_CORE_RC_TKEEP_WIDTH +
+                         AXI4_CORE_RC_TUSER_WIDTH+1];
+    assign read_tlast_upper = fifo_read_data[AXI4_CORE_DATA_WIDTH*2 + AXI4_CORE_RC_TKEEP_WIDTH*2 +
+                         (AXI4_CORE_RC_TUSER_WIDTH+1)*2 +2];
+      end
+    else
+      begin
+    assign read_sop0_ptr_lower = fifo_read_data[TUSER_LOWER_OFFSET + AXI4_CORE_RC_TUSER_WIDTH-32];
+    assign read_sop0_ptr_upper = fifo_read_data[TUSER_UPPER_OFFSET + AXI4_CORE_RC_TUSER_WIDTH-64];
+    assign read_tlast_lower = fifo_read_data[AXI4_CORE_DATA_WIDTH + AXI4_CORE_RC_TKEEP_WIDTH +
+                         (AXI4_CORE_RC_TUSER_WIDTH+1) -32];
+    assign read_tlast_upper = fifo_read_data[AXI4_CORE_DATA_WIDTH*2 + AXI4_CORE_RC_TKEEP_WIDTH*2 +
+                         (AXI4_CORE_RC_TUSER_WIDTH+1)*2 +2 -64];
+      end // else: !if(PARITY_ENABLE)
+  endgenerate
+
+    assign        read_data_valid_lower = fifo_read_data[FIFO_WIDTH/2-1] & fifo_read_data_valid;
+    assign        read_data_valid_upper = fifo_read_data[FIFO_WIDTH-1] & fifo_read_data_valid;
+
+  assign        read_sop_upper = read_sop0_upper;
+
+  assign        read_eop_lower = ~attr_straddle_en_i? read_tlast_lower:
+           ~read_sop0_lower? // No new TLP starting
+           read_eop0_lower:
+           (read_sop0_lower & ~read_sop0_ptr_lower)? // New TLP starting on DW 0
+           ((read_eop0_lower & ~read_sop1_lower) | read_eop1_lower):
+           (read_sop0_lower & read_sop0_ptr_lower)? // TLP contiuning from last beat, new TLP starting on DW 4
+           read_eop1_lower: 1'b0;
+  
+  assign        read_eop_upper = ~attr_straddle_en_i? read_tlast_upper:
+           ~read_sop0_upper? // No new TLP starting
+           read_eop0_upper:
+           (read_sop0_upper & ~read_sop0_ptr_upper)? // New TLP starting on DW 0
+           ((read_eop0_upper & ~read_sop1_upper) | read_eop1_upper):
+           (read_sop0_upper & read_sop0_ptr_upper)? // TLP contiuning from last beat, new TLP starting on DW 4
+           read_eop1_upper: 1'b0;
+
+   // Read State Machine States
+   //
+   // IDLE: Currently not forwarding a packet.  Read data register is either empty, or contains the last beat of a packet.
+   // EXPECT_NEW_WORD: Currently forwarding a packet, and there is no data saved from a previous beat
+   // SEND_SAVED_HALF_WORD: There is a half-word saved from a previous beat in the saved data register.
+   // WAIT_FOR_UPPER_HALF: There is a half-word saved from a previous beat in the read data register which does not end with an EOP.
+   
+   always @(posedge user_clk_i)
+     if (~reset_n_user_clk_i)
+       begin
+      read_data_valid_reg <= #TCQ 2'b00;
+      read_state <= #TCQ IDLE;
+       end
+     else if (link_down_reset_i)
+       begin
+      read_data_valid_reg <= #TCQ 2'b00;
+      read_state <= #TCQ IDLE;
+       end
+     else
+    case(read_state)
+      IDLE:
+        begin
+           // IDLE: Currently not forwarding a packet.  Read data register is either empty, or contains the last beat of a packet.
+           if ((read_data_valid_reg == 2'b00) | output_mux_ready)
+         begin
+            if (read_data_valid_lower)
+              // New TLP starting in the lower half of the incoming word.
+              // Update the lower half of the data register with the lower half of the incoming word.
+              begin
+             if (read_data_valid_upper)
+               // Both halves of the incoming word have valid data in them.
+               begin
+                  // If straddle is not enabled and the packet in the upper half is a new one,
+                  // Save it for next cycle.
+                  // Also, if the packet in the lower half ends with an error, do not fill the upper half.
+                  if ((~attr_straddle_en_i & read_sop_upper)|
+                  read_discontinue_lower)
+                begin
+                   read_data_valid_reg <= #TCQ 2'b01;
+                   read_state <= #TCQ SEND_SAVED_HALF_WORD;
+                end
+                  else
+                begin
+                   read_data_valid_reg <= #TCQ 2'b11;
+                  if (read_eop_upper)
+                     read_state <= #TCQ IDLE;
+                   else
+                     read_state <= #TCQ EXPECT_NEW_WORD;
+                end // else: !if(~attr_straddle_en_i & read_sop_upper)
+               end // if (read_data_valid_upper)
+             else
+               begin
+                  // New TLP started in the lower half, but there is no valid data in the upper half.
+                  if (read_eop_lower)
+                // We have a complete TLP in the lower half, send it.
+                begin
+                   read_data_valid_reg <= #TCQ 2'b01;
+                   read_state <= #TCQ IDLE;
+                end
+                  else
+                begin
+                   // Wait for more data to fill upper half of read data register.
+                   read_data_valid_reg <= #TCQ 2'b00;
+                   read_state <= #TCQ WAIT_FOR_UPPER_HALF;
+                end // else: !if(read_eop_lower)
+               end // else: !if(read_data_valid_upper)
+              end // if (read_data_valid_lower)
+            else
+              if (read_data_valid_upper)
+            begin
+               // No valid data in the lower half of the incoming word, but there is a packet starting in the upper half.
+               if (read_eop_upper)
+                 // We have a complete packet, send it in the lower half.
+                 begin
+                read_data_valid_reg <= #TCQ 2'b01;
+                read_state <= #TCQ IDLE;
+                 end
+               else
+                 begin
+                // Save the upper half of the incoming word
+                // and wait for more data.
+                read_data_valid_reg <= #TCQ 2'b00;
+                read_state <= #TCQ WAIT_FOR_UPPER_HALF;
+                 end // else: !if(read_eop_upper)
+            end // if (read_data_valid_upper)
+              else
+            // No valid data from FIFO
+            begin
+               if (output_mux_ready)
+                 read_data_valid_reg <= #TCQ 2'b00;
+               read_state <= #TCQ IDLE;
+            end // else: !if(read_data_valid_upper)
+         end // if ((read_data_valid_reg == 2'b00) | output_mux_ready)
+        end // case: IDLE
+      
+      EXPECT_NEW_WORD:
+        begin
+           // Currently forwarding a packet.  There is no saved data.
+           if ((read_data_valid_reg == 2'b00) | output_mux_ready)
+         begin
+            if (read_data_valid_lower)
+              // New data starting in the lower half of the incoming word.
+              // Update the lower half of the data register with the lower half of the incoming word.
+              begin
+             if (read_data_valid_upper)
+               // Both halves of the incoming word have valid data in them.
+               begin
+                  // If straddle is not enabled and the packet in the upper half is a new one,
+                  // Save it for next cycle.
+                  // Also, if the packet in the lower half ends with an error, do not fill the upper half.
+                  if ((~attr_straddle_en_i & read_sop_upper)|
+                  read_discontinue_lower)
+                begin
+                   read_data_valid_reg <= #TCQ 2'b01;
+                   read_state <= #TCQ SEND_SAVED_HALF_WORD;
+                end
+                  else
+                begin
+                   read_data_valid_reg <= #TCQ 2'b11;
+                  if (read_eop_upper)
+                     read_state <= #TCQ IDLE;
+                  else
+                     read_state <= #TCQ EXPECT_NEW_WORD;
+                end // else: !if((~attr_straddle_en_i & read_sop_upper)|...
+               end // if (read_data_valid_upper)
+             else
+               begin
+                  // Valid data in the lower half, but no valid data in the upper half.
+                  if (read_eop_lower)
+                // We have the packet ending in the lower half, send it.
+                begin
+                   read_data_valid_reg <= #TCQ 2'b01;
+                   read_state <= #TCQ IDLE;
+                end
+                  else
+                begin
+                   // Wait for more data to fill upper half of read data register.
+                   read_data_valid_reg <= #TCQ 2'b00;
+                   read_state <= #TCQ WAIT_FOR_UPPER_HALF;
+                end // else: !if(read_eop_lower)
+               end // else: !if(read_data_valid_upper)
+              end // if (read_data_valid_lower)
+            else
+              if (read_data_valid_upper)
+            begin
+               // No valid data in the lower half of the incoming word, but there is data in the upper half.
+               if (read_eop_upper)
+                 // We have a complete packet, send it in the lower half.
+                 begin
+                read_data_valid_reg <= #TCQ 2'b01;
+                read_state <= #TCQ IDLE;
+                 end
+               else
+                 begin
+                // Save the upper half of the incoming word
+                // and wait for more data.
+                read_data_valid_reg <= #TCQ 2'b00;
+                read_state <= #TCQ WAIT_FOR_UPPER_HALF;
+                 end // else: !if(read_eop_upper)
+            end // if (read_data_valid_upper)
+              else
+            // No valid data from FIFO
+            begin
+               if (output_mux_ready)
+                 read_data_valid_reg <= #TCQ 2'b00;
+               read_state <= #TCQ EXPECT_NEW_WORD;
+            end // else: !if(read_data_valid_upper)
+         end // if ((read_data_valid_reg == 2'b00) | output_mux_ready)
+        end // case: EXPECT_NEW_WORD
+
+      SEND_SAVED_HALF_WORD:
+        begin
+           // There is a half-word saved from a previous beat in the saved data register.
+           if ((read_data_valid_reg == 2'b00) | output_mux_ready)
+         begin
+            if ((~attr_straddle_en_i & saved_eop) | saved_err)
+              // Saved data is the last beat of a packet and straddle is disabled.
+              // Do not fill the upper half of read data register.
+              begin
+            read_data_valid_reg <= #TCQ 2'b01;
+            read_state <= #TCQ IDLE;
+              end
+            else
+              if (read_data_valid_lower)
+            // New data starting in the lower half of the incoming word.
+            // Update the upper half of the data register with the lower half of the incoming word.
+            begin
+               if (read_data_valid_upper)
+                 // Both halves of the incoming word have valid data in them.
+                 begin
+                read_data_valid_reg <= #TCQ 2'b11;
+                read_state <= #TCQ SEND_SAVED_HALF_WORD;
+                 end
+               else
+                 begin
+                read_data_valid_reg <= #TCQ 2'b11;
+                if (read_eop_lower)
+                  read_state <= #TCQ IDLE;
+                else
+                  read_state <= #TCQ EXPECT_NEW_WORD;
+                 end // else: !if(read_data_valid_upper)
+            end // if (read_data_valid_lower)
+              else
+            if (read_data_valid_upper)
+              begin
+                 // No valid data in the lower half of the incoming word, but there is data in the upper half.
+                 if (read_eop_upper)
+                   // We have a complete packet, send it in the upper half.
+                   begin
+                  read_data_valid_reg <= #TCQ 2'b11;
+                  read_state <= #TCQ IDLE;
+                   end
+                 else
+                   begin
+                  read_data_valid_reg <= #TCQ 2'b11;
+                  read_state <= #TCQ EXPECT_NEW_WORD;
+                   end // else: !if(read_eop_upper)
+              end // if (read_data_valid_upper)
+            else
+              // No valid data from FIFO
+              begin
+                read_data_valid_reg <= #TCQ 2'b01;
+                read_state <= #TCQ IDLE;
+              end // else: !if(read_data_valid_upper)
+         end // if ((read_data_valid_reg == 2'b00) | output_mux_ready)
+        end // case: SEND_SAVED_HALF_WORD
+
+      WAIT_FOR_UPPER_HALF:
+        begin
+           // There is a half-word saved from a previous beat in the read data register which does not end with an EOP.
+           if ((read_data_valid_reg == 2'b00) | output_mux_ready)
+         begin
+            if (read_data_valid_lower)
+              // New data starting in the lower half of the incoming word.
+              // Update the upper half of the data register with the lower half of the incoming word.
+              begin
+             read_data_valid_reg <= #TCQ 2'b11;
+             if (read_data_valid_upper)
+               // Both halves of the incoming word have valid data in them.
+               begin
+                 if (read_eop_upper)
+                   read_state <= #TCQ SEND_SAVED_HALF_WORD;
+                 else
+                   read_state <= #TCQ WAIT_FOR_UPPER_HALF;
+               end
+             else
+               begin
+                 if (read_eop_lower)
+                   read_state <= #TCQ IDLE;
+                 else
+                   read_state <= #TCQ EXPECT_NEW_WORD;
+               end // else: !if(read_data_valid_upper)
+              end // if (read_data_valid_lower)
+            else
+              if (read_data_valid_upper)
+            begin
+               // No valid data in the lower half of the incoming word, but there is data in the upper half.
+               read_data_valid_reg <= #TCQ 2'b11;
+               if (read_eop_upper)
+                 read_state <= #TCQ IDLE;
+               else
+                 read_state <= #TCQ EXPECT_NEW_WORD;
+            end // if (read_data_valid_upper)
+              else
+            begin
+               read_data_valid_reg <= #TCQ 2'b00;
+               read_state <= #TCQ WAIT_FOR_UPPER_HALF;
+            end // else: !if(read_data_valid_upper)
+         end // if ((read_data_valid_reg == 2'b00) | output_mux_ready)
+        end // case: WAIT_FOR_UPPER_HALF
+    endcase // case(read_state)
+
+   always @(posedge user_clk_i)
+     if (~reset_n_user_clk_i)
+       begin
+      read_data_reg <= #TCQ {FIFO_WIDTH{1'b0}};
+      saved_data_reg <= #TCQ {FIFO_WIDTH/2{1'b0}};
+      saved_eop <= #TCQ 1'b0;
+      saved_err <= #TCQ 1'b0;
+       end
+     else
+    case(read_state)
+      IDLE:
+        begin
+           // IDLE: Currently not forwarding a packet.  Read data register is either empty, or contains the last beat of a packet.
+           if ((read_data_valid_reg == 2'b00) | output_mux_ready)
+         begin
+            if (read_data_valid_lower)
+              read_data_reg[FIFO_WIDTH/2-1:0] <= #TCQ fifo_read_data[FIFO_WIDTH/2-1:0];
+            else
+              read_data_reg[FIFO_WIDTH/2-1:0] <= #TCQ fifo_read_data[FIFO_WIDTH-1: FIFO_WIDTH/2];
+            read_data_reg[FIFO_WIDTH-1: FIFO_WIDTH/2] <= #TCQ fifo_read_data[FIFO_WIDTH-1: FIFO_WIDTH/2];
+            saved_data_reg <= #TCQ fifo_read_data[FIFO_WIDTH-1:FIFO_WIDTH/2];
+            saved_eop <= #TCQ read_eop_upper;
+            saved_err <= #TCQ read_discontinue_upper;
+         end
+        end // case: IDLE
+
+      EXPECT_NEW_WORD:
+        begin
+           // Currently not forwarding a packet.  
+           // Read data register is either empty, or contains the last beat of a packet.           
+           if ((read_data_valid_reg == 2'b00) | output_mux_ready)
+         begin
+            if (read_data_valid_lower)
+              read_data_reg[FIFO_WIDTH/2-1:0] <= #TCQ fifo_read_data[FIFO_WIDTH/2-1:0];
+            else
+              read_data_reg[FIFO_WIDTH/2-1:0] <= #TCQ fifo_read_data[FIFO_WIDTH-1: FIFO_WIDTH/2];
+            read_data_reg[FIFO_WIDTH-1: FIFO_WIDTH/2] <= #TCQ fifo_read_data[FIFO_WIDTH-1: FIFO_WIDTH/2];
+            saved_data_reg <= #TCQ fifo_read_data[FIFO_WIDTH-1:FIFO_WIDTH/2];
+            saved_eop <= #TCQ read_eop_upper;
+            saved_err <= #TCQ read_discontinue_upper;
+         end
+        end // case: EXPECT_NEW_WORD
+      
+      SEND_SAVED_HALF_WORD:
+        begin
+           // There is a half-word saved from a previous beat in the saved data register.
+           if ((read_data_valid_reg == 2'b00) | output_mux_ready)
+         begin
+            read_data_reg[FIFO_WIDTH/2-1:0] <= #TCQ saved_data_reg[FIFO_WIDTH/2-1: 0];
+            if (read_data_valid_lower)
+              read_data_reg[FIFO_WIDTH-1: FIFO_WIDTH/2] <= #TCQ fifo_read_data[FIFO_WIDTH/2-1: 0];
+            else
+              read_data_reg[FIFO_WIDTH-1: FIFO_WIDTH/2] <= #TCQ fifo_read_data[FIFO_WIDTH-1: FIFO_WIDTH/2];
+            
+
+            if ((~attr_straddle_en_i & saved_eop) | saved_err)
+              // Save incoming data for next cycle.
+              begin
+             if (read_data_valid_lower)
+               begin
+                  saved_data_reg <= #TCQ fifo_read_data[FIFO_WIDTH/2-1: 0];
+                  saved_eop <= #TCQ read_eop_lower;
+                  saved_err <= #TCQ read_discontinue_lower;
+               end
+             else
+               begin
+                  saved_data_reg <= #TCQ fifo_read_data[FIFO_WIDTH-1: FIFO_WIDTH/2];
+                  saved_eop <= #TCQ read_eop_upper;
+                  saved_err <= #TCQ read_discontinue_upper;
+               end
+              end
+            else
+              begin
+             saved_data_reg <= #TCQ fifo_read_data[FIFO_WIDTH-1: FIFO_WIDTH/2];
+             saved_eop <= #TCQ read_eop_upper;
+             saved_err <= #TCQ read_discontinue_upper;
+              end // else: !if((~attr_straddle_en_i & saved_eop) | saved_err)
+         end // if ((read_data_valid_reg == 2'b00) | output_mux_ready)
+        end // case: SEND_SAVED_HALF_WORD
+      WAIT_FOR_UPPER_HALF:
+        begin
+           // There is a half-word saved from a previous beat in the read data register which does not end with an EOP.
+           if ((read_data_valid_reg == 2'b00) | output_mux_ready)
+         begin
+           read_data_reg[FIFO_WIDTH/2-1:0] <= #TCQ saved_data_reg[FIFO_WIDTH/2-1:0];
+            if (read_data_valid_lower)
+              read_data_reg[FIFO_WIDTH-1: FIFO_WIDTH/2] <= #TCQ fifo_read_data[FIFO_WIDTH/2-1: 0];
+            else
+              read_data_reg[FIFO_WIDTH-1: FIFO_WIDTH/2] <= #TCQ {FIFO_WIDTH/2{1'b0}};
+              // Save incoming data for next cycle.
+            saved_data_reg <= #TCQ fifo_read_data[FIFO_WIDTH-1: FIFO_WIDTH/2];
+            saved_eop <= #TCQ read_eop_upper;
+            saved_err <= #TCQ read_discontinue_upper;
+         end
+        end // case: WAIT_FOR_UPPER_HALF
+    endcase // case(read_state)
+         
+   // Generate upstream ready
+   always @(*)
+     begin
+    case(read_state)
+      IDLE:
+        begin
+           fifo_read_en = (read_data_valid_reg == 2'b00) | output_mux_ready;
+        end
+      
+      EXPECT_NEW_WORD:
+        begin
+           fifo_read_en = (read_data_valid_reg == 2'b00) | output_mux_ready;
+        end
+
+      SEND_SAVED_HALF_WORD:
+        begin
+           // There is a half-word saved from a previous beat in the saved data register.
+           if ((read_data_valid_reg == 2'b00) | output_mux_ready)
+         begin
+            if ((~attr_straddle_en_i & saved_eop) | saved_err)
+              // Saved data is the last beat of a packet and straddle is disabled.
+              // Do not fill the upper half of read data register.
+              fifo_read_en = 1'b0;
+            else
+              fifo_read_en = 1'b1;
+         end
+           else
+         fifo_read_en = 1'b0;
+        end // case: SEND_SAVED_HALF_WORD
+
+      WAIT_FOR_UPPER_HALF:
+        begin
+           // There is a half-word saved from a previous beat in the read data register which does not end with an EOP.
+           fifo_read_en = (read_data_valid_reg == 2'b00) | output_mux_ready;
+        end
+    endcase // case(read_state)
+     end // always @ (*)
+   
+   assign read_data_reg_byte_en_lower = read_data_reg[TUSER_LOWER_OFFSET +31:
+                                 TUSER_LOWER_OFFSET];
+   assign read_data_reg_sop0_lower = read_data_reg[TUSER_LOWER_OFFSET + 32];
+  assign  read_data_reg_sop1_lower = attr_straddle_en_i? read_data_reg[TUSER_LOWER_OFFSET + 33]: 1'b0;
+   assign read_data_reg_eop0_lower = attr_straddle_en_i? read_data_reg[TUSER_LOWER_OFFSET + 34]:
+      read_data_reg_tlast_lower;
+   assign read_data_reg_eop0_ptr_lower[2:0] = read_data_reg[TUSER_LOWER_OFFSET + 37:
+                                TUSER_LOWER_OFFSET + 35];
+  assign  read_data_reg_eop1_lower = attr_straddle_en_i? read_data_reg[TUSER_LOWER_OFFSET + 38]: 1'b0;
+   assign read_data_reg_eop1_ptr_lower[2:0] = attr_straddle_en_i? read_data_reg[TUSER_LOWER_OFFSET + 41:
+                                        TUSER_LOWER_OFFSET + 39]: 3'd0;
+   assign read_data_reg_discontinue_lower = read_data_reg[TUSER_LOWER_OFFSET + 42];
+
+  generate
+    if (PARITY_ENABLE)
+      begin
+    assign read_data_reg_parity_lower = read_data_reg[TUSER_LOWER_OFFSET + 74:   
+                                   TUSER_LOWER_OFFSET + 43];
+    assign read_data_reg_sop0_ptr_lower = read_data_reg[TUSER_LOWER_OFFSET + 75];
+      end
+    else
+      begin
+    assign read_data_reg_parity_lower = 32'd0;
+    assign read_data_reg_sop0_ptr_lower = read_data_reg[TUSER_LOWER_OFFSET + 43];
+      end // else: !if(PARITY_ENABLE)
+  endgenerate
+  
+  assign     read_data_reg_byte_en_upper = read_data_reg[TUSER_UPPER_OFFSET +31:
+                                 TUSER_UPPER_OFFSET];
+   assign read_data_reg_sop0_upper = read_data_reg[TUSER_UPPER_OFFSET + 32];
+  assign  read_data_reg_sop1_upper = attr_straddle_en_i? read_data_reg[TUSER_UPPER_OFFSET + 33]: 1'b0;
+   assign read_data_reg_eop0_upper = attr_straddle_en_i? read_data_reg[TUSER_UPPER_OFFSET + 34]:
+      read_data_reg_tlast_upper;
+   assign read_data_reg_eop0_ptr_upper[2:0] = read_data_reg[TUSER_UPPER_OFFSET + 37:
+                                TUSER_UPPER_OFFSET + 35];
+   assign read_data_reg_eop1_upper = attr_straddle_en_i? read_data_reg[TUSER_UPPER_OFFSET + 38]: 1'b0;
+   assign read_data_reg_eop1_ptr_upper[2:0] = attr_straddle_en_i? read_data_reg[TUSER_UPPER_OFFSET + 41:
+                                        TUSER_UPPER_OFFSET + 39]: 3'd0;
+   assign read_data_reg_discontinue_upper = read_data_reg[TUSER_UPPER_OFFSET + 42];
+
+  generate
+    if (PARITY_ENABLE)
+      begin
+    assign read_data_reg_parity_upper = read_data_reg[TUSER_UPPER_OFFSET + 74:   
+                                   TUSER_UPPER_OFFSET + 43];
+    assign read_data_reg_sop0_ptr_upper = read_data_reg[TUSER_UPPER_OFFSET + 75];
+      end
+    else
+      begin
+    assign read_data_reg_parity_upper = 32'd0;
+    assign read_data_reg_sop0_ptr_upper = read_data_reg[TUSER_UPPER_OFFSET + 43];
+      end // else: !if(PARITY_ENABLE)
+  endgenerate
+
+  generate
+    if (PARITY_ENABLE)
+      begin
+    assign  read_data_reg_tlast_lower = read_data_reg[AXI4_CORE_DATA_WIDTH + AXI4_CORE_RC_TKEEP_WIDTH +
+                              AXI4_CORE_RC_TUSER_WIDTH+1];
+    assign     read_data_reg_tlast_upper = read_data_reg[AXI4_CORE_DATA_WIDTH*2 + AXI4_CORE_RC_TKEEP_WIDTH*2 +
+                              (AXI4_CORE_RC_TUSER_WIDTH+1)*2 +2];
+      end
+    else
+      begin
+    assign  read_data_reg_tlast_lower = read_data_reg[AXI4_CORE_DATA_WIDTH + AXI4_CORE_RC_TKEEP_WIDTH +
+                              AXI4_CORE_RC_TUSER_WIDTH+1 -32];
+    assign     read_data_reg_tlast_upper = read_data_reg[AXI4_CORE_DATA_WIDTH*2 + AXI4_CORE_RC_TKEEP_WIDTH*2 +
+                              (AXI4_CORE_RC_TUSER_WIDTH+1)*2 +2 -64];
+      end // else: !if(PARITY_ENABLE)
+  endgenerate
+
+   assign read_data_out_byte_en[31:0] = read_data_valid_reg[0]? read_data_reg_byte_en_lower: 32'd0;
+   assign read_data_out_byte_en[63:32] = read_data_valid_reg[1]? read_data_reg_byte_en_upper: 32'd0;
+
+  assign  read_data_out_is_sop[0] = ((read_data_valid_reg[0] & (read_data_reg_sop0_lower | 
+                                read_data_reg_sop1_lower))) |
+      ((read_data_valid_reg[1] & (read_data_reg_sop0_upper | read_data_reg_sop1_upper)));
+  
+  assign  read_data_out_is_sop[1] = (read_data_valid_reg[0] & read_data_reg_sop1_lower) | 
+      (read_data_valid_reg[1] & read_data_reg_sop1_upper) | 
+      (read_data_valid_reg[0] & read_data_reg_sop0_lower & read_data_valid_reg[1] &
+       read_data_reg_sop0_upper);
+
+  assign  read_data_out_is_sop[2] = read_data_valid_reg[0] & read_data_valid_reg[1] & 
+      ((read_data_reg_sop1_lower & read_data_reg_sop0_upper) |
+       (read_data_reg_sop0_lower & read_data_reg_sop1_upper));
+  
+  assign  read_data_out_is_sop[3] = read_data_valid_reg[0] & read_data_valid_reg[1] & 
+      read_data_reg_sop1_lower & read_data_reg_sop1_upper;
+
+  assign  read_data_out_is_sop0_ptr[1:0] = (read_data_valid_reg[0] & read_data_reg_sop0_lower)?
+      {1'b0, read_data_reg_sop0_ptr_lower}:
+      (read_data_valid_reg[0] & read_data_reg_sop1_lower)? 2'd1:
+      (read_data_valid_reg[1] & read_data_reg_sop0_upper)?
+      {1'b1, read_data_reg_sop0_ptr_upper}:
+      (read_data_valid_reg[1] & read_data_reg_sop1_upper)? 2'd3: 2'd0;
+  assign  read_data_out_is_sop1_ptr[1:0] = (read_data_valid_reg[0] & read_data_reg_sop1_lower)? 4'd1:
+      (read_data_valid_reg[0] & read_data_valid_reg[1] & read_data_reg_sop0_lower &
+       read_data_reg_sop0_upper)? {1'b1, read_data_reg_sop0_ptr_upper}:
+      (read_data_valid_reg[1] & read_data_reg_sop0_upper &
+       read_data_reg_sop1_upper)? 2'd3: 2'd0;
+    assign  read_data_out_is_sop2_ptr[1:0] = (read_data_valid_reg[0] & read_data_valid_reg[1] & 
+                          read_data_reg_sop1_lower & read_data_reg_sop0_upper)? 
+        {1'b1, read_data_reg_sop0_ptr_upper}:
+        (read_data_valid_reg[0] & read_data_valid_reg[1] & 
+         read_data_reg_sop0_lower & read_data_reg_sop1_upper)? 2'd3: 2'd0;
+  assign    read_data_out_is_sop3_ptr[1:0] = (read_data_valid_reg[0] & read_data_valid_reg[1] & 
+                          read_data_reg_sop1_lower & read_data_reg_sop1_upper)? 2'd3: 2'd0;
+
+  assign  read_data_out_is_eop[0] = ((read_data_valid_reg[0] & (read_data_reg_eop0_lower | 
+                                read_data_reg_eop1_lower))) |
+      ((read_data_valid_reg[1] & (read_data_reg_eop0_upper | read_data_reg_eop1_upper)));
+
+  assign  read_data_out_is_eop0_ptr[3:0] = (read_data_valid_reg[0] & read_data_reg_eop0_lower)?
+       {1'b0, read_data_reg_eop0_ptr_lower[2:0]}:
+      (read_data_valid_reg[0] & read_data_reg_eop1_lower)?
+       {1'b0, read_data_reg_eop1_ptr_lower[2:0]}:
+      (read_data_valid_reg[1] & read_data_reg_eop0_upper)?
+       {1'b1, read_data_reg_eop0_ptr_upper[2:0]}:
+      (read_data_valid_reg[1] & read_data_reg_eop1_upper)?
+       {1'b1, read_data_reg_eop1_ptr_upper[2:0]}: 4'd0;
+  
+  assign  read_data_out_is_eop[1] = (read_data_valid_reg[0] & read_data_reg_eop1_lower) | 
+      (read_data_valid_reg[1] & read_data_reg_eop1_upper) | 
+      (read_data_valid_reg[0] & read_data_reg_eop0_lower & read_data_valid_reg[1] &
+       read_data_reg_eop0_upper);
+  assign  read_data_out_is_eop1_ptr[3:0] = (read_data_valid_reg[0] & read_data_reg_eop1_lower)?
+       {1'b0, read_data_reg_eop1_ptr_lower[2:0]}:
+      (read_data_valid_reg[0] & read_data_reg_eop0_lower & 
+       read_data_valid_reg[1] & read_data_reg_eop0_upper)?
+       {1'b1, read_data_reg_eop0_ptr_upper[2:0]}:
+      (read_data_valid_reg[1] & read_data_reg_eop1_upper)?
+      {1'b1, read_data_reg_eop1_ptr_upper[2:0]}: 4'd0;
+
+  assign  read_data_out_is_eop[2] = read_data_valid_reg[0] & read_data_valid_reg[1] & 
+      ((read_data_reg_eop1_lower & read_data_reg_eop0_upper) |
+       (read_data_reg_eop0_lower & read_data_reg_eop1_upper));
+  assign  read_data_out_is_eop2_ptr[3:0] = (read_data_valid_reg[0] & read_data_valid_reg[1] & 
+                        read_data_reg_eop1_lower & read_data_reg_eop0_upper)?
+       {1'b1, read_data_reg_eop0_ptr_upper[2:0]}:
+      (read_data_valid_reg[0] & read_data_valid_reg[1] & 
+       read_data_reg_eop0_lower & read_data_reg_eop1_upper)?
+       {1'b1, read_data_reg_eop1_ptr_upper[2:0]}: 4'd0;
+  assign  read_data_out_is_eop[3] = read_data_valid_reg[0] & read_data_valid_reg[1] & 
+      read_data_reg_eop1_lower & read_data_reg_eop1_upper;
+  assign  read_data_out_is_eop3_ptr[3:0] = (read_data_valid_reg[0] & read_data_valid_reg[1] & 
+                        read_data_reg_eop1_lower & read_data_reg_eop1_upper)?
+      {1'b1, read_data_reg_eop1_ptr_upper[2:0]}: 4'd0;
+
+   assign read_data_out_discontinue = (read_data_valid_reg[0] & read_data_reg_discontinue_lower) |
+      (read_data_valid_reg[1] & read_data_reg_discontinue_upper);      
+
+   assign read_data_out_parity[31:0] = read_data_valid_reg[0]? read_data_reg_parity_lower: 32'd0;
+   assign read_data_out_parity[63:32] = read_data_valid_reg[1]? read_data_reg_parity_upper: 32'd0;  
+
+   assign read_data_out_tuser = {
+                 read_data_out_parity[63:0],
+                 read_data_out_discontinue,
+                 read_data_out_is_eop3_ptr[3:0],
+                 read_data_out_is_eop2_ptr[3:0],
+                 read_data_out_is_eop1_ptr[3:0],
+                 read_data_out_is_eop0_ptr[3:0],
+                 read_data_out_is_eop[3:0],
+                 read_data_out_is_sop3_ptr[1:0],
+                 read_data_out_is_sop2_ptr[1:0],
+                 read_data_out_is_sop1_ptr[1:0],
+                 read_data_out_is_sop0_ptr[1:0],
+                 read_data_out_is_sop[3:0],
+                 read_data_out_byte_en[63:0]
+                 };
+
+   assign read_data_out_tdata[AXI4_USER_DATA_WIDTH/2-1:0] = read_data_valid_reg[0]? read_data_reg[AXI4_CORE_DATA_WIDTH-1:0]:
+      {AXI4_USER_DATA_WIDTH/2{1'b0}};
+   assign read_data_out_tdata[AXI4_USER_DATA_WIDTH-1:AXI4_USER_DATA_WIDTH/2] = read_data_valid_reg[1]?
+      read_data_reg[FIFO_READ_DATA_UPPER_OFFSET+AXI4_CORE_DATA_WIDTH-1:FIFO_READ_DATA_UPPER_OFFSET]: {AXI4_USER_DATA_WIDTH/2{1'b0}};
+   
+  assign  read_data_out_tkeep[AXI4_USER_RC_TKEEP_WIDTH/2-1:0] = attr_straddle_en_i? {AXI4_USER_RC_TKEEP_WIDTH/2{1'b1}}:
+      read_data_valid_reg[0]? 
+      read_data_reg[AXI4_CORE_DATA_WIDTH+AXI4_CORE_RC_TKEEP_WIDTH-1:AXI4_CORE_DATA_WIDTH]: {AXI4_USER_RC_TKEEP_WIDTH/2{1'b0}};
+   assign read_data_out_tkeep[AXI4_USER_RC_TKEEP_WIDTH-1:AXI4_USER_RC_TKEEP_WIDTH/2] = attr_straddle_en_i? {AXI4_USER_RC_TKEEP_WIDTH/2{1'b1}}:
+      read_data_valid_reg[1]? 
+      read_data_reg[FIFO_READ_TKEEP_UPPER_OFFSET+AXI4_CORE_RC_TKEEP_WIDTH-1:FIFO_READ_TKEEP_UPPER_OFFSET]:
+      {AXI4_USER_RC_TKEEP_WIDTH/2{1'b0}};
+
+   assign read_data_out_tlast = attr_straddle_en_i? 1'b0: 
+      (read_data_valid_reg[0] & read_data_reg_tlast_lower) |
+      (read_data_valid_reg[1] & read_data_reg_tlast_upper);
+
+   assign output_mux_in_data = {
+                read_data_out_tlast,
+                read_data_out_tuser,
+                read_data_out_tkeep,
+                read_data_out_tdata
+                };
+
+   // Instance of output MUX
+   xp4_usp_smsw_512b_rc_output_mux #
+     (
+      .TCQ(TCQ),
+      .IMPL_TARGET(IMPL_TARGET),
+      .IN_DATA_WIDTH(OUTPUT_MUX_IN_DATA_WIDTH),
+      .OUT_DATA_WIDTH(AXI4_USER_DATA_WIDTH),
+      .TUSER_WIDTH(AXI4_USER_RC_TUSER_WIDTH),
+      .TKEEP_WIDTH(AXI4_USER_RC_TKEEP_WIDTH)
+      )
+     pcie_4_0_512b_rc_output_mux_blk
+       (
+        .clk_i(user_clk_i),
+        .reset_n_i(reset_n_user_clk_i),
+        .link_down_reset_i(link_down_reset_i),
+    .in_data_i(output_mux_in_data),
+    .in_data_valid_i(read_data_valid_reg[0]),
+        .attr_straddle_en_i(attr_straddle_en_i),
+
+    .upstream_ready_o(output_mux_ready),
+    .out_data_o(m_axis_rc_tdata_o),
+        .out_data_valid_o(m_axis_rc_tvalid_o),
+    .out_tuser_o(m_axis_rc_tuser_o),
+    .out_tlast_o(m_axis_rc_tlast_o),
+    .out_tkeep_o(m_axis_rc_tkeep_o),
+    .downstream_ready_i(m_axis_rc_tready_i),
+
+    // Completion delivered indications to AXI hard block
+    .pcie_compl_delivered_o(pcie_compl_delivered_user_clk),
+    .pcie_compl_delivered_tag0_o(pcie_compl_delivered_tag0_user_clk),
+    .pcie_compl_delivered_tag1_o(pcie_compl_delivered_tag1_user_clk),
+    .pcie_compl_delivered_tag2_o(pcie_compl_delivered_tag2_user_clk),
+    .pcie_compl_delivered_tag3_o(pcie_compl_delivered_tag3_user_clk)
+    );
+
+  // Return tags of delivered Completions to the AXI hard block.
+  always @(posedge user_clk2_i)
+    if (~reset_n_user_clk2_i)
+      begin
+    compl_delivered_o <= #TCQ 2'b00;
+    compl_delivered_tag0_o <= #TCQ 8'd0;
+    compl_delivered_tag1_o <= #TCQ 8'd0;
+      end
+    else if (~user_clk_en_i)
+      begin
+    compl_delivered_o <= #TCQ pcie_compl_delivered_user_clk[1:0];
+    compl_delivered_tag0_o <= #TCQ pcie_compl_delivered_tag0_user_clk;
+    compl_delivered_tag1_o <= #TCQ pcie_compl_delivered_tag1_user_clk;
+      end
+    else
+      begin
+    compl_delivered_o <= #TCQ pcie_compl_delivered_user_clk[3:2];
+    compl_delivered_tag0_o <= #TCQ pcie_compl_delivered_tag2_user_clk;
+    compl_delivered_tag1_o <= #TCQ pcie_compl_delivered_tag3_user_clk;
+      end // else: !if(~user_clk_en_i)
+
+endmodule // pcie_4_0_512b_rc_intfc
+
+
+
+
+
+
+
+   
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2023 AMD, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD, Inc. and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : UltraScale+ FPGA PCI Express v4.0 Integrated Block
+// File       : xp4_usp_smsw_512b_rc_output_mux.v
+// Version    : 1.1 
+//-----------------------------------------------------------------------------
+//--------------------------------------------------------------------------------------------------
+`timescale 1ps/1ps
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_512b_rc_output_mux #(
+   parameter TCQ = 100,
+   parameter IMPL_TARGET = "SOFT",
+   parameter IN_DATA_WIDTH = 512+183+16+1,    
+   parameter OUT_DATA_WIDTH = 512,
+   parameter TUSER_WIDTH = 183,
+   parameter TKEEP_WIDTH = 16
+   )
+  (
+    input  wire           clk_i // 250 MHz clock for client-facing interfaces
+   ,input  wire           reset_n_i // Reset in the user clock domain
+   ,input  wire           link_down_reset_i // Link went down
+
+   ,input  wire           attr_straddle_en_i // Enable straddle
+
+   ,input wire[IN_DATA_WIDTH-1:0] in_data_i
+   ,input wire in_data_valid_i
+   ,output wire upstream_ready_o
+
+   ,output reg [OUT_DATA_WIDTH-1:0]  out_data_o
+   ,output reg           out_data_valid_o
+   ,output reg [TUSER_WIDTH-1:0] out_tuser_o
+   ,output wire          out_tlast_o
+   ,output wire [TKEEP_WIDTH-1:0] out_tkeep_o
+   ,input  wire           downstream_ready_i
+
+   // Completion delivered indications to AXI hard block
+   ,output reg [3:0]     pcie_compl_delivered_o
+   ,output reg [7:0]     pcie_compl_delivered_tag0_o
+   ,output reg [7:0]     pcie_compl_delivered_tag1_o
+   ,output reg [7:0]     pcie_compl_delivered_tag2_o
+   ,output reg [7:0]     pcie_compl_delivered_tag3_o
+   );
+
+
+   localparam MAX_CREDIT = 32;
+
+   reg [1:0] output_fifo_occupancy;
+   reg          output_fifo_write_ptr;
+   reg          output_fifo_read_ptr;
+   wire      output_fifo_full;
+   wire      output_fifo_empty;
+
+   reg [OUT_DATA_WIDTH-1:0] m_axis_rc_tdata_first_reg;
+   reg [TKEEP_WIDTH-1:0]    m_axis_rc_tkeep_first_reg;
+   reg [TUSER_WIDTH-1:0]    m_axis_rc_tuser_first_reg;
+   reg                 m_axis_rc_tlast_first_reg;
+   
+   reg [OUT_DATA_WIDTH-1:0] m_axis_rc_tdata_second_reg;
+   reg [TKEEP_WIDTH-1:0]    m_axis_rc_tkeep_second_reg;
+   reg [TUSER_WIDTH-1:0]    m_axis_rc_tuser_second_reg;
+   reg                 m_axis_rc_tlast_second_reg;
+   
+   wire             output_reg_mux_sel;
+   reg                 out_tlast_reg;
+   reg [TKEEP_WIDTH-1:0]    out_tkeep_reg;
+
+  wire                 sop0_dw0;
+  wire                 sop0_dw4;
+  wire                 sop0_dw8;
+  wire                 sop0_dw12;
+  wire                 sop1_dw4;
+  wire                 sop1_dw8;
+  wire                 sop1_dw12;
+  wire                 sop2_dw8;
+  wire                 sop2_dw12;
+  wire                 sop3_dw12;
+
+   //---------------------------------------------------------------------------------------------
+   // Output FIFO
+   // The main FIFO feeds into two read registers in the user clock domain, which are configured
+   // as a 2-entry FIFO.
+   // These are termed m_axis_rc_*_reg_first and m_axis_rc_*_reg_second.
+   // These can be thought of as logical extensions of the main FIFO.
+   //---------------------------------------------------------------------------------------------
+
+   // Send signal to read from main FIFO into the output FIFO when the latter is not full.
+   assign    upstream_ready_o = ~output_fifo_full;
+
+   // Maintain write and read pointers
+   always @(posedge clk_i)
+     if (~reset_n_i)
+       output_fifo_write_ptr <= #(TCQ) 1'b0;
+     else if (link_down_reset_i)
+       output_fifo_write_ptr <= #(TCQ) 1'b0;
+     else
+       if (in_data_valid_i & ~output_fifo_full)
+     output_fifo_write_ptr <= #(TCQ) ~output_fifo_write_ptr;
+
+   always @(posedge clk_i)
+     if (~reset_n_i)
+       output_fifo_read_ptr <= #(TCQ) 1'b0;
+     else if (link_down_reset_i)
+       output_fifo_read_ptr <= #(TCQ) 1'b0;
+     else
+       if ((downstream_ready_i | ~out_data_valid_o) &
+       ~output_fifo_empty)
+     output_fifo_read_ptr <= #(TCQ) ~output_fifo_read_ptr;
+
+    // Maintain FIFO occupancy
+   always @(posedge clk_i)
+     if (~reset_n_i)
+       output_fifo_occupancy <= #(TCQ) 2'd0;
+     else if (link_down_reset_i)
+       output_fifo_occupancy <= #(TCQ) 2'd0;
+     else
+       if ((in_data_valid_i & ~output_fifo_full) &
+       ~((downstream_ready_i | ~out_data_valid_o) &
+         ~output_fifo_empty))
+     output_fifo_occupancy <= #(TCQ) output_fifo_occupancy + 2'd1;
+       else
+     if (~(in_data_valid_i & ~output_fifo_full) &
+         ((downstream_ready_i | ~out_data_valid_o) &
+          ~output_fifo_empty))
+       output_fifo_occupancy <= #(TCQ) output_fifo_occupancy - 2'd1;
+   
+
+   assign output_fifo_full = output_fifo_occupancy[1];
+   assign output_fifo_empty = (output_fifo_occupancy == 2'b00);
+
+   // Write data into the Output FIFO.                                                                                    
+   always @(posedge clk_i)
+     if (~reset_n_i)
+       begin
+          m_axis_rc_tdata_first_reg <= #(TCQ) {OUT_DATA_WIDTH{1'b0}};
+          m_axis_rc_tdata_second_reg <= #(TCQ) {OUT_DATA_WIDTH{1'b0}};
+          m_axis_rc_tkeep_first_reg <= #(TCQ) {TKEEP_WIDTH{1'b0}};
+          m_axis_rc_tkeep_second_reg <= #(TCQ) {TKEEP_WIDTH{1'b0}};
+          m_axis_rc_tuser_first_reg <= #(TCQ) {TUSER_WIDTH{1'b0}};
+          m_axis_rc_tuser_second_reg <= #(TCQ) {TUSER_WIDTH{1'b0}};
+          m_axis_rc_tlast_first_reg <= #(TCQ) 1'b0;
+          m_axis_rc_tlast_second_reg <= #(TCQ) 1'b0;
+       end
+     else
+        if (in_data_valid_i & ~output_fifo_full)
+      begin
+         case(output_fifo_write_ptr)
+           1'b0:
+         begin
+            m_axis_rc_tdata_first_reg <= #(TCQ) in_data_i[OUT_DATA_WIDTH-1:0];
+            m_axis_rc_tkeep_first_reg <= #(TCQ) in_data_i[OUT_DATA_WIDTH+TKEEP_WIDTH-1:OUT_DATA_WIDTH];
+            m_axis_rc_tuser_first_reg <= #(TCQ) in_data_i[OUT_DATA_WIDTH+TKEEP_WIDTH+TUSER_WIDTH-1:OUT_DATA_WIDTH+TKEEP_WIDTH];
+            m_axis_rc_tlast_first_reg <= #(TCQ) in_data_i[IN_DATA_WIDTH-1];
+         end
+           default:
+         begin
+            m_axis_rc_tdata_second_reg <= #(TCQ) in_data_i[OUT_DATA_WIDTH-1:0];
+            m_axis_rc_tkeep_second_reg <= #(TCQ) in_data_i[OUT_DATA_WIDTH+TKEEP_WIDTH-1:OUT_DATA_WIDTH];
+            m_axis_rc_tuser_second_reg <= #(TCQ) in_data_i[OUT_DATA_WIDTH+TKEEP_WIDTH+TUSER_WIDTH-1:OUT_DATA_WIDTH+TKEEP_WIDTH];
+            m_axis_rc_tlast_second_reg <= #(TCQ) in_data_i[IN_DATA_WIDTH-1];
+         end
+         endcase // case(output_fifo_write_ptr)
+      end // if (in_data_valid_i & ~output_fifo_full)
+   
+   // Output registers
+
+   assign output_reg_mux_sel = output_fifo_read_ptr;
+
+   always @(posedge clk_i)
+     if (~reset_n_i)
+       begin
+      out_data_o <= #(TCQ) {OUT_DATA_WIDTH-1{1'b0}};
+      out_tuser_o <= #(TCQ) {TUSER_WIDTH-1{1'b0}};
+      out_tkeep_reg <= #(TCQ) {TKEEP_WIDTH-1{1'b0}};
+      out_tlast_reg <= #(TCQ) 1'b0;
+       end
+     else
+       if (~out_data_valid_o | downstream_ready_i)
+     begin
+        case(output_reg_mux_sel)
+          1'b0:
+        begin
+           out_data_o <= #(TCQ) m_axis_rc_tdata_first_reg;
+           out_tkeep_reg <= #(TCQ) m_axis_rc_tkeep_first_reg;
+           out_tuser_o <= #(TCQ) m_axis_rc_tuser_first_reg;
+           out_tlast_reg <= #(TCQ) m_axis_rc_tlast_first_reg;
+        end
+          default:
+        begin
+           out_data_o <= #(TCQ) m_axis_rc_tdata_second_reg;
+           out_tkeep_reg <= #(TCQ) m_axis_rc_tkeep_second_reg;
+           out_tuser_o <= #(TCQ) m_axis_rc_tuser_second_reg;
+           out_tlast_reg <= #(TCQ) m_axis_rc_tlast_second_reg;
+        end
+        endcase // case(output_reg_mux_sel)
+     end // if (~out_data_o | downstream_ready_i)
+
+   always @(posedge clk_i)
+     if (~reset_n_i)
+       out_data_valid_o <= #(TCQ) 1'b0;
+     else
+       if (~out_data_valid_o | downstream_ready_i)
+     out_data_valid_o <= #(TCQ) ~output_fifo_empty;
+
+  assign out_tkeep_o =  attr_straddle_en_i? {TKEEP_WIDTH{1'b1}}: out_tkeep_reg;
+  assign out_tlast_o =  attr_straddle_en_i? 1'b0: out_tlast_reg;
+
+  //-----------------------------------------------------------------------------------------
+  // Generate Completion delivered indications to AXI hard block
+  //-----------------------------------------------------------------------------------------
+
+  reg                  compl_data_valid;
+  reg [3:0]          compl_delivered;
+  reg              pkt_in_progress;
+  reg [3:0]          compl_sop;
+  reg [3:0]          compl_eop;
+  reg [1:0]          compl_sop0_ptr;
+  reg [1:0]          compl_sop1_ptr;
+  reg [1:0]          compl_sop2_ptr;
+  reg [7:0]          compl_tag0;
+  reg [7:0]          compl_tag1;
+  reg [7:0]          compl_tag2;
+  reg [7:0]          compl_tag3;
+
+  reg              saved_compl_delivered;
+  reg [7:0]          saved_compl_tag;
+
+  always @(posedge clk_i)
+    if (~reset_n_i)
+      compl_data_valid <= #(TCQ) 1'b0;
+    else if (link_down_reset_i)
+      compl_data_valid <= #(TCQ) 1'b0;
+    else
+      compl_data_valid <= #(TCQ) out_data_valid_o & downstream_ready_i;
+  
+  always @(posedge clk_i)
+    if (~reset_n_i)
+      begin
+    compl_sop <= #(TCQ) 4'd0;
+    compl_eop <= #(TCQ) 4'd0;
+    compl_sop0_ptr <= #(TCQ) 2'd0;
+    compl_sop1_ptr <= #(TCQ) 2'd0;
+    compl_sop2_ptr <= #(TCQ) 2'd0;
+    compl_delivered <= #(TCQ) 4'd0;
+    compl_tag0 <= #(TCQ) 8'd0;
+    compl_tag1 <= #(TCQ) 8'd0;
+    compl_tag2 <= #(TCQ) 8'd0;
+    compl_tag3 <= #(TCQ) 8'd0;
+      end // if (~reset_n_i)
+    else
+      begin
+    if (attr_straddle_en_i)
+      begin
+        compl_sop <= #(TCQ) out_tuser_o[67:64];
+        compl_sop0_ptr <= #(TCQ) out_tuser_o[69:68];
+        compl_sop1_ptr <= #(TCQ) out_tuser_o[71:70];
+        compl_sop2_ptr <= #(TCQ) out_tuser_o[73:72];
+        compl_eop <= #(TCQ) out_tuser_o[79:76];
+        compl_delivered[0] <= #(TCQ) out_data_o[30] && (out_data_o[15:12] != 4'b0110);  // Exclude invalid tag error
+        compl_delivered[1] <= #(TCQ) out_data_o[128+30] && (out_data_o[128+15:128+12] != 4'b0110);
+        compl_delivered[2] <= #(TCQ) out_data_o[128*2+30] && (out_data_o[128*2+15:128*2+12] != 4'b0110);
+        compl_delivered[3] <= #(TCQ) out_data_o[128*3+30] && (out_data_o[128*3+15:128*3+12] != 4'b0110);    
+        compl_tag0 <= #(TCQ) out_data_o[71:64];
+        compl_tag1 <= #(TCQ) out_data_o[128+71:128+64];
+        compl_tag2 <= #(TCQ) out_data_o[128*2+71:128*2+64];
+        compl_tag3 <= #(TCQ) out_data_o[128*3+71:128*3+64];
+      end // if (attr_straddle_en_i)
+    else
+      begin
+        compl_sop[0] <= #(TCQ) out_tuser_o[64];
+        compl_sop[3:1] <= #(TCQ) 3'd0;
+        compl_sop0_ptr <= #(TCQ) 2'd0;
+        compl_sop1_ptr <= #(TCQ) 2'd0;
+        compl_sop2_ptr <= #(TCQ) 2'd0;
+        compl_eop[0] <= #(TCQ) out_tlast_reg;
+        compl_eop[3:1] <= #(TCQ) 3'd0;
+        compl_delivered[0] <= #(TCQ) out_data_o[30] && (out_data_o[15:12] != 4'b0110);  // Exclude invalid tag error
+        compl_delivered[3:1] <= #(TCQ) 3'd0;
+        compl_tag0 <= #(TCQ) out_data_o[71:64];
+        compl_tag1 <= #(TCQ) 8'd0;
+        compl_tag2 <= #(TCQ) 8'd0;
+        compl_tag3 <= #(TCQ) 8'd0;
+      end // else: !if(attr_straddle_en_i)
+      end // else: !if(~reset_n_i)
+    
+  // Keep track of continuing packets
+  always @(posedge clk_i)
+    if (~reset_n_i)
+      pkt_in_progress <= #(TCQ) 1'b0;
+    else if (link_down_reset_i)
+      pkt_in_progress <= #(TCQ) 1'b0;
+    else if (compl_data_valid)
+       begin
+     if (attr_straddle_en_i)
+       begin
+         if (~pkt_in_progress)
+           pkt_in_progress <= #(TCQ) ~compl_eop[0] |
+                  (compl_sop[1] & ~compl_eop[1]) | 
+                  (compl_sop[2] & ~compl_eop[2]) | 
+                  (compl_sop[3] & ~compl_eop[3]);
+         else
+           pkt_in_progress <= #(TCQ) ~compl_eop[0] |
+                  (compl_sop[0] & ~compl_eop[1]) | 
+                  (compl_sop[1] & ~compl_eop[2]) | 
+                  (compl_sop[2] & ~compl_eop[3]);
+       end // if (attr_straddle_en_i)
+     else
+       pkt_in_progress <= #(TCQ) ~compl_eop[0];
+       end // if (compl_data_valid)
+    
+  assign sop0_dw0 = compl_sop[0] && (compl_sop0_ptr == 2'd0) && compl_delivered[0];
+  assign sop0_dw4 = compl_sop[0] && (compl_sop0_ptr == 2'd1) && compl_delivered[1];
+  assign sop0_dw8 = compl_sop[0] && (compl_sop0_ptr == 2'd2) && compl_delivered[2];
+  assign sop0_dw12 = compl_sop[0] && (compl_sop0_ptr == 2'd3) && compl_delivered[3];
+  assign sop1_dw4 = compl_sop[1] && (compl_sop1_ptr == 2'd1) && compl_delivered[1];
+  assign sop1_dw8 = compl_sop[1] && (compl_sop1_ptr == 2'd2) && compl_delivered[2];
+  assign sop1_dw12 = compl_sop[1] && (compl_sop1_ptr == 2'd3) && compl_delivered[3];
+  assign sop2_dw8 = compl_sop[2] && (compl_sop2_ptr == 2'd2) && compl_delivered[2];
+  assign sop2_dw12 = compl_sop[2] && (compl_sop2_ptr == 2'd3) && compl_delivered[3];
+  assign sop3_dw12 = compl_sop[3] & compl_delivered[3];
+
+  // Send out tags of delivered Completions
+  always @(posedge clk_i)
+    if (~reset_n_i)
+      begin
+     pcie_compl_delivered_o <= #(TCQ) 4'd0;
+     pcie_compl_delivered_tag0_o <= #(TCQ) 8'd0;
+     pcie_compl_delivered_tag1_o <= #(TCQ) 8'd0;
+     pcie_compl_delivered_tag2_o <= #(TCQ) 8'd0;
+     pcie_compl_delivered_tag3_o <= #(TCQ) 8'd0;
+      end
+     else if (compl_data_valid)
+       begin
+     if (~pkt_in_progress)
+       begin
+         pcie_compl_delivered_o[0] <= #(TCQ) (sop0_dw0 & compl_eop[0])|
+                      (sop1_dw4 & compl_eop[1])| 
+                      (sop1_dw8 & compl_eop[1])| 
+                      (sop1_dw12 & compl_eop[1])| 
+                      (sop2_dw8 & compl_eop[2])| 
+                      (sop2_dw12 & compl_eop[2])| 
+                      (sop3_dw12 & compl_eop[3]);
+         pcie_compl_delivered_tag0_o <= #(TCQ) (sop0_dw0 & compl_eop[0])?
+                        compl_tag0:
+                        (sop1_dw4 & compl_eop[1])? 
+                        compl_tag1:
+                        ((sop1_dw8 & compl_eop[1])|
+                         (sop2_dw8 & compl_eop[2]))? 
+                        compl_tag2:
+                        compl_tag3;
+
+         if (sop0_dw0 & compl_eop[0])
+           begin
+         pcie_compl_delivered_o[1] <= #(TCQ) (sop1_dw4 & compl_eop[1])| 
+                          (sop1_dw8 & compl_eop[1])| 
+                          (sop1_dw12 & compl_eop[1])| 
+                          (sop2_dw8 & compl_eop[2])| 
+                          (sop2_dw12 & compl_eop[2])| 
+                          (sop3_dw12 & compl_eop[3]);
+         if (sop1_dw4 & compl_eop[1])
+           pcie_compl_delivered_tag1_o <= #(TCQ) compl_tag1;
+         else if ((sop1_dw8 & compl_eop[1])| 
+              (sop2_dw8 & compl_eop[2]))
+           pcie_compl_delivered_tag1_o <= #(TCQ) compl_tag2;
+         else
+           pcie_compl_delivered_tag1_o <= #(TCQ) compl_tag3;
+           end
+         else if (sop1_dw4 & compl_eop[1])
+           begin
+         pcie_compl_delivered_o[1] <= #(TCQ)(sop2_dw8 & compl_eop[2])| 
+                          (sop2_dw12 & compl_eop[2])| 
+                          (sop3_dw12 & compl_eop[3]);
+         if (sop2_dw8 & compl_eop[2])
+           pcie_compl_delivered_tag1_o <= #(TCQ) compl_tag2;
+         else
+           pcie_compl_delivered_tag1_o <= #(TCQ) compl_tag3;
+           end
+         else if (sop1_dw8 & compl_eop[1])
+           begin
+         pcie_compl_delivered_o[1] <= #(TCQ) sop2_dw12 & compl_eop[2];
+         pcie_compl_delivered_tag1_o <= #(TCQ) compl_tag3;
+           end
+         else if (sop2_dw8 & compl_eop[2])
+           begin
+         pcie_compl_delivered_o[1] <= #(TCQ) sop3_dw12 & compl_eop[3];
+         pcie_compl_delivered_tag1_o <= #(TCQ) compl_tag3;
+           end
+         else
+           begin
+         pcie_compl_delivered_o[1] <= #(TCQ) 1'b0;
+         pcie_compl_delivered_tag1_o <= #(TCQ) compl_tag3;
+           end
+
+         if (sop0_dw0 & compl_eop[0])
+           begin
+         if (sop1_dw4 & compl_eop[1])
+           begin
+             pcie_compl_delivered_o[2] <= #(TCQ) (sop2_dw8 & compl_eop[2])| 
+                          (sop2_dw12 & compl_eop[2])| 
+                          (sop3_dw12 & compl_eop[3]);
+             if (sop2_dw8 & compl_eop[2])
+               pcie_compl_delivered_tag2_o <= #(TCQ) compl_tag2;
+             else
+               pcie_compl_delivered_tag2_o <= #(TCQ) compl_tag3;
+           end
+         else if (sop1_dw8 & compl_eop[1])
+           begin
+             pcie_compl_delivered_o[2] <= #(TCQ) (sop2_dw12 & compl_eop[2])| 
+                          (sop3_dw12 & compl_eop[3]);
+             pcie_compl_delivered_tag2_o <= #(TCQ) compl_tag3;
+           end
+         else
+           pcie_compl_delivered_o[2] <= #(TCQ) 1'b0;
+           end // if (sop0_dw0 & compl_eop[0])
+         else if (sop1_dw4 & compl_eop[1])
+           begin
+         if (sop2_dw8 & compl_eop[2])
+           begin
+             pcie_compl_delivered_o[2] <= #(TCQ) (sop3_dw12 & compl_eop[3]);
+             pcie_compl_delivered_tag2_o <= #(TCQ) compl_tag3;
+           end
+         else
+           pcie_compl_delivered_o[2] <= #(TCQ) 1'b0;
+           end
+         else
+           pcie_compl_delivered_o[2] <= #(TCQ) 1'b0;
+         
+         pcie_compl_delivered_o[3] <= #(TCQ) sop0_dw0 & compl_eop[0] &
+                      (sop1_dw4 & compl_eop[1]) & 
+                      (sop2_dw8 & compl_eop[2]) & 
+                      (sop3_dw12 & compl_eop[3]);
+         pcie_compl_delivered_tag3_o <= #(TCQ) compl_tag3;
+       end // if (~pkt_in_progress)
+     else
+       begin
+         pcie_compl_delivered_o[0] <= #(TCQ) (saved_compl_delivered & compl_eop[0])|
+                      (sop0_dw4 & compl_eop[1])| 
+                      (sop0_dw8 & compl_eop[1])| 
+                      (sop0_dw12 & compl_eop[1])| 
+                      (sop1_dw8 & compl_eop[2])| 
+                      (sop1_dw12 & compl_eop[2])| 
+                      (sop2_dw12 & compl_eop[3]);
+         pcie_compl_delivered_tag0_o <= #(TCQ) (saved_compl_delivered & compl_eop[0])?
+                        saved_compl_tag:
+                        (sop0_dw4 & compl_eop[1])?
+                        compl_tag1:
+                        ((sop0_dw8 & compl_eop[1])| 
+                         (sop1_dw8 & compl_eop[2]))?
+                         compl_tag2:
+                         compl_tag3;
+
+         if (saved_compl_delivered & compl_eop[0])
+           begin
+         pcie_compl_delivered_o[1] <= #(TCQ) (sop0_dw4 & compl_eop[1])| 
+                          (sop0_dw8 & compl_eop[1])| 
+                          (sop0_dw12 & compl_eop[1])| 
+                          (sop1_dw8 & compl_eop[2])| 
+                          (sop1_dw12 & compl_eop[2])| 
+                          (sop2_dw12 & compl_eop[3]);
+         if (sop0_dw4 & compl_eop[1])
+           pcie_compl_delivered_tag1_o <= #(TCQ) compl_tag1;
+         else if ((sop0_dw8 & compl_eop[1])| 
+              (sop1_dw8 & compl_eop[2]))
+           pcie_compl_delivered_tag1_o <= #(TCQ) compl_tag2;
+         else
+           pcie_compl_delivered_tag1_o <= #(TCQ) compl_tag3;
+           end
+         else if (sop0_dw4 & compl_eop[1])
+           begin
+         pcie_compl_delivered_o[1] <= #(TCQ)(sop1_dw8 & compl_eop[2])| 
+                          (sop1_dw12 & compl_eop[2])| 
+                          (sop2_dw12 & compl_eop[3]);
+         if (sop1_dw8 & compl_eop[2])
+           pcie_compl_delivered_tag1_o <= #(TCQ) compl_tag2;
+         else
+           pcie_compl_delivered_tag1_o <= #(TCQ) compl_tag3;
+           end
+         else if (sop0_dw8 & compl_eop[1])
+           begin
+         pcie_compl_delivered_o[1] <= #(TCQ) sop1_dw12 & compl_eop[2];
+         pcie_compl_delivered_tag1_o <= #(TCQ) compl_tag3;
+           end
+         else if (sop1_dw8 & compl_eop[2])
+           begin
+         pcie_compl_delivered_o[1] <= #(TCQ) sop2_dw12 & compl_eop[3];
+         pcie_compl_delivered_tag1_o <= #(TCQ) compl_tag3;
+           end
+         else
+           begin
+         pcie_compl_delivered_o[1] <= #(TCQ) 1'b0;
+         pcie_compl_delivered_tag1_o <= #(TCQ) compl_tag3;
+           end
+
+         if (saved_compl_delivered & compl_eop[0])
+           begin
+         if (sop0_dw4 & compl_eop[1])
+           begin
+             pcie_compl_delivered_o[2] <= #(TCQ) (sop1_dw8 & compl_eop[2])| 
+                          (sop1_dw12 & compl_eop[2])| 
+                          (sop2_dw12 & compl_eop[3]);
+             if (sop1_dw8 & compl_eop[2])
+               pcie_compl_delivered_tag2_o <= #(TCQ) compl_tag2;
+             else
+               pcie_compl_delivered_tag2_o <= #(TCQ) compl_tag3;
+           end
+         else if (sop0_dw8 & compl_eop[1])
+           begin
+             pcie_compl_delivered_o[2] <= #(TCQ) (sop1_dw12 & compl_eop[2])| 
+                          (sop2_dw12 & compl_eop[3]);
+             pcie_compl_delivered_tag2_o <= #(TCQ) compl_tag3;
+           end
+         else
+           pcie_compl_delivered_o[2] <= #(TCQ) 1'b0;
+           end // if (saved_compl_delivered & compl_eop[0])
+         else if (sop0_dw4 & compl_eop[1])
+           begin
+         if (sop1_dw8 & compl_eop[2])
+           begin
+             pcie_compl_delivered_o[2] <= #(TCQ) (sop2_dw12 & compl_eop[3]);
+             pcie_compl_delivered_tag2_o <= #(TCQ) compl_tag3;
+           end
+         else
+           pcie_compl_delivered_o[2] <= #(TCQ) 1'b0;
+           end
+         else
+           pcie_compl_delivered_o[2] <= #(TCQ) 1'b0;
+
+         pcie_compl_delivered_o[3] <= #(TCQ) (saved_compl_delivered & compl_eop[0]) &
+                      (sop0_dw4 & compl_eop[1]) & 
+                      (sop1_dw8 & compl_eop[2]) & 
+                      (sop2_dw12 & compl_eop[3]);
+         pcie_compl_delivered_tag3_o <= #(TCQ) compl_tag3;
+       end // else: !if(~pkt_in_progress)
+       end // if (compl_data_valid)
+     else
+       pcie_compl_delivered_o <= #(TCQ) 4'd0;
+
+  // Save tag for next cycle
+   always @(posedge clk_i)
+     if (~reset_n_i)
+       begin
+     saved_compl_delivered <= #(TCQ) 1'b0;
+     saved_compl_tag <= #(TCQ) 8'd0;
+       end
+     else if (compl_data_valid)
+       begin
+     if (compl_sop[3])
+       begin
+         saved_compl_delivered <= #(TCQ) compl_delivered[3];
+         saved_compl_tag <= #(TCQ) compl_tag3;
+       end
+     else if (compl_sop[2])
+       case(compl_sop2_ptr)
+         2'd2:
+           begin
+         saved_compl_delivered <= #(TCQ) compl_delivered[2];
+         saved_compl_tag <= #(TCQ) compl_tag2;
+           end
+         default:
+           begin
+         saved_compl_delivered <= #(TCQ) compl_delivered[3];
+         saved_compl_tag <= #(TCQ) compl_tag3;
+           end
+       endcase // case(compl_sop2_ptr)
+     else if (compl_sop[1])
+       case(compl_sop1_ptr)
+         2'd1:
+           begin
+         saved_compl_delivered <= #(TCQ) compl_delivered[1];
+         saved_compl_tag <= #(TCQ) compl_tag1;
+           end
+         2'd2:
+           begin
+         saved_compl_delivered <= #(TCQ) compl_delivered[2];
+         saved_compl_tag <= #(TCQ) compl_tag2;
+           end
+         default:
+           begin
+         saved_compl_delivered <= #(TCQ) compl_delivered[3];
+         saved_compl_tag <= #(TCQ) compl_tag3;
+           end
+       endcase // case(compl_sop1_ptr)
+     else if (compl_sop[0])
+       case(compl_sop0_ptr)
+         2'd0:
+           begin
+         saved_compl_delivered <= #(TCQ) compl_delivered[0];
+         saved_compl_tag <= #(TCQ) compl_tag0;
+           end
+         2'd1:
+           begin
+         saved_compl_delivered <= #(TCQ) compl_delivered[1];
+         saved_compl_tag <= #(TCQ) compl_tag1;
+           end
+         2'd2:
+           begin
+         saved_compl_delivered <= #(TCQ) compl_delivered[2];
+         saved_compl_tag <= #(TCQ) compl_tag2;
+           end
+         default:
+           begin
+         saved_compl_delivered <= #(TCQ) compl_delivered[3];
+         saved_compl_tag <= #(TCQ) compl_tag3;
+           end
+       endcase // case(compl_sop0_ptr)
+       end // if (compl_data_valid)
+
+endmodule // pcie_4_0_512b_rc_output_mux
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2023 AMD, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD, Inc. and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : UltraScale+ FPGA PCI Express v4.0 Integrated Block
+// File       : xp4_usp_smsw_512b_rq_intfc.v
+// Version    : 1.1 
+//-----------------------------------------------------------------------------
+//--------------------------------------------------------------------------------------------------
+`timescale 1ps/1ps
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_512b_rq_intfc #(
+   parameter TCQ = 100,
+   parameter IMPL_TARGET = "SOFT",
+   parameter AXI4_USER_DATA_WIDTH = 512,
+   parameter AXI4_CORE_DATA_WIDTH = 256,
+   parameter AXI4_USER_RQ_TUSER_WIDTH = 137,
+   parameter AXI4_CORE_RQ_TUSER_WIDTH = 62,
+   parameter AXI4_USER_RQ_TKEEP_WIDTH = 16,
+   parameter AXI4_CORE_RQ_TKEEP_WIDTH = 8,
+   parameter AXI4_CORE_RQ_TREADY_WIDTH = 4,
+   parameter PARITY_ENABLE = 0                
+   ) 
+  (
+    input  wire           user_clk2_i // 500 MHz clock for core-facing interfaces
+   ,input  wire           user_clk_i // 250 MHz clock for client-facing interfaces
+   ,input  wire           user_clk_en_i // User clock enable for clock domain crossing
+   ,input  wire           reset_n_user_clk_i // Reset in the user clock domain
+   ,input  wire           reset_n_user_clk2_i // Reset in the user clock2 domain
+   ,input  wire           link_down_reset_i // Link went down
+   // Attributes
+   ,input  wire           attr_straddle_en_i // Enable straddle
+   ,input wire [1:0]      attr_alignment_mode_i // Payload alignment mode
+                                                // (00= Dword-aligned, 10 = 128b address-aligned)
+   ,input wire            attr_axisten_if_rq_cc_registered_tready_i // 0 = registered_tready enabled, 1 = registered_tready disabled
+   //-----------------------------------------------------------------------------------------------
+   // Client-side signals
+   //-----------------------------------------------------------------------------------------------
+   ,input wire [511:0]    s_axis_rq_tdata_i
+   ,input wire            s_axis_rq_tvalid_i
+   ,input wire [AXI4_USER_RQ_TUSER_WIDTH-1:0] s_axis_rq_tuser_i
+   ,input wire            s_axis_rq_tlast_i
+   ,input wire [AXI4_USER_RQ_TKEEP_WIDTH-1:0] s_axis_rq_tkeep_i
+   ,output reg            s_axis_rq_tready_o   
+   //-----------------------------------------------------------------------------------------------
+   // Core-side signals
+   //-----------------------------------------------------------------------------------------------
+   ,output wire [255:0]   core_rq_tdata_o
+   ,output wire           core_rq_tvalid_o
+   ,output wire [AXI4_CORE_RQ_TUSER_WIDTH-1:0] core_rq_tuser_o
+   ,output wire            core_rq_tlast_o
+   ,output wire [AXI4_CORE_RQ_TKEEP_WIDTH-1:0] core_rq_tkeep_o
+   ,input wire [AXI4_CORE_RQ_TREADY_WIDTH-1:0] core_rq_tready_i
+   );
+
+   localparam FIFO_IN_DATA_WIDTH = AXI4_USER_DATA_WIDTH + AXI4_USER_RQ_TKEEP_WIDTH + AXI4_CORE_RQ_TUSER_WIDTH*2 +
+                   2; // tlast
+   localparam FIFO_OUT_DATA_WIDTH = FIFO_IN_DATA_WIDTH/2;
+
+   localparam OUTPUT_MUX_IN_DATA_WIDTH = AXI4_CORE_DATA_WIDTH + AXI4_CORE_RQ_TKEEP_WIDTH + AXI4_CORE_RQ_TUSER_WIDTH + 1;
+
+   reg [AXI4_USER_DATA_WIDTH-1:0] s_axis_rq_tdata_reg;
+   reg                   s_axis_rq_tvalid_reg_lower;
+   reg                   s_axis_rq_tvalid_reg_upper;
+   reg [AXI4_USER_RQ_TKEEP_WIDTH-1:0] s_axis_rq_tkeep_reg;
+   reg                       s_axis_rq_tlast_reg_lower;
+   reg                       s_axis_rq_tlast_reg_upper;
+   reg [AXI4_USER_RQ_TUSER_WIDTH-1:0] s_axis_rq_tuser_reg;
+
+
+   wire [1:0]                   s_axis_rq_sop;
+   wire [1:0]                   s_axis_rq_eop;
+   wire [1:0]                   s_axis_rq_sop0_ptr;
+   wire [3:0]                   s_axis_rq_eop0_ptr;
+   wire [3:0]                   s_axis_rq_eop1_ptr;
+   wire [63:0]                   s_axis_rq_parity;
+
+   wire [AXI4_CORE_RQ_TUSER_WIDTH*2-1:0] fifo_in_data_tuser;
+   wire [1:0]                  fifo_in_data_tlast;
+
+   wire [FIFO_IN_DATA_WIDTH-1:0]      fifo_in_data;
+   wire [1:0]                  fifo_in_data_valid;
+   wire                  fifo_almost_full_user_clk;
+
+   reg                      s_axis_rq_tuser_discontinue_reg_lower;
+   reg                      s_axis_rq_tuser_discontinue_reg_upper;
+
+    wire [FIFO_OUT_DATA_WIDTH-1:0]      fifo_read_data;
+   wire                  fifo_read_data_valid;
+   wire                  output_mux_ready;
+
+  wire [3:0] 		 s_axis_rq_fbe_lower;
+  wire [3:0] 		 s_axis_rq_fbe_upper;
+  wire [3:0] 		 s_axis_rq_lbe_lower;
+  wire [3:0] 		 s_axis_rq_lbe_upper;
+  wire [1:0]             s_axis_rq_addr_offset_lower;
+  wire [1:0]             s_axis_rq_addr_offset_upper;
+  wire 			 s_axis_rq_tph_present_lower;
+  wire 			 s_axis_rq_tph_present_upper;
+  wire [1:0] 		 s_axis_rq_tph_type_lower;
+  wire [1:0] 		 s_axis_rq_tph_type_upper;
+  wire [7:0] 		 s_axis_rq_tph_st_tag_lower;
+  wire [7:0] 		 s_axis_rq_tph_st_tag_upper;
+  wire [5:0] 		 s_axis_rq_seq_num_lower;
+  wire [5:0] 		 s_axis_rq_seq_num_upper;
+  wire [63:0] 		 s_axis_rq_parity_i;
+
+  reg [AXI4_CORE_RQ_TREADY_WIDTH-1:0] core_rq_tready_reg;
+  wire [AXI4_CORE_RQ_TREADY_WIDTH-1:0] core_rq_tready_int;
+
+  assign  s_axis_rq_sop[1:0] =  s_axis_rq_tuser_i[21:20];
+  assign  s_axis_rq_sop0_ptr[1:0] =  s_axis_rq_tuser_i[23:22];
+  assign  s_axis_rq_eop[1:0] =  s_axis_rq_tuser_i[27:26];
+  assign  s_axis_rq_eop0_ptr[3:0] =  s_axis_rq_tuser_i[31:28];
+  assign  s_axis_rq_eop1_ptr[3:0] =  s_axis_rq_tuser_i[35:32];
+
+  // First BE
+  assign  s_axis_rq_fbe_lower[3:0] = s_axis_rq_tuser_i[3:0];
+  assign  s_axis_rq_fbe_upper[3:0] = (attr_straddle_en_i & s_axis_rq_sop[0] & s_axis_rq_sop0_ptr[1])?
+	  s_axis_rq_tuser_i[3:0]: s_axis_rq_tuser_i[7:4];
+  // Last BE
+  assign  s_axis_rq_lbe_lower[3:0] = s_axis_rq_tuser_i[11:8];
+  assign  s_axis_rq_lbe_upper[3:0] =  (attr_straddle_en_i & s_axis_rq_sop[0] & s_axis_rq_sop0_ptr[1])? 
+	  s_axis_rq_tuser_i[11:8]: s_axis_rq_tuser_i[15:12];
+  // Address Offset
+  assign  s_axis_rq_addr_offset_lower[1:0] = s_axis_rq_tuser_i[17:16];
+  assign  s_axis_rq_addr_offset_upper[1:0] = (attr_straddle_en_i & s_axis_rq_sop[0] & s_axis_rq_sop0_ptr[1])?
+	  s_axis_rq_tuser_i[17:16]: s_axis_rq_tuser_i[19:18];
+  // TPH-related signals
+  assign  s_axis_rq_tph_present_lower = s_axis_rq_tuser_i[37];
+  assign  s_axis_rq_tph_present_upper = (attr_straddle_en_i & s_axis_rq_sop[0] & s_axis_rq_sop0_ptr[1])?
+	  s_axis_rq_tuser_i[37]: s_axis_rq_tuser_i[38];
+  assign  s_axis_rq_tph_type_lower[1:0] = s_axis_rq_tuser_i[40:39];
+  assign  s_axis_rq_tph_type_upper[1:0] = (attr_straddle_en_i & s_axis_rq_sop[0] & s_axis_rq_sop0_ptr[1])?
+	  s_axis_rq_tuser_i[40:39]: s_axis_rq_tuser_i[42:41];
+  assign  s_axis_rq_tph_st_tag_lower[7:0] = s_axis_rq_tuser_i[52:45];
+  assign  s_axis_rq_tph_st_tag_upper[7:0] = (attr_straddle_en_i & s_axis_rq_sop[0] & s_axis_rq_sop0_ptr[1])?
+	  s_axis_rq_tuser_i[52:45]: s_axis_rq_tuser_i[60:53];
+  assign  s_axis_rq_seq_num_lower[5:0] = s_axis_rq_tuser_i[66:61];
+  assign  s_axis_rq_seq_num_upper[5:0] = (attr_straddle_en_i & s_axis_rq_sop[0] & s_axis_rq_sop0_ptr[1])?
+	  s_axis_rq_tuser_i[66:61]: s_axis_rq_tuser_i[72:67];
+  // Parity
+  generate
+    if (PARITY_ENABLE)
+      assign  s_axis_rq_parity_i[63:0] =  s_axis_rq_tuser_i[136:73];
+    else
+      assign  s_axis_rq_parity_i[63:0] =  64'd0;
+  endgenerate    
+
+   // Register input data
+   always @(posedge user_clk_i)
+     if (~reset_n_user_clk_i)
+       begin
+      s_axis_rq_tdata_reg <= {AXI4_USER_DATA_WIDTH{1'b0}};
+      s_axis_rq_tvalid_reg_lower <= 1'b0;
+      s_axis_rq_tvalid_reg_upper <= 1'b0;
+      s_axis_rq_tkeep_reg <= {AXI4_USER_RQ_TKEEP_WIDTH{1'b0}};
+      s_axis_rq_tuser_reg <= {AXI4_USER_RQ_TUSER_WIDTH{1'b0}};
+      s_axis_rq_tuser_discontinue_reg_lower <= 1'b0;
+       s_axis_rq_tuser_discontinue_reg_upper <= 1'b0;
+      s_axis_rq_tlast_reg_lower <= 1'b0;
+      s_axis_rq_tlast_reg_upper <= 1'b0;
+       end
+     else
+       begin
+      s_axis_rq_tdata_reg <= s_axis_rq_tdata_i;
+      s_axis_rq_tvalid_reg_lower <= s_axis_rq_tvalid_i & s_axis_rq_tready_o;
+      s_axis_rq_tvalid_reg_upper <= attr_straddle_en_i? (~s_axis_rq_eop[0] | s_axis_rq_eop0_ptr[3] |
+                                 (s_axis_rq_sop[0] & s_axis_rq_sop0_ptr[1]) |
+                                 s_axis_rq_sop[1]) &
+                    s_axis_rq_tvalid_i & s_axis_rq_tready_o:
+                    (~s_axis_rq_tlast_i | s_axis_rq_tkeep_i[8]) &
+                    s_axis_rq_tvalid_i & s_axis_rq_tready_o;
+     // Generate tkeep settings for core side
+     if (~attr_straddle_en_i)
+       s_axis_rq_tkeep_reg[7:0] <= s_axis_rq_tkeep_i[7:0];
+     else if (s_axis_rq_tvalid_i & s_axis_rq_tready_o)
+       begin
+         if (~s_axis_rq_eop[0] | s_axis_rq_eop0_ptr[3])
+           s_axis_rq_tkeep_reg[7:0] <= 8'hff;
+         else
+           case(s_axis_rq_eop0_ptr[2:0])
+         3'd0: s_axis_rq_tkeep_reg[7:0] <= 8'h01;
+         3'd1: s_axis_rq_tkeep_reg[7:0] <= 8'h03;
+         3'd2: s_axis_rq_tkeep_reg[7:0] <= 8'h07;
+         3'd3: s_axis_rq_tkeep_reg[7:0] <= 8'h0f;
+         3'd4: s_axis_rq_tkeep_reg[7:0] <= 8'h1f;
+         3'd5: s_axis_rq_tkeep_reg[7:0] <= 8'h3f;
+         3'd6: s_axis_rq_tkeep_reg[7:0] <= 8'h7f;
+         default: s_axis_rq_tkeep_reg[7:0] <= 8'hff;
+           endcase // case(s_axis_rq_eop0_ptr[2:0])
+       end // if (s_axis_rq_tvalid_i & s_axis_rq_tready_o)
+     else
+       s_axis_rq_tkeep_reg[7:0] <= 8'd0;
+         
+     if (~attr_straddle_en_i)
+       s_axis_rq_tkeep_reg[15:8] <= s_axis_rq_tkeep_i[15:8];
+     else if (s_axis_rq_tvalid_i & s_axis_rq_tready_o)
+       begin
+         if (~s_axis_rq_eop[0])
+           s_axis_rq_tkeep_reg[15:8] <= 8'hff;
+         else if (s_axis_rq_eop0_ptr[3])
+           case(s_axis_rq_eop0_ptr[2:0])
+         3'd0: s_axis_rq_tkeep_reg[15:8] <= 8'h01;
+         3'd1: s_axis_rq_tkeep_reg[15:8] <= 8'h03;
+         3'd2: s_axis_rq_tkeep_reg[15:8] <= 8'h07;
+         3'd3: s_axis_rq_tkeep_reg[15:8] <= 8'h0f;
+         3'd4: s_axis_rq_tkeep_reg[15:8] <= 8'h1f;
+         3'd5: s_axis_rq_tkeep_reg[15:8] <= 8'h3f;
+         3'd6: s_axis_rq_tkeep_reg[15:8] <= 8'h7f;
+         default: s_axis_rq_tkeep_reg[15:8] <= 8'hff;
+           endcase // case(s_axis_rq_eop0_ptr[2:0])
+         else if ((s_axis_rq_sop[0] && (s_axis_rq_sop0_ptr[1]))||
+              s_axis_rq_sop[1])
+           // Packet starting in second half
+           begin
+         if (~s_axis_rq_eop[1])
+           s_axis_rq_tkeep_reg[15:8] <= 8'hff;
+         else
+           case(s_axis_rq_eop1_ptr[2:0])
+             3'd2: s_axis_rq_tkeep_reg[15:8] <= 8'h07;
+             3'd3: s_axis_rq_tkeep_reg[15:8] <= 8'h0f;
+             3'd4: s_axis_rq_tkeep_reg[15:8] <= 8'h1f;
+             3'd5: s_axis_rq_tkeep_reg[15:8] <= 8'h3f;
+             3'd6: s_axis_rq_tkeep_reg[15:8] <= 8'h7f;
+             default: s_axis_rq_tkeep_reg[15:8] <= 8'hff;
+           endcase // case(s_axis_rq_eop1_ptr[2:0])
+           end // if ((s_axis_rq_sop[0] && (s_axis_rq_sop0_ptr[1]))||...
+         else
+           s_axis_rq_tkeep_reg[15:8] <= 8'd0;
+       end // if (s_axis_rq_tvalid_i & s_axis_rq_tready_o)
+     else
+       s_axis_rq_tkeep_reg[15:8] <= 8'd0;
+
+
+      s_axis_rq_tuser_reg <= {
+			      s_axis_rq_parity_i[63:0],
+			      s_axis_rq_seq_num_upper[5:0],
+			      s_axis_rq_seq_num_lower[5:0],
+			      s_axis_rq_tph_st_tag_upper[7:0],
+			      s_axis_rq_tph_st_tag_lower[7:0],
+			      2'd0, // TPH Indirect Tag Enable
+			      s_axis_rq_tph_type_upper[1:0],
+			      s_axis_rq_tph_type_lower[1:0],
+			      s_axis_rq_tph_present_upper,
+			      s_axis_rq_tph_present_lower,
+			      s_axis_rq_tuser_i[36:20],
+			      s_axis_rq_addr_offset_upper[1:0],
+			      s_axis_rq_addr_offset_lower[1:0],
+			      s_axis_rq_lbe_upper[3:0],
+			      s_axis_rq_lbe_lower[3:0],
+			      s_axis_rq_fbe_upper[3:0],
+			      s_axis_rq_fbe_lower[3:0]
+			      };
+
+     // Generate discontinue for lower and upper halves
+     if (~attr_straddle_en_i) 
+       begin
+         s_axis_rq_tuser_discontinue_reg_lower <= s_axis_rq_tuser_i[36] &
+                              (~s_axis_rq_tlast_i |
+                               ~s_axis_rq_tkeep_i[8]);
+         s_axis_rq_tuser_discontinue_reg_upper <= s_axis_rq_tuser_i[36] &
+                              (~s_axis_rq_tlast_i |
+                               s_axis_rq_tkeep_i[8]);
+       end // if (~attr_straddle_en_i)
+     else
+       begin
+         s_axis_rq_tuser_discontinue_reg_lower <= s_axis_rq_tuser_i[36] &
+                              (~s_axis_rq_eop[0] |
+                               ~s_axis_rq_eop0_ptr[3]);
+         s_axis_rq_tuser_discontinue_reg_upper <= s_axis_rq_tuser_i[36] &
+                              (~s_axis_rq_eop[0] |
+                               s_axis_rq_eop0_ptr[3]);
+       end // else: !if(~attr_straddle_en_i)
+     
+     s_axis_rq_tlast_reg_lower <= attr_straddle_en_i? 
+                      (s_axis_rq_eop[0] & ~s_axis_rq_eop0_ptr[3]):
+                      (s_axis_rq_tlast_i & ~s_axis_rq_tkeep_i[8]);
+     s_axis_rq_tlast_reg_upper <= attr_straddle_en_i? 
+                      (s_axis_rq_eop[0] & s_axis_rq_eop0_ptr[3]) | s_axis_rq_eop[1]:
+                      (s_axis_rq_tlast_i & s_axis_rq_tkeep_i[8]);
+       end // else: !if(~reset_n_user_clk_i)
+
+  assign s_axis_rq_parity[63:0] =  PARITY_ENABLE? s_axis_rq_tuser_reg[136:73] : 64'd0;
+
+   // Generate the tuser signals for the core side
+   // discontinue
+  assign  fifo_in_data_tuser[11] = s_axis_rq_tuser_discontinue_reg_lower;
+   assign fifo_in_data_tuser[AXI4_CORE_RQ_TUSER_WIDTH+11] = s_axis_rq_tuser_discontinue_reg_upper;
+
+  // First and Last BE
+  assign  fifo_in_data_tuser[3:0] = s_axis_rq_tuser_reg[3:0]; // First BE
+  assign  fifo_in_data_tuser[AXI4_CORE_RQ_TUSER_WIDTH+3:AXI4_CORE_RQ_TUSER_WIDTH] = s_axis_rq_tuser_reg[7:4];
+  assign  fifo_in_data_tuser[7:4] = s_axis_rq_tuser_reg[11:8]; // Last BE
+  assign  fifo_in_data_tuser[AXI4_CORE_RQ_TUSER_WIDTH+7:AXI4_CORE_RQ_TUSER_WIDTH+4] = s_axis_rq_tuser_reg[15:12];
+
+  // addr offset
+  assign  fifo_in_data_tuser[10:8] = {1'b0, s_axis_rq_tuser_reg[17:16]}; 
+  assign  fifo_in_data_tuser[AXI4_CORE_RQ_TUSER_WIDTH+10:AXI4_CORE_RQ_TUSER_WIDTH+8] =
+      {1'b0, s_axis_rq_tuser_reg[19:18]}; 
+  // TPH present
+  assign  fifo_in_data_tuser[12] = s_axis_rq_tuser_reg[37];
+  assign  fifo_in_data_tuser[AXI4_CORE_RQ_TUSER_WIDTH+12] =s_axis_rq_tuser_reg[38];
+  // TPH Type
+  assign  fifo_in_data_tuser[14:13] = s_axis_rq_tuser_reg[40:39];
+  assign  fifo_in_data_tuser[AXI4_CORE_RQ_TUSER_WIDTH+14:AXI4_CORE_RQ_TUSER_WIDTH+13] = s_axis_rq_tuser_reg[42:41];
+  // TPH Indirect Tag Enable
+  assign  fifo_in_data_tuser[15] = 1'b0;
+  assign  fifo_in_data_tuser[AXI4_CORE_RQ_TUSER_WIDTH+15] = 1'b0;
+  // TPH Steering Tag
+  assign  fifo_in_data_tuser[23:16] = s_axis_rq_tuser_reg[52:45];
+  assign  fifo_in_data_tuser[AXI4_CORE_RQ_TUSER_WIDTH+23:AXI4_CORE_RQ_TUSER_WIDTH+16] = s_axis_rq_tuser_reg[60:53];
+  // Sequence Number
+  assign  fifo_in_data_tuser[27:24] = s_axis_rq_tuser_reg[64:61];
+  assign  fifo_in_data_tuser[61:60] = s_axis_rq_tuser_reg[66:65];
+  assign  fifo_in_data_tuser[AXI4_CORE_RQ_TUSER_WIDTH+27:AXI4_CORE_RQ_TUSER_WIDTH+24] = s_axis_rq_tuser_reg[70:67];
+  assign  fifo_in_data_tuser[AXI4_CORE_RQ_TUSER_WIDTH+61:AXI4_CORE_RQ_TUSER_WIDTH+60] = s_axis_rq_tuser_reg[72:71];
+   // parity
+   assign fifo_in_data_tuser[59:28] = s_axis_rq_parity[31:0];
+   assign fifo_in_data_tuser[AXI4_CORE_RQ_TUSER_WIDTH+59:AXI4_CORE_RQ_TUSER_WIDTH+28] = s_axis_rq_parity[63:32];
+   
+   // Generate tlast for lower and upper halves
+  assign fifo_in_data_tlast[0] = s_axis_rq_tlast_reg_lower;
+  assign fifo_in_data_tlast[1] = s_axis_rq_tlast_reg_upper;
+
+   // Generate valid for upper half
+  assign fifo_in_data_valid[0] = s_axis_rq_tvalid_reg_lower;
+  assign fifo_in_data_valid[1] = s_axis_rq_tvalid_reg_upper;
+
+   assign fifo_in_data[AXI4_CORE_DATA_WIDTH-1:0] = s_axis_rq_tdata_reg[AXI4_CORE_DATA_WIDTH-1:0];
+   assign fifo_in_data[FIFO_IN_DATA_WIDTH/2+AXI4_CORE_DATA_WIDTH-1:FIFO_IN_DATA_WIDTH/2] =
+      s_axis_rq_tdata_reg[AXI4_CORE_DATA_WIDTH*2-1:AXI4_CORE_DATA_WIDTH];
+
+   assign fifo_in_data[AXI4_CORE_DATA_WIDTH + AXI4_CORE_RQ_TKEEP_WIDTH-1: AXI4_CORE_DATA_WIDTH] =
+      s_axis_rq_tkeep_reg[AXI4_CORE_RQ_TKEEP_WIDTH-1:0];
+  assign  fifo_in_data[FIFO_IN_DATA_WIDTH/2 + AXI4_CORE_DATA_WIDTH + AXI4_CORE_RQ_TKEEP_WIDTH-1:
+               FIFO_IN_DATA_WIDTH/2 + AXI4_CORE_DATA_WIDTH] =
+      s_axis_rq_tkeep_reg[AXI4_CORE_RQ_TKEEP_WIDTH*2-1:AXI4_CORE_RQ_TKEEP_WIDTH];
+
+   assign fifo_in_data[AXI4_CORE_DATA_WIDTH + AXI4_CORE_RQ_TKEEP_WIDTH +  AXI4_CORE_RQ_TUSER_WIDTH-1:
+               AXI4_CORE_DATA_WIDTH + AXI4_CORE_RQ_TKEEP_WIDTH] = 
+      fifo_in_data_tuser[AXI4_CORE_RQ_TUSER_WIDTH-1:0];
+   assign fifo_in_data[FIFO_IN_DATA_WIDTH/2 + AXI4_CORE_DATA_WIDTH + AXI4_CORE_RQ_TKEEP_WIDTH +  AXI4_CORE_RQ_TUSER_WIDTH-1:
+               FIFO_IN_DATA_WIDTH/2 + AXI4_CORE_DATA_WIDTH + AXI4_CORE_RQ_TKEEP_WIDTH] = 
+      fifo_in_data_tuser[AXI4_CORE_RQ_TUSER_WIDTH*2-1:AXI4_CORE_RQ_TUSER_WIDTH];
+
+   assign fifo_in_data[AXI4_CORE_DATA_WIDTH + AXI4_CORE_RQ_TKEEP_WIDTH +  AXI4_CORE_RQ_TUSER_WIDTH] =
+      fifo_in_data_tlast[0];
+   assign fifo_in_data[FIFO_IN_DATA_WIDTH/2 + AXI4_CORE_DATA_WIDTH + AXI4_CORE_RQ_TKEEP_WIDTH +  AXI4_CORE_RQ_TUSER_WIDTH] =
+      fifo_in_data_tlast[1];
+ 
+   // De-assert ready when FIFO is almost full
+   always @(posedge user_clk_i)
+     if (~reset_n_user_clk_i)
+       s_axis_rq_tready_o <= 1'b0;
+     else
+       s_axis_rq_tready_o <= #(TCQ) ~fifo_almost_full_user_clk;
+
+  // Register tready from hard block
+   always @(posedge user_clk2_i)
+     if (~reset_n_user_clk2_i)
+       core_rq_tready_reg <= {AXI4_CORE_RQ_TREADY_WIDTH{1'b0}};
+     else
+       core_rq_tready_reg <= core_rq_tready_i;
+
+  assign  core_rq_tready_int = attr_axisten_if_rq_cc_registered_tready_i?
+      core_rq_tready_reg : core_rq_tready_i;
+
+   // Async FIFO
+   xp4_usp_smsw_512b_async_fifo #
+     (
+      .TCQ(TCQ),
+      .IMPL_TARGET(IMPL_TARGET),
+      .IN_DATA_WIDTH(FIFO_IN_DATA_WIDTH),
+      .FIFO_WIDTH(FIFO_OUT_DATA_WIDTH),
+      .FIFO_DEPTH(16),
+      .FIFO_ALMOST_FULL_THRESHOLD(7)
+      )
+     pcie_4_0_512b_async_fifo_blk
+       (
+    .clk_i(user_clk2_i),
+    .clk_en_i(user_clk_en_i),
+        .reset_n_i(reset_n_user_clk2_i),
+        .link_down_reset_i(link_down_reset_i),
+    // Write side
+    .write_data_i(fifo_in_data),
+    .write_en_i(fifo_in_data_valid),
+    .fifo_almost_full_o(fifo_almost_full_user_clk),
+    // Read side
+    .read_en_i(output_mux_ready),
+    .read_data_o(fifo_read_data),
+    .read_data_valid_o(fifo_read_data_valid)
+    );
+
+   // Instance of output MUX
+   xp4_usp_smsw_512b_rq_output_mux #
+     (
+      .TCQ(TCQ),
+      .IMPL_TARGET(IMPL_TARGET),
+      .IN_DATA_WIDTH(OUTPUT_MUX_IN_DATA_WIDTH),
+      .OUT_DATA_WIDTH(AXI4_CORE_DATA_WIDTH),
+      .TUSER_WIDTH(AXI4_CORE_RQ_TUSER_WIDTH),
+      .TKEEP_WIDTH(AXI4_CORE_RQ_TKEEP_WIDTH),
+      .TREADY_WIDTH(AXI4_CORE_RQ_TREADY_WIDTH)
+      )
+     pcie_4_0_512b_rq_output_mux_blk
+       (
+        .clk_i(user_clk2_i),
+        .reset_n_i(reset_n_user_clk_i),
+        .link_down_reset_i(link_down_reset_i),
+    .in_data_i(fifo_read_data),
+    .in_data_valid_i(fifo_read_data_valid),
+    .upstream_ready_o(output_mux_ready),
+
+    .out_data_o(core_rq_tdata_o),
+        .out_data_valid_o(core_rq_tvalid_o),
+    .out_tuser_o(core_rq_tuser_o),
+    .out_tlast_o(core_rq_tlast_o),
+    .out_tkeep_o(core_rq_tkeep_o),
+    .downstream_ready_i(core_rq_tready_int)
+    );
+
+endmodule // pcie_4_0_512b_rq_intfc
+
+
+
+
+
+
+
+   
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2023 AMD, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD, Inc. and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : UltraScale+ FPGA PCI Express v4.0 Integrated Block
+// File       : xp4_usp_smsw_512b_rq_output_mux.v
+// Version    : 1.1 
+//-----------------------------------------------------------------------------
+//--------------------------------------------------------------------------------------------------
+`timescale 1ps/1ps
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_512b_rq_output_mux #(
+   parameter TCQ = 100,
+   parameter IMPL_TARGET = "SOFT",
+   parameter IN_DATA_WIDTH = 256+33+8+1,    
+   parameter OUT_DATA_WIDTH = 256,
+   parameter TUSER_WIDTH = 33,
+   parameter TKEEP_WIDTH = 8,
+   parameter TREADY_WIDTH = 4
+   )
+  (
+    input  wire           clk_i // 250 MHz clock for client-facing interfaces
+   ,input  wire           reset_n_i // Reset in the user clock domain
+   ,input  wire           link_down_reset_i // Link went down
+
+   ,input wire[IN_DATA_WIDTH-1:0] in_data_i
+   ,input wire in_data_valid_i
+   ,output wire upstream_ready_o
+
+   ,output reg [OUT_DATA_WIDTH-1:0]  out_data_o
+   ,output reg           out_data_valid_o
+   ,output reg [TUSER_WIDTH-1:0] out_tuser_o
+   ,output reg          out_tlast_o
+   ,output reg [TKEEP_WIDTH-1:0] out_tkeep_o
+   ,input  wire [TREADY_WIDTH-1:0]  downstream_ready_i
+   );
+
+
+   reg [1:0] output_fifo_occupancy;
+  reg          output_fifo_write_ptr;
+  reg          output_fifo_read_ptr;
+   wire      output_fifo_full;
+   wire      output_fifo_empty;
+
+   reg [OUT_DATA_WIDTH-1:0] m_axis_rq_tdata_first_reg;
+   reg [TKEEP_WIDTH-1:0]    m_axis_rq_tkeep_first_reg;
+   reg [TUSER_WIDTH-1:0]    m_axis_rq_tuser_first_reg;
+   reg                 m_axis_rq_tlast_first_reg;
+   
+   reg [OUT_DATA_WIDTH-1:0] m_axis_rq_tdata_second_reg;
+   reg [TKEEP_WIDTH-1:0]    m_axis_rq_tkeep_second_reg;
+   reg [TUSER_WIDTH-1:0]    m_axis_rq_tuser_second_reg;
+   reg                 m_axis_rq_tlast_second_reg;
+   
+   wire             output_reg_mux_sel;
+   //---------------------------------------------------------------------------------------------
+   // Output FIFO.
+   // The main FIFO feeds into two read registers in the core clock domain, which are configured
+   // as a 2-entry FIFO.
+   // This can be thought of as logical extensions of the main FIFO.
+   //---------------------------------------------------------------------------------------------
+
+   assign    upstream_ready_o = ~output_fifo_full;
+
+   // Maintain write and read pointers
+   // Write pointer is updated only in alternate cycles.
+   always @(posedge clk_i)
+     if (~reset_n_i)
+       output_fifo_write_ptr <= #(TCQ)  1'b0;
+     else if (link_down_reset_i)
+       output_fifo_write_ptr <= #(TCQ)  1'b0;
+     else
+       if (in_data_valid_i & ~output_fifo_full)
+     output_fifo_write_ptr <= #(TCQ) ~output_fifo_write_ptr;
+   
+   always @(posedge clk_i)
+     if (~reset_n_i)
+       output_fifo_read_ptr <= #(TCQ) 2'd0;
+     else if (link_down_reset_i)
+       output_fifo_read_ptr <= #(TCQ) 2'd0;
+     else
+       if ((downstream_ready_i[3] | ~out_data_valid_o) &
+       ~output_fifo_empty)
+     output_fifo_read_ptr <= #(TCQ) ~output_fifo_read_ptr;
+
+      // Maintain FIFO occupancy
+   always @(posedge clk_i)
+     if (~reset_n_i)
+       output_fifo_occupancy <= #(TCQ)  2'd0;
+     else if (link_down_reset_i)
+       output_fifo_occupancy <= #(TCQ)  2'd0;
+     else
+       if ((in_data_valid_i & ~output_fifo_full) &
+       ~((downstream_ready_i[3] | ~out_data_valid_o) &
+         ~output_fifo_empty))
+     output_fifo_occupancy <= #(TCQ) output_fifo_occupancy + 2'd1;
+       else
+     if (~(in_data_valid_i & ~output_fifo_full) &
+         ((downstream_ready_i[3] | ~out_data_valid_o) &
+          ~output_fifo_empty))
+       output_fifo_occupancy <= #(TCQ) output_fifo_occupancy - 2'd1;
+   
+   assign output_fifo_full = output_fifo_occupancy[1];
+   assign output_fifo_empty = (output_fifo_occupancy == 2'b00);
+
+   // Write data into FIFO.
+   always @(posedge clk_i)
+     if (~reset_n_i)
+       begin
+          m_axis_rq_tdata_first_reg <= #(TCQ) {OUT_DATA_WIDTH{1'b0}};
+          m_axis_rq_tdata_second_reg <= #(TCQ) {OUT_DATA_WIDTH{1'b0}};
+          m_axis_rq_tkeep_first_reg <= #(TCQ) {TKEEP_WIDTH{1'b0}};
+          m_axis_rq_tkeep_second_reg <= #(TCQ) {TKEEP_WIDTH{1'b0}};
+          m_axis_rq_tuser_first_reg <= #(TCQ) {TUSER_WIDTH{1'b0}};
+          m_axis_rq_tuser_second_reg <= #(TCQ) {TUSER_WIDTH{1'b0}};
+          m_axis_rq_tlast_first_reg <= #(TCQ) 1'b0;
+          m_axis_rq_tlast_second_reg <= #(TCQ) 1'b0;
+       end
+     else
+        if (in_data_valid_i & ~output_fifo_full)
+      begin
+        case(output_fifo_write_ptr)
+          1'b0:
+         begin
+            m_axis_rq_tdata_first_reg <= #(TCQ) in_data_i[OUT_DATA_WIDTH-1:0];
+            m_axis_rq_tkeep_first_reg <= #(TCQ) in_data_i[OUT_DATA_WIDTH+TKEEP_WIDTH-1:OUT_DATA_WIDTH];
+            m_axis_rq_tuser_first_reg <= #(TCQ) in_data_i[OUT_DATA_WIDTH+TKEEP_WIDTH+TUSER_WIDTH-1:OUT_DATA_WIDTH+TKEEP_WIDTH];
+            m_axis_rq_tlast_first_reg <= #(TCQ) in_data_i[IN_DATA_WIDTH-1];
+         end
+           default:
+         begin
+            m_axis_rq_tdata_second_reg <= #(TCQ) in_data_i[OUT_DATA_WIDTH-1:0];
+            m_axis_rq_tkeep_second_reg <= #(TCQ) in_data_i[OUT_DATA_WIDTH+TKEEP_WIDTH-1:OUT_DATA_WIDTH];
+            m_axis_rq_tuser_second_reg <= #(TCQ) in_data_i[OUT_DATA_WIDTH+TKEEP_WIDTH+TUSER_WIDTH-1:OUT_DATA_WIDTH+TKEEP_WIDTH];
+            m_axis_rq_tlast_second_reg <= #(TCQ) in_data_i[IN_DATA_WIDTH-1];
+         end
+         endcase // case(output_fifo_write_ptr)
+        end // if (in_data_valid_i & ~output_fifo_full)
+   
+   // Output registers
+   assign output_reg_mux_sel = output_fifo_read_ptr;
+
+   always @(posedge clk_i)
+     if (~reset_n_i)
+       begin
+      out_data_o <= #(TCQ)  {OUT_DATA_WIDTH{1'b0}};
+      out_tuser_o <= #(TCQ)  {TUSER_WIDTH{1'b0}};
+      out_tkeep_o <= #(TCQ)  {TKEEP_WIDTH{1'b0}};
+      out_tlast_o <= #(TCQ)  1'b0;
+       end
+     else
+       begin
+      if (~out_data_valid_o | downstream_ready_i[0])
+        begin
+           case(output_reg_mux_sel)
+         1'b0:
+           begin
+              out_data_o[127:0] <= #(TCQ)  m_axis_rq_tdata_first_reg[127:0];
+           end
+         default:
+           begin
+              out_data_o[127:0] <= #(TCQ)  m_axis_rq_tdata_second_reg[127:0];
+           end
+           endcase // case(output_reg_mux_sel)
+        end // if (~out_data_valid_o | downstream_ready_i[0])
+
+      if (~out_data_valid_o | downstream_ready_i[1])
+        begin
+           case(output_reg_mux_sel)
+         1'b0:
+           begin
+              out_data_o[255:128] <= #(TCQ)  m_axis_rq_tdata_first_reg[255:128];
+           end
+         default:
+           begin
+              out_data_o[255:128] <= #(TCQ)  m_axis_rq_tdata_second_reg[255:128];
+           end
+           endcase // case(output_reg_mux_sel)
+        end // if (~out_data_valid_o | downstream_ready_i[1])
+      
+      if (~out_data_valid_o | downstream_ready_i[2])
+        begin
+           case(output_reg_mux_sel)
+         1'b0:
+           begin
+              out_tuser_o <= #(TCQ)  m_axis_rq_tuser_first_reg;
+           end
+         default:
+           begin
+              out_tuser_o <= #(TCQ)  m_axis_rq_tuser_second_reg;
+           end
+           endcase // case(output_reg_mux_sel)
+        end // if (~out_data_valid_o | downstream_ready_i[2])
+      
+      if (~out_data_valid_o | downstream_ready_i[3])
+        begin
+           case(output_reg_mux_sel)
+         1'b0:         
+           begin
+              out_tkeep_o <= #(TCQ)  m_axis_rq_tkeep_first_reg;
+              out_tlast_o <= #(TCQ)  m_axis_rq_tlast_first_reg;
+           end
+         default:
+           begin
+              out_tkeep_o <= #(TCQ)  m_axis_rq_tkeep_second_reg;
+              out_tlast_o <= #(TCQ)  m_axis_rq_tlast_second_reg;
+           end
+           endcase // case(output_reg_mux_sel)
+        end // if (~out_data_valid_o | downstream_ready_i[3])
+       end // else: !if(~reset_n_i)
+
+   always @(posedge clk_i)
+     if (~reset_n_i)
+       out_data_valid_o <= #(TCQ) 1'b0;
+     else
+       if (~out_data_valid_o | downstream_ready_i[0])
+     out_data_valid_o <= #(TCQ) ~output_fifo_empty;
+
+endmodule // pcie_4_0_512b_rq_output_mux
+
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2023 AMD, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD, Inc. and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : UltraScale+ FPGA PCI Express v4.0 Integrated Block
+// File       : xp4_usp_smsw_512b_sync_fifo.v
+// Version    : 1.1 
+//-----------------------------------------------------------------------------
+//--------------------------------------------------------------------------------------------------
+`timescale 1ps/1ps
+(* DowngradeIPIdentifiedWarnings = "yes" *)
+module xp4_usp_smsw_512b_sync_fifo #
+  (
+   parameter TCQ = 100,
+   parameter IMPL_TARGET = "SOFT",
+   parameter AXISTEN_IF_EXT_512_INTFC_RAM_STYLE = "SRL",
+   parameter FIFO_WIDTH = 512,
+   parameter FIFO_DEPTH = 8,
+   parameter FIFO_ALMOST_FULL_THRESHOLD = 5
+   ) 
+  (
+    input  wire           clk_i // clock
+   ,input  wire           reset_n_i // Reset
+   ,input  wire           link_down_reset_i // Reset FIFO on link down
+
+   ,input wire [FIFO_WIDTH-1:0] write_data_i
+   ,input wire write_en_i
+   ,input wire read_en_i
+   ,output wire [FIFO_WIDTH-1:0] read_data_o
+   ,output wire read_data_valid_o
+   ,output reg fifo_almost_full
+   );
+   
+   reg [2:0] write_ptr;
+   reg [2:0] read_ptr;
+   reg [3:0] fifo_occupancy;
+   wire      fifo_empty;
+   wire      fifo_full;
+
+  integer    i;
+
+   reg [FIFO_WIDTH-1:0] ram_array[FIFO_DEPTH-1:0];
+   
+  // SRL 16 should be inferred when RAM_STYLE = "SRL"
+  generate 
+    if (AXISTEN_IF_EXT_512_INTFC_RAM_STYLE =="SRL") 
+      begin: srl_style_fifo
+
+    // synthesis translate_off
+    initial
+          begin
+        for (i=0; i < FIFO_DEPTH; i=i+1)
+          ram_array[i] = 0;
+      end
+        // synthesis translate_on
+
+  //Write to SRL inputs, and shift SRL
+  always @(posedge clk_i)
+      if (write_en_i & ~fifo_full)
+        begin
+      for (i= (FIFO_DEPTH-1); i>0; i=i-1)
+        ram_array[i] <= #TCQ ram_array[i-1];
+      ram_array[0]    <= #TCQ write_data_i;
+        end
+
+  //Maintain read pointer based on occupancy of the FIFO.
+  // Read pointer points to the highest index of full locations.
+   always @(posedge clk_i)
+     if (~reset_n_i)
+       read_ptr <= #TCQ 3'd0;
+     else if (link_down_reset_i)
+       read_ptr <= #TCQ 3'd0;
+     else if (write_en_i && ~fifo_full &&
+          (~(read_en_i & ~fifo_empty)))
+       // Write but no read
+       begin
+     if (~fifo_empty)
+       read_ptr <= #TCQ read_ptr + 3'd1;
+       end
+     else if ((~(write_en_i & ~fifo_full)) &&
+          read_en_i && ~fifo_empty &&
+          (read_ptr != 3'd0))
+       // Read but no write
+       read_ptr <= #TCQ read_ptr - 3'd1;
+
+     assign    read_data_o = ram_array[read_ptr];
+   end // block: srl_style_fifo
+    else
+      begin
+   // Write pointer
+   always @(posedge clk_i)
+     if (~reset_n_i)
+       write_ptr <= #TCQ 3'd0;
+     else if (link_down_reset_i)
+       write_ptr <= #TCQ 3'd0;
+     else if (write_en_i & ~fifo_full)
+       begin
+      if (write_ptr == FIFO_DEPTH-1)
+        write_ptr <= #TCQ 3'd0;
+      else
+        write_ptr <= #TCQ write_ptr + 3'd1;
+       end
+   always @(posedge clk_i)
+     if (write_en_i & ~fifo_full)
+       ram_array[write_ptr] <= #TCQ write_data_i;
+
+   // Read pointer
+   always @(posedge clk_i)
+     if (~reset_n_i)
+       read_ptr <= #TCQ 3'd0;
+     else if (link_down_reset_i)
+       read_ptr <= #TCQ 3'd0;
+     else if (read_en_i & ~fifo_empty)
+       begin
+      if (read_ptr == FIFO_DEPTH-1)
+        read_ptr <= #TCQ 3'd0;
+      else
+        read_ptr <= #TCQ read_ptr + 3'd1;
+       end
+    assign    read_data_o = ram_array[read_ptr];
+
+    end // else: !if(AXISTEN_IF_EXT_512_INTFC_RAM_STYLE =="SRL")
+  endgenerate
+
+   // Maintain FIFO occupancy
+   always @(posedge clk_i)
+     if (~reset_n_i)
+       fifo_occupancy <= #TCQ 4'd0;
+     else if (link_down_reset_i)
+       fifo_occupancy <= #TCQ 4'd0;
+     else if (write_en_i & ~fifo_full &
+          ~(read_en_i & ~fifo_empty))
+       fifo_occupancy <= #TCQ fifo_occupancy + 4'd1;
+     else if (~(write_en_i & ~fifo_full) &
+          read_en_i & ~fifo_empty)
+       fifo_occupancy <= #TCQ fifo_occupancy - 4'd1;
+
+   always @(posedge clk_i)
+     if (~reset_n_i)
+       fifo_almost_full <= #TCQ 1'b0;
+     else
+       fifo_almost_full <= #TCQ (fifo_occupancy >= FIFO_ALMOST_FULL_THRESHOLD);
+
+   assign    fifo_empty = (fifo_occupancy == 4'd0);
+   assign    fifo_full = (fifo_occupancy == FIFO_DEPTH);
+   assign    read_data_valid_o = ~fifo_empty;
+
+endmodule // pcie_4_0_512b_sync_fifo
+
+//
+// Gen4 Specific Module - GEN4
+//
+
diff --git a/sim/tb/include/board_common.vh b/sim/tb/include/board_common.vh
new file mode 100644
index 0000000..610ca48
--- /dev/null
+++ b/sim/tb/include/board_common.vh
@@ -0,0 +1,91 @@
+
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2025 Advanced Micro Devices, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : PCI Express DMA 
+// File       : board_common.vh
+// Version    : 5.0
+//-----------------------------------------------------------------------------
+
+`timescale 1ps/1ps
+
+`define IO_TRUE                      1
+`define IO_FALSE                     0
+
+`define TX_TASKS                     board.RP.tx_usrapp
+
+// Endpoint Sys clock clock frequency 100 MHz -> half clock -> 5000 pS
+`define SYS_CLK_COR_HALF_CLK_PERIOD         5000
+
+// Downstrean Port Sys clock clock frequency 250 MHz -> half clock -> 2000 pS
+`define SYS_CLK_DSPORT_HALF_CLK_PERIOD      2000
+
+`define RX_LOG                       0
+`define TX_LOG                       1
+
+// PCI Express TLP Types constants
+`define  PCI_EXP_MEM_READ32          7'b0000000
+`define  PCI_EXP_IO_READ             7'b0000010
+`define  PCI_EXP_CFG_READ0           7'b0000100
+`define  PCI_EXP_COMPLETION_WO_DATA  7'b0001010
+`define  PCI_EXP_MEM_READ64          7'b0100000
+`define  PCI_EXP_MSG_NODATA          7'b0110xxx
+`define  PCI_EXP_MEM_WRITE32         7'b1000000
+`define  PCI_EXP_IO_WRITE            7'b1000010
+`define  PCI_EXP_CFG_WRITE0          7'b1000100
+`define  PCI_EXP_COMPLETION_DATA     7'b1001010
+`define  PCI_EXP_MEM_WRITE64         7'b1100000
+`define  PCI_EXP_MSG_DATA            7'b1110xxx
+
+`define  RC_RX_TIMEOUT               5000
+`define  CQ_RX_TIMEOUT               5000
+
+`define  SYNC_RQ_RDY                 0
+`define  SYNC_CC_RDY                 1
diff --git a/sim/tb/include/initialization.svh b/sim/tb/include/initialization.svh
new file mode 100644
index 0000000..ac040a8
--- /dev/null
+++ b/sim/tb/include/initialization.svh
@@ -0,0 +1,154 @@
+// A collection of all the initialization tasks (previously part of the main usrapp_tx file)
+
+/************************************************************
+Task : TSK_XDMA_FIND_BAR
+Inputs : input BAR1 address
+Outputs : None
+Description : Read XDMA configuration register
+*************************************************************/
+task TSK_XDMA_FIND_BAR;
+  integer jj;
+  integer xdma_bar_found;
+begin
+  jj = 0;
+  xdma_bar_found = 0;
+  while (xdma_bar_found == 0 && (jj < 6)) begin   // search QDMA bar from 0 to 5 only
+    board.RP.tx_usrapp.P_READ_DATA = 32'hffff_ffff;
+    fork
+      if(board.RP.tx_usrapp.BAR_INIT_P_BAR_ENABLED[jj] == 2'b10) begin
+        board.RP.tx_usrapp.TSK_TX_MEMORY_READ_32(board.RP.tx_usrapp.DEFAULT_TAG,
+        board.RP.tx_usrapp.DEFAULT_TC, 11'd1,
+        board.RP.tx_usrapp.BAR_INIT_P_BAR[jj][31:0]+16'h0, 4'h0, 4'hF);
+        board.RP.tx_usrapp.TSK_WAIT_FOR_READ_DATA;
+      end else if(board.RP.tx_usrapp.BAR_INIT_P_BAR_ENABLED[jj] == 2'b11) begin
+        board.RP.tx_usrapp.TSK_TX_MEMORY_READ_64(board.RP.tx_usrapp.DEFAULT_TAG,
+        board.RP.tx_usrapp.DEFAULT_TC, 11'd1,{board.RP.tx_usrapp.BAR_INIT_P_BAR[jj+1][31:0],
+        board.RP.tx_usrapp.BAR_INIT_P_BAR[jj][31:0]+16'h0}, 4'h0, 4'hF);
+        board.RP.tx_usrapp.TSK_WAIT_FOR_READ_DATA;
+      end
+    join
+    board.RP.tx_usrapp.TSK_TX_CLK_EAT(10);
+
+    if((board.RP.tx_usrapp.BAR_INIT_P_BAR_ENABLED[jj] == 2'b10) || (board.RP.tx_usrapp.BAR_INIT_P_BAR_ENABLED[jj] == 2'b11)) begin
+      board.RP.tx_usrapp.DEFAULT_TAG = board.RP.tx_usrapp.DEFAULT_TAG + 1;
+
+      $display ("[%t] : Data read %h from Address 0x0000",$realtime , board.RP.tx_usrapp.P_READ_DATA);
+      if(board.RP.tx_usrapp.P_READ_DATA[31:16] == 16'h1FD3 ) begin  //Mask [15:0] which will have revision number.
+        xdma_bar = jj;
+        xdma_bar_found = 1;
+        $display (" QDMA BAR found : BAR %d is QDMA BAR\n", xdma_bar);
+      end
+      else if(board.RP.tx_usrapp.P_READ_DATA[31:16] == 16'h1FC0) begin  // XDMA Mask [15:0] which will have revision number.
+        xdma_bar = jj;
+        xdma_bar_found = 1;
+        $display (" XDMA BAR found : BAR %d is XDMA BAR\n", xdma_bar);
+      end
+      else begin
+        $display (" QDMA BAR : BAR %d is NOT QDMA BAR\n", jj);
+      end
+    end
+    jj = jj + 1;
+  end
+  if(xdma_bar_found == 0) begin
+    $display (" Not able to find QDMA BAR **ERROR** \n");
+  end
+end
+endtask
+
+/************************************************************
+Task : TSK_SYSTEM_INITIALIZATION
+Inputs : None
+Outputs : None
+Description : Waits for Transaction Interface Reset and Link-Up
+*************************************************************/
+
+task TSK_SYSTEM_INITIALIZATION;
+begin
+  //--------------------------------------------------------------------------
+  // Event # 1: Wait for Transaction reset to be de-asserted...
+  //--------------------------------------------------------------------------
+  wait (reset == 0);
+  $display("[%t] : Transaction Reset Is De-asserted...", $realtime);
+  //--------------------------------------------------------------------------
+  // Event # 2: Wait for Transaction link to be asserted...
+  //--------------------------------------------------------------------------
+  board.RP.cfg_usrapp.TSK_WRITE_CFG_DW(32'h01, 32'h00000007, 4'h1);
+  board.RP.cfg_usrapp.TSK_READ_CFG_DW(DEV_CTRL_REG_ADDR/4);
+  board.RP.cfg_usrapp.TSK_WRITE_CFG_DW(DEV_CTRL_REG_ADDR/4,( board.RP.cfg_usrapp.cfg_rd_data | (DEV_CAP_MAX_PAYLOAD_SUPPORTED * 32)) , 4'h1);
+
+  board.RP.tx_usrapp.TSK_TX_CLK_EAT(100);
+  wait (board.RP.pcie_4_0_rport.user_lnk_up == 1);
+  board.RP.tx_usrapp.TSK_TX_CLK_EAT(100);
+  $display("[%t] : Transaction Link Is Up...", $realtime);
+  //TSK_SYSTEM_CONFIGURATION_CHECK;
+end
+endtask
+//
+/************************************************************
+Task : TSK_SYSTEM_CONFIGURATION_CHECK
+Inputs : None
+Outputs : None
+Description : Check that options selected from Coregen GUI are
+              set correctly.
+              Checks - Max Link Speed/Width, Device/Vendor ID, CMPS
+*************************************************************/
+task TSK_SYSTEM_CONFIGURATION_CHECK;
+begin
+  error_check = 0;
+
+  // Check Link Speed/Width
+  TSK_TX_TYPE0_CONFIGURATION_READ(DEFAULT_TAG, LINK_CTRL_REG_ADDR, 4'hF); // 12'hD0
+  TSK_WAIT_FOR_READ_DATA;
+
+  if(P_READ_DATA[19:16] == MAX_LINK_SPEED) begin
+    if     (P_READ_DATA[19:16] == 1) $display("[%t] :    Check Max Link Speed = 2.5GT/s - PASSED", $realtime);
+    else if(P_READ_DATA[19:16] == 2) $display("[%t] :    Check Max Link Speed = 5.0GT/s - PASSED", $realtime);
+    else if(P_READ_DATA[19:16] == 3) $display("[%t] :    Check Max Link Speed = 8.0GT/s - PASSED", $realtime);
+    else if(P_READ_DATA[19:16] == 4) $display("[%t] :    Check Max Link Speed = 16.0GT/s - PASSED", $realtime);
+    else if(P_READ_DATA[19:16] == 5) $display("[%t] :    Check Max Link Speed = 32.0GT/s - PASSED", $realtime);
+  end else begin
+    $display("ERROR: [%t] :    Check Max Link Speed - FAILED", $realtime);
+    $display("[%t] :    Data Error Mismatch, Parameter Data %x != Read Data %x", $realtime, MAX_LINK_SPEED, P_READ_DATA[19:16]);
+    board.RP.tx_usrapp.test_state =1;
+  end
+
+  if(P_READ_DATA[24:20] == LINK_CAP_MAX_LINK_WIDTH)
+    $display("[%t] :    Check Negotiated Link Width = 5'h%x - PASSED", $realtime, LINK_CAP_MAX_LINK_WIDTH);
+  else
+    $display("[%t] :    Data Error Mismatch, Parameter Data %x != Read Data %x", $realtime, LINK_CAP_MAX_LINK_WIDTH, P_READ_DATA[24:20]);
+
+  // Check Device/Vendor ID
+  TSK_TX_TYPE0_CONFIGURATION_READ(DEFAULT_TAG, 12'h0, 4'hF);
+  TSK_WAIT_FOR_READ_DATA;
+
+  if(P_READ_DATA[31:16] != EP_DEV_ID1) begin
+    $display("ERROR: [%t] :    Check Device/Vendor ID - FAILED", $realtime);
+    $display("[%t] :    Data Error Mismatch, Parameter Data %x != Read Data %x", $realtime, EP_DEV_ID1, P_READ_DATA);
+    board.RP.tx_usrapp.test_state =1;
+  //error_check = 1;
+  end else begin
+    $display("[%t] :    Check Device/Vendor ID - PASSED", $realtime);
+  end
+
+  // Check CMPS
+  TSK_TX_TYPE0_CONFIGURATION_READ(DEFAULT_TAG, PCIE_DEV_CAP_ADDR, 4'hF); //12'hC4
+  TSK_WAIT_FOR_READ_DATA;
+
+  if(P_READ_DATA[2:0] != DEV_CAP_MAX_PAYLOAD_SUPPORTED) begin
+    $display("ERROR: [%t] :    Check CMPS ID - FAILED", $realtime);
+    $display("[%t] :    Data Error Mismatch, Parameter Data %x != Read data %x", $realtime, DEV_CAP_MAX_PAYLOAD_SUPPORTED, P_READ_DATA[2:0]);
+    board.RP.tx_usrapp.test_state =1;
+  //error_check = 1;
+  end else begin
+    $display("[%t] :    Check CMPS ID - PASSED", $realtime);
+  end
+
+  if(error_check == 0) begin
+    $display("[%t] :    SYSTEM CHECK PASSED", $realtime);
+  end else begin
+    $display("ERROR: [%t] :    SYSTEM CHECK FAILED", $realtime);
+    board.RP.tx_usrapp.test_state =1;
+    $finish;
+  end
+end
+endtask 
diff --git a/sim/tb/include/pci_exp_expect_tasks.vh b/sim/tb/include/pci_exp_expect_tasks.vh
new file mode 100644
index 0000000..0062370
--- /dev/null
+++ b/sim/tb/include/pci_exp_expect_tasks.vh
@@ -0,0 +1,1397 @@
+
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2025 Advanced Micro Devices, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : PCI Express DMA 
+// File       : pci_exp_expect_tasks.vh
+// Version    : 5.0
+//-----------------------------------------------------------------------------
+//--------------------------------------------------------------------------------
+
+`define EXPECT_CPLD_PAYLOAD board.RP.tx_usrapp.expect_cpld_payload
+`define EXPECT_MEMWR_PAYLOAD board.RP.tx_usrapp.expect_memwr_payload
+`define EXPECT_MEMWR64_PAYLOAD board.RP.tx_usrapp.expect_memwr64_payload
+
+reg [31:0] error_file_ptr;
+
+initial
+begin
+  error_file_ptr = $fopen("error.dat");
+  if (!error_file_ptr) begin
+    $write("ERROR: Could not open error.dat.\n");
+    $finish;
+  end
+end
+
+/************************************************************
+Task : TSK_EXPECT_CPLD
+Inputs : traffic_class, td, ep, attr, length, payload
+Outputs : status 0-Failed 1-Successful
+Description : Expecting a TLP from Rx side with matching
+              traffic_class, td, ep, attr, length and payload
+*************************************************************/
+task TSK_EXPECT_CPLD;
+
+  input   [2:0]  traffic_class;
+  input          td;
+  input          ep;
+  input   [1:0]  attr;
+  input   [9:0]  length;
+  input   [15:0] completer_id;
+  input   [2:0]  completion_status;
+  input          bcm;
+  input   [11:0] byte_count;
+  input   [15:0] requester_id;
+  input   [7:0]  tag;
+  input   [6:0]  address_low;
+
+  output         expect_status;
+
+  reg   [2:0]  traffic_class_;
+  reg          td_;
+  reg          ep_;
+  reg   [1:0]  attr_;
+  reg   [9:0]  length_;
+  reg   [15:0] completer_id_;
+  reg   [2:0]  completion_status_;
+  reg          bcm_;
+  reg   [11:0] byte_count_;
+  reg   [15:0] requester_id_;
+  reg   [7:0]  tag_;
+  reg   [6:0]  address_low_;
+
+  integer      payload_len;
+  integer      i_;
+  reg          wait_for_next;
+
+  begin
+    wait_for_next = 1'b1; //haven't found any matching tag yet
+    while(wait_for_next)
+    begin
+      @ rcvd_cpld; //wait for a rcvd_cpld event
+      traffic_class_ = frame_store_rx[1] >> 4;
+      td_ = frame_store_rx[2] >> 7;
+      ep_ = frame_store_rx[2] >> 6;
+      attr_ = frame_store_rx[2] >> 4;
+      length_ = frame_store_rx[2];
+      length_ = (length_ << 8) | (frame_store_rx[3]);
+      bcm_ = frame_store_rx[6] >> 4;
+      completion_status_= frame_store_rx[6] >> 5;
+      byte_count_ = (frame_store_rx[6]);
+      byte_count_ = (byte_count_ << 8) | frame_store_rx[7];
+      completer_id_ = {frame_store_rx[4], frame_store_rx[5]};
+      requester_id_= {frame_store_rx[8], frame_store_rx[9]};
+      tag_= frame_store_rx[10];
+      address_low_ = frame_store_rx[11];
+
+      payload_len = (bcm_) ? byte_count_ : (length << 2);
+      if (payload_len==0) payload_len = 4096;
+
+      $display("[%t] : Received CPLD --- Tag 0x%h", $realtime, tag_);
+      if(tag == tag_) //find matching tag
+      begin
+        wait_for_next = 1'b0;
+        if((traffic_class == traffic_class_) &&
+           (td === td_) && (ep == ep_) && (attr == attr_) &&
+           (length == length_) && (bcm == bcm_) &&
+           (completion_status == completion_status_) &&
+           (byte_count == byte_count_) &&
+           (completer_id == completer_id_) &&
+           (requester_id == requester_id_) &&
+           (address_low == address_low_))
+        begin
+          // find matching header then compare payload
+          for (i_ = 0; i_ < payload_len; i_ = i_ + 1)
+            if(`EXPECT_CPLD_PAYLOAD[i_] != frame_store_rx[12 + i_]) //find mismatch
+            begin
+              $fdisplay(error_file_ptr, "[%t] : Found payload mismatch in received CPLD - Tag 0x%h: \n", $time, tag_);
+              $fdisplay(error_file_ptr, "Expected:");
+              for (i_ = 0; i_ < payload_len; i_ = i_ + 1)
+                $fdisplay(error_file_ptr,"\t %0x", `EXPECT_CPLD_PAYLOAD[i_]);
+              $fdisplay(error_file_ptr, "Received:");
+              for (i_ = 0; i_ < payload_len; i_ = i_ + 1)
+                $fdisplay(error_file_ptr,"\t %0x", frame_store_rx[12+i_]);
+
+              $fdisplay(error_file_ptr, "");
+              expect_status = 1'b0;
+              i_ = 5000;
+            end
+          //find matching frame
+          if(i_ == payload_len)
+            expect_status = 1'b1;
+        end
+        else // header mismatches, error out
+        begin
+          $fdisplay(error_file_ptr, "[%t] : Found header mismatch in received CPLD - Tag 0x%h: \n", $time, tag_);
+          $fdisplay(error_file_ptr, "Expected:");
+          $fdisplay(error_file_ptr, "\t Traffic Class: 0x%h", traffic_class);
+          $fdisplay(error_file_ptr, "\t TD: %h", td);
+          $fdisplay(error_file_ptr, "\t EP: %h", ep);
+          $fdisplay(error_file_ptr, "\t Attributes: 0x%h", attr);
+          $fdisplay(error_file_ptr, "\t Length: 0x%h", length);
+          $fdisplay(error_file_ptr, "\t BCM: 0x%h", bcm);
+          $fdisplay(error_file_ptr, "\t Completion Status: 0x%h", completion_status);
+          $fdisplay(error_file_ptr, "\t Byte Count: 0x%h", byte_count);
+          $fdisplay(error_file_ptr, "\t Completer ID: 0x%h", completer_id);
+          $fdisplay(error_file_ptr, "\t Requester ID: 0x%h", requester_id);
+          $fdisplay(error_file_ptr, "\t Tag: 0x%h", tag);
+          $fdisplay(error_file_ptr, "\t Lower Address: 0x%h", address_low);
+          $fdisplay(error_file_ptr, "Received:");
+          $fdisplay(error_file_ptr, "\t Traffic Class: 0x%h", traffic_class_);
+          $fdisplay(error_file_ptr, "\t TD: %h", td_);
+          $fdisplay(error_file_ptr, "\t EP: %h", ep_);
+          $fdisplay(error_file_ptr, "\t Attributes: 0x%h", attr_);
+          $fdisplay(error_file_ptr, "\t Length: 0x%h", length_);
+          $fdisplay(error_file_ptr, "\t BCM: 0x%h", bcm_);
+          $fdisplay(error_file_ptr, "\t Completion Status: 0x%h", completion_status_);
+          $fdisplay(error_file_ptr, "\t Byte Count: 0x%h", byte_count_);
+          $fdisplay(error_file_ptr, "\t Completer ID: 0x%h", completer_id_);
+          $fdisplay(error_file_ptr, "\t Requester ID: 0x%h", requester_id_);
+          $fdisplay(error_file_ptr, "\t Tag: 0x%h", tag_);
+          $fdisplay(error_file_ptr, "\t Lower Address: 0x%h", address_low_);
+          $fdisplay(error_file_ptr, "");
+          expect_status = 1'b0;
+        end
+      end
+    end
+  end
+endtask
+
+
+/************************************************************
+Task : TSK_EXPECT_CPL
+Inputs : traffic_class, td, ep, attr, length, payload
+Outputs : status 0-Failed 1-Successful
+Description : Expecting a TLP from Rx side with matching
+              traffic_class, td, ep, attr and length
+*************************************************************/
+task TSK_EXPECT_CPL;
+
+  input   [2:0]  traffic_class;
+  input          td;
+  input          ep;
+  input   [1:0]  attr;
+  input   [15:0] completer_id;
+  input   [2:0]  completion_status;
+  input          bcm;
+  input   [11:0] byte_count;
+  input   [15:0] requester_id;
+  input   [7:0]  tag;
+  input   [6:0]  address_low;
+
+  output         expect_status;
+
+  reg   [2:0]  traffic_class_;
+  reg          td_;
+  reg          ep_;
+  reg   [1:0]  attr_;
+  reg   [15:0] completer_id_;
+  reg   [2:0]  completion_status_;
+  reg          bcm_;
+  reg   [11:0] byte_count_;
+  reg   [15:0] requester_id_;
+  reg   [7:0]  tag_;
+  reg   [6:0]  address_low_;
+
+  integer      i_;
+  reg          wait_for_next;
+
+  begin
+    wait_for_next = 1'b1; //haven't found any matching tag yet
+    while(wait_for_next)
+    begin
+      @ rcvd_cpl; //wait for a rcvd_cpl event
+      traffic_class_ = frame_store_rx[1] >> 4;
+      td_ = frame_store_rx[2] >> 7;
+      ep_ = frame_store_rx[2] >> 6;
+      attr_ = frame_store_rx[2] >> 4;
+      bcm_ = frame_store_rx[6] >> 4;
+      completion_status_= frame_store_rx[6] >> 5;
+      byte_count_ = (frame_store_rx[6]);
+      byte_count_ = (byte_count_ << 8) | frame_store_rx[7];
+      completer_id_ = {frame_store_rx[4], frame_store_rx[5]};
+      requester_id_= {frame_store_rx[8], frame_store_rx[9]};
+      tag_= frame_store_rx[10];
+      address_low_ = frame_store_rx[11];
+
+      $display("[%t] : Received CPL --- Tag 0x%h", $realtime, tag_);
+      if(tag == tag_) //find matching tag
+      begin
+        wait_for_next = 1'b0;
+        if((traffic_class == traffic_class_) &&
+           (td === td_) && (ep == ep_) && (attr == attr_) &&
+           (bcm == bcm_) && (completion_status == completion_status_) &&
+           (byte_count == byte_count_) &&
+           (completer_id == completer_id_) &&
+           (requester_id == requester_id_) &&
+           (address_low == address_low_))
+        begin
+          // header matches
+          expect_status = 1'b1;
+        end
+        else // header mismatches, error out
+        begin
+          $fdisplay(error_file_ptr, "[%t] : Found header mismatch in received CPL - Tag 0x%h: \n", $time, tag_);
+          $fdisplay(error_file_ptr, "Expected:");
+          $fdisplay(error_file_ptr, "\t Traffic Class: 0x%h", traffic_class);
+          $fdisplay(error_file_ptr, "\t TD: %h", td);
+          $fdisplay(error_file_ptr, "\t EP: %h", ep);
+          $fdisplay(error_file_ptr, "\t Attributes: 0x%h", attr);
+          $fdisplay(error_file_ptr, "\t BCM: 0x%h", bcm);
+          $fdisplay(error_file_ptr, "\t Completion Status: 0x%h", completion_status);
+          $fdisplay(error_file_ptr, "\t Byte Count: 0x%h", byte_count);
+          $fdisplay(error_file_ptr, "\t Completer ID: 0x%h", completer_id);
+          $fdisplay(error_file_ptr, "\t Requester ID: 0x%h", requester_id);
+          $fdisplay(error_file_ptr, "\t Tag: 0x%h", tag);
+          $fdisplay(error_file_ptr, "\t Lower Address: 0x%h", address_low);
+          $fdisplay(error_file_ptr, "Received:");
+          $fdisplay(error_file_ptr, "\t Traffic Class: 0x%h", traffic_class_);
+          $fdisplay(error_file_ptr, "\t TD: %h", td_);
+          $fdisplay(error_file_ptr, "\t EP: %h", ep_);
+          $fdisplay(error_file_ptr, "\t Attributes: 0x%h", attr_);
+          $fdisplay(error_file_ptr, "\t BCM: 0x%h", bcm_);
+          $fdisplay(error_file_ptr, "\t Completion Status: 0x%h", completion_status_);
+          $fdisplay(error_file_ptr, "\t Byte Count: 0x%h", byte_count_);
+          $fdisplay(error_file_ptr, "\t Completer ID: 0x%h", completer_id_);
+          $fdisplay(error_file_ptr, "\t Requester ID: 0x%h", requester_id_);
+          $fdisplay(error_file_ptr, "\t Tag: 0x%h", tag_);
+          $fdisplay(error_file_ptr, "\t Lower Address: 0x%h", address_low_);
+          $fdisplay(error_file_ptr, "");
+          expect_status = 1'b0;
+        end
+      end
+    end
+  end
+endtask
+
+
+/************************************************************
+Task : TSK_EXPECT_MEMRD
+Inputs : traffic_class, td, ep, attr, length, last_dw_be,
+         first_dw_be, address
+Outputs : status 0-Failed 1-Successful
+Description : Expecting a memory read (32-bit address) TLP
+              from Rx side with matching header fields
+*************************************************************/
+task TSK_EXPECT_MEMRD;
+
+  input   [2:0]  traffic_class;
+  input          td;
+  input          ep;
+  input   [1:0]  attr;
+  input   [9:0]  length;
+  input   [15:0] requester_id;
+  input   [7:0]  tag;
+  input   [3:0]  last_dw_be;
+  input   [3:0]  first_dw_be;
+  input   [29:0] address;
+
+  output         expect_status;
+
+  reg   [2:0]  traffic_class_;
+  reg          td_;
+  reg          ep_;
+  reg   [1:0]  attr_;
+  reg   [9:0]  length_;
+  reg   [15:0] requester_id_;
+  reg   [7:0]  tag_;
+  reg   [3:0]  last_dw_be_;
+  reg   [3:0]  first_dw_be_;
+  reg   [29:0] address_;
+
+  integer      i_;
+  reg          wait_for_next;
+
+  begin
+    wait_for_next = 1'b1; //haven't found any matching tag yet
+    while(wait_for_next)
+    begin
+      @ rcvd_memrd; //wait for a rcvd_memrd event
+      traffic_class_ = frame_store_rx[1] >> 4;
+      td_ = frame_store_rx[2] >> 7;
+      ep_ = frame_store_rx[2] >> 6;
+      attr_ = frame_store_rx[2] >> 4;
+      length_ = frame_store_rx[2];
+      length_ = (length_ << 8) | (frame_store_rx[3]);
+      requester_id_= {frame_store_rx[4], frame_store_rx[5]};
+      tag_= frame_store_rx[6];
+      last_dw_be_= frame_store_rx[7] >> 4;
+      first_dw_be_= frame_store_rx[7];
+      address_[29:6] = {frame_store_rx[8], frame_store_rx[9], frame_store_rx[10]};
+      address_[5:0] = frame_store_rx[11] >> 2;
+
+      $display("[%t] : Received MEMRD --- Tag 0x%h", $realtime, tag_);
+      if(tag == tag_) //find matching tag
+      begin
+        wait_for_next = 1'b0;
+        if((traffic_class == traffic_class_) &&
+           (td === td_) && (ep == ep_) && (attr == attr_) &&
+           (length == length_) && (requester_id == requester_id_) &&
+           (last_dw_be == last_dw_be_) && (first_dw_be == first_dw_be_) &&
+           (address == address_))
+        begin
+          // header matches
+          expect_status = 1'b1;
+        end
+        else // header mismatches, error out
+        begin
+          $fdisplay(error_file_ptr, "[%t] : Found header mismatch in received MEMRD - Tag 0x%h: \n", $time, tag_);
+          $fdisplay(error_file_ptr, "Expected:");
+          $fdisplay(error_file_ptr, "\t Traffic Class: 0x%h", traffic_class);
+          $fdisplay(error_file_ptr, "\t TD: %h", td);
+          $fdisplay(error_file_ptr, "\t EP: %h", ep);
+          $fdisplay(error_file_ptr, "\t Attributes: 0x%h", attr);
+          $fdisplay(error_file_ptr, "\t Length: 0x%h", length);
+          $fdisplay(error_file_ptr, "\t Requester ID: 0x%h", requester_id);
+          $fdisplay(error_file_ptr, "\t Tag: 0x%h", tag);
+          $fdisplay(error_file_ptr, "\t Last DW byte-enable: 0x%h", last_dw_be);
+          $fdisplay(error_file_ptr, "\t First DW byte-enable: 0x%h", first_dw_be);
+          $fdisplay(error_file_ptr, "\t Address: 0x%h", address);
+          $fdisplay(error_file_ptr, "Received:");
+          $fdisplay(error_file_ptr, "\t Traffic Class: 0x%h", traffic_class_);
+          $fdisplay(error_file_ptr, "\t TD: %h", td_);
+          $fdisplay(error_file_ptr, "\t EP: %h", ep_);
+          $fdisplay(error_file_ptr, "\t Attributes: 0x%h", attr_);
+          $fdisplay(error_file_ptr, "\t Length: 0x%h", length_);
+          $fdisplay(error_file_ptr, "\t Requester ID: 0x%h", requester_id_);
+          $fdisplay(error_file_ptr, "\t Tag: 0x%h", tag_);
+          $fdisplay(error_file_ptr, "\t Last DW byte-enable: 0x%h", last_dw_be_);
+          $fdisplay(error_file_ptr, "\t First DW byte-enable: 0x%h", first_dw_be_);
+          $fdisplay(error_file_ptr, "\t Address: 0x%h", address_);
+          $fdisplay(error_file_ptr, "");
+          expect_status = 1'b0;
+        end
+      end
+    end
+  end
+endtask
+
+
+/************************************************************
+Task : TSK_EXPECT_MEMRD64
+Inputs : traffic_class, td, ep, attr, length, last_dw_be,
+         first_dw_be, address
+Outputs : status 0-Failed 1-Successful
+Description : Expecting a memory read (64-bit address) TLP
+              from Rx side with matching header fields
+*************************************************************/
+task TSK_EXPECT_MEMRD64;
+
+  input   [2:0]  traffic_class;
+  input          td;
+  input          ep;
+  input   [1:0]  attr;
+  input   [9:0]  length;
+  input   [15:0] requester_id;
+  input   [7:0]  tag;
+  input   [3:0]  last_dw_be;
+  input   [3:0]  first_dw_be;
+  input   [61:0] address;
+
+  output         expect_status;
+
+  reg   [2:0]  traffic_class_;
+  reg          td_;
+  reg          ep_;
+  reg   [1:0]  attr_;
+  reg   [9:0]  length_;
+  reg   [15:0] requester_id_;
+  reg   [7:0]  tag_;
+  reg   [3:0]  last_dw_be_;
+  reg   [3:0]  first_dw_be_;
+  reg   [61:0] address_;
+
+  integer      i_;
+  reg          wait_for_next;
+
+  begin
+    wait_for_next = 1'b1; //haven't found any matching tag yet
+    while(wait_for_next)
+    begin
+      @ rcvd_memrd64; //wait for a rcvd_memrd64 event
+      traffic_class_ = frame_store_rx[1] >> 4;
+      td_ = frame_store_rx[2] >> 7;
+      ep_ = frame_store_rx[2] >> 6;
+      attr_ = frame_store_rx[2] >> 4;
+      length_ = frame_store_rx[2];
+      length_ = (length_ << 8) | (frame_store_rx[3]);
+      requester_id_= {frame_store_rx[4], frame_store_rx[5]};
+      tag_= frame_store_rx[6];
+      last_dw_be_= frame_store_rx[7] >> 4;
+      first_dw_be_= frame_store_rx[7];
+      address_[61:6] = {frame_store_rx[8], frame_store_rx[9],
+                        frame_store_rx[10], frame_store_rx[11],
+                        frame_store_rx[12], frame_store_rx[13],
+                        frame_store_rx[14]};
+      address_[5:0] = frame_store_rx[15] >> 2;
+
+      $display("[%t] : Received MEMRD64 --- Tag 0x%h", $realtime, tag_);
+      if(tag == tag_) //find matching tag
+      begin
+        wait_for_next = 1'b0;
+        if((traffic_class == traffic_class_) &&
+           (td === td_) && (ep == ep_) && (attr == attr_) &&
+           (length == length_) && (requester_id == requester_id_) &&
+           (last_dw_be == last_dw_be_) && (first_dw_be == first_dw_be_) &&
+           (address == address_))
+        begin
+          // header matches
+          expect_status = 1'b1;
+        end
+        else // header mismatches, error out
+        begin
+          $fdisplay(error_file_ptr, "[%t] : Found header mismatch in received MEMRD64 - Tag 0x%h: \n", $time, tag_);
+          $fdisplay(error_file_ptr, "Expected:");
+          $fdisplay(error_file_ptr, "\t Traffic Class: 0x%h", traffic_class);
+          $fdisplay(error_file_ptr, "\t TD: %h", td);
+          $fdisplay(error_file_ptr, "\t EP: %h", ep);
+          $fdisplay(error_file_ptr, "\t Attributes: 0x%h", attr);
+          $fdisplay(error_file_ptr, "\t Length: 0x%h", length);
+          $fdisplay(error_file_ptr, "\t Requester ID: 0x%h", requester_id);
+          $fdisplay(error_file_ptr, "\t Tag: 0x%h", tag);
+          $fdisplay(error_file_ptr, "\t Last DW byte-enable: 0x%h", last_dw_be);
+          $fdisplay(error_file_ptr, "\t First DW byte-enable: 0x%h", first_dw_be);
+          $fdisplay(error_file_ptr, "\t Address: 0x%h", address);
+          $fdisplay(error_file_ptr, "Received:");
+          $fdisplay(error_file_ptr, "\t Traffic Class: 0x%h", traffic_class_);
+          $fdisplay(error_file_ptr, "\t TD: %h", td_);
+          $fdisplay(error_file_ptr, "\t EP: %h", ep_);
+          $fdisplay(error_file_ptr, "\t Attributes: 0x%h", attr_);
+          $fdisplay(error_file_ptr, "\t Length: 0x%h", length_);
+          $fdisplay(error_file_ptr, "\t Requester ID: 0x%h", requester_id_);
+          $fdisplay(error_file_ptr, "\t Tag: 0x%h", tag_);
+          $fdisplay(error_file_ptr, "\t Last DW byte-enable: 0x%h", last_dw_be_);
+          $fdisplay(error_file_ptr, "\t First DW byte-enable: 0x%h", first_dw_be_);
+          $fdisplay(error_file_ptr, "\t Address: 0x%h", address_);
+          $fdisplay(error_file_ptr, "");
+          expect_status = 1'b0;
+        end
+      end
+    end
+  end
+endtask
+
+
+/************************************************************
+Task : TSK_EXPECT_MEMWR
+Inputs : traffic_class, td, ep, attr, length, last_dw_be,
+         first_dw_be, address
+Outputs : status 0-Failed 1-Successful
+Description : Expecting a memory write (32-bit address) TLP
+              from Rx side with matching header fields and
+              payload
+*************************************************************/
+task TSK_EXPECT_MEMWR;
+
+  input   [2:0]  traffic_class;
+  input          td;
+  input          ep;
+  input   [1:0]  attr;
+  input   [9:0]  length;
+  input   [15:0] requester_id;
+  input   [7:0]  tag;
+  input   [3:0]  last_dw_be;
+  input   [3:0]  first_dw_be;
+  input   [29:0] address;
+
+  output         expect_status;
+
+  reg   [2:0]  traffic_class_;
+  reg          td_;
+  reg          ep_;
+  reg   [1:0]  attr_;
+  reg   [9:0]  length_;
+  reg   [15:0] requester_id_;
+  reg   [7:0]  tag_;
+  reg   [3:0]  last_dw_be_;
+  reg   [3:0]  first_dw_be_;
+  reg   [29:0] address_;
+
+  integer      payload_len;
+  integer      i_;
+  reg          wait_for_next;
+  reg          check_byte;
+
+  begin
+    wait_for_next = 1'b1; //haven't found any matching tag yet
+    while(wait_for_next)
+    begin
+      @ rcvd_memwr; //wait for a rcvd_memwr event
+      traffic_class_ = frame_store_rx[1] >> 4;
+      td_ = frame_store_rx[2] >> 7;
+      ep_ = frame_store_rx[2] >> 6;
+      attr_ = frame_store_rx[2] >> 4;
+      length_ = frame_store_rx[2];
+      length_ = (length_ << 8) | (frame_store_rx[3]);
+      requester_id_= {frame_store_rx[4], frame_store_rx[5]};
+      tag_= frame_store_rx[6];
+      last_dw_be_= frame_store_rx[7] >> 4;
+      first_dw_be_= frame_store_rx[7];
+      address_[29:6] = {frame_store_rx[8], frame_store_rx[9], frame_store_rx[10]};
+      address_[5:0] = frame_store_rx[11] >> 2;
+
+      payload_len = (length << 2);
+      if (payload_len==0) payload_len = 4096;
+
+      $display("[%t] : Received MEMWR --- Tag 0x%h", $realtime, tag_);
+      if(tag == tag_) //find matching tag
+      begin
+        wait_for_next = 1'b0;
+        if((traffic_class == traffic_class_) &&
+           (td === td_) && (ep == ep_) && (attr == attr_) &&
+           (length == length_) && (requester_id == requester_id_) &&
+           (last_dw_be == last_dw_be_) && (first_dw_be == first_dw_be_) &&
+           (address == address_))
+        begin
+          // find matching header then compare payload
+          for (i_ = 0; i_ < payload_len; i_ = i_ + 1)
+          begin
+            check_byte = 1;
+            if (i_ < 4) // apply first_dw_be
+            begin
+              if (first_dw_be[i_])
+                check_byte = 1;
+              else
+                check_byte = 0;
+            end else if (i_ > (payload_len - 5)) // apply last_dw_be
+            begin
+              if (last_dw_be[4 - (payload_len - i_)])
+                check_byte = 1;
+              else
+                check_byte = 0;
+            end
+            if(check_byte && `EXPECT_MEMWR_PAYLOAD[i_] != frame_store_rx[12 + i_]) //find mismatch
+            begin
+              $fdisplay(error_file_ptr, "[%t] : Found payload mismatch in received MEMWR - Tag 0x%h: \n", $time, tag_);
+              $fdisplay(error_file_ptr, "Expected:");
+              for (i_ = 0; i_ < payload_len; i_ = i_ + 1)
+                $fdisplay(error_file_ptr,"\t %0x", `EXPECT_MEMWR_PAYLOAD[i_]);
+              $fdisplay(error_file_ptr, "Received:");
+              for (i_ = 0; i_ < payload_len; i_ = i_ + 1)
+                $fdisplay(error_file_ptr,"\t %0x", frame_store_rx[12+i_]);
+
+              $fdisplay(error_file_ptr, "");
+              expect_status = 1'b0;
+              i_ = 5000;
+            end
+          end
+          //find matching frame
+          if(i_ == payload_len)
+            expect_status = 1'b1;
+        end
+        else // header mismatches, error out
+        begin
+          $fdisplay(error_file_ptr, "[%t] : Found header mismatch in received MEMWR - Tag 0x%h: \n", $time, tag_);
+          $fdisplay(error_file_ptr, "Expected:");
+          $fdisplay(error_file_ptr, "\t Traffic Class: 0x%h", traffic_class);
+          $fdisplay(error_file_ptr, "\t TD: %h", td);
+          $fdisplay(error_file_ptr, "\t EP: %h", ep);
+          $fdisplay(error_file_ptr, "\t Attributes: 0x%h", attr);
+          $fdisplay(error_file_ptr, "\t Length: 0x%h", length);
+          $fdisplay(error_file_ptr, "\t Requester ID: 0x%h", requester_id);
+          $fdisplay(error_file_ptr, "\t Tag: 0x%h", tag);
+          $fdisplay(error_file_ptr, "\t Last DW byte-enable: 0x%h", last_dw_be);
+          $fdisplay(error_file_ptr, "\t First DW byte-enable: 0x%h", first_dw_be);
+          $fdisplay(error_file_ptr, "\t Address: 0x%h", address);
+          $fdisplay(error_file_ptr, "Received:");
+          $fdisplay(error_file_ptr, "\t Traffic Class: 0x%h", traffic_class_);
+          $fdisplay(error_file_ptr, "\t TD: %h", td_);
+          $fdisplay(error_file_ptr, "\t EP: %h", ep_);
+          $fdisplay(error_file_ptr, "\t Attributes: 0x%h", attr_);
+          $fdisplay(error_file_ptr, "\t Length: 0x%h", length_);
+          $fdisplay(error_file_ptr, "\t Requester ID: 0x%h", requester_id_);
+          $fdisplay(error_file_ptr, "\t Tag: 0x%h", tag_);
+          $fdisplay(error_file_ptr, "\t Last DW byte-enable: 0x%h", last_dw_be_);
+          $fdisplay(error_file_ptr, "\t First DW byte-enable: 0x%h", first_dw_be_);
+          $fdisplay(error_file_ptr, "\t Address: 0x%h", address_);
+          $fdisplay(error_file_ptr, "");
+          expect_status = 1'b0;
+        end
+      end
+    end
+  end
+endtask
+
+
+/************************************************************
+Task : TSK_EXPECT_MEMWR64
+Inputs : traffic_class, td, ep, attr, length, last_dw_be,
+         first_dw_be, address
+Outputs : status 0-Failed 1-Successful
+Description : Expecting a memory write (64-bit address) TLP
+              from Rx side with matching header fields and
+              payload
+*************************************************************/
+task TSK_EXPECT_MEMWR64;
+
+  input   [2:0]  traffic_class;
+  input          td;
+  input          ep;
+  input   [1:0]  attr;
+  input   [9:0]  length;
+  input   [15:0] requester_id;
+  input   [7:0]  tag;
+  input   [3:0]  last_dw_be;
+  input   [3:0]  first_dw_be;
+  input   [61:0] address;
+
+  output         expect_status;
+
+  reg   [2:0]  traffic_class_;
+  reg          td_;
+  reg          ep_;
+  reg   [1:0]  attr_;
+  reg   [9:0]  length_;
+  reg   [15:0] requester_id_;
+  reg   [7:0]  tag_;
+  reg   [3:0]  last_dw_be_;
+  reg   [3:0]  first_dw_be_;
+  reg   [61:0] address_;
+
+  integer      payload_len;
+  integer      i_;
+  reg          wait_for_next;
+  reg          check_byte;
+
+  begin
+    wait_for_next = 1'b1; //haven't found any matching tag yet
+    while(wait_for_next)
+    begin
+      @ rcvd_memwr64; //wait for a rcvd_memwr64 event
+      traffic_class_ = frame_store_rx[1] >> 4;
+      td_ = frame_store_rx[2] >> 7;
+      ep_ = frame_store_rx[2] >> 6;
+      attr_ = frame_store_rx[2] >> 4;
+      length_ = frame_store_rx[2];
+      length_ = (length_ << 8) | (frame_store_rx[3]);
+      requester_id_= {frame_store_rx[4], frame_store_rx[5]};
+      tag_= frame_store_rx[6];
+      last_dw_be_= frame_store_rx[7] >> 4;
+      first_dw_be_= frame_store_rx[7];
+      address_[61:6] = {frame_store_rx[8], frame_store_rx[9],
+                        frame_store_rx[10], frame_store_rx[11],
+                        frame_store_rx[12], frame_store_rx[13],
+                        frame_store_rx[14]};
+      address_[5:0] = frame_store_rx[15] >> 2;
+
+      payload_len = (length << 2);
+      if (payload_len==0) payload_len = 4096;
+
+      $display("[%t] : Received MEMWR64 --- Tag 0x%h", $realtime, tag_);
+      if(tag == tag_) //find matching tag
+      begin
+        wait_for_next = 1'b0;
+        if((traffic_class == traffic_class_) &&
+           (td === td_) && (ep == ep_) && (attr == attr_) &&
+           (length == length_) && (requester_id == requester_id_) &&
+           (last_dw_be == last_dw_be_) && (first_dw_be == first_dw_be_) &&
+           (address == address_))
+        begin
+          // find matching header then compare payload
+          for (i_ = 0; i_ < payload_len; i_ = i_ + 1)
+          begin
+            check_byte = 1;
+            if (i_ < 4) // apply first_dw_be
+            begin
+              if (first_dw_be[i_])
+                check_byte = 1;
+              else
+                check_byte = 0;
+            end else if (i_ > (payload_len - 5)) // apply last_dw_be
+            begin
+              if (last_dw_be[4 - (payload_len - i_)])
+                check_byte = 1;
+              else
+                check_byte = 0;
+            end
+            if(check_byte && `EXPECT_MEMWR64_PAYLOAD[i_] != frame_store_rx[16 + i_]) //find mismatch
+            begin
+              $fdisplay(error_file_ptr, "[%t] : Found payload mismatch in received MEMWR64 - Tag 0x%h: \n", $time, tag_);
+              $fdisplay(error_file_ptr, "Expected:");
+              for (i_ = 0; i_ < payload_len; i_ = i_ + 1)
+                $fdisplay(error_file_ptr,"\t %0x", `EXPECT_MEMWR64_PAYLOAD[i_]);
+              $fdisplay(error_file_ptr, "Received:");
+              for (i_ = 0; i_ < payload_len; i_ = i_ + 1)
+                $fdisplay(error_file_ptr,"\t %0x", frame_store_rx[16+i_]);
+
+              $fdisplay(error_file_ptr, "");
+              expect_status = 1'b0;
+              i_ = 5000;
+            end
+          end
+          //find matching frame
+          if(i_ == payload_len)
+            expect_status = 1'b1;
+        end
+        else // header mismatches, error out
+        begin
+          $fdisplay(error_file_ptr, "[%t] : Found header mismatch in received MEMWR64 - Tag 0x%h: \n", $time, tag_);
+          $fdisplay(error_file_ptr, "Expected:");
+          $fdisplay(error_file_ptr, "\t Traffic Class: 0x%h", traffic_class);
+          $fdisplay(error_file_ptr, "\t TD: %h", td);
+          $fdisplay(error_file_ptr, "\t EP: %h", ep);
+          $fdisplay(error_file_ptr, "\t Attributes: 0x%h", attr);
+          $fdisplay(error_file_ptr, "\t Length: 0x%h", length);
+          $fdisplay(error_file_ptr, "\t Requester ID: 0x%h", requester_id);
+          $fdisplay(error_file_ptr, "\t Tag: 0x%h", tag);
+          $fdisplay(error_file_ptr, "\t Last DW byte-enable: 0x%h", last_dw_be);
+          $fdisplay(error_file_ptr, "\t First DW byte-enable: 0x%h", first_dw_be);
+          $fdisplay(error_file_ptr, "\t Address: 0x%h", address);
+          $fdisplay(error_file_ptr, "Received:");
+          $fdisplay(error_file_ptr, "\t Traffic Class: 0x%h", traffic_class_);
+          $fdisplay(error_file_ptr, "\t TD: %h", td_);
+          $fdisplay(error_file_ptr, "\t EP: %h", ep_);
+          $fdisplay(error_file_ptr, "\t Attributes: 0x%h", attr_);
+          $fdisplay(error_file_ptr, "\t Length: 0x%h", length_);
+          $fdisplay(error_file_ptr, "\t Requester ID: 0x%h", requester_id_);
+          $fdisplay(error_file_ptr, "\t Tag: 0x%h", tag_);
+          $fdisplay(error_file_ptr, "\t Last DW byte-enable: 0x%h", last_dw_be_);
+          $fdisplay(error_file_ptr, "\t First DW byte-enable: 0x%h", first_dw_be_);
+          $fdisplay(error_file_ptr, "\t Address: 0x%h", address_);
+          $fdisplay(error_file_ptr, "");
+          expect_status = 1'b0;
+        end
+      end
+    end
+  end
+endtask
+
+
+
+// Please note that the following io tasks can be only used if the customer has a mechanism for allowing
+// the customer design to generate io write or io read tlps received by the dsport rx port.
+
+
+/************************************************************
+Task : TSK_EXPECT_IOWRITE
+Inputs : td, ep, requested_id, tag, firstDwBe, address, data
+Outputs : status 0-Failed 1-Successful
+Description : Expecting a TLP from Rx side with matching
+              td, ep, requested_id, tag, firstDwBe, address, and 32 bit data
+*************************************************************/
+task TSK_EXPECT_IOWRITE;
+
+
+  input          td;
+  input          ep;
+  input   [15:0] requester_id;
+  input   [7:0]  tag;
+  input   [3:0]  firstDwBe;
+  input   [31:0] address; // note that low bits [1:0] are not used
+  input   [31:0] data; 
+
+  output         expect_status;
+
+  reg   [2:0]  traffic_class;  
+  reg   [1:0]  attr;
+  reg   [9:0]  length; 
+  reg   [3:0]  lastDwBe;   
+
+  reg   [2:0]  traffic_class_;
+  reg          td_;
+  reg          ep_;
+  reg   [1:0]  attr_;
+  reg   [9:0]  length_;
+  reg   [15:0] requester_id_;
+  reg   [7:0]  tag_;
+  reg   [3:0]  lastDwBe_;
+  reg   [3:0]  firstDwBe_;
+  reg   [31:0] address_; // note that the bottom two bits are not used in comparison
+
+  reg   [7:0]  write_payload[0:3];
+
+
+  reg   [3:0]  byte_enabled;
+  integer      i_;
+  reg          wait_for_next;
+  integer      j_;
+  
+  begin
+    // following assignments are required for io header
+    traffic_class = 3'b000;
+    attr = 2'b00;
+    length = 10'b00_0000_0001;
+    lastDwBe = 4'b0000;
+    write_payload[0] = data[31:24];
+    write_payload[1] = data[23:16];
+    write_payload[2] = data[15:8];
+    write_payload[3] = data[7:0];
+ 
+    j_ = 1000;
+    wait_for_next = 1'b1; //haven't found any matching tag yet
+   fork 
+    while(wait_for_next)
+    begin
+      @ rcvd_iowr; //wait for a rcvd_iowr event
+      byte_enabled = 4'h0;
+      traffic_class_ = frame_store_rx[1] >> 4; 
+      td_ = frame_store_rx[2] >> 7;
+      ep_ = frame_store_rx[2] >> 6;
+      attr_ = frame_store_rx[2] >> 4; 
+      length_ = frame_store_rx[2];
+      length_ = (length_ << 8) | (frame_store_rx[3]); 
+      requester_id_= {frame_store_rx[4], frame_store_rx[5]};
+      tag_= frame_store_rx[6];
+      lastDwBe_ = frame_store_rx[7] >>4;
+      firstDwBe_ = frame_store_rx[7];
+      
+      address_ = (frame_store_rx[8]);
+      address_ = (address_ << 8) | frame_store_rx[9];
+      address_ = (address_ << 8) | frame_store_rx[10];
+      address_ = (address_ << 8) | frame_store_rx[11];
+      
+      $display("[%t] : Received IO WRITE TLP --- Tag 0x%h", $realtime, tag_);
+      if(tag == tag_) //find matching tag
+      begin
+        wait_for_next = 1'b0;
+        if((traffic_class == traffic_class_) &&
+           (td === td_) && (ep == ep_) && (attr == attr_) &&
+           (length == length_) &&
+           (requester_id == requester_id_) && 
+           (lastDwBe == lastDwBe_) &&
+           (firstDwBe == firstDwBe_) &&           
+           (address[31:2] == address_[31:2]))
+        begin
+          // find matching header then compare payload
+            expect_status = 1'b1; //assume that we will succeed
+            byte_enabled = firstDwBe;
+            for (i_ = 0; i_ < 4; i_ = i_ + 1)
+             begin
+              if (byte_enabled[3] && expect_status)
+               if (write_payload[i_] != frame_store_rx[12 + i_]) //find mismatch
+               begin
+                 $fdisplay(error_file_ptr, "[%t] : Found payload mismatch in IO WRITE DATA - Tag 0x%h: \n", $time, tag_);
+                 $fdisplay(error_file_ptr, "Expected:");
+                 for (i_ = 0; i_ < 4; i_ = i_ + 1)
+                     $fdisplay(error_file_ptr,"\t %0x", write_payload[i_]);
+                 $fdisplay(error_file_ptr, "Received:");
+                 for (i_ = 0; i_ < 4; i_ = i_ + 1)
+                    $fdisplay(error_file_ptr,"\t %0x", frame_store_rx[12+i_]);
+
+                 $fdisplay(error_file_ptr, "");
+                 expect_status = 1'b0;                 
+               end
+              byte_enabled = byte_enabled << 1; 
+             end            
+        end
+        else // header mismatches, error out
+        begin
+          $fdisplay(error_file_ptr, "[%t] : Found header mismatch in received CPLD - Tag 0x%h: \n", $time, tag_);
+          $fdisplay(error_file_ptr, "Expected:");
+          $fdisplay(error_file_ptr, "\t Traffic Class: 0x%h", traffic_class);
+          $fdisplay(error_file_ptr, "\t TD: %h", td);
+          $fdisplay(error_file_ptr, "\t EP: %h", ep);
+          $fdisplay(error_file_ptr, "\t Attributes: 0x%h", attr);
+          $fdisplay(error_file_ptr, "\t Length: 0x%h", length);
+          $fdisplay(error_file_ptr, "\t Requester ID: 0x%h", requester_id);
+          $fdisplay(error_file_ptr, "\t Tag: 0x%h", tag);
+          $fdisplay(error_file_ptr, "\t Last DW Byte Enable: 0x%h", lastDwBe);
+          $fdisplay(error_file_ptr, "\t 1st DW Byte Enable: 0x%h", firstDwBe); 
+          $fdisplay(error_file_ptr, "\t Address: 0x%h", address);
+          $fdisplay(error_file_ptr, "Received:");
+          $fdisplay(error_file_ptr, "\t Traffic Class: 0x%h", traffic_class_);
+          $fdisplay(error_file_ptr, "\t TD: %h", td_);
+          $fdisplay(error_file_ptr, "\t EP: %h", ep_);
+          $fdisplay(error_file_ptr, "\t Attributes: 0x%h", attr_);
+          $fdisplay(error_file_ptr, "\t Length: 0x%h", length_);
+          $fdisplay(error_file_ptr, "\t Requester ID: 0x%h", requester_id_);
+          $fdisplay(error_file_ptr, "\t Tag: 0x%h", tag_);
+          $fdisplay(error_file_ptr, "\t Last DW Byte Enable: 0x%h", lastDwBe_);
+          $fdisplay(error_file_ptr, "\t 1st DW Byte Enable: 0x%h", firstDwBe_); 
+          $fdisplay(error_file_ptr, "\t Address: 0x%h", address_);
+          $fdisplay(error_file_ptr, "");
+          expect_status = 1'b0;
+        end
+      end
+    end // while
+    begin
+      // time out task function and return 0 if tlp never received and/or tag never matches
+      while (j_ && wait_for_next) 
+        begin
+         `TX_TASKS.TSK_TX_CLK_EAT(1); 
+         j_ = j_ - 1;
+        end
+      if (wait_for_next) 
+        begin
+          $display("Failure: TSK_EXPECT_IOWRITE timeout. IO WRITE TLP never received or tag mismatch");
+          $finish;
+        end
+    end
+   join
+  end // 1st
+endtask
+
+
+
+/************************************************************
+Task : TSK_EXPECT_IOREAD
+Inputs : td, ep, requested_id, tag, firstDwBe, address
+Outputs : status 0-Failed 1-Successful
+Description : Expecting a TLP from Rx side with matching
+              td, ep, requested_id, tag, firstDwBe, and address
+*************************************************************/
+task TSK_EXPECT_IOREAD;
+
+
+
+  input          td;
+  input          ep;
+  input   [15:0] requester_id;
+  input   [7:0]  tag;
+  input   [3:0]  firstDwBe;
+  input   [31:0] address; // note that low bits [1:0] are not used
+
+  output         expect_status;
+
+  reg   [2:0]  traffic_class;  
+  reg   [1:0]  attr;
+  reg   [9:0]  length; 
+  reg   [3:0]  lastDwBe;   
+
+  reg   [2:0]  traffic_class_;
+  reg          td_;
+  reg          ep_;
+  reg   [1:0]  attr_;
+  reg   [9:0]  length_;
+  reg   [15:0] requester_id_;
+  reg   [7:0]  tag_;
+  reg   [3:0]  lastDwBe_;
+  reg   [3:0]  firstDwBe_;
+  reg   [31:0] address_; // note that the bottom two bits are not used in comparison
+
+  integer      i_;
+  reg          wait_for_next;
+  integer      j_;
+
+  begin
+    // following assignments are required for io header
+    traffic_class = 3'b000;
+    attr = 2'b00;
+    length = 10'b00_0000_0001;
+    lastDwBe = 4'b0000;
+
+    j_ = 1000;    
+    wait_for_next = 1'b1; //haven't found any matching tag yet
+   fork
+    while(wait_for_next)
+    begin
+      @ rcvd_iord; //wait for a rcvd_iord event
+      traffic_class_ = frame_store_rx[1] >> 4; 
+      td_ = frame_store_rx[2] >> 7;
+      ep_ = frame_store_rx[2] >> 6;
+      attr_ = frame_store_rx[2] >> 4; 
+      length_ = frame_store_rx[2];
+      length_ = (length_ << 8) | (frame_store_rx[3]); 
+      requester_id_= {frame_store_rx[4], frame_store_rx[5]};
+      tag_= frame_store_rx[6];
+      lastDwBe_ = frame_store_rx[7] >>4;
+      firstDwBe_ = frame_store_rx[7];
+      
+      address_ = (frame_store_rx[8]);
+      address_ = (address_ << 8) | frame_store_rx[9];
+      address_ = (address_ << 8) | frame_store_rx[10];
+      address_ = (address_ << 8) | frame_store_rx[11];
+      
+      $display("[%t] : Received IO READ TLP --- Tag 0x%h", $realtime, tag_);
+      if(tag == tag_) //find matching tag
+      begin
+        wait_for_next = 1'b0;
+        if((traffic_class == traffic_class_) &&
+           (td === td_) && (ep == ep_) && (attr == attr_) &&
+           (length == length_) &&
+           (requester_id == requester_id_) && 
+           (lastDwBe == lastDwBe_) &&
+           (firstDwBe == firstDwBe_) &&           
+           (address[31:2] == address_[31:2]))
+        begin          
+          expect_status = 1'b1;
+        end
+        else // header mismatches, error out
+        begin
+          $fdisplay(error_file_ptr, "[%t] : Found header mismatch in received CPLD - Tag 0x%h: \n", $time, tag_);
+          $fdisplay(error_file_ptr, "Expected:");
+          $fdisplay(error_file_ptr, "\t Traffic Class: 0x%h", traffic_class);
+          $fdisplay(error_file_ptr, "\t TD: %h", td);
+          $fdisplay(error_file_ptr, "\t EP: %h", ep);
+          $fdisplay(error_file_ptr, "\t Attributes: 0x%h", attr);
+          $fdisplay(error_file_ptr, "\t Length: 0x%h", length);
+          $fdisplay(error_file_ptr, "\t Requester ID: 0x%h", requester_id);
+          $fdisplay(error_file_ptr, "\t Tag: 0x%h", tag);
+          $fdisplay(error_file_ptr, "\t Last DW Byte Enable: 0x%h", lastDwBe);
+          $fdisplay(error_file_ptr, "\t 1st DW Byte Enable: 0x%h", firstDwBe); 
+          $fdisplay(error_file_ptr, "\t Address: 0x%h", address);
+          $fdisplay(error_file_ptr, "Received:");
+          $fdisplay(error_file_ptr, "\t Traffic Class: 0x%h", traffic_class_);
+          $fdisplay(error_file_ptr, "\t TD: %h", td_);
+          $fdisplay(error_file_ptr, "\t EP: %h", ep_);
+          $fdisplay(error_file_ptr, "\t Attributes: 0x%h", attr_);
+          $fdisplay(error_file_ptr, "\t Length: 0x%h", length_);
+          $fdisplay(error_file_ptr, "\t Requester ID: 0x%h", requester_id_);
+          $fdisplay(error_file_ptr, "\t Tag: 0x%h", tag_);
+          $fdisplay(error_file_ptr, "\t Last DW Byte Enable: 0x%h", lastDwBe_);
+          $fdisplay(error_file_ptr, "\t 1st DW Byte Enable: 0x%h", firstDwBe_); 
+          $fdisplay(error_file_ptr, "\t Address: 0x%h", address_);
+          $fdisplay(error_file_ptr, "");
+          expect_status = 1'b0;
+        end
+      end
+    end // while
+    begin
+      // time out task function and return 0 if tlp never received and/or tag never matches
+      while (j_ && wait_for_next) 
+        begin
+         `TX_TASKS.TSK_TX_CLK_EAT(1); 
+         j_ = j_ - 1;
+        end
+      if (wait_for_next) 
+        begin
+          $display("Failure: TSK_EXPECT_IOREAD timeout. IO READ TLP never received or tag mismatch");
+          $finish;
+        end
+    end       
+   join
+  end //1st
+endtask
+
+
+
+// Please note that the following task, TSK_EXPECT_TYPE0_CONFIGURATION_WRITE, should not be exported
+// to the customer because all the current express cores currently consume all Type 0 configuration
+// accesses. This means that this task will always time out since a type 0 config tlp will never
+// be received at the rx trn interface. This function is being included for completeness and in case
+// a future release of an express core passes type 0 configuration writes through the express core 
+// and on to the customer rx application.
+
+// Also note that this function has not been tested completely due to the restrictions indicated above.
+
+
+/************************************************************
+Task : TSK_EXPECT_TYPE0_CONFIGURATION_WRITE
+Inputs : td, ep, requested_id, tag, firstDwBe, , data
+Outputs : status 0-Failed 1-Successful
+Description : Expecting a TLP from Rx side with matching
+              td, ep, requested_id, tag, firstDwBe, , and 32 bit data
+*************************************************************/
+task TSK_EXPECT_TYPE0_CONFIGURATION_WRITE;
+
+
+  input          td;
+  input          ep;
+  input   [15:0] requester_id;
+  input   [7:0]  tag;
+  input   [3:0]  firstDwBe;
+  input   [7:0]  busNumber;
+  input   [4:0]  deviceNumber;
+  input   [2:0]  functionNumber;
+  input   [3:0]  extRegNumber;
+  input   [5:0]  registerNumber;
+  input   [31:0] data; 
+
+  output         expect_status;
+
+  reg   [2:0]  traffic_class;  
+  reg   [1:0]  attr;
+  reg   [9:0]  length; 
+  reg   [3:0]  lastDwBe;   
+
+  reg   [2:0]  traffic_class_;
+  reg          td_;
+  reg          ep_;
+  reg   [1:0]  attr_;
+  reg   [9:0]  length_;
+  reg   [15:0] requester_id_;
+  reg   [7:0]  tag_;
+  reg   [3:0]  lastDwBe_;
+  reg   [3:0]  firstDwBe_;
+  reg   [7:0]  busNumber_;
+  reg   [4:0]  deviceNumber_;
+  reg   [2:0]  functionNumber_;
+  reg   [3:0]  extRegNumber_;
+  reg   [5:0]  registerNumber_;
+
+  reg   [7:0]  write_payload[0:3];
+
+
+  reg   [3:0]  byte_enabled;
+  integer      i_;
+  reg          wait_for_next;
+  integer      j_;
+  
+  begin
+    // following assignments are required for io header
+    traffic_class = 3'b000;
+    attr = 2'b00;
+    length = 10'b00_0000_0001;
+    lastDwBe = 4'b0000;
+    write_payload[0] = data[31:24];
+    write_payload[1] = data[23:16];
+    write_payload[2] = data[15:8];
+    write_payload[3] = data[7:0];
+ 
+    j_ = 1000;
+    wait_for_next = 1'b1; //haven't found any matching tag yet
+   fork 
+    while(wait_for_next)
+    begin
+      @ rcvd_cfgwr0; //wait for a rcvd_cfgwr0 event *** currently this event will never occur
+      byte_enabled = 4'h0;
+      traffic_class_ = frame_store_rx[1] >> 4; 
+      td_ = frame_store_rx[2] >> 7;
+      ep_ = frame_store_rx[2] >> 6;
+      attr_ = frame_store_rx[2] >> 4; 
+      length_ = frame_store_rx[2];
+      length_ = (length_ << 8) | (frame_store_rx[3]); 
+      requester_id_= {frame_store_rx[4], frame_store_rx[5]};
+      tag_= frame_store_rx[6];
+      lastDwBe_ = frame_store_rx[7] >>4;
+      firstDwBe_ = frame_store_rx[7];
+      
+      busNumber_ = frame_store_rx[8];
+      deviceNumber_ = frame_store_rx[9] >> 3;
+      functionNumber_ = frame_store_rx[9];
+      extRegNumber_ = frame_store_rx[10];
+      registerNumber_ = frame_store_rx[11] >> 2;
+            
+      $display("[%t] : Received TYPE 0 CFG WRITE TLP --- Tag 0x%h", $realtime, tag_);
+      if(tag == tag_) //find matching tag
+      begin
+        wait_for_next = 1'b0;
+        if((traffic_class == traffic_class_) &&
+           (td === td_) && (ep == ep_) && (attr == attr_) &&
+           (length == length_) &&
+           (requester_id == requester_id_) && 
+           (lastDwBe == lastDwBe_) &&
+           (firstDwBe == firstDwBe_) &&  
+           (busNumber == busNumber_) &&         
+           (deviceNumber == deviceNumber_) &&
+           (functionNumber == functionNumber_) &&
+           (extRegNumber == extRegNumber_) &&
+           (registerNumber == registerNumber_))          
+        begin
+          // find matching header then compare payload
+            expect_status = 1'b1; //assume that we will succeed
+            byte_enabled = firstDwBe;
+            for (i_ = 0; i_ < 4; i_ = i_ + 1)
+             begin
+              if (byte_enabled[3] && expect_status)
+               if (write_payload[i_] != frame_store_rx[12 + i_]) //find mismatch
+               begin
+                 $fdisplay(error_file_ptr, "[%t] : Found payload mismatch in TYPE 0 WRITE DATA - Tag 0x%h: \n", $time, tag_);
+                 $fdisplay(error_file_ptr, "Expected:");
+                 for (i_ = 0; i_ < 4; i_ = i_ + 1)
+                     $fdisplay(error_file_ptr,"\t %0x", write_payload[i_]);
+                 $fdisplay(error_file_ptr, "Received:");
+                 for (i_ = 0; i_ < 4; i_ = i_ + 1)
+                    $fdisplay(error_file_ptr,"\t %0x", frame_store_rx[12+i_]);
+
+                 $fdisplay(error_file_ptr, "");
+                 expect_status = 1'b0;                 
+               end
+              byte_enabled = byte_enabled << 1; 
+             end            
+        end
+        else // header mismatches, error out
+        begin
+          $fdisplay(error_file_ptr, "[%t] : Found header mismatch in received CPLD - Tag 0x%h: \n", $time, tag_);
+          $fdisplay(error_file_ptr, "Expected:");
+          $fdisplay(error_file_ptr, "\t Traffic Class: 0x%h", traffic_class);
+          $fdisplay(error_file_ptr, "\t TD: %h", td);
+          $fdisplay(error_file_ptr, "\t EP: %h", ep);
+          $fdisplay(error_file_ptr, "\t Attributes: 0x%h", attr);
+          $fdisplay(error_file_ptr, "\t Length: 0x%h", length);
+          $fdisplay(error_file_ptr, "\t Requester ID: 0x%h", requester_id);
+          $fdisplay(error_file_ptr, "\t Tag: 0x%h", tag);
+          $fdisplay(error_file_ptr, "\t Last DW Byte Enable: 0x%h", lastDwBe);
+          $fdisplay(error_file_ptr, "\t 1st DW Byte Enable: 0x%h", firstDwBe); 
+          $fdisplay(error_file_ptr, "\t Bus Number: 0x%h", busNumber); 
+          $fdisplay(error_file_ptr, "\t Device Number: 0x%h", deviceNumber); 
+          $fdisplay(error_file_ptr, "\t Function Number: 0x%h", functionNumber); 
+          $fdisplay(error_file_ptr, "\t Ext Reg Number: 0x%h", extRegNumber);                                         
+          $fdisplay(error_file_ptr, "\t Register Number: 0x%h", registerNumber);           
+         
+          $fdisplay(error_file_ptr, "Received:");
+          $fdisplay(error_file_ptr, "\t Traffic Class: 0x%h", traffic_class_);
+          $fdisplay(error_file_ptr, "\t TD: %h", td_);
+          $fdisplay(error_file_ptr, "\t EP: %h", ep_);
+          $fdisplay(error_file_ptr, "\t Attributes: 0x%h", attr_);
+          $fdisplay(error_file_ptr, "\t Length: 0x%h", length_);
+          $fdisplay(error_file_ptr, "\t Requester ID: 0x%h", requester_id_);
+          $fdisplay(error_file_ptr, "\t Tag: 0x%h", tag_);
+          $fdisplay(error_file_ptr, "\t Last DW Byte Enable: 0x%h", lastDwBe_);
+          $fdisplay(error_file_ptr, "\t 1st DW Byte Enable: 0x%h", firstDwBe_); 
+          $fdisplay(error_file_ptr, "\t Bus Number: 0x%h", busNumber_); 
+          $fdisplay(error_file_ptr, "\t Device Number: 0x%h", deviceNumber_); 
+          $fdisplay(error_file_ptr, "\t Function Number: 0x%h", functionNumber_); 
+          $fdisplay(error_file_ptr, "\t Ext Reg Number: 0x%h", extRegNumber_);                                         
+          $fdisplay(error_file_ptr, "\t Register Number: 0x%h", registerNumber_);              
+          
+          $fdisplay(error_file_ptr, "");
+          expect_status = 1'b0;
+        end
+      end
+    end // while
+    begin
+      // time out task function and return 0 if tlp never received and/or tag never matches
+      while (j_ && wait_for_next) 
+        begin
+         `TX_TASKS.TSK_TX_CLK_EAT(1); 
+         j_ = j_ - 1;
+        end
+      if (wait_for_next) 
+        begin
+          $display("Failure: TSK_EXPECT_TYPE0_CONFIGURATION_WRITE timeout. CFG TYPE 0 WRITE TLP never received");
+          $finish;
+        end
+    end
+   join
+  end // 1st
+endtask
+
+
+/************************************************************
+Task : TSK_EXPECT_MSG
+Inputs : traffic_class, td, ep, attr, length, msg type, msg code
+        address
+Outputs : status 0-Failed 1-Successful
+Description : Expecting a message no data TLP
+              from Rx side with matching header fields
+*************************************************************/
+task TSK_EXPECT_MSG;
+
+  input   [2:0]  traffic_class;
+  input          td;
+  input          ep;
+  input   [1:0]  attr;
+  input   [9:0]  length;
+  input   [15:0] requester_id;
+  input   [7:0]  tag;
+  input   [7:0]  msg_code;
+  input   [29:0] address;
+
+  output         expect_status;
+
+  reg   [2:0]  traffic_class_;
+  reg          td_;
+  reg          ep_;
+  reg   [1:0]  attr_;
+  reg   [9:0]  length_;
+  reg   [15:0] requester_id_;
+  reg   [7:0]  tag_;
+  reg   [7:0]  msg_code_;
+  reg   [29:0] address_;
+
+  integer      i_;
+  reg          wait_for_next;
+
+  begin
+    wait_for_next = 1'b1; //haven't found any matching tag yet
+    while(wait_for_next)
+    begin
+      @ rcvd_msg; //wait for a rcvd_memrd event
+      traffic_class_ = frame_store_rx[1] >> 4;
+      td_ = frame_store_rx[2] >> 7;
+      ep_ = frame_store_rx[2] >> 6;
+      attr_ = frame_store_rx[2] >> 4;
+      length_ = frame_store_rx[2];
+      length_ = (length_ << 8) | (frame_store_rx[3]);
+      requester_id_= {frame_store_rx[4], frame_store_rx[5]};
+      tag_= frame_store_rx[6];
+      msg_code_ = frame_store_rx[7];
+
+      address_[29:6] = {frame_store_rx[8], frame_store_rx[9], frame_store_rx[10]};
+      address_[5:0] = frame_store_rx[11] >> 2;
+
+      $display("[%t] : Received MSG w/o Data --- Tag 0x%h", $realtime, tag_);
+      if(tag == tag_) //find matching tag
+      begin
+        wait_for_next = 1'b0;
+        if((traffic_class == traffic_class_) &&
+           (td === td_) && (ep == ep_) && (attr == attr_) &&
+           (length == length_) && (requester_id == requester_id_) &&
+           (msg_code == msg_code_) && (address == address_))
+        begin
+          // header matches
+          expect_status = 1'b1;
+        end
+        else // header mismatches, error out
+        begin
+          $fdisplay(error_file_ptr, "[%t] : Found header mismatch in received MSG w/o Data - Tag 0x%h: \n", $time, tag_);
+          $fdisplay(error_file_ptr, "Expected:");
+          $fdisplay(error_file_ptr, "\t Traffic Class: 0x%h", traffic_class);
+          $fdisplay(error_file_ptr, "\t TD: %h", td);
+          $fdisplay(error_file_ptr, "\t EP: %h", ep);
+          $fdisplay(error_file_ptr, "\t Attributes: 0x%h", attr);
+          $fdisplay(error_file_ptr, "\t Length: 0x%h", length);
+          $fdisplay(error_file_ptr, "\t Requester ID: 0x%h", requester_id);
+          $fdisplay(error_file_ptr, "\t Tag: 0x%h", tag);
+          $fdisplay(error_file_ptr, "\t Msg Code: 0x%h", msg_code);
+          $fdisplay(error_file_ptr, "\t Address: 0x%h", address);
+          $fdisplay(error_file_ptr, "Received:");
+          $fdisplay(error_file_ptr, "\t Traffic Class: 0x%h", traffic_class_);
+          $fdisplay(error_file_ptr, "\t TD: %h", td_);
+          $fdisplay(error_file_ptr, "\t EP: %h", ep_);
+          $fdisplay(error_file_ptr, "\t Attributes: 0x%h", attr_);
+          $fdisplay(error_file_ptr, "\t Length: 0x%h", length_);
+          $fdisplay(error_file_ptr, "\t Requester ID: 0x%h", requester_id_);
+          $fdisplay(error_file_ptr, "\t Tag: 0x%h", tag_);
+          $fdisplay(error_file_ptr, "\t Msg Code: 0x%h", msg_code_);
+          $fdisplay(error_file_ptr, "\t Address: 0x%h", address_);
+          $fdisplay(error_file_ptr, "");
+          expect_status = 1'b0;
+        end
+      end
+    end
+  end
+endtask
+
+
+
+
+
diff --git a/sim/tb/include/sample_tests.vh b/sim/tb/include/sample_tests.vh
new file mode 100644
index 0000000..5756c3b
--- /dev/null
+++ b/sim/tb/include/sample_tests.vh
@@ -0,0 +1,510 @@
+
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2025 Advanced Micro Devices, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : PCI Express DMA
+// File       : sample_tests.vh
+// Version    : 5.0
+//-----------------------------------------------------------------------------
+//
+//------------------------------------------------------------------------------
+
+
+//else if(board.RP.tx_usrapp.testname =="irq_test0")
+//begin
+//   board.RP.tx_usrapp.qid = 11'h0;
+//   board.RP.tx_usrapp.TSK_QDMA_MM_H2C_TEST(board.RP.tx_usrapp.qid, 0, 0);
+//   #1000;
+//   board.RP.tx_usrapp.TSK_USR_IRQ_TEST;
+//
+//end
+else if(board.RP.tx_usrapp.testname =="qdma_mm_test0")
+begin
+   board.RP.tx_usrapp.qid = 11'h1;
+   board.RP.tx_usrapp.TSK_QDMA_MM_H2C_TEST(board.RP.tx_usrapp.qid, 0, 0);
+   board.RP.tx_usrapp.TSK_QDMA_MM_C2H_TEST(board.RP.tx_usrapp.qid, 0, 0);
+   $display("\n\nCOMPLETED QDMA TEST\n\n");
+   //#1000;
+   //board.RP.tx_usrapp.pfTestIteration = board.RP.tx_usrapp.pfTestIteration + 1;
+   //if (board.RP.tx_usrapp.test_state == 1 )
+   //  $display ("ERROR: TEST FAILED \n");
+   //#1000;
+   //$finish;
+end
+else if(board.RP.tx_usrapp.testname == "qdma_st_test0")
+begin
+  board.RP.tx_usrapp.qid = 11'h0;
+  board.RP.tx_usrapp.TSK_QDMA_ST_H2C_TEST(board.RP.tx_usrapp.qid, 0);
+  board.RP.tx_usrapp.TSK_QDMA_ST_C2H_TEST(board.RP.tx_usrapp.qid, 0);
+  $display("\n\nCOMPLETED QDMA TEST\n\n");
+//   #1000;
+//   board.RP.tx_usrapp.pfTestIteration = board.RP.tx_usrapp.pfTestIteration + 1;
+//    if (board.RP.tx_usrapp.test_state == 1 )
+//     $display ("ERROR: TEST FAILED \n");
+//   #1000;
+//   $finish;
+end
+//else if(board.RP.tx_usrapp.testname == "qdma_st_c2h_simbyp_test0")
+//begin
+//   board.RP.tx_usrapp.qid = 11'h3;
+//   board.RP.tx_usrapp.TSK_QDMA_ST_C2H_SIMBYP_TEST(board.RP.tx_usrapp.qid, 1);
+//   #1000;
+//   board.RP.tx_usrapp.pfTestIteration = board.RP.tx_usrapp.pfTestIteration + 1;
+//    if (board.RP.tx_usrapp.test_state == 1 )
+//     $display ("ERROR: TEST FAILED \n");
+//   #1000;
+//   $finish;
+//end
+//else if(board.RP.tx_usrapp.testname == "qdma_imm_test0")
+//begin
+//   board.RP.tx_usrapp.qid = 11'h2;
+//   board.RP.tx_usrapp.TSK_QDMA_IMM_TEST(board.RP.tx_usrapp.qid);
+//   #1000;
+//   board.RP.tx_usrapp.pfTestIteration = board.RP.tx_usrapp.pfTestIteration + 1;
+//    if (board.RP.tx_usrapp.test_state == 1 )
+//     $display ("ERROR: TEST FAILED \n");
+//   #1000;
+//   $finish;
+//end
+//
+else if(board.RP.tx_usrapp.testname == "qdma_mm_st_test0")
+begin
+  board.RP.tx_usrapp.qid = 11'h0;
+  board.RP.tx_usrapp.TSK_QDMA_MM_H2C_TEST(board.RP.tx_usrapp.qid, 0, 1);
+  board.RP.tx_usrapp.TSK_QDMA_MM_C2H_TEST(board.RP.tx_usrapp.qid, 0, 1);
+  $display("\n\n\COMPLETED MM TEST\n\n");
+  board.RP.tx_usrapp.TSK_QDMA_ST_H2C_TEST(board.RP.tx_usrapp.qid, 0);
+  board.RP.tx_usrapp.TSK_QDMA_ST_C2H_TEST(board.RP.tx_usrapp.qid, 0);
+//   #1000;
+//   board.RP.tx_usrapp.pfTestIteration = board.RP.tx_usrapp.pfTestIteration + 1;
+//    if (board.RP.tx_usrapp.test_state == 1 )
+//     $display ("ERROR: TEST FAILED \n");
+//   #1000;
+//   $finish;
+end
+//
+//else if(board.RP.tx_usrapp.testname == "qdma_h2c_lp_c2h_imm_test0")
+//begin
+//   board.RP.tx_usrapp.qid = 11'h1;
+//   board.RP.tx_usrapp.TSK_QDMA_H2C_LP_C2H_IMM_TEST(board.RP.tx_usrapp.qid, 0);
+//   #1000;
+//   board.RP.tx_usrapp.pfTestIteration = board.RP.tx_usrapp.pfTestIteration + 1;
+//    if (board.RP.tx_usrapp.test_state == 1 )
+//     $display ("ERROR: TEST FAILED \n");
+//   #1000;
+//   $finish;
+//end
+//
+//else if(board.RP.tx_usrapp.testname == "qdma_mm_st_dsc_byp_test0")
+//begin
+//   board.RP.tx_usrapp.qid = 11'h4;
+//   board.RP.tx_usrapp.TSK_QDMA_MM_H2C_TEST(board.RP.tx_usrapp.qid, 1, 0);
+//   board.RP.tx_usrapp.TSK_QDMA_MM_C2H_TEST(board.RP.tx_usrapp.qid, 1, 0);
+//   board.RP.tx_usrapp.TSK_QDMA_ST_C2H_TEST(board.RP.tx_usrapp.qid, 1);
+//   board.RP.tx_usrapp.TSK_QDMA_ST_H2C_TEST(board.RP.tx_usrapp.qid, 1);
+//   #1000;
+//   board.RP.tx_usrapp.pfTestIteration = board.RP.tx_usrapp.pfTestIteration + 1;
+//    if (board.RP.tx_usrapp.test_state == 1 )
+//     $display ("ERROR: TEST FAILED \n");
+//   #1000;
+//   $finish;
+//end
+//else if(board.RP.tx_usrapp.testname =="qdma_mm_user_reset_test0")
+//begin
+//   board.RP.tx_usrapp.qid = 0;
+//   board.RP.tx_usrapp.TSK_QDMA_MM_H2C_TEST(board.RP.tx_usrapp.qid, 0, 0);
+//   board.RP.tx_usrapp.TSK_QDMA_MM_C2H_TEST(board.RP.tx_usrapp.qid, 0, 0);
+//   #1000;
+//   board.RP.tx_usrapp.TSK_REG_WRITE(board.RP.tx_usrapp.user_bar,32'h98, 32'h640001, 4'hF);
+//   #30000000
+//   board.RP.tx_usrapp.TSK_QDMA_MM_H2C_TEST(board.RP.tx_usrapp.qid, 0, 0);
+//   board.RP.tx_usrapp.TSK_QDMA_MM_C2H_TEST(board.RP.tx_usrapp.qid, 0, 0);
+//    if (board.RP.tx_usrapp.test_state == 1 )
+//      $display ("ERROR: TEST FAILED \n");
+//
+//   $finish;
+//end
+//
+//
+//
+//else if(board.RP.tx_usrapp.testname == "sample_smoke_test0")
+//begin
+//
+//
+//    board.RP.tx_usrapp.TSK_SIMULATION_TIMEOUT(5050);
+//
+//    //System Initialization
+//    board.RP.tx_usrapp.TSK_SYSTEM_INITIALIZATION;
+//
+//
+//
+//
+//
+//    $display("[%t] : Expected Device/Vendor ID = %x", $realtime, board.RP.tx_usrapp.DEV_VEN_ID);
+//
+//    //--------------------------------------------------------------------------
+//    // Read core configuration space via PCIe fabric interface
+//    //--------------------------------------------------------------------------
+//
+//    $display("[%t] : Reading from PCI/PCI-Express Configuration Register 0x00", $realtime);
+//
+//    board.RP.tx_usrapp.TSK_TX_TYPE0_CONFIGURATION_READ(board.RP.tx_usrapp.DEFAULT_TAG, 12'h0, 4'hF);
+//    board.RP.tx_usrapp.TSK_WAIT_FOR_READ_DATA;
+//    if  (board.RP.tx_usrapp.P_READ_DATA != board.RP.tx_usrapp.DEV_VEN_ID) begin
+//        $display("ERROR: [%t] : TEST FAILED --- Data Error Mismatch, Write Data %x != Read Data %x", $realtime,
+//                                    board.RP.tx_usrapp.DEV_VEN_ID, board.RP.tx_usrapp.P_READ_DATA);
+//    end
+//    else begin
+//        $display("[%t] : TEST PASSED --- Device/Vendor ID %x successfully received", $realtime, board.RP.tx_usrapp.P_READ_DATA);
+//        $display("[%t] : Test Completed Successfully",$realtime);
+//    end
+//
+//    //--------------------------------------------------------------------------
+//    // Direct Root Port to allow upstream traffic by enabling Mem, I/O and
+//    // BusMstr in the command register
+//    //--------------------------------------------------------------------------
+//
+//    board.RP.cfg_usrapp.TSK_READ_CFG_DW(32'h00000001);
+//    board.RP.cfg_usrapp.TSK_WRITE_CFG_DW(32'h00000001, 32'h00000007, 4'b0001);
+//    board.RP.cfg_usrapp.TSK_READ_CFG_DW(32'h00000001);
+//
+//     if (board.RP.tx_usrapp.test_state == 1 )
+//     $display ("ERROR: TEST FAILED \n");
+//
+//  $finish;
+//end
+//
+//
+//else if(board.RP.tx_usrapp.testname == "sample_smoke_test1")
+//begin
+//
+//    // This test use tlp expectation tasks.
+//
+//    board.RP.tx_usrapp.TSK_SIMULATION_TIMEOUT(5050);
+//
+//    // System Initialization
+//    board.RP.tx_usrapp.TSK_SYSTEM_INITIALIZATION;
+//    // Program BARs (Required so Completer ID at the Endpoint is updated)
+//    board.RP.tx_usrapp.TSK_BAR_INIT;
+//
+//fork
+//  begin
+//    //--------------------------------------------------------------------------
+//    // Read core configuration space via PCIe fabric interface
+//    //--------------------------------------------------------------------------
+//
+//    $display("[%t] : Reading from PCI/PCI-Express Configuration Register 0x00", $realtime);
+//
+//    board.RP.tx_usrapp.TSK_TX_TYPE0_CONFIGURATION_READ(board.RP.tx_usrapp.DEFAULT_TAG, 12'h0, 4'hF);
+//    board.RP.tx_usrapp.DEFAULT_TAG = board.RP.tx_usrapp.DEFAULT_TAG + 1;
+//    board.RP.tx_usrapp.TSK_TX_CLK_EAT(100);
+//  end
+//    //---------------------------------------------------------------------------
+//    // List Rx TLP expections
+//    //---------------------------------------------------------------------------
+//  begin
+//    board.RP.tx_usrapp.test_vars[0] = 0;
+//
+//    $display("[%t] : Expected Device/Vendor ID = %x", $realtime, board.RP.tx_usrapp.DEV_VEN_ID);
+//
+//    board.RP.tx_usrapp.expect_cpld_payload[0] = board.RP.tx_usrapp.DEV_VEN_ID[31:24];
+//    board.RP.tx_usrapp.expect_cpld_payload[1] = board.RP.tx_usrapp.DEV_VEN_ID[23:16];
+//    board.RP.tx_usrapp.expect_cpld_payload[2] = board.RP.tx_usrapp.DEV_VEN_ID[15:8];
+//    board.RP.tx_usrapp.expect_cpld_payload[3] = board.RP.tx_usrapp.DEV_VEN_ID[7:0];
+//    @(posedge board.RP.tx_usrapp.pcie_rq_tag_vld);
+//    board.RP.tx_usrapp.exp_tag = board.RP.tx_usrapp.pcie_rq_tag;
+//
+//    board.RP.com_usrapp.TSK_EXPECT_CPLD(
+//      3'h0, //traffic_class;
+//      1'b0, //td;
+//      1'b0, //ep;
+//      2'h0, //attr;
+//      10'h1, //length;
+//      board.RP.tx_usrapp.EP_BUS_DEV_FNS, //completer_id;
+//      3'h0, //completion_status;
+//      1'b0, //bcm;
+//      12'h4, //byte_count;
+//      board.RP.tx_usrapp.RP_BUS_DEV_FNS, //requester_id;
+//      board.RP.tx_usrapp.exp_tag ,
+//      7'b0, //address_low;
+//      board.RP.tx_usrapp.expect_status //expect_status;
+//    );
+//
+//    if (board.RP.tx_usrapp.expect_status)
+//      board.RP.tx_usrapp.test_vars[0] = board.RP.tx_usrapp.test_vars[0] + 1;
+//  end
+//join
+//
+//  board.RP.tx_usrapp.expect_finish_check = 1;
+//
+//  if (board.RP.tx_usrapp.test_vars[0] == 1) begin
+//    $display("[%t] : TEST PASSED --- Finished transmission of PCI-Express TLPs", $realtime);
+//    $display("[%t] : Test Completed Successfully",$realtime);
+//  end else begin
+//    $display("ERROR: [%t] : TEST FAILED --- Haven't Received All Expected TLPs", $realtime);
+//
+//    //--------------------------------------------------------------------------
+//    // Direct Root Port to allow upstream traffic by enabling Mem, I/O and
+//    // BusMstr in the command register
+//    //--------------------------------------------------------------------------
+//
+//    board.RP.cfg_usrapp.TSK_READ_CFG_DW(32'h00000001);
+//    board.RP.cfg_usrapp.TSK_WRITE_CFG_DW(32'h00000001, 32'h00000007, 4'b0001);
+//    board.RP.cfg_usrapp.TSK_READ_CFG_DW(32'h00000001);
+//
+//  end
+//
+//  $finish;
+//end
+//
+//else if(board.RP.tx_usrapp.testname == "pio_writeReadBack_test0")
+//begin
+//
+//    // This test performs a 32 bit write to a 32 bit Memory space and performs a read back
+//
+//    board.RP.tx_usrapp.TSK_SIMULATION_TIMEOUT(10050);
+//
+//    board.RP.tx_usrapp.TSK_SYSTEM_INITIALIZATION;
+//
+//    board.RP.tx_usrapp.TSK_BAR_INIT;
+//
+////--------------------------------------------------------------------------
+//// Event : Testing BARs
+////--------------------------------------------------------------------------
+//
+//        for (board.RP.tx_usrapp.ii = 0; board.RP.tx_usrapp.ii <= 6; board.RP.tx_usrapp.ii =
+//            board.RP.tx_usrapp.ii + 1) begin
+//            if ((board.RP.tx_usrapp.BAR_INIT_P_BAR_ENABLED[board.RP.tx_usrapp.ii] > 2'b00)) // bar is enabled
+//               case(board.RP.tx_usrapp.BAR_INIT_P_BAR_ENABLED[board.RP.tx_usrapp.ii])
+//                   2'b01 : // IO SPACE
+//                        begin
+//
+//                          $display("[%t] : Transmitting TLPs to IO Space BAR %x", $realtime, board.RP.tx_usrapp.ii);
+//
+//                          //--------------------------------------------------------------------------
+//                          // Event : IO Write bit TLP
+//                          //--------------------------------------------------------------------------
+//
+//
+//
+//                          board.RP.tx_usrapp.TSK_TX_IO_WRITE(board.RP.tx_usrapp.DEFAULT_TAG,
+//                             board.RP.tx_usrapp.BAR_INIT_P_BAR[board.RP.tx_usrapp.ii][31:0], 4'hF, 32'hdead_beef);
+//                             @(posedge board.RP.tx_usrapp.pcie_rq_tag_vld);
+//                             board.RP.tx_usrapp.exp_tag = board.RP.tx_usrapp.pcie_rq_tag;
+//
+//
+//                          board.RP.com_usrapp.TSK_EXPECT_CPL(3'h0, 1'b0, 1'b0, 2'b0,
+//                             board.RP.tx_usrapp.EP_BUS_DEV_FNS, 3'h0, 1'b0, 12'h4,
+//                             board.RP.tx_usrapp.RP_BUS_DEV_FNS, board.RP.tx_usrapp.exp_tag,
+//                             board.RP.tx_usrapp.BAR_INIT_P_BAR[board.RP.tx_usrapp.ii][31:0], board.RP.tx_usrapp.test_vars[0]);
+//
+//                          board.RP.tx_usrapp.TSK_TX_CLK_EAT(10);
+//                          board.RP.tx_usrapp.DEFAULT_TAG = board.RP.tx_usrapp.DEFAULT_TAG + 1;
+//
+//                          //--------------------------------------------------------------------------
+//                          // Event : IO Read bit TLP
+//                          //--------------------------------------------------------------------------
+//
+//
+//                          // make sure P_READ_DATA has known initial value
+//                          board.RP.tx_usrapp.P_READ_DATA = 32'hffff_ffff;
+//                          fork
+//                             board.RP.tx_usrapp.TSK_TX_IO_READ(board.RP.tx_usrapp.DEFAULT_TAG,
+//                                board.RP.tx_usrapp.BAR_INIT_P_BAR[board.RP.tx_usrapp.ii][31:0], 4'hF);
+//                             board.RP.tx_usrapp.TSK_WAIT_FOR_READ_DATA;
+//                          join
+//                          if  (board.RP.tx_usrapp.P_READ_DATA != 32'hdead_beef)
+//                             begin
+//			       board.RP.tx_usrapp.testError=1'b1;
+//                               $display("ERROR:  [%t] : Test FAILED --- Data Error Mismatch, Write Data %x != Read Data %x",
+//                                   $realtime, 32'hdead_beef, board.RP.tx_usrapp.P_READ_DATA);
+//                             end
+//                          else
+//                             begin
+//                               $display("[%t] : Test PASSED --- Write Data: %x successfully received",
+//                                   $realtime, board.RP.tx_usrapp.P_READ_DATA);
+//                             end
+//
+//
+//                          board.RP.tx_usrapp.TSK_TX_CLK_EAT(10);
+//                          board.RP.tx_usrapp.DEFAULT_TAG = board.RP.tx_usrapp.DEFAULT_TAG + 1;
+//
+//
+//                        end
+//
+//                   2'b10 : // MEM 32 SPACE
+//                        begin
+//
+//
+//                          $display("[%t] : Transmitting TLPs to Memory 32 Space BAR %x", $realtime,
+//                              board.RP.tx_usrapp.ii);
+//
+//                          //--------------------------------------------------------------------------
+//                          // Event : Memory Write 32 bit TLP
+//                          //--------------------------------------------------------------------------
+//
+//                          board.RP.tx_usrapp.DATA_STORE[0] = 8'h04;
+//                          board.RP.tx_usrapp.DATA_STORE[1] = 8'h03;
+//                          board.RP.tx_usrapp.DATA_STORE[2] = 8'h02;
+//                          board.RP.tx_usrapp.DATA_STORE[3] = 8'h01;
+//
+//                          board.RP.tx_usrapp.TSK_TX_MEMORY_WRITE_32(board.RP.tx_usrapp.DEFAULT_TAG,
+//                              board.RP.tx_usrapp.DEFAULT_TC, 11'd1,
+//                              board.RP.tx_usrapp.BAR_INIT_P_BAR[board.RP.tx_usrapp.ii][31:0]+8'h10, 4'h0, 4'hF, 1'b0);
+//                          board.RP.tx_usrapp.TSK_TX_CLK_EAT(100);
+//                          board.RP.tx_usrapp.DEFAULT_TAG = board.RP.tx_usrapp.DEFAULT_TAG + 1;
+//
+//                          //--------------------------------------------------------------------------
+//                          // Event : Memory Read 32 bit TLP
+//                          //--------------------------------------------------------------------------
+//
+//
+//                         // make sure P_READ_DATA has known initial value
+//                         board.RP.tx_usrapp.P_READ_DATA = 32'hffff_ffff;
+//                          fork
+//                             board.RP.tx_usrapp.TSK_TX_MEMORY_READ_32(board.RP.tx_usrapp.DEFAULT_TAG,
+//                                 board.RP.tx_usrapp.DEFAULT_TC, 11'd1,
+//                                 board.RP.tx_usrapp.BAR_INIT_P_BAR[board.RP.tx_usrapp.ii][31:0]+8'h10, 4'h0, 4'hF);
+//                             board.RP.tx_usrapp.TSK_WAIT_FOR_READ_DATA;
+//                          join
+//                          if  (board.RP.tx_usrapp.P_READ_DATA != {board.RP.tx_usrapp.DATA_STORE[3],
+//                             board.RP.tx_usrapp.DATA_STORE[2], board.RP.tx_usrapp.DATA_STORE[1],
+//                             board.RP.tx_usrapp.DATA_STORE[0] })
+//                             begin
+//			       board.RP.tx_usrapp.testError=1'b1;
+//                               $display("ERROR: [%t] : Test FAILED --- Data Error Mismatch, Write Data %x != Read Data %x",
+//                                    $realtime, {board.RP.tx_usrapp.DATA_STORE[3],board.RP.tx_usrapp.DATA_STORE[2],
+//                                     board.RP.tx_usrapp.DATA_STORE[1],board.RP.tx_usrapp.DATA_STORE[0]},
+//                                     board.RP.tx_usrapp.P_READ_DATA);
+//
+//                             end
+//                          else
+//                             begin
+//                               $display("[%t] : Test PASSED --- Write Data: %x successfully received",
+//                                   $realtime, board.RP.tx_usrapp.P_READ_DATA);
+//                             end
+//
+//
+//                          board.RP.tx_usrapp.TSK_TX_CLK_EAT(10);
+//                          board.RP.tx_usrapp.DEFAULT_TAG = board.RP.tx_usrapp.DEFAULT_TAG + 1;
+//
+//                     end
+//                2'b11 : // MEM 64 SPACE
+//                     begin
+//
+//
+//                          $display("[%t] : Transmitting TLPs to Memory 64 Space BAR %x", $realtime,
+//                              board.RP.tx_usrapp.ii);
+//
+//
+//                          //--------------------------------------------------------------------------
+//                          // Event : Memory Write 64 bit TLP
+//                          //--------------------------------------------------------------------------
+//
+//                          board.RP.tx_usrapp.DATA_STORE[0] = 8'h64;
+//                          board.RP.tx_usrapp.DATA_STORE[1] = 8'h63;
+//                          board.RP.tx_usrapp.DATA_STORE[2] = 8'h62;
+//                          board.RP.tx_usrapp.DATA_STORE[3] = 8'h61;
+//
+//                          board.RP.tx_usrapp.TSK_TX_MEMORY_WRITE_64(board.RP.tx_usrapp.DEFAULT_TAG,
+//                              board.RP.tx_usrapp.DEFAULT_TC, 10'd1,
+//                              {board.RP.tx_usrapp.BAR_INIT_P_BAR[board.RP.tx_usrapp.ii+1][31:0],
+//                              board.RP.tx_usrapp.BAR_INIT_P_BAR[board.RP.tx_usrapp.ii][31:0]+8'h20}, 4'h0, 4'hF, 1'b0);
+//                          board.RP.tx_usrapp.TSK_TX_CLK_EAT(10);
+//                          board.RP.tx_usrapp.DEFAULT_TAG = board.RP.tx_usrapp.DEFAULT_TAG + 1;
+//
+//                          //--------------------------------------------------------------------------
+//                          // Event : Memory Read 64 bit TLP
+//                          //--------------------------------------------------------------------------
+//
+//
+//                          // make sure P_READ_DATA has known initial value
+//                          board.RP.tx_usrapp.P_READ_DATA = 32'hffff_ffff;
+//                          fork
+//                             board.RP.tx_usrapp.TSK_TX_MEMORY_READ_64(board.RP.tx_usrapp.DEFAULT_TAG,
+//                                 board.RP.tx_usrapp.DEFAULT_TC, 10'd1,
+//                                 {board.RP.tx_usrapp.BAR_INIT_P_BAR[board.RP.tx_usrapp.ii+1][31:0],
+//                                 board.RP.tx_usrapp.BAR_INIT_P_BAR[board.RP.tx_usrapp.ii][31:0]+8'h20}, 4'h0, 4'hF);
+//                             board.RP.tx_usrapp.TSK_WAIT_FOR_READ_DATA;
+//                          join
+//                          if  (board.RP.tx_usrapp.P_READ_DATA != {board.RP.tx_usrapp.DATA_STORE[3],
+//                             board.RP.tx_usrapp.DATA_STORE[2], board.RP.tx_usrapp.DATA_STORE[1],
+//                             board.RP.tx_usrapp.DATA_STORE[0] })
+//
+//                             begin
+//			       board.RP.tx_usrapp.testError=1'b1;
+//                               $display("ERROR: [%t] : Test FAILED --- Data Error Mismatch, Write Data %x != Read Data %x",
+//                                   $realtime, {board.RP.tx_usrapp.DATA_STORE[3],
+//                                   board.RP.tx_usrapp.DATA_STORE[2], board.RP.tx_usrapp.DATA_STORE[1],
+//                                   board.RP.tx_usrapp.DATA_STORE[0]}, board.RP.tx_usrapp.P_READ_DATA);
+//
+//                             end
+//                          else
+//                             begin
+//                               $display("[%t] : Test PASSED --- Write Data: %x successfully received",
+//                                   $realtime, board.RP.tx_usrapp.P_READ_DATA);
+//                             end
+//
+//
+//                          board.RP.tx_usrapp.TSK_TX_CLK_EAT(10);
+//                          board.RP.tx_usrapp.DEFAULT_TAG = board.RP.tx_usrapp.DEFAULT_TAG + 1;
+//
+//
+//                     end
+//                default : $display("Error case in usrapp_tx\n");
+//            endcase
+//
+//         end
+//    if(board.RP.tx_usrapp.testError==1'b0)
+//      $display("[%t] : Test Completed Successfully",$realtime);
+//
+//    $display("[%t] : Finished transmission of PCI-Express TLPs", $realtime);
+//    $finish;
+//end
diff --git a/sim/tb/include/tests.vh b/sim/tb/include/tests.vh
new file mode 100644
index 0000000..b2fd710
--- /dev/null
+++ b/sim/tb/include/tests.vh
@@ -0,0 +1 @@
+`include "sample_tests.vh"
\ No newline at end of file
diff --git a/sim/tb/open_nic_tb.sv b/sim/tb/open_nic_tb.sv
new file mode 100644
index 0000000..0a12d7d
--- /dev/null
+++ b/sim/tb/open_nic_tb.sv
@@ -0,0 +1,370 @@
+
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2025 Advanced Micro Devices, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : PCI Express DMA
+// File       : board.v
+// Version    : 5.0
+//-----------------------------------------------------------------------------
+//-----------------------------------------------------------------------------
+//
+// Project    : Ultrascale FPGA Gen3 Integrated Block for PCI Express
+// File       : board.v
+// Version    : 5.0
+//-----------------------------------------------------------------------------
+//-----------------------------------------------------------------------------
+//
+// Description: Top level testbench
+//
+//------------------------------------------------------------------------------
+
+`timescale 1ps/1ps
+
+`include "board_common.vh"
+`define SIMULATION
+`define LINKWIDTH 16
+`define LINKSPEED 4
+
+import open_nic_file_tools::*;
+
+module board;
+
+  parameter          REF_CLK_FREQ       = 0 ;      // 0 - 100 MHz, 1 - 125 MHz,  2 - 250 MHz
+  localparam         REF_CLK_HALF_CYCLE = (REF_CLK_FREQ == 0) ? 5000 :
+                                          (REF_CLK_FREQ == 1) ? 4000 :
+                                          (REF_CLK_FREQ == 2) ? 2000 : 0;
+  localparam   [2:0] PF0_DEV_CAP_MAX_PAYLOAD_SIZE = 3'b011;
+  localparam   [4:0] LINK_WIDTH = 5'd`LINKWIDTH;
+  localparam   [2:0] LINK_SPEED = 3'h`LINKSPEED;
+
+//  defparam board.EP.qdma_0_i.inst.pcie4c_ip_i.inst.PL_SIM_FAST_LINK_TRAINING=2'h3;
+  localparam EXT_PIPE_SIM = "FALSE";
+  parameter C_DATA_WIDTH = 512;
+
+  integer            i;
+
+  // System-level clock and reset
+  logic                sys_rst_n;
+
+  logic               ep_sys_clk;
+  logic               rp_sys_clk;
+  logic               ep_sys_clk_p;
+  logic               ep_sys_clk_n;
+  logic               rp_sys_clk_p;
+  logic               rp_sys_clk_n;
+  logic               cmac_clk;
+
+
+  //
+  // PCI-Express Serial Interconnect
+  //
+  logic  [(LINK_WIDTH-1):0]  ep_pci_exp_txn;
+  logic  [(LINK_WIDTH-1):0]  ep_pci_exp_txp;
+  logic  [(LINK_WIDTH-1):0]  rp_pci_exp_txn;
+  logic  [(LINK_WIDTH-1):0]  rp_pci_exp_txp;
+
+  // Control signals
+  logic phy_ready;
+  logic user_lnk_up;
+
+
+  //------------------------------------------------------------------------------//
+  // CMAC simulation
+  //------------------------------------------------------------------------------//
+
+  assign cmac_clk = EP.cmac_clk[0];
+  axis #(C_DATA_WIDTH, 1) phy_send (cmac_clk);
+
+  assign EP.m_axis_cmac_tx_sim_tready    = sys_rst_n;
+
+  assign EP.s_axis_cmac_rx_sim_tvalid    = phy_send.tvalid;
+  assign EP.s_axis_cmac_rx_sim_tdata     = phy_send.tdata;
+  assign EP.s_axis_cmac_rx_sim_tkeep     = phy_send.tkeep;
+  assign EP.s_axis_cmac_rx_sim_tlast     = phy_send.tlast;
+  assign EP.s_axis_cmac_rx_sim_tuser_err = phy_send.tuser;
+  assign phy_send.tready = sys_rst_n;
+
+  FileReader #(C_DATA_WIDTH, 1) phy_in_reader;
+  initial begin
+    phy_in_reader = new ($sformatf("%s/%s", `WORK_DIR, "axi_in_cmac0.txt"), phy_send);
+    phy_send.reset();
+  end
+
+  task TSK_SEND_PACKET_CMAC;
+    @(negedge cmac_clk);
+    phy_in_reader.start();
+    forever begin
+      @(negedge cmac_clk);
+      if (!phy_in_reader.get_finished())
+        continue;
+      return;
+    end
+  endtask
+
+
+  //------------------------------------------------------------------------------//
+  // Generate system clock
+  //------------------------------------------------------------------------------//
+  sys_clk_gen_ds # (
+    .halfcycle(REF_CLK_HALF_CYCLE),
+    .offset(0)
+  )
+  CLK_GEN_RP (
+    .sys_clk_p(rp_sys_clk_p),
+    .sys_clk_n(rp_sys_clk_n)
+  );
+
+  sys_clk_gen_ds # (
+    .halfcycle(REF_CLK_HALF_CYCLE),
+    .offset(0)
+  )
+  CLK_GEN_EP (
+    .sys_clk_p(ep_sys_clk_p),
+    .sys_clk_n(ep_sys_clk_n)
+  );
+
+
+
+  //------------------------------------------------------------------------------//
+  // Generate system-level reset
+  //------------------------------------------------------------------------------//
+  parameter ON=3, OFF=4, UNIQUE=32, UNIQUE0=64, PRIORITY=128;
+
+  initial begin
+    `ifndef XILINX_SIMULATOR
+    // Disable UNIQUE, UNIQUE0, and PRIORITY analysis during reset because signal can be at unknown value during reset
+    $assertcontrol( OFF , UNIQUE | UNIQUE0 | PRIORITY);
+    `endif
+
+    $display("[%t] : System Reset Is Asserted...", $realtime);
+    sys_rst_n = 1'b0;
+    repeat (500) @(posedge rp_sys_clk_p);
+    $display("[%t] : System Reset Is De-asserted...", $realtime);
+    sys_rst_n = 1'b1;
+
+    `ifndef XILINX_SIMULATOR
+    // Re-enable UNIQUE, UNIQUE0, and PRIORITY analysis
+    $assertcontrol( ON , UNIQUE | UNIQUE0 | PRIORITY);
+    `endif
+  end
+  //------------------------------------------------------------------------------//
+
+  //------------------------------------------------------------------------------//
+  // EndPoint DUT with PIO Slave
+  //------------------------------------------------------------------------------//
+  //
+  // PCI-Express Endpoint Instance
+  //
+
+
+  open_nic_shell
+  #(
+    .BUILD_TIMESTAMP (32'h01010000),
+    .MIN_PKT_LEN     (64),
+    .MAX_PKT_LEN     (1518),
+    .USE_PHYS_FUNC   (1),
+    .NUM_PHYS_FUNC   (1),
+    .NUM_QUEUE       (512),
+    .NUM_CMAC_PORT   (1)
+  ) EP (
+    .pcie_rxn (rp_pci_exp_txn),
+    .pcie_rxp (rp_pci_exp_txp),
+    .pcie_txn (ep_pci_exp_txn),
+    .pcie_txp (ep_pci_exp_txp),
+
+    .pcie_refclk_p (ep_sys_clk_p),
+    .pcie_refclk_n (ep_sys_clk_n),
+    .pcie_rstn (sys_rst_n)
+  );
+
+
+  //------------------------------------------------------------------------------//
+  // Simulation Root Port Model
+  // (Comment out this module to interface EndPoint with BFM)
+  //------------------------------------------------------------------------------//
+  //
+  // PCI-Express Model Root Port Instance
+  //
+
+  xilinx_pcie4_uscale_rp
+  #(
+     .PF0_DEV_CAP_MAX_PAYLOAD_SIZE(PF0_DEV_CAP_MAX_PAYLOAD_SIZE)
+     //ONLY FOR RP
+  ) RP (
+
+    // SYS Inteface
+    .sys_clk_n(rp_sys_clk_n),
+    .sys_clk_p(rp_sys_clk_p),
+    .sys_rst_n                  ( sys_rst_n ),
+    // PCI-Express Serial Interface
+    .pci_exp_txn(rp_pci_exp_txn),
+    .pci_exp_txp(rp_pci_exp_txp),
+    .pci_exp_rxn(ep_pci_exp_txn),
+    .pci_exp_rxp(ep_pci_exp_txp)
+
+  );
+
+
+  initial begin
+
+    if ($test$plusargs ("dump_all")) begin
+
+  `ifdef NCV // Cadence TRN dump
+
+      $recordsetup("design=board",
+                   "compress",
+                   "wrapsize=100M",
+                   "version=1",
+                   "run=1");
+      $recordvars();
+
+  `elsif VCS //Synopsys VPD dump
+
+      $vcdplusfile("board.vpd");
+      $vcdpluson;
+      $vcdplusglitchon;
+      $vcdplusflush;
+
+  `else
+
+      // Verilog VC dump
+      $dumpfile("board.vcd");
+      $dumpvars(0, board);
+
+  `endif
+
+    end
+
+  end
+
+//--------------------MAIN TEST-------------------\\
+initial begin
+  $timeformat(-9, 3, "ns", 8);
+  board.RP.tx_usrapp.pfIndex     = 0;
+  board.RP.tx_usrapp.pfTestIteration = 0;
+  board.RP.tx_usrapp.pf_loop_index   = 0;
+  board.RP.tx_usrapp.expect_status   = 0;
+  board.RP.tx_usrapp.expect_finish_check = 0;
+  board.RP.tx_usrapp.testError = 1'b0;
+  // Tx transaction interface signal initialization.
+  board.RP.tx_usrapp.pcie_tlp_data = 0;
+  board.RP.tx_usrapp.pcie_tlp_rem  = 0;
+
+  // Payload data initialization.
+  board.RP.tx_usrapp.TSK_USR_DATA_SETUP_SEQ;
+
+  board.RP.tx_usrapp.TSK_SIMULATION_TIMEOUT(10050);
+  for (board.RP.tx_usrapp.pfIndex = 0; board.RP.tx_usrapp.pfIndex < board.RP.tx_usrapp.NUMBER_OF_PFS; board.RP.tx_usrapp.pfIndex = board.RP.tx_usrapp.pfIndex + 1)
+  begin
+    board.RP.tx_usrapp.pfTestIteration = board.RP.tx_usrapp.pfIndex;
+    if( board.RP.tx_usrapp.pfIndex == 0) board.RP.tx_usrapp.EP_DEV_ID1 = 16'h903F;
+    if( board.RP.tx_usrapp.pfIndex == 1) board.RP.tx_usrapp.EP_DEV_ID1 = 16'h913F;
+    if( board.RP.tx_usrapp.pfIndex == 2) board.RP.tx_usrapp.EP_DEV_ID1 = 16'h923F;
+    if( board.RP.tx_usrapp.pfIndex == 3) board.RP.tx_usrapp.EP_DEV_ID1 = 16'h933F;
+
+    board.RP.tx_usrapp.DEV_VEN_ID = (board.RP.tx_usrapp.EP_DEV_ID1 << 16) | (32'h10EE);
+    board.RP.tx_usrapp.EP_BUS_DEV_FNS = {board.RP.tx_usrapp.EP_BUS_DEV_FNS_INIT[15:2], board.RP.tx_usrapp.pfIndex[1:0]};
+
+    board.RP.tx_usrapp.TSK_SYSTEM_INITIALIZATION;
+    board.RP.tx_usrapp.TSK_BAR_INIT;
+
+    // Find which BAR is XDMA BAR and assign 'xdma_bar' variable
+    board.RP.tx_usrapp.TSK_XDMA_FIND_BAR;
+
+    // Find which BAR is USR BAR and assign 'user_bar' variable
+    board.RP.tx_usrapp.TSK_REG_READ(board.RP.tx_usrapp.xdma_bar, 16'h00);
+    if(board.RP.tx_usrapp.P_READ_DATA[31:16] == 16'h1fd3) begin    // QDMA
+      board.RP.tx_usrapp.TSK_FIND_USR_BAR;
+    end
+
+    // Write the number of QDMA queues to the OpenNIC
+    board.RP.tx_usrapp.TSK_REG_WRITE(board.RP.tx_usrapp.user_bar, 16'h1000, 32'h200, 4'hf);
+
+    board.RP.tx_usrapp.testname = "qdma_mm_st_test0";
+    //Test starts here
+    if(board.RP.tx_usrapp.testname == "dummy_test") begin
+      $display("[%t] %m: Invalid TESTNAME: %0s", $realtime, board.RP.tx_usrapp.testname);
+      $finish(2);
+    end
+    `include "tests.vh"
+    else begin
+      $display("[%t] %m: Error: Unrecognized TESTNAME: %0s", $realtime, board.RP.tx_usrapp.testname);
+      $finish(2);
+    end
+    wait (board.RP.tx_usrapp.pfTestIteration == (board.RP.tx_usrapp.pfIndex +1));
+
+
+    #100
+    board.RP.tx_usrapp.OUT_OF_LO_MEM       = 1'b0;
+    board.RP.tx_usrapp.OUT_OF_IO           = 1'b0;
+    board.RP.tx_usrapp.OUT_OF_HI_MEM       = 1'b0;
+    // Disable variables to start
+    for (int ii = 0; ii <= 6; ii = ii + 1) begin
+      board.RP.tx_usrapp.BAR_INIT_P_BAR[ii]         = 33'h00000_0000;
+      board.RP.tx_usrapp.BAR_INIT_P_BAR_RANGE[ii]   = 32'h0000_0000;
+      board.RP.tx_usrapp.BAR_INIT_P_BAR_ENABLED[ii] = 2'b00;
+    end
+
+    board.RP.tx_usrapp.BAR_INIT_P_MEM64_HI_START =  32'h0000_0001;  // hi 32 bit start of 64bit memory
+    board.RP.tx_usrapp.BAR_INIT_P_MEM64_LO_START =  32'h0000_0000;  // low 32 bit start of 64bit memory
+    board.RP.tx_usrapp.BAR_INIT_P_MEM32_START    =  33'h00000_0000; // start of 32bit memory
+    board.RP.tx_usrapp.BAR_INIT_P_IO_START       =  33'h00000_0000; // start of 32bit io
+    board.RP.tx_usrapp.NUMBER_OF_IO_BARS    = 0;
+    board.RP.tx_usrapp.NUMBER_OF_MEM32_BARS = 0;
+    board.RP.tx_usrapp.NUMBER_OF_MEM64_BARS = 0;
+
+    board.RP.tx_usrapp.cpld_to = 0;        // By default time out has not occured
+    board.RP.tx_usrapp.cpld_to_finish = 1; // By default end simulation on time out
+    board.RP.tx_usrapp.verbose = 0;        // turned off by default
+  end
+  $finish;
+end
+
+endmodule // BOARD
diff --git a/sim/tb/usrapp/usp_pci_exp_usrapp_cfg.v b/sim/tb/usrapp/usp_pci_exp_usrapp_cfg.v
new file mode 100644
index 0000000..a71239a
--- /dev/null
+++ b/sim/tb/usrapp/usp_pci_exp_usrapp_cfg.v
@@ -0,0 +1,439 @@
+
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2025 Advanced Micro Devices, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : PCI Express DMA 
+// File       : usp_pci_exp_usrapp_cfg.v
+// Version    : 5.0
+//-----------------------------------------------------------------------------
+//--
+//--------------------------------------------------------------------------------
+`include "board_common.vh"
+
+module pci_exp_usrapp_cfg (
+
+  user_clk,
+  user_reset,
+  // Management Interface
+  cfg_mgmt_addr,
+  cfg_mgmt_write,
+  cfg_mgmt_write_data,
+  cfg_mgmt_byte_enable, 
+
+  cfg_mgmt_read,
+  cfg_mgmt_read_data,
+  cfg_mgmt_read_write_done,
+  cfg_mgmt_type1_cfg_reg_access,
+  //-------------------------------------------------------------------------------------------//
+  // 4. Configuration (CFG) Interface                                                          //
+  //-------------------------------------------------------------------------------------------//
+  // EP and RP                                                                                 //
+  //-------------------------------------------------------------------------------------------//
+
+  cfg_phy_link_down,
+  cfg_phy_link_status,
+  cfg_negotiated_width,
+  cfg_current_speed,
+  cfg_max_payload,
+  cfg_max_read_req,
+  cfg_function_status,
+  cfg_function_power_state,
+  cfg_vf_status,
+  cfg_vf_power_state,
+  cfg_link_power_state,
+
+  // Error Reporting Interface
+  cfg_err_cor_out,
+  cfg_err_nonfatal_out,
+  cfg_err_fatal_out,
+  //cfg_local_error,
+
+  cfg_ltr_enable,
+  cfg_ltssm_state,
+  cfg_rcb_status,
+  cfg_dpa_substate_change,
+  cfg_obff_enable,
+  cfg_pl_status_change,
+
+  cfg_tph_requester_enable,
+  cfg_tph_st_mode,
+  cfg_vf_tph_requester_enable,
+  cfg_vf_tph_st_mode,
+
+  cfg_msg_received,
+  cfg_msg_received_data,
+  cfg_msg_received_type,
+
+  cfg_msg_transmit,
+  cfg_msg_transmit_type,
+  cfg_msg_transmit_data,
+  cfg_msg_transmit_done,
+
+  cfg_fc_ph,
+  cfg_fc_pd,
+  cfg_fc_nph,
+  cfg_fc_npd,
+  cfg_fc_cplh,
+  cfg_fc_cpld,
+  cfg_fc_sel,
+  cfg_per_func_status_control,
+  cfg_per_func_status_data,
+  cfg_per_function_number,
+  cfg_per_function_output_request,
+  cfg_per_function_update_done,
+
+  cfg_dsn,
+  cfg_power_state_change_ack,
+  cfg_power_state_change_interrupt,
+  cfg_err_cor_in,
+  cfg_err_uncor_in,
+
+  cfg_flr_in_process,
+  cfg_flr_done,
+  cfg_vf_flr_in_process,
+  cfg_vf_flr_done,
+
+  cfg_link_training_enable,
+  cfg_ds_port_number,
+
+  cfg_interrupt_msix_enable,
+  cfg_interrupt_msix_mask,
+  cfg_interrupt_msix_vf_enable,
+  cfg_interrupt_msix_vf_mask,
+  cfg_interrupt_msix_data,
+  cfg_interrupt_msix_address,
+  cfg_interrupt_msix_int,
+  cfg_interrupt_msix_sent,
+  cfg_interrupt_msix_fail,
+
+  cfg_hot_reset_out,
+  cfg_config_space_enable,
+  cfg_req_pm_transition_l23_ready,
+  //-------------------------------------------------------------------------------------------//
+  // RP Only                                                                                   //
+  //-------------------------------------------------------------------------------------------//
+  cfg_hot_reset_in,
+
+  cfg_ds_bus_number,
+  cfg_ds_device_number,
+  cfg_ds_function_number,
+  // Interrupt Interface Signals
+  cfg_interrupt_int,
+  cfg_interrupt_pending,
+  cfg_interrupt_sent
+
+);
+
+  input                                 user_clk;
+  input                                 user_reset;
+  // Management Interface
+  output reg                     [9:0]     cfg_mgmt_addr;
+  output reg                                cfg_mgmt_write;
+  output reg                     [31:0]     cfg_mgmt_write_data;
+  output reg                      [3:0]     cfg_mgmt_byte_enable; 
+
+  output reg                                cfg_mgmt_read;
+  input                      [31:0]     cfg_mgmt_read_data;
+  input                                 cfg_mgmt_read_write_done;
+  output reg                                cfg_mgmt_type1_cfg_reg_access;
+  //-------------------------------------------------------------------------------------------//
+  // 4. Configuration (CFG) Interface                                                          //
+  //-------------------------------------------------------------------------------------------//
+  // EP and RP                                                                                 //
+  //-------------------------------------------------------------------------------------------//
+
+  input                                 cfg_phy_link_down;
+  input                       [1:0]     cfg_phy_link_status;
+  input                       [2:0]     cfg_negotiated_width;
+  input                       [1:0]     cfg_current_speed;
+  input                       [1:0]     cfg_max_payload;
+  input                       [2:0]     cfg_max_read_req;
+  input                      [15:0]     cfg_function_status;
+  input                      [11:0]     cfg_function_power_state;
+  input                      [503:0]     cfg_vf_status;
+  input                      [755:0]     cfg_vf_power_state;
+  input                       [1:0]     cfg_link_power_state;
+
+  // Error Reporting Interface
+  input                                 cfg_err_cor_out;
+  input                                 cfg_err_nonfatal_out;
+  input                                 cfg_err_fatal_out;
+  //input                                 cfg_local_error;
+
+  input                                 cfg_ltr_enable;
+  input                       [5:0]     cfg_ltssm_state;
+  input                       [3:0]     cfg_rcb_status;
+  input                       [3:0]     cfg_dpa_substate_change;
+  input                       [1:0]     cfg_obff_enable;
+  input                                 cfg_pl_status_change;
+  input                       [3:0]     cfg_tph_requester_enable;
+  input                      [11:0]     cfg_tph_st_mode;
+  input                       [251:0]     cfg_vf_tph_requester_enable;
+  input                      [755:0]     cfg_vf_tph_st_mode;
+
+  input                                 cfg_msg_received;
+  input                       [7:0]     cfg_msg_received_data;
+  input                       [4:0]     cfg_msg_received_type;
+
+  output reg                                cfg_msg_transmit;
+  output reg                      [2:0]     cfg_msg_transmit_type;
+  output reg                     [31:0]     cfg_msg_transmit_data;
+  input                                 cfg_msg_transmit_done;
+
+  input                       [7:0]     cfg_fc_ph;
+  input                      [11:0]     cfg_fc_pd;
+  input                       [7:0]     cfg_fc_nph;
+  input                      [11:0]     cfg_fc_npd;
+  input                       [7:0]     cfg_fc_cplh;
+  input                      [11:0]     cfg_fc_cpld;
+  output reg                      [2:0]     cfg_fc_sel;
+
+  output reg                      [2:0]     cfg_per_func_status_control;
+  input                      [15:0]     cfg_per_func_status_data;
+  output reg                      [2:0]     cfg_per_function_number;
+  output reg                                cfg_per_function_output_request;
+  input                                 cfg_per_function_update_done;
+
+  output reg                     [63:0]     cfg_dsn;
+  output reg                                cfg_power_state_change_ack;
+  input                                 cfg_power_state_change_interrupt;
+  output reg                                cfg_err_cor_in;
+  output reg                                cfg_err_uncor_in;
+
+  input                       [3:0]     cfg_flr_in_process;
+  output reg                      [1:0]     cfg_flr_done;
+  input                       [251:0]     cfg_vf_flr_in_process;
+  output reg                           cfg_vf_flr_done;
+
+  output reg                                cfg_link_training_enable;
+  output reg                      [7:0]     cfg_ds_port_number;
+
+  // Interrupt Interface Signals
+  output reg                      [3:0]     cfg_interrupt_int;
+  output reg                      [1:0]     cfg_interrupt_pending;
+  input                                 cfg_interrupt_sent;
+
+  input                       [1:0]     cfg_interrupt_msix_enable;
+  input                       [1:0]     cfg_interrupt_msix_mask;
+  input                       [5:0]     cfg_interrupt_msix_vf_enable;
+  input                       [5:0]     cfg_interrupt_msix_vf_mask;
+  output reg                     [31:0]     cfg_interrupt_msix_data;
+  output reg                     [63:0]     cfg_interrupt_msix_address;
+  output reg                                cfg_interrupt_msix_int;
+  input                                 cfg_interrupt_msix_sent;
+  input                                 cfg_interrupt_msix_fail;
+
+
+  input                                 cfg_hot_reset_out;
+  output reg                                cfg_config_space_enable;
+  output reg                                cfg_req_pm_transition_l23_ready;
+  //-------------------------------------------------------------------------------------------//
+  // RP Only                                                                                   //
+  //-------------------------------------------------------------------------------------------//
+  output reg                                cfg_hot_reset_in;
+
+  output reg                      [7:0]     cfg_ds_bus_number;
+  output reg                      [4:0]     cfg_ds_device_number;
+  output reg                      [2:0]     cfg_ds_function_number;
+//----------------------------------------------------------------------------------------------------------------//
+
+reg  [31:0]                cfg_rd_data;
+parameter                  Tcq = 1;
+
+//----------------------------------------------------------------------------------------------------------------//
+
+initial begin
+
+  cfg_mgmt_addr        <= 0;
+  cfg_mgmt_write_data  <= 0;
+  cfg_mgmt_byte_enable <= 0;
+  cfg_mgmt_write       <= 0;
+  cfg_mgmt_read        <= 0;
+
+
+  cfg_mgmt_type1_cfg_reg_access    <= 0 ;//       
+  cfg_msg_transmit                 <= 0 ;// 
+  cfg_msg_transmit_type            <= 0 ;//[2:0]
+  cfg_msg_transmit_data            <= 0 ;//[31:0]      
+  cfg_fc_sel                       <= 0 ;//[2:0]     
+
+  cfg_per_func_status_control      <= 0 ;//[2:0]             
+  cfg_per_function_output_request  <= 0 ;//      
+  cfg_per_function_number          <= 0; //[2:0]
+
+  cfg_dsn                          <= 64'h78EE32BAD28F906B ;//[63:0]       
+  cfg_power_state_change_ack       <= 0 ;//    
+  cfg_err_cor_in                   <= 0 ;
+  cfg_err_uncor_in                 <= 0 ;//     
+
+  cfg_flr_done                     <= 0 ;//[1:0]
+  cfg_vf_flr_done                  <= 0 ;//[5:0]    
+
+  cfg_link_training_enable         <= 1 ;//         
+
+  cfg_ds_port_number               <= 8'h9F ;//[7:0] 
+
+
+  // Interrupt Interface Signals
+  cfg_interrupt_int                <= 0 ;//[3:0]  
+  cfg_interrupt_pending            <= 0 ;//[1:0]      
+
+  cfg_interrupt_msix_data          <= 0 ;//[31:0]    
+  cfg_interrupt_msix_address       <= 0 ;//[63:0]    
+  cfg_interrupt_msix_int           <= 0 ;// 
+
+  cfg_config_space_enable          <= 1'b1 ;//    
+  cfg_req_pm_transition_l23_ready  <= 0 ;//         
+  // RP Only                                                   //                             
+  cfg_hot_reset_in                 <= 0 ;//        
+
+  cfg_ds_bus_number                <= board.RP.tx_usrapp.RP_BUS_DEV_FNS[15:8]; //[7:0]
+  cfg_ds_device_number             <= board.RP.tx_usrapp.RP_BUS_DEV_FNS[7:3];  //[4:0]
+  cfg_ds_function_number           <= board.RP.tx_usrapp.RP_BUS_DEV_FNS[2:0];  //[2:0]
+end
+/********************************************************************************************************************
+Task : TSK_READ_CFG_DW                
+Description : Read Configuration Space DW
+*********************************************************************************************************************/
+
+
+task TSK_READ_CFG_DW;
+
+input   [31:0]   addr_;
+begin           
+
+  if (user_reset) begin
+  
+    $display("[%t] : user_reset is asserted", $realtime);
+    $finish(1); 
+  
+  end
+
+ // wait ( cfg_mgmt_read_write_done == 1'b1)
+
+  @(posedge user_clk);
+  cfg_mgmt_addr  <= #(Tcq) addr_;
+  cfg_mgmt_write <= #(Tcq) 1'b0;
+  cfg_mgmt_read  <= #(Tcq) 1'b1;
+
+  $display("[%t] : Reading Cfg Addr [0x%h]", $realtime, addr_);
+  $fdisplay(board.RP.com_usrapp.tx_file_ptr,
+            "\n[%t] : Local Configuration Read Access :", 
+            $realtime);
+                 
+  @(posedge user_clk); 
+  #(Tcq);
+  wait ( cfg_mgmt_read_write_done == 1'b1)
+  #(Tcq);
+
+  $fdisplay(board.RP.com_usrapp.tx_file_ptr,
+            "\t\t\tCfg Addr [0x%h] -> Data [0x%h]\n", 
+            {addr_,2'b00}, cfg_mgmt_read_data);
+  cfg_mgmt_read <= #(Tcq) 1'b0;
+  board.RP.cfg_usrapp.cfg_rd_data = cfg_mgmt_read_data;
+         
+end
+
+endtask // TSK_READ_CFG_DW;
+
+/********************************************************************************************************************
+Task : TSK_WRITE_CFG_DW
+Description : Write Configuration Space DW
+*********************************************************************************************************************/
+
+task TSK_WRITE_CFG_DW;
+
+input   [31:0]   addr_;
+input   [31:0]   data_;
+input   [3:0]    ben_;
+
+begin
+
+  if (user_reset) begin
+
+    $display("[%t] : trn_reset_n is asserted", $realtime);
+    $finish(1);
+
+  end
+
+  //wait ( cfg_mgmt_read_write_done == 1'b1)
+
+  @(posedge user_clk);
+  cfg_mgmt_addr        <= #(Tcq) addr_;
+  cfg_mgmt_write_data  <= #(Tcq) data_;
+  cfg_mgmt_byte_enable <= #(Tcq) ben_;
+  cfg_mgmt_write       <= #(Tcq) 1'b1;
+  cfg_mgmt_read        <= #(Tcq) 1'b0;
+
+  $display("[%t] : Writing Cfg Addr [0x%h]", $realtime, addr_);
+  $fdisplay(board.RP.com_usrapp.tx_file_ptr,
+            "\n[%t] : Local Configuration Write Access :",
+            $realtime);
+
+  @(posedge user_clk);
+  #(Tcq);
+  wait ( cfg_mgmt_read_write_done == 1'b1)
+  #(Tcq);
+
+  cfg_mgmt_addr        <= #(Tcq) 0;
+  cfg_mgmt_write       <= #(Tcq) 1'b0;
+  cfg_mgmt_byte_enable <= #(Tcq) 0;
+  @(posedge user_clk);
+  @(posedge user_clk);
+
+end
+
+endtask // TSK_WRITE_CFG_DW;
+
+//----------------------------------------------------------------------------------------------------------------//
+
+endmodule // pci_exp_usrapp_cfg
+//----------------------------------------------------------------------------------------------------------------//
+
diff --git a/sim/tb/usrapp/usp_pci_exp_usrapp_com.v b/sim/tb/usrapp/usp_pci_exp_usrapp_com.v
new file mode 100644
index 0000000..5f67e98
--- /dev/null
+++ b/sim/tb/usrapp/usp_pci_exp_usrapp_com.v
@@ -0,0 +1,770 @@
+
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2025 Advanced Micro Devices, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : PCI Express DMA 
+// File       : usp_pci_exp_usrapp_com.v
+// Version    : 5.0
+//-----------------------------------------------------------------------------
+//--
+//--------------------------------------------------------------------------------
+`include "board_common.vh"
+
+module pci_exp_usrapp_com ();
+
+
+/* Local variables */
+
+reg   [31:0]           rx_file_ptr;
+reg   [7:0]            frame_store_rx[5119:0];
+integer                frame_store_rx_idx;
+reg   [31:0]           tx_file_ptr;
+reg   [7:0]            frame_store_tx[5119:0];
+integer                frame_store_tx_idx;
+
+reg   [31:0]           log_file_ptr;
+integer                _frame_store_idx;
+
+event                  rcvd_cpld, rcvd_memrd, rcvd_memwr;
+event                  rcvd_cpl, rcvd_memrd64, rcvd_memwr64;
+event                  rcvd_msg, rcvd_msgd, rcvd_cfgrd0;
+event                  rcvd_cfgwr0, rcvd_cfgrd1, rcvd_cfgwr1;
+event                  rcvd_iord, rcvd_iowr;
+
+initial begin
+
+  frame_store_rx_idx = 0;
+  frame_store_tx_idx = 0;
+
+  rx_file_ptr = $fopen("rx.dat");
+
+  if (!rx_file_ptr) begin
+
+    $write("ERROR: Could not open rx.dat.\n");
+    $finish;
+
+  end
+
+  tx_file_ptr = $fopen("tx.dat");
+
+  if (!tx_file_ptr) begin
+
+    $write("ERROR: Could not open tx.dat.\n");
+    $finish;
+  end
+end
+
+  /************************************************************
+  Task : TSK_PARSE_FRAME
+  Inputs : None
+  Outputs : None
+  Description : Parse frame data
+  *************************************************************/
+
+  task TSK_PARSE_FRAME;
+  input    log_file;
+
+  reg   [1:0]   fmt;
+  reg   [4:0]   f_type;
+  reg   [2:0]   traffic_class;
+  reg     td;
+  reg      ep;
+  reg  [1:0]   attr;
+  reg  [9:0]   length;
+  reg     payload;
+  reg  [15:0]   requester_id;
+  reg  [15:0]   completer_id;
+  reg  [7:0]   tag;
+  reg  [7:0]   byte_enables;
+  reg  [7:0]  message_code;
+  reg  [31:0]   address_low;
+  reg  [31:0]   address_high;
+  reg  [9:0]   register_address;
+  reg   [2:0]   completion_status;
+  reg  [31:0]  _log_file_ptr;
+  integer    _frame_store_idx;
+
+  begin
+
+  if (log_file == `RX_LOG)
+    _log_file_ptr = rx_file_ptr;
+  else
+    _log_file_ptr = tx_file_ptr;
+
+  if (log_file == `RX_LOG) begin
+
+    _frame_store_idx = frame_store_rx_idx;
+    frame_store_rx_idx = 0;
+
+  end else begin
+
+    _frame_store_idx = frame_store_tx_idx;
+    frame_store_tx_idx = 0;
+
+  end
+
+//  if (log_file == `RX_LOG) begin
+
+//    $display("[%t] : TSK_PARSE_FRAME on Receive", $realtime);
+
+//    end
+//  else begin
+
+//    $display("[%t] : TSK_PARSE_FRAME on Transmit", $realtime);
+
+//    end          
+
+  TSK_DECIPHER_FRAME (fmt, f_type, traffic_class, td, ep, attr, length, log_file);  
+
+  // decode the packets received based on fmt and f_type
+
+  casex({fmt, f_type})
+
+    `PCI_EXP_MEM_READ32 : begin
+
+      $fdisplay(_log_file_ptr, "[%t] : Memory Read-32 Frame \n", $time);
+      payload = 0;
+      TSK_3DW(fmt, f_type, traffic_class, td, ep, attr, length, payload, _frame_store_idx, _log_file_ptr, log_file);
+      
+      if (log_file == `RX_LOG)
+        -> rcvd_memrd;
+    end
+
+    `PCI_EXP_IO_READ : begin
+
+      $fdisplay(_log_file_ptr, "[%t] : IO Read Frame \n", $time);
+      payload = 0;
+      TSK_3DW(fmt, f_type, traffic_class, td, ep, attr, length, payload, _frame_store_idx, _log_file_ptr, log_file);
+
+      if (log_file == `RX_LOG)
+        -> rcvd_iord;
+    end
+
+    `PCI_EXP_CFG_READ0 : begin
+
+      $fdisplay(_log_file_ptr, "[%t] : Config Read Type 0 Frame \n", $time);
+      payload = 0;
+      TSK_3DW(fmt, f_type, traffic_class, td, ep, attr, length, payload, _frame_store_idx, _log_file_ptr, log_file);
+
+      if (log_file == `RX_LOG) 
+        -> rcvd_cfgrd0;
+    end
+
+    `PCI_EXP_COMPLETION_WO_DATA: begin
+
+      $fdisplay(_log_file_ptr, "[%t] : Completion Without Data Frame \n", $time);
+      payload = 0;
+      TSK_3DW(fmt, f_type, traffic_class, td, ep, attr, length, payload, _frame_store_idx, _log_file_ptr, log_file);
+
+      if (log_file == `RX_LOG) 
+        -> rcvd_cpl;
+    end
+
+    `PCI_EXP_MEM_READ64: begin
+
+      $fdisplay(_log_file_ptr, "[%t] : Memory Read-64 Frame \n", $time);
+      payload = 0;
+      TSK_4DW(fmt, f_type, traffic_class, td, ep, attr, length, payload,  _frame_store_idx, _log_file_ptr, log_file);
+
+      if (log_file == `RX_LOG) 
+        -> rcvd_memrd64;
+    end
+
+    `PCI_EXP_MSG_NODATA: begin
+
+      $fdisplay(_log_file_ptr, "[%t] : Message With No Data Frame \n", $time);
+      payload = 0;
+      TSK_4DW(fmt, f_type, traffic_class, td, ep, attr, length, payload,  _frame_store_idx, _log_file_ptr, log_file);
+
+      if (log_file == `RX_LOG) 
+        -> rcvd_msg;
+    end
+
+    `PCI_EXP_MEM_WRITE32: begin
+
+      $fdisplay(_log_file_ptr, "[%t] : Memory Write-32 Frame \n", $time);
+      payload = 1;
+      TSK_3DW(fmt, f_type, traffic_class, td, ep, attr, length, payload, _frame_store_idx, _log_file_ptr, log_file);
+      $fdisplay(_log_file_ptr, "\n");
+
+      if (log_file == `RX_LOG) 
+        -> rcvd_memwr;
+    end
+
+    `PCI_EXP_IO_WRITE: begin
+
+      $fdisplay(_log_file_ptr, "[%t] : IO Write Frame \n", $time);
+      payload = 1;
+      TSK_3DW(fmt, f_type, traffic_class, td, ep, attr, length, payload, _frame_store_idx, _log_file_ptr, log_file);
+      $fdisplay(_log_file_ptr, "\n");
+
+      if (log_file == `RX_LOG) 
+        -> rcvd_iowr;
+    end
+
+    `PCI_EXP_CFG_WRITE0: begin
+
+      $fdisplay(_log_file_ptr, "[%t] : Config Write Type 0 Frame \n", $time);
+      payload = 1;
+      TSK_3DW(fmt, f_type, traffic_class, td, ep, attr, length, payload, _frame_store_idx, _log_file_ptr, log_file);
+      $fdisplay(_log_file_ptr, "\n");
+
+      if (log_file == `RX_LOG) 
+        -> rcvd_cfgwr0;
+    end
+
+    `PCI_EXP_COMPLETION_DATA: begin
+
+      $fdisplay(_log_file_ptr, "[%t] : Completion With Data Frame \n", $time);
+      payload = 1;
+      TSK_3DW(fmt, f_type, traffic_class, td, ep, attr, length, payload, _frame_store_idx, _log_file_ptr, log_file);
+      $fdisplay(_log_file_ptr, "\n");
+
+      if (log_file == `RX_LOG) 
+        -> rcvd_cpld;
+    end
+
+    `PCI_EXP_MEM_WRITE64: begin
+
+      $fdisplay(_log_file_ptr, "[%t] : Memory Write-64 Frame \n", $time);
+      payload = 1;
+      TSK_4DW(fmt, f_type, traffic_class, td, ep, attr, length, payload,  _frame_store_idx, _log_file_ptr, log_file);
+      $fdisplay(_log_file_ptr, "\n");
+
+      if (log_file == `RX_LOG) 
+        -> rcvd_memwr64;
+    end
+
+    `PCI_EXP_MSG_DATA: begin
+
+      $fdisplay(_log_file_ptr, "[%t] : Message With Data Frame \n", $time);
+      payload = 1;
+      TSK_4DW(fmt, f_type, traffic_class, td, ep, attr, length, payload,  _frame_store_idx, _log_file_ptr, log_file);
+      $fdisplay(_log_file_ptr, "\n");
+
+      if (log_file == `RX_LOG) 
+        -> rcvd_msgd;
+    end
+
+    default: begin
+      $fdisplay(_log_file_ptr, "[%t] : Not a valid frame \n", $time);
+      $display(_log_file_ptr, "[%t] : Received an invalid frame \n", $time);
+      $finish(2);
+    end
+
+  endcase
+  end
+  endtask // TSK_PARSE_FRAME
+
+  /************************************************************
+  Task : TSK_DECIPHER_FRAME
+  Inputs : None
+  Outputs : fmt, f_type, traffic_class, td, ep, attr, length
+  Description : Deciphers frame
+  *************************************************************/
+
+  task TSK_DECIPHER_FRAME;
+  output [1:0]   fmt;
+  output [4:0]   f_type;
+  output [2:0]   traffic_class;
+  output     td;
+  output     ep;
+  output [1:0]   attr;
+  output [9:0]   length;
+  input    txrx;
+
+  begin
+
+    fmt = (txrx ? frame_store_tx[0] : frame_store_rx[0]) >> 5;
+    f_type = txrx ? frame_store_tx[0] : frame_store_rx[0];
+    traffic_class = (txrx ? frame_store_tx[1] : frame_store_rx[1]) >> 4;
+    td = (txrx ? frame_store_tx[2] : frame_store_rx[2]) >> 7;
+    ep = (txrx ? frame_store_tx[2] : frame_store_rx[2]) >> 6;
+    attr = (txrx ? frame_store_tx[2] : frame_store_rx[2]) >> 4;
+    length = (txrx ? frame_store_tx[2] : frame_store_rx[2]);
+    length = (length << 8) | (txrx ? frame_store_tx[3] : frame_store_rx[3]);
+
+  end
+
+  endtask // TSK_DECIPHER_FRAME
+
+
+  /************************************************************
+  Task : TSK_3DW
+  Inputs : fmt, f_type, traffic_class, td, ep, attr, length, 
+  payload, _frame_store_idx
+  Outputs : None
+  Description : Gets variables and prints frame 
+  *************************************************************/
+
+  task TSK_3DW;
+  input   [1:0]   fmt;
+  input   [4:0]   f_type;
+  input   [2:0]   traffic_class;
+  input     td;
+  input     ep;
+  input   [1:0]   attr;
+  input   [9:0]   length;
+  input      payload;
+  input  [31:0]  _frame_store_idx;
+  input  [31:0]  _log_file_ptr;
+  input     txrx;
+
+  reg [15:0] requester_id;
+  reg [7:0] tag;
+  reg [7:0] byte_enables;
+  reg [31:0] address_low;
+  reg [15:0] completer_id;
+  reg [9:0] register_address;
+  reg [2:0] completion_status;
+  reg [63:0] dword_data; // this will be used to recontruct bytes of data and sent to tx_app
+ 
+  integer    _i;
+
+  begin
+    $fdisplay(_log_file_ptr, "\t Traffic Class: 0x%h", traffic_class);
+    $fdisplay(_log_file_ptr, "\t TD: %h", td);
+    $fdisplay(_log_file_ptr, "\t EP: %h", ep);
+    $fdisplay(_log_file_ptr, "\t Attributes: 0x%h", attr);
+    $fdisplay(_log_file_ptr, "\t Length: 0x%h", length);
+
+    casex({fmt, f_type})
+
+    `PCI_EXP_CFG_READ0, 
+    `PCI_EXP_CFG_WRITE0: begin
+
+      requester_id = txrx ? {frame_store_tx[4], frame_store_tx[5]} : {frame_store_rx[4], frame_store_rx[5]};
+      tag = txrx ? frame_store_tx[6] : frame_store_rx[6];
+      byte_enables = txrx ? frame_store_tx[7] : frame_store_rx[7];
+      completer_id = {txrx ? frame_store_tx[8] : frame_store_rx[8], txrx ? frame_store_tx[9] : frame_store_rx[9]};
+      register_address = txrx ? frame_store_tx[10] : frame_store_rx[10];
+      register_address = (register_address << 8) | (txrx ? frame_store_tx[11] : frame_store_rx[11]);
+
+      $fdisplay(_log_file_ptr, "\t Requester Id: 0x%h", requester_id);
+      $fdisplay(_log_file_ptr, "\t Tag: 0x%h", tag);
+      $fdisplay(_log_file_ptr, "\t Last and First Byte Enables: 0x%h", byte_enables);
+      $fdisplay(_log_file_ptr, "\t Completer Id: 0x%h", completer_id);
+      $fdisplay(_log_file_ptr, "\t Register Address: 0x%h \n", register_address);
+
+      if (payload == 1) begin
+
+        for (_i = 12; _i < _frame_store_idx; _i = _i + 1) begin
+
+          $fdisplay(_log_file_ptr, "\t 0x%h", txrx ? frame_store_tx[_i] : frame_store_rx[_i]);
+
+        end
+      end
+    end
+
+    `PCI_EXP_COMPLETION_WO_DATA,
+    `PCI_EXP_COMPLETION_DATA: begin
+
+      completer_id = txrx ? {frame_store_tx[4], frame_store_tx[5]} : {frame_store_rx[4], frame_store_rx[5]};
+      completion_status = txrx ? (frame_store_tx[6] >> 5) : (frame_store_rx[6] >> 5);
+      requester_id = txrx ? {frame_store_tx[8], frame_store_tx[9]} : {frame_store_rx[8], frame_store_rx[9]};
+      tag = txrx ? frame_store_tx[10] : frame_store_rx[10];
+      $fdisplay(_log_file_ptr, "\t Completer Id: 0x%h", completer_id);
+      $fdisplay(_log_file_ptr, "\t Completion Status: 0x%h", completion_status);
+      $fdisplay(_log_file_ptr, "\t Requester Id: 0x%h ", requester_id);
+      $fdisplay(_log_file_ptr, "\t Tag: 0x%h \n", tag);
+
+      if (payload == 1) begin      
+                                
+         dword_data = 64'h0000_0000_0000_0000;
+				
+	 for (_i = 12; _i < _frame_store_idx; _i = _i + 1) begin
+				    				    
+		$fdisplay(_log_file_ptr, "\t 0x%h", txrx ? frame_store_tx[_i] : frame_store_rx[_i]);
+		if (!txrx) begin // if we are called from rx
+				       
+			dword_data = dword_data << 8; // build a dword to send to tx app
+			dword_data = dword_data | {56'h0000_0000_0000_00,frame_store_rx[_i]}; 
+		end  
+	end
+        `TX_TASKS.TSK_SET_READ_DATA(4'hf,dword_data); // send the data to the tx_app
+      end
+    
+    
+    end
+
+    // memory reads, io reads, memory writes and io writes
+    default: begin
+
+      requester_id = txrx ? {frame_store_tx[4], frame_store_tx[5]} : {frame_store_rx[4], frame_store_rx[5]};
+      tag = txrx ? frame_store_tx[6] : frame_store_rx[6];
+      byte_enables = txrx ? frame_store_tx[7] : frame_store_rx[7];
+      address_low = txrx ? frame_store_tx[8] : frame_store_rx[8];
+      address_low = (address_low << 8) | (txrx ? frame_store_tx[9] : frame_store_rx[9]);
+      address_low = (address_low << 8) | (txrx ? frame_store_tx[10] : frame_store_rx[10]);
+      address_low = (address_low << 8) | (txrx ? frame_store_tx[11] : frame_store_rx[11]);
+      $fdisplay(_log_file_ptr, "\t Requester Id: 0x%h", requester_id);
+      $fdisplay(_log_file_ptr, "\t Tag: 0x%h", tag);
+      $fdisplay(_log_file_ptr, "\t Last and First Byte Enables: 0x%h", byte_enables);
+      $fdisplay(_log_file_ptr, "\t Address Low: 0x%h \n", address_low);
+      if (payload == 1) begin
+
+        for (_i = 12; _i < _frame_store_idx; _i = _i + 1) begin
+  
+          $fdisplay(_log_file_ptr, "\t 0x%h", (txrx ? frame_store_tx[_i] : frame_store_rx[_i]));
+        end
+
+      end
+      
+    end
+  endcase 
+  end
+  endtask // TSK_3DW
+
+
+  /************************************************************
+  Task : TSK_4DW
+  Inputs : fmt, f_type, traffic_class, td, ep, attr, length
+  payload, _frame_store_idx
+  Outputs : None
+  Description : Gets variables and prints frame 
+  *************************************************************/
+  
+  task TSK_4DW;
+  input [1:0]   fmt;
+  input [4:0]   f_type;
+  input [2:0]   traffic_class;
+  input         td;
+  input     ep;
+  input [1:0]   attr;
+  input [9:0]   length;
+  input      payload;
+  input  [31:0]  _frame_store_idx;
+  input  [31:0]  _log_file_ptr;
+  input    txrx;
+  
+  reg [15:0]   requester_id;
+  reg [7:0]   tag;
+  reg [7:0]   byte_enables;
+  reg [7:0]   message_code;
+  reg [31:0]   address_high;
+  reg [31:0]   address_low;
+  reg [2:0]   msg_type;
+  
+  integer    _i;
+  
+  begin
+
+    $fdisplay(_log_file_ptr, "\t Traffic Class: 0x%h", traffic_class);
+    $fdisplay(_log_file_ptr, "\t TD: %h", td);
+    $fdisplay(_log_file_ptr, "\t EP: %h", ep);
+    $fdisplay(_log_file_ptr, "\t Attributes: 0x%h", attr);
+    $fdisplay(_log_file_ptr, "\t Length: 0x%h", length);
+  
+    requester_id = txrx ? {frame_store_tx[4], frame_store_tx[5]} : {frame_store_rx[4], frame_store_rx[5]};
+    tag = txrx ? frame_store_tx[6] : frame_store_rx[6];
+    byte_enables = txrx ? frame_store_tx[7] : frame_store_rx[7];
+    message_code = txrx ? frame_store_tx[7] : frame_store_rx[7];
+    address_high = txrx ? frame_store_tx[8] : frame_store_rx[8];
+    address_high = (address_high << 8) | (txrx ? frame_store_tx[9] : frame_store_rx[9]);
+    address_high = (address_high << 8) | (txrx ? frame_store_tx[10] : frame_store_rx[10]);
+    address_high = (address_high << 8) | (txrx ? frame_store_tx[11] : frame_store_rx[11]);
+    address_low = txrx ? frame_store_tx[12] : frame_store_rx[12];
+    address_low = (address_low << 8) | (txrx ? frame_store_tx[13] : frame_store_rx[13]);
+    address_low = (address_low << 8) | (txrx ? frame_store_tx[14] : frame_store_rx[14]);
+    address_low = (address_low << 8) | (txrx ? frame_store_tx[15] : frame_store_rx[15]);
+    
+    $fdisplay(_log_file_ptr, "\t Requester Id: 0x%h", requester_id);
+    $fdisplay(_log_file_ptr, "\t Tag: 0x%h", tag);
+    
+    casex({fmt, f_type})
+  
+      `PCI_EXP_MEM_READ64,
+      `PCI_EXP_MEM_WRITE64: begin
+  
+        $fdisplay(_log_file_ptr, "\t Last and First Byte Enables: 0x%h", byte_enables);
+        $fdisplay(_log_file_ptr, "\t Address High: 0x%h", address_high);
+        $fdisplay(_log_file_ptr, "\t Address Low: 0x%h \n", address_low);
+        if (payload == 1) begin
+  
+          for (_i = 16; _i < _frame_store_idx; _i = _i + 1) begin
+  
+            $fdisplay(_log_file_ptr, "\t 0x%h", txrx ? frame_store_tx[_i] : frame_store_rx[_i]);
+  
+          end
+        end
+      end
+    
+      `PCI_EXP_MSG_NODATA,
+      `PCI_EXP_MSG_DATA: begin
+  
+        msg_type = f_type;
+        $fdisplay(_log_file_ptr, "\t Message Type: 0x%h", msg_type);
+        $fdisplay(_log_file_ptr, "\t Message Code: 0x%h", message_code);
+        $fdisplay(_log_file_ptr, "\t Address High: 0x%h", address_high);
+        $fdisplay(_log_file_ptr, "\t Address Low: 0x%h \n", address_low);
+  
+        if (payload == 1) begin
+  
+          for (_i = 16; _i < _frame_store_idx; _i = _i + 1) begin
+  
+            $fdisplay(_log_file_ptr, "\t 0x%h", txrx ? frame_store_tx[_i] : frame_store_rx[_i]);
+          end
+        end
+      end
+    endcase
+    end
+  endtask // TSK_4DW
+
+  
+   /************************************************************
+        Task : TSK_READ_DATA
+        Inputs : None
+        Outputs : None
+        Description : Consume clocks.
+   *************************************************************/
+
+  task TSK_READ_DATA;
+    input    last;
+    input    txrx;
+    input  [63:0]  trn_d;
+    input    trn_rem;
+    integer   _i;
+    reg  [7:0]  _byte;
+    reg  [63:0]  _msk;
+    reg  [3:0]  _rem;
+                begin
+
+      _msk = 64'hff00000000000000;
+      _rem = (last ? ((trn_rem == 1) ? 4 : 8) : 8);
+
+      for (_i = 0; _i < _rem; _i = _i + 1) begin
+
+        _byte = (trn_d & (_msk >> (_i * 8))) >> (((7) - _i) * 8);
+
+        if (txrx) begin
+
+          board.RP.com_usrapp.frame_store_tx[board.RP.com_usrapp.frame_store_tx_idx] = _byte;
+          board.RP.com_usrapp.frame_store_tx_idx = board.RP.com_usrapp.frame_store_tx_idx + 1;
+
+        end else begin
+
+          board.RP.com_usrapp.frame_store_rx[board.RP.com_usrapp.frame_store_rx_idx] = _byte;
+          board.RP.com_usrapp.frame_store_rx_idx = board.RP.com_usrapp.frame_store_rx_idx + 1;
+        end
+
+      end 
+                end
+   endtask // TSK_READ_DATA
+
+   /************************************************************
+        Task : TSK_READ_DATA_128
+        Inputs : None
+        Outputs : None
+        Description : Consume clocks.
+   *************************************************************/
+
+  task TSK_READ_DATA_128;
+    input    first;
+    input    last;
+    input    txrx;
+    input  [127:0]  trn_d;
+    input  [1:0]  trn_rem;
+    integer   _i;
+    reg  [7:0]  _byte;
+    reg  [127:0]  _msk;
+    reg  [4:0]  _rem;
+    reg  [3:0]  _strt_pos;
+                begin
+
+      _msk =   128'hff000000000000000000000000000000;
+      _rem = (trn_rem[1] ? (trn_rem[0] ? 4 : 8) : (trn_rem[0] ? 12 : 16)) ;
+      _strt_pos = 4'd15;
+
+      for (_i = 0; _i < _rem; _i = _i + 1) begin
+
+        _byte = (trn_d & (_msk >> (_i * 8))) >> (((_strt_pos) - _i) * 8);
+
+        if (txrx) begin
+
+          board.RP.com_usrapp.frame_store_tx[board.RP.com_usrapp.frame_store_tx_idx] = _byte;
+          board.RP.com_usrapp.frame_store_tx_idx = board.RP.com_usrapp.frame_store_tx_idx + 1;
+
+        end else begin
+
+          board.RP.com_usrapp.frame_store_rx[board.RP.com_usrapp.frame_store_rx_idx] = _byte;
+          board.RP.com_usrapp.frame_store_rx_idx = board.RP.com_usrapp.frame_store_rx_idx + 1;
+        end
+
+      end 
+                end
+   endtask // TSK_READ_DATA_128
+
+   /************************************************************
+        Task : TSK_READ_DATA_256
+        Inputs : None
+        Outputs : None
+        Description : Consume clocks.
+   *************************************************************/
+
+  task TSK_READ_DATA_256;
+    input    first;
+    input    last;
+    input    txrx;
+    input  [255:0]  trn_d;
+    input  [2:0]  trn_rem;
+    integer   _i;
+    reg  [7:0]  _byte;
+    reg  [255:0]  _msk;
+    reg  [5:0]  _rem;
+    reg  [4:0]  _strt_pos;
+                begin
+
+//      _msk = ((first && trn_rem[2]) ? 
+//             (trn_rem[1] ? 256'h000000000000000000000000000000000000000000000000ff00000000000000 : 256'h00000000000000000000000000000000ff000000000000000000000000000000): 
+//             (trn_rem[1] ? 256'h0000000000000000ff0000000000000000000000000000000000000000000000 : 256'hff00000000000000000000000000000000000000000000000000000000000000)); 
+
+      _msk = 256'hff00000000000000000000000000000000000000000000000000000000000000;
+
+       casex (trn_rem)
+           3'b000 : _rem = 32;
+           3'b001 : _rem = 28;
+           3'b010 : _rem = 24;
+           3'b011 : _rem = 20;
+           3'b100 : _rem = 16;
+           3'b101 : _rem = 12;
+           3'b110 : _rem =  8;
+           3'b111 : _rem =  4;
+           default  : _rem = 32;
+        endcase
+
+      //_strt_pos = ((first && trn_rem[2]) ? (trn_rem[1] ? 4'd7 : 4'd15) : (trn_rem[1] ? 4'd23 : 4'd31));
+      _strt_pos = 5'd31; //((first && trn_rem[2]) ? (trn_rem[1] ? 5'd23 : 5'd31) : (trn_rem[1] ? 5'd7 : 5'd15));
+
+      for (_i = 0; _i < _rem; _i = _i + 1) begin
+
+        _byte = (trn_d & (_msk >> (_i * 8))) >> (((_strt_pos) - _i) * 8);
+
+        if (txrx) begin
+
+          board.RP.com_usrapp.frame_store_tx[board.RP.com_usrapp.frame_store_tx_idx] = _byte;
+          board.RP.com_usrapp.frame_store_tx_idx = board.RP.com_usrapp.frame_store_tx_idx + 1;
+
+        end else begin
+
+          board.RP.com_usrapp.frame_store_rx[board.RP.com_usrapp.frame_store_rx_idx] = _byte;
+          board.RP.com_usrapp.frame_store_rx_idx = board.RP.com_usrapp.frame_store_rx_idx + 1;
+        end
+
+      end 
+                end
+   endtask // TSK_READ_DATA_256
+
+   /************************************************************
+        Task : TSK_READ_DATA_512
+        Inputs : None
+        Outputs : None
+        Description : Consume clocks.
+   *************************************************************/
+
+  task TSK_READ_DATA_512;
+    input    first;
+    input    last;
+    input    txrx;
+    input  [511:0]  trn_d;
+    input  [3:0]  trn_rem;
+    integer   _i;
+    reg  [7:0]  _byte;
+    reg  [511:0]  _msk;
+    reg  [6:0]  _rem;
+    reg  [5:0]  _strt_pos;
+                begin
+
+      _msk = 512'hff000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
+
+       casex (trn_rem)
+           4'b0000 : _rem = 64;
+           4'b0001 : _rem = 60;
+           4'b0010 : _rem = 56;
+           4'b0011 : _rem = 52;
+           4'b0100 : _rem = 48;
+           4'b0101 : _rem = 44;
+           4'b0110 : _rem = 40;
+           4'b0111 : _rem = 36;
+           4'b0000 : _rem = 32;
+           4'b0001 : _rem = 28;
+           4'b0010 : _rem = 24;
+           4'b0011 : _rem = 20;
+           4'b0100 : _rem = 16;
+           4'b0101 : _rem = 12;
+           4'b0110 : _rem =  8;
+           4'b0111 : _rem =  4;
+           default  : _rem = 64;
+        endcase
+
+      _strt_pos = 6'd63;
+
+      for (_i = 0; _i < _rem; _i = _i + 1) begin
+
+        _byte = (trn_d & (_msk >> (_i * 8))) >> (((_strt_pos) - _i) * 8);
+
+        if (txrx) begin
+
+          board.RP.com_usrapp.frame_store_tx[board.RP.com_usrapp.frame_store_tx_idx] = _byte;
+          board.RP.com_usrapp.frame_store_tx_idx = board.RP.com_usrapp.frame_store_tx_idx + 1;
+
+        end else begin
+
+          board.RP.com_usrapp.frame_store_rx[board.RP.com_usrapp.frame_store_rx_idx] = _byte;
+          board.RP.com_usrapp.frame_store_rx_idx = board.RP.com_usrapp.frame_store_rx_idx + 1;
+        end
+
+      end 
+                end
+   endtask // TSK_READ_DATA_512
+   
+   
+`include "pci_exp_expect_tasks.vh"
+
+endmodule // pci_exp_usrapp_com
diff --git a/sim/tb/usrapp/usp_pci_exp_usrapp_rx.v b/sim/tb/usrapp/usp_pci_exp_usrapp_rx.v
new file mode 100644
index 0000000..78b5a3c
--- /dev/null
+++ b/sim/tb/usrapp/usp_pci_exp_usrapp_rx.v
@@ -0,0 +1,889 @@
+
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2025 Advanced Micro Devices, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : PCI Express DMA 
+// File       : usp_pci_exp_usrapp_rx.v
+// Version    : 5.0
+//-----------------------------------------------------------------------------
+//--
+//--------------------------------------------------------------------------------
+
+`include "board_common.vh"
+
+`define EXPECT_FINISH_CHECK board.RP.tx_usrapp.expect_finish_check
+module pci_exp_usrapp_rx #(
+    parameter   C_DATA_WIDTH                   = 64,
+    parameter   AXISTEN_IF_RQ_ALIGNMENT_MODE   = "FALSE",
+    parameter   AXISTEN_IF_CC_ALIGNMENT_MODE   = "FALSE",
+    parameter   AXISTEN_IF_CQ_ALIGNMENT_MODE   = "FALSE",
+    parameter   AXISTEN_IF_RC_ALIGNMENT_MODE   = "FALSE",
+    parameter   STRB_WIDTH                     = C_DATA_WIDTH / 8,    // TSTRB width
+    parameter   KEEP_WIDTH                     = C_DATA_WIDTH / 32,
+    parameter   AXISTEN_IF_CQ_PARITY_CHECK     = 0,
+    parameter   AXISTEN_IF_RC_PARITY_CHECK     = 0,
+	
+    parameter   PARITY_WIDTH                   = C_DATA_WIDTH / 8    // TPARITY width
+)
+(
+    m_axis_cq_tdata,
+    m_axis_cq_tlast,
+    m_axis_cq_tvalid,
+    m_axis_cq_tuser,
+    m_axis_cq_tkeep,
+    m_axis_rc_tdata,
+    m_axis_rc_tlast,
+    m_axis_rc_tvalid,
+    m_axis_rc_tuser,
+    m_axis_rc_tkeep,
+    pcie_cq_np_req_count,
+    m_axis_cq_tready,
+    m_axis_rc_tready,
+    pcie_cq_np_req,
+	cfg_max_read_req,
+    cfg_max_payload,
+    cfg_rcb_status,
+    user_clk,
+    user_reset,
+    user_lnk_up
+);
+
+
+input                            user_clk;
+input                            user_reset;
+input                            user_lnk_up;
+
+input      [C_DATA_WIDTH-1:0]    m_axis_cq_tdata;
+input                            m_axis_cq_tlast;
+input                            m_axis_cq_tvalid;
+input                 [182:0]    m_axis_cq_tuser;
+input        [KEEP_WIDTH-1:0]    m_axis_cq_tkeep;
+input                   [5:0]    pcie_cq_np_req_count;
+input      [C_DATA_WIDTH-1:0]    m_axis_rc_tdata;
+input                            m_axis_rc_tlast;
+input                            m_axis_rc_tvalid;
+input                 [160:0]    m_axis_rc_tuser;
+input        [KEEP_WIDTH-1:0]    m_axis_rc_tkeep;
+input                   [2:0]    cfg_max_read_req;
+input                   [1:0]    cfg_max_payload;
+input                   [3:0]    cfg_rcb_status;
+output reg                       m_axis_cq_tready;
+output reg                       m_axis_rc_tready;
+output reg                       pcie_cq_np_req;
+
+parameter                        Tcq = 1;
+
+
+/* Local variables */
+
+reg  [11:0]              byte_count_fbe;
+reg  [11:0]              byte_count_lbe;
+reg  [11:0]              byte_count;
+reg  [15:0]              lower_addr;
+
+reg               req_compl;
+reg               req_compl_wd;
+reg               req_compl_zero_len;
+reg               req_compl_ur;
+reg               req_compl_q;
+reg               req_compl_qq;
+reg               req_compl_wd_q;
+reg               req_compl_wd_qq;
+reg               req_compl_ur_q;
+reg               req_compl_ur_qq;
+
+reg   [4:0]       cq_rx_state, next_cq_rx_state;
+reg   [4:0]       rc_rx_state, next_rc_rx_state;
+reg               cq_rx_in_frame, next_cq_rx_in_frame;
+reg   [63:0]      cq_data;
+reg   [63:0]      rc_data;
+reg   [7:0]       cq_be;
+reg   [7:0]       rc_be;
+reg   [31:0]      next_cq_rx_timeout;
+reg               cq_beat0_valid;
+reg               rc_beat0_valid;
+reg   [7:0]       ii;                   // Loop through tkeep
+reg   [6:0]       jj;                   // Loop through CQ_tuser's Byte Enable
+wire              user_reset_n;
+reg   [7:0]       tkeep;
+reg   [7:0]       tkeep_q;
+reg   [7:0]       tkeep_qq;
+
+
+localparam        CQ_TUSER_BYTE_EN_OFFSET = 16;
+
+assign user_reset_n  = ~user_reset;
+
+always @  (m_axis_rc_tdata[4:2]) begin
+  casex (m_axis_rc_tdata[4:2])
+
+    3'b000 : tkeep = (AXISTEN_IF_CC_ALIGNMENT_MODE == "TRUE" ) ? 16'h1  : 16'h1; 
+    3'b001 : tkeep = (AXISTEN_IF_CC_ALIGNMENT_MODE == "TRUE" ) ? 16'h3  : 16'h1; 
+    3'b010 : tkeep = (AXISTEN_IF_CC_ALIGNMENT_MODE == "TRUE" ) ? 16'h7  : 16'h1; 
+    3'b011 : tkeep = (AXISTEN_IF_CC_ALIGNMENT_MODE == "TRUE" ) ? 16'hf  : 16'h1; 
+    3'b100 : tkeep = (AXISTEN_IF_CC_ALIGNMENT_MODE == "TRUE" ) ? 16'h1f : 16'h1; 
+    3'b101 : tkeep = (AXISTEN_IF_CC_ALIGNMENT_MODE == "TRUE" ) ? 16'h3f : 16'h1; 
+    3'b110 : tkeep = (AXISTEN_IF_CC_ALIGNMENT_MODE == "TRUE" ) ? 16'h7f : 16'h1; 
+    3'b111 : tkeep = (AXISTEN_IF_CC_ALIGNMENT_MODE == "TRUE" ) ? 16'hff : 16'h1; 
+  endcase
+end
+
+always @(posedge user_clk or negedge user_reset_n) begin
+  if (user_reset_n == 1'b0) begin
+     tkeep_q  <= 8'h0;
+     tkeep_qq <= 8'h0;
+  end else begin 
+     tkeep_q  <= tkeep;
+     tkeep_qq <= tkeep_q;
+  end
+end
+
+/* State variables */
+
+`define           CQ_RX_RESET    5'b00001
+`define           CQ_RX_DOWN     5'b00010
+`define           CQ_RX_IDLE     5'b00100
+`define           CQ_RX_ACTIVE   5'b01000
+`define           CQ_RX_SRC_DSC  5'b10000
+
+`define           RC_RX_RESET    5'b00001
+`define           RC_RX_DOWN     5'b00010
+`define           RC_RX_IDLE     5'b00100
+`define           RC_RX_ACTIVE   5'b01000
+`define           RC_RX_SRC_DSC  5'b10000
+
+/* Transaction Receive User Interface State Machine */
+
+always @(posedge user_clk or negedge user_reset_n) begin
+
+  if (user_reset_n == 1'b0) begin
+    cq_rx_state     <= #(Tcq)  `CQ_RX_RESET;
+  end
+  else begin
+
+  case (cq_rx_state)
+
+    `CQ_RX_RESET :  begin
+        
+        m_axis_cq_tready <= #(Tcq) 1'b0;
+        cq_rx_state      <= #(Tcq) `CQ_RX_DOWN;
+        
+    end
+
+    `CQ_RX_DOWN : begin
+
+      if (user_lnk_up == 1'b0) begin
+        m_axis_cq_tready <= #(Tcq) 1'b0;
+        cq_rx_state      <= #(Tcq) `CQ_RX_DOWN;
+      end else begin
+        m_axis_cq_tready <= #(Tcq) 1'b1;
+        cq_rx_state      <= #(Tcq) `CQ_RX_IDLE;
+      end
+
+    end
+
+    `CQ_RX_IDLE : begin
+
+      if (user_lnk_up == 1'b0) begin
+        m_axis_cq_tready <= #(Tcq) 1'b0;
+        cq_rx_state      <= #(Tcq) `CQ_RX_DOWN;
+      end else begin
+
+        m_axis_cq_tready     <= #(Tcq) 1'b1;
+		
+        // Start of Packet && Valid && Ready
+	   if ( (((m_axis_cq_tuser[40] == 1'b1) && ((C_DATA_WIDTH==64)|| (C_DATA_WIDTH==128) || (C_DATA_WIDTH==256))) || ((m_axis_cq_tuser[80] == 1'b1) && (C_DATA_WIDTH==512)))&&
+              (m_axis_cq_tvalid    == 1'b1) &&
+              (m_axis_cq_tready    == 1'b1)  ) begin
+
+          if(C_DATA_WIDTH==64) begin
+
+             cq_data        <= #(Tcq) m_axis_cq_tdata;
+             cq_be          <= #(Tcq) m_axis_cq_tuser[7:0];
+             cq_beat0_valid <= #(Tcq) 1'b1;
+             
+             m_axis_cq_tready <= #(Tcq) 1'b1;
+             cq_rx_state      <= #(Tcq) `CQ_RX_ACTIVE;
+
+          end
+          else if(C_DATA_WIDTH==128) begin
+          
+             TSK_BUILD_CQ_TO_PCIE_PKT(m_axis_cq_tdata[63:0], m_axis_cq_tuser[7:0], m_axis_cq_tdata[127:64]);
+          
+             if(m_axis_cq_tlast == 1'b1) begin
+
+                board.RP.com_usrapp.TSK_PARSE_FRAME(`RX_LOG);
+
+                if (m_axis_cq_tdata[78:75] == 4'b0000) begin // Memory Read Request
+                   m_axis_cq_tready <= #(Tcq) 1'b0;
+                   TSK_BUILD_CPLD_PKT(m_axis_cq_tdata[63:0], m_axis_cq_tuser[7:0], m_axis_cq_tdata[127:64]);
+                end
+                
+                m_axis_cq_tready <= #(Tcq) 1'b1;
+                cq_rx_state      <= #(Tcq) `CQ_RX_IDLE;
+
+             end else begin
+             
+                m_axis_cq_tready <= #(Tcq) 1'b1;
+                cq_rx_state      <= #(Tcq) `CQ_RX_ACTIVE;
+                
+             end
+          end
+          else if(C_DATA_WIDTH==256)begin
+          
+             TSK_BUILD_CQ_TO_PCIE_PKT(m_axis_cq_tdata[63:0], m_axis_cq_tuser[7:0], m_axis_cq_tdata[127:64]);
+             
+             // Payload starts at DW 4
+             for(ii=4; ii<KEEP_WIDTH ; ii = ii +2)begin 
+                if(m_axis_cq_tkeep[ii] == 1'b1 || m_axis_cq_tkeep[ii+1] == 1'b1 )
+                   // PCIe requires that payload byte enable be all valid except the first DW or last DW only
+                   board.RP.com_usrapp.TSK_READ_DATA(m_axis_cq_tlast, `RX_LOG, {m_axis_cq_tdata[(ii+1)*32-1 -:32], m_axis_cq_tdata[(ii+2)*32-1 -:32]}, ~m_axis_cq_tkeep[ii+1]);
+             end
+          
+             if(m_axis_cq_tlast == 1'b1) begin
+
+                board.RP.com_usrapp.TSK_PARSE_FRAME(`RX_LOG);
+
+                if (m_axis_cq_tdata[78:75] == 4'b0000) begin // Memory Read Request
+                   m_axis_cq_tready <= #(Tcq) 1'b0;
+                   TSK_BUILD_CPLD_PKT(m_axis_cq_tdata[63:0], m_axis_cq_tuser[7:0], m_axis_cq_tdata[127:64]);
+                end
+                
+                m_axis_cq_tready <= #(Tcq) 1'b1;
+                cq_rx_state      <= #(Tcq) `CQ_RX_IDLE;
+
+             end else begin
+             
+                m_axis_cq_tready <= #(Tcq) 1'b1;
+                cq_rx_state      <= #(Tcq) `CQ_RX_ACTIVE;
+             
+             end
+	  end
+	  else if(C_DATA_WIDTH==512)begin
+		  
+	     TSK_BUILD_CQ_TO_PCIE_PKT(m_axis_cq_tdata[63:0], m_axis_cq_tuser[7:0], m_axis_cq_tdata[127:64]);
+             
+             // Payload starts at DW 4
+             for (ii=4; ii<KEEP_WIDTH ; ii = ii +2) begin 
+                if(m_axis_cq_tkeep[ii] == 1'b1 || m_axis_cq_tkeep[ii+1] == 1'b1 )
+                   // PCIe requires that payload byte enable be all valid except the first DW or last DW only
+                   board.RP.com_usrapp.TSK_READ_DATA(m_axis_cq_tlast, `RX_LOG, {m_axis_cq_tdata[(ii+1)*32-1 -:32], m_axis_cq_tdata[(ii+2)*32-1 -:32]}, ~m_axis_cq_tkeep[ii+1]);
+             end
+          
+             if(m_axis_cq_tlast == 1'b1) begin
+
+                board.RP.com_usrapp.TSK_PARSE_FRAME(`RX_LOG);
+
+                if (m_axis_cq_tdata[78:75] == 4'b0000) begin // Memory Read Request
+                   $display ("[%t] : Memory Read Received! ", $realtime);
+                   m_axis_cq_tready <= #(Tcq) 1'b0;
+                   TSK_BUILD_CPLD_PKT(m_axis_cq_tdata[63:0], {m_axis_cq_tuser[11:8],m_axis_cq_tuser[3:0]}, m_axis_cq_tdata[127:64]);
+                end
+                
+                m_axis_cq_tready <= #(Tcq) 1'b1;
+                cq_rx_state      <= #(Tcq) `CQ_RX_IDLE;
+
+             end else begin
+             
+                m_axis_cq_tready <= #(Tcq) 1'b1;
+                cq_rx_state      <= #(Tcq) `CQ_RX_ACTIVE;
+             
+             end
+             
+          end // (DATA_WIDTH)
+        end // (sop & valid & ready)
+      end // (linkup)
+
+    end
+
+    `CQ_RX_ACTIVE : begin
+
+      if (user_lnk_up == 1'b0)
+        cq_rx_state <= #(Tcq) `CQ_RX_DOWN;
+      else begin
+      
+        if (  (m_axis_cq_tvalid == 1'b1) &&
+              (m_axis_cq_tready == 1'b1)  ) begin
+
+           if(C_DATA_WIDTH==64)begin
+           
+             if (cq_beat0_valid == 1'b1) begin // Second DW header
+             
+               TSK_BUILD_CQ_TO_PCIE_PKT( cq_data, cq_be, m_axis_cq_tdata);
+               cq_beat0_valid <= #(Tcq) 1'b0;
+               
+             end
+             else begin // Payload data
+             
+               board.RP.com_usrapp.TSK_READ_DATA(m_axis_cq_tlast, `RX_LOG, {m_axis_cq_tdata[31:0], m_axis_cq_tdata[63:32]}, ~m_axis_cq_tkeep[1]);
+               
+             end
+
+             if (m_axis_cq_tlast == 1'b1) begin
+             
+               board.RP.com_usrapp.TSK_PARSE_FRAME(`RX_LOG);
+
+               if (m_axis_cq_tdata[14:11] == 4'b0000) begin // Memory Read Request
+                  m_axis_cq_tready <= #(Tcq) 1'b0;
+                  TSK_BUILD_CPLD_PKT(cq_data, cq_be, m_axis_cq_tdata);
+               end
+               
+               m_axis_cq_tready <= #(Tcq) 1'b1;
+               cq_rx_state      <= #(Tcq) `CQ_RX_IDLE;
+               
+             end
+             
+           end
+           else if(C_DATA_WIDTH==128)begin
+           
+             for(ii=0; ii<KEEP_WIDTH ; ii = ii +2)begin 
+             
+               if(m_axis_cq_tkeep[ii] == 1'b1 || m_axis_cq_tkeep[ii+1] == 1'b1 )
+                   // PCIe requires that payload byte enable be all valid except the first DW or last DW only
+                   board.RP.com_usrapp.TSK_READ_DATA(m_axis_cq_tlast, `RX_LOG, {m_axis_cq_tdata[(ii+1)*32-1 -:32], m_axis_cq_tdata[(ii+2)*32-1 -:32]}, ~m_axis_cq_tkeep[ii+1]);
+                   
+             end
+             
+             if (m_axis_cq_tlast  == 1'b1) begin
+             
+               board.RP.com_usrapp.TSK_PARSE_FRAME(`RX_LOG);
+               cq_rx_state <= #(Tcq) `CQ_RX_IDLE;
+               
+             end
+
+           end
+           else if(C_DATA_WIDTH==256)begin
+           
+             for(ii=0; ii<KEEP_WIDTH ; ii = ii +2)begin 
+             
+               if(m_axis_cq_tkeep[ii] == 1'b1 ||m_axis_cq_tkeep[ii+1] == 1'b1 )
+                   board.RP.com_usrapp.TSK_READ_DATA(m_axis_cq_tlast, `RX_LOG, {m_axis_cq_tdata[(ii+1)*32-1 -:32], m_axis_cq_tdata[(ii+2)*32-1 -:32]}, ~m_axis_cq_tkeep[ii+1]);
+                   
+             end           
+             
+             if (m_axis_cq_tlast  == 1'b1) begin
+             
+               board.RP.com_usrapp.TSK_PARSE_FRAME(`RX_LOG);
+               cq_rx_state <= #(Tcq) `CQ_RX_IDLE;
+               
+             end
+		   end
+		   else if(C_DATA_WIDTH==512)begin
+			 
+			 for (ii=0; ii<KEEP_WIDTH ; ii = ii +2) begin 
+             
+               if(m_axis_cq_tkeep[ii] == 1'b1 ||m_axis_cq_tkeep[ii+1] == 1'b1 )
+                   board.RP.com_usrapp.TSK_READ_DATA(m_axis_cq_tlast, `RX_LOG, {m_axis_cq_tdata[(ii+1)*32-1 -:32], m_axis_cq_tdata[(ii+2)*32-1 -:32]}, ~m_axis_cq_tkeep[ii+1]);
+                   
+             end
+             
+             if (m_axis_cq_tlast  == 1'b1) begin
+             
+               board.RP.com_usrapp.TSK_PARSE_FRAME(`RX_LOG);
+               cq_rx_state <= #(Tcq) `CQ_RX_IDLE;
+               
+             end
+             
+           end // (DATA_WIDTH)
+        end // (valid & ready)
+      end // (linkup)
+    end
+
+  endcase
+
+  end // !(reset)
+
+end
+
+always @(posedge user_clk or negedge user_reset_n) begin
+
+  if (user_reset_n == 1'b0) begin
+    rc_rx_state     <= #(Tcq)  `RC_RX_RESET;
+  end 
+  else begin
+
+  case (rc_rx_state)
+
+    `RC_RX_RESET :  begin
+    
+        rc_rx_state <= #(Tcq) `RC_RX_DOWN;
+        
+    end
+
+    `RC_RX_DOWN : begin
+
+      if (user_lnk_up == 1'b0)
+        rc_rx_state <= #(Tcq) `RC_RX_DOWN;
+      else
+        rc_rx_state <= #(Tcq) `RC_RX_IDLE;
+
+    end
+
+    `RC_RX_IDLE : begin
+
+      if (user_lnk_up == 1'b0)
+        rc_rx_state <= #(Tcq) `RC_RX_DOWN;
+      else begin
+
+        // (start of frame & valid & ready)
+        //if (  (m_axis_rc_tuser[32] == 1'b1) &&
+        //      (m_axis_rc_tvalid    == 1'b1) &&
+        //      (m_axis_rc_tready    == 1'b1)  ) begin
+        if (  (m_axis_rc_tvalid    == 1'b1) &&
+              (m_axis_rc_tready    == 1'b1)  ) begin
+
+          if(C_DATA_WIDTH==64)begin
+          
+             rc_data        <= #(Tcq) m_axis_rc_tdata;
+             rc_be          <= #(Tcq) m_axis_rc_tuser[7:0];
+             rc_beat0_valid <= #(Tcq) 1'b1;
+             rc_rx_state    <= #(Tcq) `RC_RX_ACTIVE;
+             
+          end
+          else if(C_DATA_WIDTH==128)begin
+          
+             if(AXISTEN_IF_RC_ALIGNMENT_MODE  == "TRUE" ) begin // Address Aligned Mode
+                TSK_BUILD_RC_TO_PCIE_PKT(m_axis_rc_tdata[63:0], m_axis_rc_tdata[127:64], 4'b0111, m_axis_rc_tlast);
+             end else begin // DWORD Aligned Mode
+                TSK_BUILD_RC_TO_PCIE_PKT(m_axis_rc_tdata[63:0], m_axis_rc_tdata[127:64], m_axis_rc_tkeep[3:0], m_axis_rc_tlast);
+             end
+             
+             if(m_axis_rc_tlast == 1'b1) begin
+                board.RP.com_usrapp.TSK_PARSE_FRAME(`RX_LOG);
+                rc_rx_state <= #(Tcq) `RC_RX_IDLE;
+             end else
+                rc_rx_state <= #(Tcq) `RC_RX_ACTIVE;
+             end
+
+          else if(C_DATA_WIDTH==256 || C_DATA_WIDTH==512)begin
+          
+             if(AXISTEN_IF_RC_ALIGNMENT_MODE  == "TRUE" ) begin // Address Aligned Mode
+                TSK_BUILD_RC_TO_PCIE_PKT(m_axis_rc_tdata[63:0], m_axis_rc_tdata[127:64], 8'h07, m_axis_rc_tlast);
+             
+             end else begin // DWORD Aligned Mode
+                TSK_BUILD_RC_TO_PCIE_PKT(m_axis_rc_tdata[63:0], m_axis_rc_tdata[127:64], m_axis_rc_tkeep[7:0], m_axis_rc_tlast);
+                
+                for(ii=4; ii<KEEP_WIDTH ; ii = ii +2) begin // Start at 4th DW because Payload at 3th position has been added by TSK_BUILD_RC_TO_PCIE_PKT call
+                   if(m_axis_rc_tkeep[ii] == 1'b1 || m_axis_rc_tkeep[ii+1] == 1'b1 )
+                      board.RP.com_usrapp.TSK_READ_DATA(m_axis_rc_tlast, `RX_LOG, {m_axis_rc_tdata[(ii+1)*32-1 -:32], m_axis_rc_tdata[(ii+2)*32-1 -:32]}, ~(m_axis_rc_tkeep[ii+1]) );
+                end
+             end
+
+             if(m_axis_rc_tlast == 1'b1) begin   
+                board.RP.com_usrapp.TSK_PARSE_FRAME(`RX_LOG);
+                rc_rx_state <= #(Tcq) `RC_RX_IDLE;
+             end else
+                rc_rx_state <= #(Tcq) `RC_RX_ACTIVE;
+                
+          end // if (C_DATA_WIDTH...)
+
+        end // (sop & valid & ready)
+
+      end // (linkup)
+
+    end
+
+    `RC_RX_ACTIVE : begin
+
+      if (user_lnk_up == 1'b0)
+        rc_rx_state <= #(Tcq) `RC_RX_DOWN;
+
+      else begin
+
+        if (  (m_axis_rc_tvalid == 1'b1) &&
+              (m_axis_rc_tready == 1'b1)  ) begin
+      
+          if(C_DATA_WIDTH==64)begin
+      
+             if(rc_beat0_valid == 1'b1) begin // Second DW header
+         
+                TSK_BUILD_RC_TO_PCIE_PKT(rc_data, m_axis_rc_tdata, m_axis_rc_tkeep[1:0], m_axis_rc_tlast);
+                rc_beat0_valid <= #(Tcq) 1'b0;
+            
+             end
+             else begin // Payload data
+         
+                board.RP.com_usrapp.TSK_READ_DATA(m_axis_rc_tlast, `RX_LOG, {m_axis_rc_tdata[31:0], m_axis_rc_tdata[64:32]}, ~m_axis_rc_tkeep[1]);
+                
+             end
+         
+             if (m_axis_rc_tlast == 1'b1) begin
+         
+                board.RP.com_usrapp.TSK_PARSE_FRAME(`RX_LOG);
+                rc_rx_state <= #(Tcq) `RC_RX_IDLE;
+                
+             end
+                
+          end
+          else if(C_DATA_WIDTH==128)begin
+      
+             for(ii=0; ii<KEEP_WIDTH ; ii = ii +2) begin
+         
+               if(m_axis_rc_tkeep[ii] == 1'b1 ||m_axis_rc_tkeep[ii+1] == 1'b1 )
+                   // PCIe requires that payload byte enable be all valid except the first DW or last DW only
+                   board.RP.com_usrapp.TSK_READ_DATA(m_axis_rc_tlast, `RX_LOG,{m_axis_rc_tdata[(ii+1)*32-1 -:32], m_axis_rc_tdata[(ii+2)*32-1 -:32]}, ~m_axis_rc_tkeep[ii+1] );
+
+             end
+
+             if (m_axis_rc_tlast == 1'b1) begin
+         
+               board.RP.com_usrapp.TSK_PARSE_FRAME(`RX_LOG);
+               rc_rx_state <= #(Tcq) `RC_RX_IDLE;
+            
+             end
+
+          end
+          else if(C_DATA_WIDTH==256 || C_DATA_WIDTH==512)begin
+      
+             for(ii=0; ii<KEEP_WIDTH ; ii = ii +2) begin
+         
+             if(m_axis_rc_tkeep[ii] == 1'b1 || m_axis_rc_tkeep[ii+1] == 1'b1 )
+               board.RP.com_usrapp.TSK_READ_DATA(m_axis_rc_tlast, `RX_LOG, {m_axis_rc_tdata[(ii+1)*32-1 -:32], m_axis_rc_tdata[(ii+2)*32-1 -:32]}, ~(m_axis_rc_tkeep[ii+1]) );
+
+             end
+         
+             if (m_axis_rc_tlast == 1'b1) begin
+         
+                board.RP.com_usrapp.TSK_PARSE_FRAME(`RX_LOG);
+                rc_rx_state <= #(Tcq) `RC_RX_IDLE;
+            
+             end
+         
+          end // (DATA_WIDTH)
+        end // (valid & ready)
+      end // (linkup)
+    end
+
+  endcase
+
+  end // !(reset)
+
+end
+
+
+/* Transaction Receive Timeout */
+
+reg [31:0] sim_timeout;
+initial
+begin
+   sim_timeout = `CQ_RX_TIMEOUT;
+   m_axis_rc_tready=1'b1;
+   pcie_cq_np_req=1'b1;
+end
+            
+//----------------------------------------------------------------------------------------------------//
+task TSK_BUILD_RC_TO_PCIE_PKT;
+  input [63:0] rc_data_QW0;
+  input [63:0] rc_data_QW1;
+  input [KEEP_WIDTH-1:0] m_axis_rc_tkeep;
+  input m_axis_rc_tlast;
+  reg [127:0] pcie_pkt;
+  
+  if((C_DATA_WIDTH == 64 && m_axis_rc_tkeep[1]==1'b1) || (C_DATA_WIDTH > 64 && m_axis_rc_tkeep[3]==1'b1)) begin
+
+    pcie_pkt   =          {
+                           1'b0,
+                           2'b10,
+                           5'b01010,
+                           1'b0,
+                           rc_data_QW1[27:25],
+                           1'b0,
+                           rc_data_QW1[30],
+                           1'b0,
+                           1'b0,
+                           1'b0,
+                           rc_data_QW0[46],
+                           rc_data_QW1[29:28],
+                           2'b00,
+                           rc_data_QW0[41:32],    // 32
+                           rc_data_QW1[23:8],
+                           rc_data_QW0[45:43],
+                           1'b0,
+                           rc_data_QW0[27:16],    // 64
+                           rc_data_QW0[63:48],
+                           rc_data_QW1[7:0],
+                           1'b0,
+                           rc_data_QW0[6:0],
+                           rc_data_QW1[63:32]
+                         };
+    board.RP.com_usrapp.TSK_READ_DATA(0, `RX_LOG, pcie_pkt[127:64], 1'b0);
+    board.RP.com_usrapp.TSK_READ_DATA(1, `RX_LOG, pcie_pkt[63:0], 1'b0);
+    
+  end
+  else begin
+  
+    pcie_pkt   =          {
+                           1'b0,
+                           {~m_axis_rc_tlast,1'b0},
+                           //2m_axis_rc_tlast;'b00,
+                           5'b01010,
+                           1'b0,
+                           rc_data_QW1[27:25],
+                           1'b0,
+                           rc_data_QW1[30],
+                           1'b0,
+                           1'b0,
+                           1'b0,
+                           rc_data_QW0[46],
+                           rc_data_QW1[29:28],
+                           2'b00,
+                           rc_data_QW0[41:32],    // 32
+                           rc_data_QW1[23:8],
+                           rc_data_QW0[45:43],
+                           1'b0,
+                           rc_data_QW0[27:16],    // 64
+                           rc_data_QW0[63:48],
+                           rc_data_QW1[7:0],
+                           1'b0,
+                           rc_data_QW0[6:0],
+                           32'h00000000
+                          };
+    board.RP.com_usrapp.TSK_READ_DATA(0, `RX_LOG, pcie_pkt[127:64], 1'b0);
+    board.RP.com_usrapp.TSK_READ_DATA(1, `RX_LOG, pcie_pkt[63:0], 1'b1);
+    
+  end
+endtask
+//----------------------------------------------------------------------------------------------------//
+
+//----------------------------------------------------------------------------------------------------//
+task TSK_BUILD_CQ_TO_PCIE_PKT;
+  input [63:0] cq_data;
+  input [7:0]  cq_be;
+  input [63:0] m_axis_cq_tdata;
+
+  reg [127:0] pcie_pkt;
+
+begin
+//----------------------------------------------------------------------------------------------------//
+  case(m_axis_cq_tdata[14:11])
+
+  4'b0000: begin //Memory Read Request
+     pcie_pkt = {
+                 ((cq_data[63:32] == 32'h0) ? 3'b000 : 3'b001), // Fmt (32-bit or 64-bit)
+                 5'b00000,               // Type
+                 1'b0,                   // *Reserved*
+                 m_axis_cq_tdata[59:57], // TC
+                 1'b0,                   // *Reserved*
+                 m_axis_cq_tdata[62],    // Attr {ID Based Ordering}
+                 2'b00,                  // TLP Processing Hint (TPH)
+                 1'b0,                   // Digest Present
+                 1'b0,                   // Error Poisoned
+                 m_axis_cq_tdata[61:60], // Attributes {Relaxed Ordering, No Snoop}
+                 2'b00,                  // Address Translation
+                 m_axis_cq_tdata[9:0],   // Length
+                 m_axis_cq_tdata[31:16], // Requester ID
+                 m_axis_cq_tdata[39:32], // Tag
+                 cq_be[7:4],             // Last DW Byte Enable
+                 cq_be[3:0],             // First DW Byte Enable
+                 ((cq_data[63:32] == 32'h0) ? {cq_data[31:2], 32'b0} : cq_data[63:2]), // Address (32-bit or 64-bit)
+                 2'b00                   // *Reserved*
+                };
+     board.RP.com_usrapp.TSK_READ_DATA(0, `RX_LOG, pcie_pkt[127:64], 1'b0);
+     board.RP.com_usrapp.TSK_READ_DATA(0, `RX_LOG, pcie_pkt[63:0], 1'b0);     
+
+  end
+//----------------------------------------------------------------------------------------------------//
+  4'b0001: begin //Memory Write Request
+     pcie_pkt = {
+                 ((cq_data[63:32] == 32'h0) ? 3'b010 : 3'b001), // Fmt (32-bit or 64-bit)
+                 5'b00000,               // Type
+                 1'b0,                   // *Reserved*
+                 m_axis_cq_tdata[59:57], // TC
+                 1'b0,                   // *Reserved*
+                 m_axis_cq_tdata[62],    // Attr {ID Based Ordering}
+                 2'b00,                  // TLP Processing Hint (TPH)
+                 1'b0,                   // Digest Present
+                 1'b0,                   // Error Poisoned
+                 m_axis_cq_tdata[61:60], // Attributes {Relaxed Ordering, No Snoop}
+                 2'b00,                  // Address Translation
+                 m_axis_cq_tdata[9:0],   // Length
+                 m_axis_cq_tdata[31:16], // Requester ID
+                 m_axis_cq_tdata[39:32], // Tag
+                 cq_be[7:4],             // Last DW Byte Enable
+                 cq_be[3:0],             // First DW Byte Enable
+                 ((cq_data[63:32] == 32'h0) ? {cq_data[31:2], 32'b0} : cq_data[63:2]), // Address (32-bit or 64-bit)
+                 2'b00                   // *Reserved*
+                }; /* Only provide header -- Payload data is not presented */
+     board.RP.com_usrapp.TSK_READ_DATA(0, `RX_LOG, pcie_pkt[127:64], 1'b0);
+     board.RP.com_usrapp.TSK_READ_DATA(0, `RX_LOG, pcie_pkt[63:0], 1'b0);
+
+  end
+//----------------------------------------------------------------------------------------------------//
+  4'b1101:begin // Vendor Defined Message
+     pcie_pkt = {
+                 3'b001,                 // Fmt
+                 2'b10,                  // Type
+                 m_axis_cq_tdata[50:48], // Message Routing
+                 1'b0,                   // *Reserved*
+                 m_axis_cq_tdata[59:57], // TC
+                 1'b0,                   // *Reserved*
+                 m_axis_cq_tdata[62],    // Attr {ID Based Ordering}
+                 2'b00,                  // TLP Processing Hint (TPH)
+                 1'b0,                   // Digest Present
+                 1'b0,                   // Error Poisoned
+                 m_axis_cq_tdata[61:60], // Attributes {Relaxed Ordering, No Snoop}
+                 2'b00,                  // Address Translation
+                 m_axis_cq_tdata[9:0],   // Length
+                 m_axis_cq_tdata[31:16], // Requester ID
+                 m_axis_cq_tdata[39:32], // Tag
+                 m_axis_cq_tdata[47:40], // Message Code
+                 cq_data[15:0],          // Destination ID (Bus/Device/Function)
+                 cq_data[31:16],         // Vendor ID
+                 cq_data[63:32]          // Vendor Message
+                };
+     board.RP.com_usrapp.TSK_READ_DATA(0, `RX_LOG, pcie_pkt[127:64], 1'b0);
+     board.RP.com_usrapp.TSK_READ_DATA(0, `RX_LOG, pcie_pkt[63:0], 1'b0);
+   
+  end
+//----------------------------------------------------------------------------------------------------//
+  4'b1110,4'b1100:begin // ATS Message and Other Messages
+     pcie_pkt = {
+                 3'b001,                 // Fmt
+                 2'b10,                  // Type
+                 m_axis_cq_tdata[50:48], // Message Routing
+                 1'b0,                   // *Reserved*
+                 m_axis_cq_tdata[59:57], // TC
+                 1'b0,                   // *Reserved*
+                 m_axis_cq_tdata[62],    // Attr {ID Based Ordering}
+                 2'b00,                  // TLP Processing Hint (TPH)
+                 1'b0,                   // Digest Present
+                 1'b0,                   // Error Poisoned
+                 m_axis_cq_tdata[61:60], // Attributes {Relaxed Ordering, No Snoop}
+                 2'b00,                  // Address Translation
+                 m_axis_cq_tdata[9:0],   // Length
+                 m_axis_cq_tdata[31:16], // Requester ID
+                 m_axis_cq_tdata[39:32], // Tag
+                 m_axis_cq_tdata[47:40], // Message Code
+                 cq_data[63:0]           // Messages (ATS or non-Vendor Defined)
+                };
+     board.RP.com_usrapp.TSK_READ_DATA(0, `RX_LOG, pcie_pkt[127:64], 1'b0);
+     board.RP.com_usrapp.TSK_READ_DATA(0, `RX_LOG, pcie_pkt[63:0], 1'b0);
+   
+  end
+  endcase
+//----------------------------------------------------------------------------------------------------//
+end
+endtask //TSK_BUILD_CQ_TO_PCIE_PKT
+//----------------------------------------------------------------------------------------------------//
+//----------------------------------------------------------------------------------------------------//
+task TSK_BUILD_CPLD_PKT;
+  input [63:0] cq_data;
+  input [7:0]  cq_be;
+  input [63:0] m_axis_cq_tdata;
+  reg   [2:0]         attr;             // Attributes
+  begin
+//----------------------------------------------------------------------------------------------------//
+    req_compl_wd = (m_axis_cq_tdata[10:0] != 11'h000 && m_axis_cq_tdata[14:11] == 4'b0000) ? 1'b1 : 1'b0;
+    attr               = m_axis_cq_tdata[62:60];
+    //--------------------------------------------------------------//
+    // Calculate byte count based on byte enable
+    //--------------------------------------------------------------//
+    casex ({cq_be[3:0],cq_be[7:4]})
+        8'b1xx10000 : byte_count = 12'h004;
+        8'b01x10000 : byte_count = 12'h003;
+        8'b1x100000 : byte_count = 12'h003;
+        8'b00110000 : byte_count = 12'h002;
+        8'b01100000 : byte_count = 12'h002;
+        8'b11000000 : byte_count = 12'h002;
+        8'b00010000 : byte_count = 12'h001;
+        8'b00100000 : byte_count = 12'h001;
+        8'b01000000 : byte_count = 12'h001;
+        8'b10000000 : byte_count = 12'h001;
+        8'b00000000 : byte_count = 12'h001;
+        8'bxxx11xxx : byte_count = (m_axis_cq_tdata[10:0] * 4) - 0;
+        8'bxxx101xx : byte_count = (m_axis_cq_tdata[10:0] * 4) - 1;
+        8'bxxx1001x : byte_count = (m_axis_cq_tdata[10:0] * 4) - 2;
+        8'bxxx10001 : byte_count = (m_axis_cq_tdata[10:0] * 4) - 3;
+        8'bxx101xxx : byte_count = (m_axis_cq_tdata[10:0] * 4) - 1;
+        8'bxx1001xx : byte_count = (m_axis_cq_tdata[10:0] * 4) - 2;
+        8'bxx10001x : byte_count = (m_axis_cq_tdata[10:0] * 4) - 3;
+        8'bxx100001 : byte_count = (m_axis_cq_tdata[10:0] * 4) - 4;
+        8'bx1001xxx : byte_count = (m_axis_cq_tdata[10:0] * 4) - 2;
+        8'bx10001xx : byte_count = (m_axis_cq_tdata[10:0] * 4) - 3;
+        8'bx100001x : byte_count = (m_axis_cq_tdata[10:0] * 4) - 4;
+        8'bx1000001 : byte_count = (m_axis_cq_tdata[10:0] * 4) - 5;
+        8'b10001xxx : byte_count = (m_axis_cq_tdata[10:0] * 4) - 3;
+        8'b100001xx : byte_count = (m_axis_cq_tdata[10:0] * 4) - 4;
+        8'b1000001x : byte_count = (m_axis_cq_tdata[10:0] * 4) - 5;
+        8'b10000001 : byte_count = (m_axis_cq_tdata[10:0] * 4) - 6;
+    endcase
+  
+    // Calculate lower address based on  byte enable
+    casex ({req_compl_wd,cq_be[3:0]})
+        5'b0_xxxx : lower_addr = 11'h0;
+        5'bx_0000 : lower_addr = {cq_data[15:2], 2'b00};
+        5'bx_xxx1 : lower_addr = {cq_data[15:2], 2'b00};
+        5'bx_xx10 : lower_addr = {cq_data[15:2], 2'b01};
+        5'bx_x100 : lower_addr = {cq_data[15:2], 2'b10};
+        5'bx_1000 : lower_addr = {cq_data[15:2], 2'b11};
+    endcase
+    $display("req_compl_wd = %d, cq_be = %d, lower_addr = %h, cq_data = %h", req_compl_wd, cq_be[3:0], lower_addr, cq_data[6:2]); 
+  
+  //----------------------------------------------------------------------------------------------------//
+
+    board.RP.tx_usrapp.TSK_TX_COMPLETION_DATA(m_axis_cq_tdata[31:16],
+                                              m_axis_cq_tdata[39:32],
+                                              m_axis_cq_tdata[59:57],
+                                              m_axis_cq_tdata[10:0],
+                                              byte_count,
+                                              lower_addr[15:0],
+                                              12'b0,
+                                              3'b000,               
+                                              1'b0,
+                                              attr);
+                                              
+//----------------------------------------------------------------------------------------------------//
+  end
+endtask //TSK_BUILD_CPLD_PKT
+//----------------------------------------------------------------------------------------------------//
+
+endmodule // pci_exp_usrapp_rx
+//----------------------------------------------------------------------------------------------------//
+
diff --git a/sim/tb/usrapp/usp_pci_exp_usrapp_tx.sv b/sim/tb/usrapp/usp_pci_exp_usrapp_tx.sv
new file mode 100644
index 0000000..e93c1a3
--- /dev/null
+++ b/sim/tb/usrapp/usp_pci_exp_usrapp_tx.sv
@@ -0,0 +1,4593 @@
+
+//-----------------------------------------------------------------------------
+//
+// (c) Copyright 2020-2025 Advanced Micro Devices, Inc. All rights reserved.
+//
+// This file contains confidential and proprietary information
+// of AMD and is protected under U.S. and
+// international copyright and other intellectual property
+// laws.
+//
+// DISCLAIMER
+// This disclaimer is not a license and does not grant any
+// rights to the materials distributed herewith. Except as
+// otherwise provided in a valid license issued to you by
+// AMD, and to the maximum extent permitted by applicable
+// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
+// WITH ALL FAULTS, AND AMD HEREBY DISCLAIMS ALL WARRANTIES
+// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
+// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
+// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
+// (2) AMD shall not be liable (whether in contract or tort,
+// including negligence, or under any other theory of
+// liability) for any loss or damage of any kind or nature
+// related to, arising under or in connection with these
+// materials, including for any direct, or any indirect,
+// special, incidental, or consequential loss or damage
+// (including loss of data, profits, goodwill, or any type of
+// loss or damage suffered as a result of any action brought
+// by a third party) even if such damage or loss was
+// reasonably foreseeable or AMD had been advised of the
+// possibility of the same.
+//
+// CRITICAL APPLICATIONS
+// AMD products are not designed or intended to be fail-
+// safe, or for use in any application requiring fail-safe
+// performance, such as life-support or safety devices or
+// systems, Class III medical devices, nuclear facilities,
+// applications related to the deployment of airbags, or any
+// other applications that could lead to death, personal
+// injury, or severe property or environmental damage
+// (individually and collectively, "Critical
+// Applications"). Customer assumes the sole risk and
+// liability of any use of AMD products in Critical
+// Applications, subject only to applicable laws and
+// regulations governing limitations on product liability.
+//
+// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
+// PART OF THIS FILE AT ALL TIMES.
+//
+//-----------------------------------------------------------------------------
+//
+// Project    : PCI Express DMA 
+// File       : usp_pci_exp_usrapp_tx.v
+// Version    : 5.0
+//-----------------------------------------------------------------------------
+//--------------------------------------------------------------------------------
+`include "board_common.vh"
+
+module pci_exp_usrapp_tx #(
+  parameter ATTR_AXISTEN_IF_ENABLE_CLIENT_TAG = 0,
+  parameter AXISTEN_IF_RQ_PARITY_CHECK   = 0,
+  parameter AXISTEN_IF_CC_PARITY_CHECK   = 0,
+  parameter AXISTEN_IF_RQ_ALIGNMENT_MODE  = "FALSE",
+  parameter AXISTEN_IF_CC_ALIGNMENT_MODE  = "FALSE",
+  parameter AXISTEN_IF_CQ_ALIGNMENT_MODE  = "FALSE",
+  parameter AXISTEN_IF_RC_ALIGNMENT_MODE  = "FALSE",
+  parameter DEV_CAP_MAX_PAYLOAD_SUPPORTED = 1,
+  parameter C_DATA_WIDTH  = 512,
+  parameter KEEP_WIDTH    = C_DATA_WIDTH / 32,
+  parameter STRB_WIDTH    = C_DATA_WIDTH / 8,
+  parameter EP_DEV_ID     = 16'h7700,
+  parameter REM_WIDTH     = C_DATA_WIDTH == 512,
+  parameter [5:0] RP_BAR_SIZE = 6'd11 // Number of RP BAR's Address Bit - 1
+)
+(
+  output reg                    s_axis_rq_tlast,
+  output reg [C_DATA_WIDTH-1:0] s_axis_rq_tdata,
+  output     [136:0]            s_axis_rq_tuser,
+  output reg [KEEP_WIDTH-1:0]   s_axis_rq_tkeep,
+  input                         s_axis_rq_tready,
+  output reg                    s_axis_rq_tvalid,
+
+  output reg [C_DATA_WIDTH-1:0] s_axis_cc_tdata,
+  output reg [82:0]             s_axis_cc_tuser,
+  output reg                    s_axis_cc_tlast,
+  output reg [KEEP_WIDTH-1:0]   s_axis_cc_tkeep,
+  output reg                    s_axis_cc_tvalid,
+  input                         s_axis_cc_tready,
+
+  input  [3:0]  pcie_rq_seq_num,
+  input         pcie_rq_seq_num_vld,
+  input  [5:0]  pcie_rq_tag,
+  input         pcie_rq_tag_vld,
+
+  input  [1:0]  pcie_tfc_nph_av,
+  input  [1:0]  pcie_tfc_npd_av,
+//------------------------------------------------------
+  input speed_change_done_n,
+//------------------------------------------------------
+  input user_clk,
+  input reset,
+  input user_lnk_up
+);
+
+parameter  Tcq = 1;
+localparam [31:0] DMA_BYTE_CNT = 128;
+
+localparam  [4:0] LINK_CAP_MAX_LINK_WIDTH = 5'd16;
+localparam  [4:0] LINK_CAP_MAX_LINK_SPEED = 5'd4;
+localparam  [3:0] MAX_LINK_SPEED = (LINK_CAP_MAX_LINK_SPEED == 5'd16) ? 4'h5 : (LINK_CAP_MAX_LINK_SPEED==5'd8) ? 4'h4 : (LINK_CAP_MAX_LINK_SPEED==5'd4) ? 4'h3 : ((LINK_CAP_MAX_LINK_SPEED==5'd2) ? 4'h2 : 4'h1);
+localparam  [5:0] BAR_ENABLED = 6'b1;
+localparam [11:0] LINK_CTRL_REG_ADDR = 12'h080;
+localparam [11:0] PCIE_DEV_CAP_ADDR  = 12'h074;
+localparam [11:0] DEV_CTRL_REG_ADDR  = 12'h078;
+localparam NUMBER_OF_PFS = 1; //1;
+localparam NUM_FN=9'h1;
+localparam QUEUE_PER_PF = 32;
+
+reg [31:0] MSIX_VEC_OFFSET[NUM_FN-1:0];
+reg [31:0] MSIX_PBA_OFFSET[NUM_FN-1:0];
+reg  [2:0] MSIX_VEC_BAR[NUM_FN-1:0];
+reg  [2:0] MSIX_PBA_BAR[NUM_FN-1:0];
+reg [10:0] MSIX_TABLE_SIZE[NUM_FN-1:0];
+reg [(C_DATA_WIDTH - 1):0] pcie_tlp_data;
+reg [(REM_WIDTH - 1):0]    pcie_tlp_rem;
+
+integer xdma_bar = 0;
+integer user_bar = 0;
+
+localparam C_NUM_USR_IRQ       = 16;
+localparam MSIX_CTRL_REG_ADDR  = 12'h060;
+localparam MSIX_VEC_TABLE_A    = 12'h64;
+localparam MSIX_PBA_TABLE_A    = 12'h68;
+localparam QUEUE_PTR_PF_ADDR   = 32'h00018000;
+localparam CMPT_ADDR = 32'h3000;
+localparam H2C_ADDR  = 32'h2000;
+localparam C2H_ADDR  = 32'h2800;
+
+/* Local Variables */
+integer                         i, j, k;
+// NOTE: The first 32 bits of DATA_STORE are reserved for the register write task!
+reg [7:0]  DATA_STORE   [16383:0]; // For Downstream Direction Data Storage
+reg [7:0]  DATA_STORE_2 [(2**(RP_BAR_SIZE+1))-1:0]; // For Upstream Direction Data Storage
+reg [31:0] ADDRESS_32_L;
+reg [31:0] ADDRESS_32_H;
+reg [63:0] ADDRESS_64;
+reg [15:0] EP_BUS_DEV_FNS_INIT;
+reg [15:0] EP_BUS_DEV_FNS;
+reg [15:0] RP_BUS_DEV_FNS;
+reg [2:0]  DEFAULT_TC;
+reg [9:0]  DEFAULT_LENGTH;
+reg [3:0]  DEFAULT_BE_LAST_DW;
+reg [3:0]  DEFAULT_BE_FIRST_DW;
+reg [1:0]  DEFAULT_ATTR;
+reg [7:0]  DEFAULT_TAG;
+reg [3:0]  DEFAULT_COMP;
+reg [11:0] EXT_REG_ADDR;
+reg        TD;
+reg        EP;
+reg [15:0] VENDOR_ID;
+reg [9:0]  LENGTH;         // For 1DW config and IO transactions
+reg [9:0]  CFG_DWADDR;
+
+event test_begin;
+
+reg [31:0] P_ADDRESS_MASK;
+reg [31:0] P_READ_DATA;      // will store the 1st DW (lo) of a PCIE read completion
+reg [31:0] P_READ_DATA_2;    // will store the 2nd DW (hi) of a PCIE read completion
+reg        P_READ_DATA_VALID;
+reg [31:0] P_WRITE_DATA;
+reg [31:0] data;
+
+reg error_check;
+reg set_malformed;
+
+// BAR Init variables
+reg [32:0] BAR_INIT_P_BAR[6:0];         // 6 corresponds to Expansion ROM
+                                        // note that bit 32 is for overflow checking
+reg [31:0] BAR_INIT_P_BAR_RANGE[6:0];   // 6 corresponds to Expansion ROM
+reg [1:0]  BAR_INIT_P_BAR_ENABLED[6:0]; // 6 corresponds to Expansion ROM
+                                        // 0 = disabled;  1 = io mapped;  2 = mem32 mapped;  3 = mem64 mapped
+
+reg [31:0] BAR_INIT_P_MEM64_HI_START;   // start address for hi memory space
+reg [31:0] BAR_INIT_P_MEM64_LO_START;   // start address for hi memory space
+reg [32:0] BAR_INIT_P_MEM32_START;      // start address for low memory space
+                                        // top bit used for overflow indicator
+reg [32:0] BAR_INIT_P_IO_START;         // start address for io space
+reg [100:0]BAR_INIT_MESSAGE[3:0];       // to be used to display info to user
+
+reg [32:0] BAR_INIT_TEMP;
+
+reg OUT_OF_LO_MEM; // flags to indicate out of mem, mem64, and io
+reg OUT_OF_IO;
+reg OUT_OF_HI_MEM;
+
+integer NUMBER_OF_IO_BARS;
+integer NUMBER_OF_MEM32_BARS; // Not counting the Mem32 EROM space
+integer NUMBER_OF_MEM64_BARS;
+
+reg     [3:0]  ii;
+integer        jj;
+integer        kk;
+reg     [3:0]  pfIndex = 0;
+reg     [3:0]  pfTestIteration = 0;
+reg     [3:0]  pf_loop_index = 0;
+reg            dmaTestDone;
+
+reg     [31:0] DEV_VEN_ID;             // holds device and vendor id
+integer        PIO_MAX_NUM_BLOCK_RAMS; // holds the max number of block RAMS
+reg     [31:0] PIO_MAX_MEMORY;
+
+reg pio_check_design; // boolean value to check PCI Express BAR configuration against
+                      // limitations of PIO design. Setting this to true will cause the
+                      // testbench to check if the core has been configured for more than
+                      // one IO space, one general purpose Mem32 space (not counting
+                      // the Mem32 EROM space), and one Mem64 space.
+
+reg cpld_to;          // boolean value to indicate if time out has occured while waiting for cpld
+reg cpld_to_finish;   // boolean value to indicate to $finish on cpld_to
+
+reg verbose;          // boolean value to display additional info to stdout
+
+wire        user_lnk_up_n;
+wire [63:0] s_axis_cc_tparity;
+wire [63:0] s_axis_rq_tparity;
+
+reg[255:0] testname;
+integer    test_vars [31:0];
+reg  [7:0] exp_tag;
+reg  [7:0] expect_cpld_payload [4095:0];
+reg  [7:0] expect_msgd_payload [4095:0];
+reg  [7:0] expect_memwr_payload [4095:0];
+reg  [7:0] expect_memwr64_payload [4095:0];
+reg  [7:0] expect_cfgwr_payload [3:0];
+reg        expect_status;
+reg        expect_finish_check;
+reg        testError;
+reg[136:0] s_axis_rq_tuser_wo_parity;
+reg [16:0] MM_wb_sts_pidx;
+reg [16:0] MM_wb_sts_cidx;
+reg [10:0] axi_mm_q;
+reg [10:0] axi_st_q;
+reg [10:0] axi_st_q_phy;
+reg [10:0] pf0_qmax;
+reg [10:0] pf1_qmax;
+reg[255:0] wr_dat;
+reg [31:0] wr_add;
+reg [15:0] data_tmp = 0;
+reg        test_state =0;
+reg [10:0] qid;
+reg  [7:0] fnc = 8'h0;
+
+assign s_axis_rq_tuser = {(AXISTEN_IF_RQ_PARITY_CHECK ?  s_axis_rq_tparity : 64'b0),s_axis_rq_tuser_wo_parity[72:0]};
+
+assign user_lnk_up_n = ~user_lnk_up;
+
+integer desc_count = 0;
+integer loop_timeout = 0;
+
+reg [15:0] EP_DEV_ID1;
+reg [31:0] h2c_status = 32'h0;
+reg [31:0] c2h_status = 32'h0;
+reg [31:0] int_req_reg;
+
+/************************************************************
+  Initial Statements
+*************************************************************/
+initial begin
+  s_axis_rq_tlast   = 0;
+  s_axis_rq_tdata   = 0;
+  s_axis_rq_tuser_wo_parity = 0;
+  s_axis_rq_tkeep   = 0;
+  s_axis_rq_tvalid  = 0;
+
+  s_axis_cc_tdata   = 0;
+  s_axis_cc_tuser   = 0;
+  s_axis_cc_tlast   = 0;
+  s_axis_cc_tkeep   = 0;
+  s_axis_cc_tvalid  = 0;
+
+  ADDRESS_32_L   = 32'b1011_1110_1110_1111_1100_1010_1111_1110;
+  ADDRESS_32_H   = 32'b1011_1110_1110_1111_1100_1010_1111_1110;
+  ADDRESS_64     = { ADDRESS_32_H, ADDRESS_32_L };
+//EP_BUS_DEV_FNS = 16'b0000_0001_0000_0000;
+//RP_BUS_DEV_FNS = 16'b0000_0000_0000_0000;
+  EP_BUS_DEV_FNS_INIT  = 16'b0000_0001_0000_0000;
+  EP_BUS_DEV_FNS = 16'b0000_0001_0000_0000;
+  RP_BUS_DEV_FNS = 16'b0000_0000_0000_0000;
+  DEFAULT_TC     = 3'b000;
+  DEFAULT_LENGTH = 10'h000;
+  DEFAULT_BE_LAST_DW  = 4'h0;
+  DEFAULT_BE_FIRST_DW = 4'h0;
+  DEFAULT_ATTR = 2'b01;
+  DEFAULT_TAG  = 8'h00;
+  DEFAULT_COMP = 4'h0;
+  EXT_REG_ADDR = 12'h000;
+  TD = 0;
+  EP = 0;
+  VENDOR_ID = 16'h10ee;
+  LENGTH    = 10'b00_0000_0001;
+
+  set_malformed = 1'b0;
+end
+//-----------------------------------------------------------------------\\
+// Pre-BAR initialization
+initial begin
+
+  BAR_INIT_MESSAGE[0] = "DISABLED";
+  BAR_INIT_MESSAGE[1] = "IO MAPPED";
+  BAR_INIT_MESSAGE[2] = "MEM32 MAPPED";
+  BAR_INIT_MESSAGE[3] = "MEM64 MAPPED";
+
+  OUT_OF_LO_MEM = 1'b0;
+  OUT_OF_IO     = 1'b0;
+  OUT_OF_HI_MEM = 1'b0;
+
+  // Disable variables to start
+  for (ii = 0; ii <= 6; ii = ii + 1) begin
+    BAR_INIT_P_BAR[ii]         = 33'h00000_0000;
+    BAR_INIT_P_BAR_RANGE[ii]   = 32'h0000_0000;
+    BAR_INIT_P_BAR_ENABLED[ii] = 2'b00;
+  end
+
+  BAR_INIT_P_MEM64_HI_START =  32'h0000_0001;  // hi 32 bit start of 64bit memory
+  BAR_INIT_P_MEM64_LO_START =  32'h0000_0000;  // low 32 bit start of 64bit memory
+  BAR_INIT_P_MEM32_START    =  33'h00000_0000; // start of 32bit memory
+  BAR_INIT_P_IO_START       =  33'h00000_0000; // start of 32bit io
+
+  DEV_VEN_ID             = (EP_DEV_ID1 << 16) | (32'h10EE);
+  PIO_MAX_MEMORY         = 8192; // PIO has max of 8Kbytes of memory
+  PIO_MAX_NUM_BLOCK_RAMS = 4;    // PIO has four block RAMS to test
+  PIO_MAX_MEMORY         = 2048; // PIO has 4 memory regions with 2 Kbytes of memory per region, ie 8 Kbytes
+  PIO_MAX_NUM_BLOCK_RAMS = 4;    // PIO has four block RAMS to test
+
+  pio_check_design = 1;  // By default check to make sure the core has been configured
+                         // appropriately for the PIO design
+  cpld_to          = 0;  // By default time out has not occured
+  cpld_to_finish   = 1;  // By default end simulation on time out
+
+  verbose = 0;  // turned off by default
+
+  NUMBER_OF_IO_BARS    = 0;
+  NUMBER_OF_MEM32_BARS = 0;
+  NUMBER_OF_MEM64_BARS = 0;
+
+end
+
+//-----------------------------------------------------------------------\\
+// logic to store received data
+
+reg [15:0] rcv_data[0:16384];
+reg 	     cq_wr;
+reg  [3:0] count;
+wire[15:0] tmp_data_0;
+wire[15:0] tmp_data_1;
+wire[15:0] tmp_data_2;
+wire[15:0] tmp_data_0_1;
+wire[15:0] tmp_data_1_1;
+wire[15:0] tmp_data_2_1;
+reg [15:0] cq_addr;
+reg 		   tvalid_d;
+wire[15:0] cq_addr_fst;
+wire [7:0] xfr_len;
+
+always @(posedge user_clk) begin
+	tvalid_d <= board.RP.m_axis_cq_tvalid & board.RP.m_axis_cq_tready;
+end
+
+assign cq_addr_fst = (board.RP.m_axis_cq_tvalid & board.RP.m_axis_cq_tready & ~tvalid_d) ? board.RP.m_axis_cq_tdata[15:0] : 16'h0;
+assign xfr_len = (board.RP.m_axis_cq_tvalid & board.RP.m_axis_cq_tready & ~tvalid_d) ? board.RP.m_axis_cq_tdata[71:64] : 8'h0;
+
+always @(posedge user_clk) begin
+  if(reset) begin
+    cq_wr <= 0;
+    count <= 0;
+    cq_addr <= 0;
+  end
+  else if(board.RP.m_axis_cq_tvalid & board.RP.m_axis_cq_tready & (cq_wr | board.RP.m_axis_cq_tdata[75])) begin
+    cq_wr <= 1'b1;
+    count <= count+1;
+    if(count == 0) begin
+	    for (i = 8; i < 32; i= i+1) begin
+	      rcv_data[cq_addr_fst + (i-8)] <=  board.RP.m_axis_cq_tdata[i*16 +: 16];
+	      if(i == 31) cq_addr <= cq_addr_fst + 24;
+	    //$display ("addr = %d, data 0 %h\n", (cq_addr_fst+ (i-8)), board.RP.m_axis_cq_tdata[i*16 +: 16]);
+	    end
+    end
+    else begin
+      for (i = 0; i < 32; i= i+1) begin
+        rcv_data[cq_addr + i] <=  board.RP.m_axis_cq_tdata[i*16 +: 16];
+        if(i == 31) cq_addr <= cq_addr + 32;
+      //$display ("addr = %d, data %h\n", (cq_addr+i), board.RP.m_axis_cq_tdata[i*16 +: 16]);
+      end
+    end
+  end
+  else begin
+    cq_wr <= 0;
+    count <= 0;
+  end
+end
+
+assign tmp_data_0 = rcv_data[2048];
+assign tmp_data_1 = rcv_data[2049];
+assign tmp_data_2 = rcv_data[2050];
+assign tmp_data_0_1 = rcv_data[2051];
+assign tmp_data_1_1 = rcv_data[2052];
+assign tmp_data_2_1 = rcv_data[2053];
+
+//--------------------------------------------------------------------------------------------------------
+
+/************************************************************
+  Logic to Compute the Parity of the CC and the RQ Channel
+*************************************************************/
+
+generate
+if(AXISTEN_IF_RQ_PARITY_CHECK == 1) begin
+  genvar a;
+  for(a=0; a< STRB_WIDTH; a = a + 1) // Parity needs to be computed for every byte of data
+  begin : parity_assign
+    assign s_axis_rq_tparity[a] = !( s_axis_rq_tdata[(8*a)+ 0] ^ s_axis_rq_tdata[(8*a)+ 1]
+                                   ^ s_axis_rq_tdata[(8*a)+ 2] ^ s_axis_rq_tdata[(8*a)+ 3]
+                                   ^ s_axis_rq_tdata[(8*a)+ 4] ^ s_axis_rq_tdata[(8*a)+ 5]
+                                   ^ s_axis_rq_tdata[(8*a)+ 6] ^ s_axis_rq_tdata[(8*a)+ 7]);
+    assign s_axis_cc_tparity[a] = !( s_axis_cc_tdata[(8*a)+ 0] ^ s_axis_cc_tdata[(8*a)+ 1]
+                                   ^ s_axis_cc_tdata[(8*a)+ 2] ^ s_axis_cc_tdata[(8*a)+ 3]
+                                   ^ s_axis_cc_tdata[(8*a)+ 4] ^ s_axis_cc_tdata[(8*a)+ 5]
+                                   ^ s_axis_cc_tdata[(8*a)+ 6] ^ s_axis_cc_tdata[(8*a)+ 7]);
+  end
+end
+endgenerate
+
+
+
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+
+
+
+task TSK_QDMA_MM_H2C_TEST;
+  input [10:0] qid;
+  input dsc_bypass;
+  input irq_en;
+
+  reg [11:0] q_count;
+  reg [10:0] q_base;
+  reg [15:0] pidx;
+  localparam NUM_ITER = 1;
+  integer    iter;
+  logic [31:0] wr_data[8];
+begin
+  //$display({__FILE__, "../../binaries/polybench/trisolv_0.bin"});
+	//----------------------------------------------------------------------------------------
+	// QDMA AXI-MM H2C Test Starts
+	//----------------------------------------------------------------------------------------
+  $display("------AXI-MM H2C Tests start--------\n");
+
+  $display(" **** read Address at BAR0  = %h\n", board.RP.tx_usrapp.BAR_INIT_P_BAR[0][31:0]);
+  $display(" **** read Address at BAR1  = %h\n", board.RP.tx_usrapp.BAR_INIT_P_BAR[1][31:0]);
+
+  // Global programming
+  //
+  // Assign Q 0 for AXI-MM
+  axi_mm_q = qid;
+  q_base   = QUEUE_PER_PF * fnc;
+  q_count  = QUEUE_PER_PF;
+  EP_BUS_DEV_FNS      = {EP_BUS_DEV_FNS_INIT[15:2], fnc};
+  pidx = 0;
+
+  //-------------- Load DATA in Buffer ----------------------------------------------------
+  // H2C DSC start at 0x0100 (256)
+  // H2C data start at 0x0300 (768)
+  // Initializes descriptor and data (addresses are hard-coded)
+  board.RP.tx_usrapp.TSK_INIT_QDMA_MM_DATA_H2C;
+
+	//-------------- DMA Engine ID Read -----------------------------------------------------
+  board.RP.tx_usrapp.TSK_REG_READ(xdma_bar, 16'h00);
+
+  //-------------- Global Ring Size for Queue 0  0x204  : num of dsc 16 ------------------------
+  // It initializes the ring size registers (from addr 0x204 to addr 0x240)
+  // with the value 16 (0x10). Each queue can choose the ring size to read.
+  for (shortint addr = 16'h204; addr <= 16'h240; addr += 4)
+    board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, addr, 32'h00000010, 4'hF);
+
+
+
+  //-------------- Ind Dire CTXT MASK 0x824  0xffffffff for all 128 bits -------------------
+  // Put all bits of the context mask to 1 (it is probably to enable all data bytes or something, but I don't know)
+  for (shortint addr = 16'h824; addr <= 16'h840; addr += 4)
+    board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, addr, 32'hffffffff, 4'hF);
+
+  //-------------- Clear HW CXTX for H2C for Qid -----------------------------------------
+  // Writing in the CTXT CMD register issues a command for the context.
+  // In this case, it clears the context for the HW H2C context.
+  wr_data[0][31:18] = 'h0; // reserved
+  wr_data[0][17:7]  = axi_mm_q[10:0]; // qid
+  wr_data[0][6:5]   = 2'h0; // MDMA_CTXT_CMD_CLR
+  wr_data[0][4:1]   = 4'h3; // MDMA_CTXT_SELC_DSC_HW_H2C
+  wr_data[0][0]     = 'h0;
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h844, wr_data[0], 4'hF);
+
+  
+  
+  //-------------- Global Function MAP 0x400  : Func0 22:11 Qnumber ( 16 Queue ) : 10:0 Qid_base for this Func
+  // Writing in the CTXT DATA register: it is putting the context to zero, except for the first two words that
+  // contain the q_base (the first queue for this physical function) and the q_count (the number of queues for
+  // each PF). Don't know exactly how it works, but apparently the Function Map is used to allocate the accesses
+  // to the different queues with some sort of addressing translation.
+  wr_data[0]  = 32'h0 | q_base;
+  wr_data[1]  = 32'h0 | q_count;
+  for (iter = 2; iter < 8; iter++)
+    wr_data[iter] = '0;
+
+  iter = 0;
+  for (shortint addr = 16'h804; addr <= 16'h820; addr += 4)
+  begin
+    TSK_REG_WRITE(xdma_bar, addr, wr_data[iter], 4'hF);
+    iter ++;
+  end
+  //-------------- Write CXTX to Function Map -----------------------------------------
+  // Writing in the CTXT CMD register issues a command for the context.
+  // In this case, it writes the content of the context to the Function Map.
+  wr_data[0][31:18] = 'h0; // reserved
+  wr_data[0][17:7]  = 11'h0 | fnc[7:0]; // fnc
+  wr_data[0][6:5]   = 2'h1; // MDMA_CTXT_CMD_WR
+  wr_data[0][4:1]   = 4'hC; // QDMA_CTXT_SELC_FMAP
+  wr_data[0][0]     = 'h0;
+  TSK_REG_WRITE(xdma_bar, 32'h844, wr_data[0], 4'hF);
+
+
+
+  // AXI-MM Transfer start
+  $display(" *** QDMA H2C *** \n");
+
+  // Here, it writes the H2C descriptor SW context
+  //-------------- Ind Direct AXI-MM H2C CTXT DATA -------------------
+  wr_dat[255:140] = 'd0;
+  wr_dat[139]     = 'd0;    // int_aggr
+  wr_dat[138:128] = 'd1;    // vec MSI-X Vector
+  wr_dat[127:64]  =  (64'h0 | H2C_ADDR); // dsc base
+  wr_dat[63]      =  1'b1;  // is_mm
+  wr_dat[62]      =  1'b0;  // mrkr_dis
+  wr_dat[61]      =  1'b0;  // irq_req
+  wr_dat[60]      =  1'b0;  // err_wb_sent
+  wr_dat[59:58]   =  2'b0;  // err
+  wr_dat[57]      =  1'b0;  // irq_no_last
+  wr_dat[56:54]   =  3'h0;  // port_id
+  wr_dat[53]      =  irq_en;  // irq_en
+  wr_dat[52]      =  1'b1;  // wbk_en
+  wr_dat[51]      =  1'b0;  // mm_chn
+  wr_dat[50]      =  dsc_bypass ? 1'b1 : 1'b0;  // bypass
+  wr_dat[49:48]   =  2'b10; // dsc_sz, 32bytes
+  wr_dat[47:44]   =  4'h1;  // rng_sz
+  wr_dat[43:41]   =  3'h0;  // reserved
+  wr_dat[40:37]   =  4'h0;  // fetch_max
+  wr_dat[36]      =  1'b0;  // atc
+  wr_dat[35]      =  1'b0;  // wbi_intvl_en
+  wr_dat[34]      =  1'b1;  // wbi_chk
+  wr_dat[33]      =  1'b0;  // fcrd_en
+  wr_dat[32]      =  1'b1;  // qen
+  wr_dat[31:25]   =  7'h0;  // reserved
+  wr_dat[24:17]   =  {4'h0,pfTestIteration[3:0]}; // func_id
+  wr_dat[16]      =  1'b0;  // irq_arm
+  wr_dat[15:0]    =  16'b0; // pidx
+
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h804, wr_dat[31 :0 ], 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h808, wr_dat[63 :32], 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h80C, wr_dat[95 :64], 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h810, wr_dat[127:96], 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h814, wr_dat[159:128], 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h818, wr_dat[191:160], 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h81C, wr_dat[223:192], 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h820, wr_dat[255:224], 4'hF);
+
+  //-------------- Ind Dire CTXT CMD 0x844 [17:7] Qid : 0 [17:7} : CMD MDMA_CTXT_CMD_WR=1 ---------
+  // [17:7] QID   00
+  // [6:5 ] MDMA_CTXT_CMD_WR=1 : 01
+  // [4:1]  MDMA_CTXT_SELC_DSC_SW_H2C = 1 : 0001
+  // 0      BUSY : 0
+  //        00000000000_01_0001_0 : 0x22
+  wr_dat = {14'h0,axi_mm_q[10:0],7'b0100010};
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h844, wr_dat[31:0], 4'hF);
+
+
+
+  //-------------- ARM H2C transfer 0x1204 MDMA_H2C_MM0_CONTROL set to run--------
+  // Writing to this register simply starts the execution of the DMA
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h1204, 32'h00000001, 4'hF);
+
+
+
+  //-------------- Start DMA tranfer ------------------------------------------------------
+  $display(" **** Start AXI-MM H2C transfer ***\n");
+
+  for (iter=0; iter < NUM_ITER; iter=iter+1) begin
+    fork
+      //-------------- Writ PIDX to 1 to transfer 1 descriptor ----------------
+      
+      // Putting the producer index into the PIXD address. I guess it's enough to use it.
+      //write address
+      $display("[%t] : Writing to PIDX register", $realtime);
+      pidx = pidx +1;
+      wr_add = QUEUE_PTR_PF_ADDR + (axi_mm_q* 16) + 4;            // Xilinx says: 32'h00006404
+      $display("Address where it puts the pixd: %x\n", wr_add);   // What I see:  32'h00018014
+      board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, wr_add[31:0], {irq_en, pidx[15:0]} | 32'h0, 4'hF);   // Write 1 PIDX
+
+      //-------------- compare H2C data -------------------------------------------------------
+      $display("------Compare H2C AXI-MM Data--------\n");
+      board.RP.tx_usrapp.COMPARE_DATA_H2C(board.RP.tx_usrapp.DMA_BYTE_CNT,768);    //input payload bytes
+    join
+
+    // Waits until the back status is the one it expects
+    //board.RP.tx_usrapp.COMPARE_TRANS_STATUS(32'h000011E0, pidx[15:0]);
+
+    board.RP.tx_usrapp.TSK_REG_READ(xdma_bar, 16'h1248);
+  end
+
+  $display("------AXI-MM H2C Completed--------\n");
+  #1000;
+end
+endtask
+
+task TSK_QDMA_MM_C2H_TEST;
+  input [10:0] qid;
+  input dsc_bypass;
+  input irq_en;
+
+  reg [11:0] q_count;
+  reg [10:0] q_base;
+  reg [15:0] pidx;
+  localparam NUM_ITER = 1; // Max 8
+  integer    iter;
+begin
+
+  //------------- This test performs a 32 bit write to a 32 bit Memory space and performs a read back
+
+	//----------------------------------------------------------------------------------------
+	// QDMA AXI-MM C2H Test Starts
+	//----------------------------------------------------------------------------------------
+  $display("------AXI-MM C2H Tests start--------\n");
+
+  $display(" **** read Address at BAR0  = %h\n", board.RP.tx_usrapp.BAR_INIT_P_BAR[0][31:0]);
+  $display(" **** read Address at BAR1  = %h\n", board.RP.tx_usrapp.BAR_INIT_P_BAR[1][31:0]);
+
+  // Global programming
+  //
+  // Assign Q 0 for AXI-MM
+  axi_mm_q = qid;
+  q_base   = QUEUE_PER_PF * fnc;
+  q_count  = QUEUE_PER_PF;
+  pidx = 0;
+
+	//-------------- DMA Engine ID Read -----------------------------------------------------
+  board.RP.tx_usrapp.TSK_REG_READ(xdma_bar, 16'h00);
+
+  // enable dsc bypass loopback
+  if(dsc_bypass)
+    board.RP.tx_usrapp.TSK_REG_WRITE(user_bar, 32'h90, 32'h3, 4'hF);
+
+  // initilize all ring size to some value.
+  //-------------- Global Ring Size for Queue 0  0x204  : num of dsc 16 ------------------------
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h204, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h208, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h20C, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h210, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h214, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h218, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h21C, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h220, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h224, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h228, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h22C, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h230, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h234, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h238, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h23C, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h240, 32'h00000010, 4'hF);
+
+  //-------------- Clear HW CXTX for C2H for Qid -----------------------------------------
+  wr_dat[31:18] = 'h0; // reserved
+  wr_dat[17:7]  = axi_mm_q[10:0]; // qid
+  wr_dat[6:5]   = 2'h0; // MDMA_CTXT_CMD_CLR
+  wr_dat[4:1]   = 4'h2; // MDMA_CTXT_SELC_DSC_HW_C2H
+  wr_dat[0]     = 'h0;
+
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h844, wr_dat[31:0], 4'hF);
+
+  // FMAP programing. set up 16Queues
+  wr_dat[31:0]   = 32'h0 | q_base;
+  wr_dat[63:32]  = 32'h0 | q_count;
+  wr_dat[255:64] = 'h0;
+
+  TSK_REG_WRITE(xdma_bar, 16'h804, wr_dat[31 :0 ], 4'hF);
+  TSK_REG_WRITE(xdma_bar, 16'h808, wr_dat[63 :32], 4'hF);
+  TSK_REG_WRITE(xdma_bar, 16'h80C, wr_dat[95 :64], 4'hF);
+  TSK_REG_WRITE(xdma_bar, 16'h810, wr_dat[127:96], 4'hF);
+  TSK_REG_WRITE(xdma_bar, 16'h814, wr_dat[159:128], 4'hF);
+  TSK_REG_WRITE(xdma_bar, 16'h818, wr_dat[191:160], 4'hF);
+  TSK_REG_WRITE(xdma_bar, 16'h81C, wr_dat[223:192], 4'hF);
+  TSK_REG_WRITE(xdma_bar, 16'h820, wr_dat[255:224], 4'hF);
+
+  wr_dat[31:18] = 'h0; // reserved
+  wr_dat[17:7]  = 11'h0 | fnc[7:0]; // fnc
+  wr_dat[6:5]   = 2'h1; // MDMA_CTXT_CMD_WR
+  wr_dat[4:1]   = 4'hC; // QDMA_CTXT_SELC_FMAP
+  wr_dat[0]     = 'h0;
+  TSK_REG_WRITE(xdma_bar, 32'h844, wr_dat[31:0], 4'hF);
+
+//for(pf_loop_index=0; pf_loop_index <= pfTestIteration; pf_loop_index = pf_loop_index + 1)
+//begin
+//  if(pf_loop_index == pfTestIteration) begin
+//    board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h400+(pf_loop_index*4), 32'h00008000, 4'hF);
+//  end else begin
+//    board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h400+(pf_loop_index*4), 32'h00000000, 4'hF);
+//  end
+//end
+
+  if(irq_en == 1'b1) begin
+    TSK_PROGRAM_MSIX_VEC_TABLE (0);
+  end
+
+  //-------------- Ind Dire CTXT MASK 0x814  0xffffffff for all 128 bits -------------------
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h824, 32'hffffffff, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h828, 32'hffffffff, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h82C, 32'hffffffff, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h830, 32'hffffffff, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h834, 32'hffffffff, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h838, 32'hffffffff, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h83C, 32'hffffffff, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h840, 32'hffffffff, 4'hF);
+
+  //-------------- Load DATA in Buffer ----------------------------------------------------
+  // C2H DSC starts at 0x0800 (2048)
+  // C2H data starts at 0x0A00 (2560)
+  board.RP.tx_usrapp.TSK_INIT_QDMA_MM_DATA_C2H;
+
+  //-------------- Ind Direer AXI-MM C2H CTXT DATA -------------------
+  wr_dat[255:140] = 'd0;
+  wr_dat[139]     = 'd0;    // int_aggr
+  wr_dat[138:128] = 'd2;    // vec MSI-X Vector
+  wr_dat[127:64]  =  (64'h0 | C2H_ADDR); // dsc base
+  wr_dat[63]      =  1'b1;  // is_mm
+  wr_dat[62]      =  1'b0;  // mrkr_dis
+  wr_dat[61]      =  1'b0;  // irq_req
+  wr_dat[60]      =  1'b0;  // err_wb_sent
+  wr_dat[59:58]   =  2'b0;  // err
+  wr_dat[57]      =  1'b0;  // irq_no_last
+  wr_dat[56:54]   =  3'h0;  // port_id
+  wr_dat[53]      =  irq_en;  // irq_en
+  wr_dat[52]      =  1'b1;  // wbk_en
+  wr_dat[51]      =  1'b0;  // mm_chn
+  wr_dat[50]      =  dsc_bypass ? 1'b1 : 1'b0;  // bypass
+  wr_dat[49:48]   =  2'b10; // dsc_sz, 32bytes
+  wr_dat[47:44]   =  4'h1;  // rng_sz
+  wr_dat[43:40]   =  4'h0;  // reserved
+  wr_dat[39:37]   =  3'h0;  // fetch_max
+  wr_dat[36]      =  1'b0;  // atc
+  wr_dat[35]      =  1'b0;  // wbi_intvl_en
+  wr_dat[34]      =  1'b1;  // wbi_chk
+  wr_dat[33]      =  1'b0;  // fcrd_en
+  wr_dat[32]      =  1'b1;  // qen
+  wr_dat[31:25]   =  7'h0;  // reserved
+  wr_dat[24:17]   =  {4'h0,pfTestIteration[3:0]}; // func_id
+  wr_dat[16]      =  1'b0;  // irq_arm
+  wr_dat[15:0]    =  16'b0; // pidx
+
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h804, wr_dat[31 :0] , 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h808, wr_dat[63 :32], 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h80C, wr_dat[95 :64], 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h810, wr_dat[127:96], 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h814, wr_dat[159:128], 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h818, wr_dat[191:160], 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h81C, wr_dat[223:192], 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h820, wr_dat[255:224], 4'hF);
+
+  //-------------- Ind Dire CTXT CMD 0x844 [17:7] Qid : 1 [17:7] : CMD MDMA_CTXT_CMD_WR=1 ---------
+  // [17:7] QID   00
+  // [6:5 ] MDMA_CTXT_CMD_WR=1 : 01
+  // [4:1]  MDMA_CTXT_SELC_DSC_SW_C2H = 0 : 0000
+  // 0      BUSY : 0
+  //        00000000000_01_0000_0 : 0010_0000 : 0x20
+  wr_dat = {14'h0,axi_mm_q[10:0],7'b0100000};
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h844, wr_dat[31:0], 4'hF);
+
+  //-------------- ARM C2H transfer 0x1004 MDMA_C2H_MM0_CONTROL set to run--------
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h1004, 32'h00000001, 4'hF);
+
+  //-------------- Start DMA tranfer ------------------------------------------------------
+  $display(" **** Start DMA C2H transfer ***\n");
+
+  for (iter=0; iter < NUM_ITER; iter=iter+1) begin
+    fork
+      //-------------- Write PIDX to 1 to transfer 1 descriptor in C2H ----------------
+      $display("[%t] : Writing to PIDX register", $realtime);
+      pidx = pidx + 1;
+      wr_add = QUEUE_PTR_PF_ADDR + (axi_mm_q* 16) + 8;  // 32'h00006408
+      board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, wr_add[31:0], {irq_en, pidx[15:0]} | 32'h0, 4'hF); // Write 1 PIDX
+
+      //compare C2H data
+      $display("------Compare C2H AXI-MM Data--------\n");
+      // for coparision H2C data is stored in 768
+      board.RP.tx_usrapp.COMPARE_DATA_C2H(board.RP.tx_usrapp.DMA_BYTE_CNT,768);
+    join
+      //board.RP.tx_usrapp.COMPARE_TRANS_STATUS(32'h000021E0, pidx[15:0]);
+      board.RP.tx_usrapp.TSK_REG_READ(xdma_bar, 16'h1048);
+      $display ("**** C2H Decsriptor Count = %h\n", P_READ_DATA);
+    end
+    $display("------AXI-MM C2H Completed--------\n");
+  end
+endtask
+
+/*
+// AXI-St C2H test
+*/
+task TSK_QDMA_ST_C2H_TEST;
+  input [10:0] qid;
+  input dsc_bypass;
+  reg [11:0] q_count;
+  reg [10:0] q_base;
+begin
+  axi_st_q = qid;
+  q_base   = QUEUE_PER_PF * fnc;
+  q_count  = QUEUE_PER_PF;
+
+  // Write Q number for AXI-ST C2H transfer
+  // board.RP.tx_usrapp.TSK_REG_WRITE(user_bar, 32'h0, {21'h0,axi_st_q[10:0]}, 4'hF);   // Write Q num to user side
+
+  $display ("\n");
+  $display ("******* AXI-ST C2H transfer START ******** \n");
+  $display ("\n");
+  //-------------- Load DATA in Buffer for aXI-ST H2C----------------------------------------------------
+  board.RP.tx_usrapp.TSK_INIT_QDMA_ST_DATA_H2C_NEW;
+
+  //-------------- Load DATA in Buffer for AXI-ST C2H ----------------------------------------------------
+  // AXI-St C2H Descriptor is at address 0x0800 (2048)
+  // AXI-St C2H Data       is at address 0x0A00 (2560)
+  board.RP.tx_usrapp.TSK_INIT_QDMA_ST_DATA_C2H;
+
+  // AXI-St C2H CMPT Data   is at address 0x1000 (2048)
+  board.RP.tx_usrapp.TSK_INIT_QDMA_ST_CMPT_C2H;     // addrss 0x1000 (2048)
+
+  // enable dsc bypass loopback
+  // if(dsc_bypass)
+    // board.RP.tx_usrapp.TSK_REG_WRITE(user_bar, 32'h90, 32'h3, 4'hF);
+
+  // initilize all ring size to some value.
+  //-------------- Global Ring Size for Queue 0  0x204  : num of dsc 16 ------------------------
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h204, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h208, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h20C, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h210, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h214, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h218, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h21C, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h220, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h224, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h228, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h22C, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h230, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h234, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h238, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h23C, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h240, 32'h00000010, 4'hF);
+
+  // FMAP programing. set up 16Queues
+  wr_dat[31:0]   = 32'h0 | q_base;
+  wr_dat[63:32]  = 32'h0 | q_count;
+  wr_dat[255:64] = 'h0;
+
+  TSK_REG_WRITE(xdma_bar, 16'h804, wr_dat[31 :0 ], 4'hF);
+  TSK_REG_WRITE(xdma_bar, 16'h808, wr_dat[63 :32], 4'hF);
+  TSK_REG_WRITE(xdma_bar, 16'h80C, wr_dat[95 :64], 4'hF);
+  TSK_REG_WRITE(xdma_bar, 16'h810, wr_dat[127:96], 4'hF);
+  TSK_REG_WRITE(xdma_bar, 16'h814, wr_dat[159:128], 4'hF);
+  TSK_REG_WRITE(xdma_bar, 16'h818, wr_dat[191:160], 4'hF);
+  TSK_REG_WRITE(xdma_bar, 16'h81C, wr_dat[223:192], 4'hF);
+  TSK_REG_WRITE(xdma_bar, 16'h820, wr_dat[255:224], 4'hF);
+
+  wr_dat[31:18] = 'h0; // reserved
+  wr_dat[17:7]  = 11'h0 | fnc[7:0]; // fnc
+  wr_dat[6:5]   = 2'h1; // MDMA_CTXT_CMD_WR
+  wr_dat[4:1]   = 4'hC; // QDMA_CTXT_SELC_FMAP
+  wr_dat[0]     = 'h0;
+  TSK_REG_WRITE(xdma_bar, 32'h844, wr_dat[31:0], 4'hF);
+
+  //-------------- Clear HW CXTX for H2C and C2H first for Q1 ------------------------------------
+  // [17:7] QID   01
+  // [6:5 ] MDMA_CTXT_CMD_CLR=0 : 00
+  // [4:1]  MDMA_CTXT_SELC_DSC_HW_H2C = 3 : 0011
+  // 0      BUSY : 0
+  //        00000000001_00_0011_0 : _1000_0110 : 0x86
+  wr_dat = {14'h0,axi_st_q[10:0],7'b0000110};
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h844, wr_dat[31:0], 4'hF);
+
+  // [17:7] QID   01
+  // [6:5 ] MDMA_CTXT_CMD_CLR=0 : 00
+  // [4:1]  MDMA_CTXT_SELC_DSC_HW_C2H = 2 : 0010
+  // 0      BUSY : 0
+  //        00000000001_00_0010_0 : _1000_0100 : 0x84
+  wr_dat = {14'h0,axi_st_q[10:0],7'b0000100};
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h844, wr_dat[31:0], 4'hF);
+
+  $display ("******* Program C2H Global and Context values ******** \n");
+  // Setup Stream H2C context
+  //-------------- Ind Dire CTXT MASK 0xffffffff for all 256 bits -------------------
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h824, 32'hffffffff, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h828, 32'hffffffff, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h82C, 32'hffffffff, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h830, 32'hffffffff, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h834, 32'hffffffff, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h838, 32'hffffffff, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h83C, 32'hffffffff, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h840, 32'hffffffff, 4'hF);
+
+  // Program AXI-ST C2H
+  //-------------- Program C2H CMPT timer Trigger to 1 ----------------------------------------------
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'hA00, 32'h00000001, 4'hF);
+
+  //-------------- Program C2H CMPT Counter Threshold to 1 ----------------------------------------------
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'hA40, 32'h00000001, 4'hF);
+
+  //-------------- Program C2H DSC buffer size to 4K ----------------------------------------------
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'hAB0, 32'h00001000, 4'hF);
+
+  // setup Stream C2H context
+  //-------------- C2H CTXT DATA -------------------
+  // ring size index is at 1
+  //
+  wr_dat[255:128] = 'd0;
+  wr_dat[127:64]  =  (64'h0 | C2H_ADDR); // dsc base
+  wr_dat[63]      =  1'b0;  // is_mm
+  wr_dat[62]      =  1'b0;  // mrkr_dis
+  wr_dat[61]      =  1'b0;  // irq_req
+  wr_dat[60]      =  1'b0;  // err_wb_sent
+  wr_dat[59:58]   =  2'b0;  // err
+  wr_dat[57]      =  1'b0;  // irq_no_last
+  wr_dat[56:54]   =  3'h0;  // port_id
+  wr_dat[53]      =  1'b0;  // irq_en
+  wr_dat[52]      =  1'b1;  // wbk_en
+  wr_dat[51]      =  1'b0;  // mm_chn
+  wr_dat[50]      =  dsc_bypass ? 1'b1 : 1'b0;  // bypass
+  wr_dat[49:48]   =  2'b00; // dsc_sz, 8bytes
+  wr_dat[47:44]   =  4'h1;  // rng_sz
+  wr_dat[43:41]   =  3'h0;  // reserved
+  wr_dat[40:37]   =  4'h0;  // fetch_max
+  wr_dat[36]      =  1'b0;  // atc
+  wr_dat[35]      =  1'b0;  // wbi_intvl_en
+  wr_dat[34]      =  1'b1;  // wbi_chk
+  wr_dat[33]      =  1'b1;  // fcrd_en
+  wr_dat[32]      =  1'b1;  // qen
+  wr_dat[31:25]   =  7'h0;  // reserved
+  wr_dat[24:17]   =  {4'h0,pfTestIteration[3:0]}; // func_id
+  wr_dat[16]      =  1'b0;  // irq_arm
+  wr_dat[15:0]    =  16'b0; // pidx
+
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h804, wr_dat[31 :0], 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h808, wr_dat[63 :32], 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h80C, wr_dat[95 :64], 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h810, wr_dat[127:96], 4'hF);
+
+  //-------------- Ind Dire CTXT CMD 0x844 [17:7] Qid : 0 [17:7} : CMD MDMA_CTXT_CMD_WR=1 ---------
+  // [17:7] QID : 2
+  // [6:5 ] MDMA_CTXT_CMD_WR=1 : 01
+  // [4:1]  MDMA_CTXT_SELC_DSC_SW_C2H = 0 : 0000
+  // 0      BUSY : 0
+  //        00000000001_01_0000_0 : 1010_0000 : 0xA0
+  wr_dat = {14'h0,axi_st_q[10:0],7'b0100000};
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h844, wr_dat[31:0], 4'hF);
+
+  //-------------- Completion  CTXT DATA -------------------
+  wr_dat[0]      = 1;      // en_stat_desc = 1
+  wr_dat[1]      = 0;      // en_int = 0
+  wr_dat[4:2]    = 3'h1;   // trig_mode = 3'b001
+  wr_dat[12:5]   = {4'h0,pfTestIteration[3:0]};   // function ID
+  wr_dat[16:13]  = 4'h0;   // reserved
+  wr_dat[20:17]  = 4'h0;   // countr_idx  = 4'b0000
+  wr_dat[24:21]  = 4'h0;   // timer_idx = 4'b0000
+  wr_dat[26:25]  = 2'h0;   // int_st = 2'b00
+  wr_dat[27]     = 1'h1;   // color = 1
+  wr_dat[31:28]  = 4'h0;   // size_64 = 4'h0
+  wr_dat[89:32]  = (58'h0 | CMPT_ADDR[31:6]);  // baddr_64 = [63:6]only
+  wr_dat[91:90]  = 2'h0;   // desc_size = 2'b00
+  wr_dat[107:92] = 16'h0;  // pidx 16
+  wr_dat[123:108]= 16'h0;  // Cidx 16
+  wr_dat[124]    = 1'h1;   // valid = 1
+  wr_dat[126:125]= 2'h0;   // err
+  wr_dat[127]    = 'h0;    // user_trig_pend
+  wr_dat[128]    = 'h0;    // timer_running
+  wr_dat[129]    = 'h0;    // full_upd
+  wr_dat[130]    = 'h0;    // ovf_chk_dis
+  wr_dat[131]    = 'h0;    // at
+  wr_dat[142:132]= 'd4;   // vec MSI-X Vector
+  wr_dat[143]     = 'd0;   // int_aggr
+  wr_dat[144]     = 'h0;   // dis_intr_on_vf
+  wr_dat[145]     = 'h0;   // vio
+  wr_dat[146]     = 'h1;   // dir_c2h ; 1 = C2H, 0 = H2C direction
+  wr_dat[150:147] = 'h0;   // reserved
+  wr_dat[173:151] = 'h0;   // reserved
+  wr_dat[174]     = 'h0;   // reserved
+  wr_dat[178:175] = 'h0 | CMPT_ADDR[5:2];   // reserved
+  wr_dat[179]     = 'h0 ;  // sh_cmpt
+  wr_dat[255:180] = 'h0;   // reserved
+
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h804, wr_dat[31:0], 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h808, wr_dat[63:32], 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h80C, wr_dat[95:64], 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h810, wr_dat[127:96], 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h814, wr_dat[159:128], 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h818, wr_dat[191:160], 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h81C, wr_dat[223:192], 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h820, wr_dat[255:224], 4'hF);
+
+  //-------------- Ind Dire CTXT CMD 0x844 [17:7] Qid : 0 [17:7} : CMD MDMA_CTXT_CMD_WR=1 ---------
+  // [17:7] QID   01
+  // [6:5 ] MDMA_CTXT_CMD_WR=1 : 01
+  // [4:1]  MDMA_CTXT_SELC_CMPT = 6 : 0110
+  // 0      BUSY : 0
+  //        00000000001_01_0110_0 : 1010_1100 : 0xAC
+  wr_dat = {14'h0,axi_st_q[10:0],7'b0101100};
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h844, wr_dat[31:0], 4'hF);
+
+  // Also update CIDX 0x00 for CMPT context
+  wr_dat[31:29] = 4'h0;   // reserver = 0
+  wr_dat[28]    = 4'h0;   // irq_en_wrb = 0
+  wr_dat[27]    = 1'b1;   // en_stat_desc = 1
+  wr_dat[26:24] = 3'h1;   // trig_mode = 3'001 (every)
+  wr_dat[23:20] = 4'h0;   // timer_idx = 4'h0
+  wr_dat[19:16] = 4'h0;   // counter_idx = 4'h0
+  wr_dat[15:0]  = 16'h0;  //sw_cidx = 16'h0000
+
+  wr_add = QUEUE_PTR_PF_ADDR + (axi_st_q* 16) + 12;  // 32'h0000641C
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, wr_add[31:0], wr_dat[31:0], 4'hF);
+
+  //-------------- PreFetch CTXT DATA -------------------
+  // valid = 1
+  // all 0's
+  // 0010_0000_0000_0000 => 2000
+  wr_dat[0]      = 1'b0;  // bypass
+  wr_dat[4:1]    = 4'h0;  // buf_size_idx
+  wr_dat[7 :5]   = 3'h0;  // port_id
+  wr_dat[8]      = 1'h0;  // var_desc. set to 0.
+  wr_dat[9]      = 1'h0;  // virtio
+  wr_dat[15:10]  = 5'h0;  // num_pfch
+  wr_dat[21:16]  = 5'h0;  // pfch_need
+  wr_dat[25:22]  = 4'h0;  // reserverd
+  wr_dat[26]     = 1'h0;  // error
+  wr_dat[27]     = 1'h0;  // prefetch enable
+  wr_dat[28]     = 1'b0;  // prefetch (Q is in prefetch)
+  wr_dat[44 :29] = 16'h0; // sw_crdt
+  wr_dat[45]     = 1'b1;  // valid
+  wr_dat[245:46] = 'h0;
+
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h804, wr_dat[31:0], 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h808, wr_dat[63:32], 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h80C, wr_dat[95:64], 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h810, wr_dat[127:96], 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h814, wr_dat[159:128], 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h818, wr_dat[191:160], 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h81C, wr_dat[223:192], 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h820, wr_dat[255:224], 4'hF);
+
+  //-------------- Ind Dire CTXT CMD 0x844 [17:7] Qid : 0 [17:7} : CMD MDMA_CTXT_CMD_WR=1 ---------
+  // [17:7] QID   01
+  // [6:5 ] MDMA_CTXT_CMD_WR=1 : 01
+  // [4:1]  MDMA_CTXT_SELC_PFTCH = 7 : 0111
+  // 0      BUSY : 0
+  //        00000000001_01_0111_0 : 1010_1110 : 0xAE
+  wr_dat = {14'h0,axi_st_q[10:0],7'b0101110};
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h844, wr_dat[31:0], 4'hF);
+
+  // Transfer C2H for 1 dsc
+
+  //-------------- Write PIDX to 1 to transfer 1 descriptor in C2H ----------------
+  //  There is no run bit for AXI-Stream, no need to arm them.
+  $display(" **** Enable PIDX for C2H first ***\n");
+  $display("[%t] : Writing to PIDX register", $realtime);
+  wr_add = QUEUE_PTR_PF_ADDR + (axi_st_q* 16) + 8;  // 32'h00006418
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, wr_add[31:0], 32'h0a, 4'hF);   // Write 0x0a PIDX
+
+  // @(board.RP.s_axis_cc_tlast) //Wait to send descriptor to QDMA
+
+  // Initiate C2H tranfer on user side.
+  // TSK_TX_CLK_EAT(1000);
+  $display("[%t] : Sending packet to CMAC", $realtime);
+  board.TSK_SEND_PACKET_CMAC();
+
+  // board.RP.tx_usrapp.TSK_REG_WRITE(user_bar, 32'h20, 32'h1, 4'hF);   // send 1 packets
+
+  // board.RP.tx_usrapp.TSK_REG_WRITE(user_bar, 32'h04, {16'h0,board.RP.tx_usrapp.DMA_BYTE_CNT}, 4'hF);   // C2H length 128 bytes //
+
+  // board.RP.tx_usrapp.TSK_REG_WRITE(user_bar, 32'h30, 32'ha4a3a2a1, 4'hF);   // Write back data
+  // board.RP.tx_usrapp.TSK_REG_WRITE(user_bar, 32'h34, 32'hb4b3b2b1, 4'hF);   // Write back data
+  // board.RP.tx_usrapp.TSK_REG_WRITE(user_bar, 32'h38, 32'hc4c3c2c1, 4'hF);   // Write back data
+  // board.RP.tx_usrapp.TSK_REG_WRITE(user_bar, 32'h3C, 32'hd4d3d2d1, 4'hF);   // Write back data
+  // board.RP.tx_usrapp.TSK_REG_WRITE(user_bar, 32'h40, 32'he4e3e2e1, 4'hF);   // Write back data
+  // board.RP.tx_usrapp.TSK_REG_WRITE(user_bar, 32'h44, 32'hf4f3f2f1, 4'hF);   // Write back data
+  // board.RP.tx_usrapp.TSK_REG_WRITE(user_bar, 32'h48, 32'h14131211, 4'hF);   // Write back data
+  // board.RP.tx_usrapp.TSK_REG_WRITE(user_bar, 32'h4C, 32'h24232221, 4'hF);   // Write back data
+
+  // board.RP.tx_usrapp.TSK_REG_WRITE(user_bar, 32'h50, 32'h2, 4'hF);   // writeback data control to set 8B, 16B or 32B
+
+  // board.RP.tx_usrapp.TSK_REG_WRITE(user_bar, 32'h08, 32'h06, 4'hF);   // Start C2H tranfer and immediate data
+  // board.RP.tx_usrapp.TSK_REG_WRITE(user_bar, 32'h08, 32'h02, 4'hF);   // Start C2H tranfer
+
+  // compare C2H data
+  // $display("------Compare C2H AXI-ST 1st Data--------\n");
+
+  // compare data with H2C data in 768
+  board.RP.tx_usrapp.COMPARE_DATA_C2H(board.RP.tx_usrapp.DMA_BYTE_CNT,768);
+  // $display("------Compare Data C2H Finished----------\n");
+  $display("[%t] : Received packet in testbench", $realtime);
+
+  //Compare status writes
+  board.RP.tx_usrapp.COMPARE_TRANS_C2H_ST_STATUS(0, 16'h1, 1, 8); //Write back entry and write back status
+  // $display("------Compare Transaction C2H Status Finished----------\n");
+  $display("[%t] : Received completion data in testbench", $realtime);
+
+  //uptate CIDX for Write back
+  wr_add = QUEUE_PTR_PF_ADDR + (axi_st_q* 16) + 12;  // 32'h0000641C
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, wr_add[31:0], 32'h09000001, 4'hF);
+
+  $display("------AXI-ST C2H Completed--------\n");
+end
+endtask
+
+task TSK_QDMA_ST_H2C_TEST;
+  input [10:0] qid;
+  input dsc_bypass;
+
+  reg [11:0] q_count;
+  reg [10:0] q_base;
+begin
+  //
+  // now doing AXI-Stream Test for QDMA
+  //
+  // Assign Q 2 for AXI-ST
+  pf0_qmax = 11'h200;
+  // axi_st_q = 11'h2;
+  axi_st_q = qid;
+  q_base   = QUEUE_PER_PF * fnc;
+  q_count  = QUEUE_PER_PF;
+
+  // Write Q number for AXI-ST C2H transfer
+  // board.RP.tx_usrapp.TSK_REG_WRITE(user_bar, 32'h0, {21'h0,axi_st_q[10:0]}, 4'hF);   // Write Q num to user side
+
+  $display ("\n");
+  $display ("******* AXI-ST H2C transfer START ******** \n");
+  $display ("\n");
+  //-------------- Load DATA in Buffer for aXI-ST H2C----------------------------------------------------
+  // AXI-St H2C Descriptor is at address 0x0100 (256)
+  // AXI-St H2c Data       is at address 0x0300 (768)
+  board.RP.tx_usrapp.TSK_INIT_QDMA_ST_DATA_H2C_NEW;
+
+  //-------------- Load DATA in Buffer for AXI-ST C2H ----------------------------------------------------
+  // AXI-St C2H Descriptor is at address 0x0800 (2048)
+  // AXI-St C2H Data       is at address 0x0A00 (2560)
+  board.RP.tx_usrapp.TSK_INIT_QDMA_ST_DATA_C2H;
+  // AXI-St C2H CMPT Data   is at address 0x1000 (2048)
+  board.RP.tx_usrapp.TSK_INIT_QDMA_ST_CMPT_C2H;     // addrss 0x1000 (2048)
+
+  // enable dsc bypass loopback
+  if(dsc_bypass)
+    board.RP.tx_usrapp.TSK_REG_WRITE(user_bar, 32'h90, 32'h3, 4'hF);
+
+  // initilize all ring size to some value.
+  //-------------- Global Ring Size for Queue 0  0x204  : num of dsc 16 ------------------------
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h204, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h208, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h20C, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h210, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h214, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h218, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h21C, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h220, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h224, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h228, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h22C, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h230, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h234, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h238, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h23C, 32'h00000010, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h240, 32'h00000010, 4'hF);
+
+  // set up 16Queues
+  wr_dat[31:0]   = 32'h0 | q_base;
+  wr_dat[63:32]  = 32'h0 | q_count;
+  wr_dat[255:64] = 'h0;
+
+  TSK_REG_WRITE(xdma_bar, 16'h804, wr_dat[31 :0 ], 4'hF);
+  TSK_REG_WRITE(xdma_bar, 16'h808, wr_dat[63 :32], 4'hF);
+  TSK_REG_WRITE(xdma_bar, 16'h80C, wr_dat[95 :64], 4'hF);
+  TSK_REG_WRITE(xdma_bar, 16'h810, wr_dat[127:96], 4'hF);
+  TSK_REG_WRITE(xdma_bar, 16'h814, wr_dat[159:128], 4'hF);
+  TSK_REG_WRITE(xdma_bar, 16'h818, wr_dat[191:160], 4'hF);
+  TSK_REG_WRITE(xdma_bar, 16'h81C, wr_dat[223:192], 4'hF);
+  TSK_REG_WRITE(xdma_bar, 16'h820, wr_dat[255:224], 4'hF);
+
+  wr_dat[31:18] = 'h0; // reserved
+  wr_dat[17:7]  = 11'h0 | fnc[7:0]; // fnc
+  wr_dat[6:5]   = 2'h1; // MDMA_CTXT_CMD_WR
+  wr_dat[4:1]   = 4'hC; // QDMA_CTXT_SELC_FMAP
+  wr_dat[0]     = 'h0;
+  TSK_REG_WRITE(xdma_bar, 32'h844, wr_dat[31:0], 4'hF);
+
+  //-------------- Clear HW CXTX for H2C and C2H first for Q1 ------------------------------------
+  // [17:7] QID   01
+  // [6:5 ] MDMA_CTXT_CMD_CLR=0 : 00
+  // [4:1]  MDMA_CTXT_SELC_DSC_HW_H2C = 3 : 0011
+  // 0      BUSY : 0
+  //        00000000001_00_0011_0 : _1000_0110 : 0x86
+  wr_dat = {14'h0,axi_st_q[10:0],7'b0000110};
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h844, wr_dat[31:0], 4'hF);
+
+  // [17:7] QID   01
+  // [6:5 ] MDMA_CTXT_CMD_CLR=0 : 00
+  // [4:1]  MDMA_CTXT_SELC_DSC_HW_C2H = 2 : 0010
+  // 0      BUSY : 0
+  //        00000000001_00_0010_0 : _1000_0100 : 0x84
+  wr_dat = {14'h0,axi_st_q[10:0],7'b0000100};
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h844, wr_dat[31:0], 4'hF);
+
+  $display ("******* Program C2H Global and Context values ******** \n");
+  // Setup Stream H2C context
+  //-------------- Ind Dire CTXT MASK 0xffffffff for all 256 bits -------------------
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h824, 32'hffffffff, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h828, 32'hffffffff, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h82C, 32'hffffffff, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h830, 32'hffffffff, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h834, 32'hffffffff, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h838, 32'hffffffff, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h83C, 32'hffffffff, 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h840, 32'hffffffff, 4'hF);
+
+  //-------------- Ind Dire CTXT AXI-ST H2C -------------------
+  // ring size index is at 1
+  //
+  wr_dat[255:140] = 'd0;
+  wr_dat[139]     = 'd0;    // int_aggr
+  wr_dat[138:128] = 'd3;    // vec MSI-X Vector
+  wr_dat[127:64]  =  (64'h0 | H2C_ADDR); // dsc base
+  wr_dat[63]      =  1'b0;  // is_mm
+  wr_dat[62]      =  1'b0;  // mrkr_dis
+  wr_dat[61]      =  1'b0;  // irq_req
+  wr_dat[60]      =  1'b0;  // err_wb_sent
+  wr_dat[59:58]   =  2'b0;  // err
+  wr_dat[57]      =  1'b0;  // irq_no_last
+  wr_dat[56:54]   =  3'h0;  // port_id
+  wr_dat[53]      =  1'b0;  // irq_en
+  wr_dat[52]      =  1'b1;  // wbk_en
+  wr_dat[51]      =  1'b0;  // mm_chn
+  wr_dat[50]      =  dsc_bypass ? 1'b1 : 1'b0;  // bypass
+  wr_dat[49:48]   =  2'b01; // dsc_sz, 16bytes
+  wr_dat[47:44]   =  4'h1;  // rng_sz
+  wr_dat[43:41]   =  3'h0;  // reserved
+  wr_dat[40:37]   =  4'h0;  // fetch_max
+  wr_dat[36]      =  1'b0;  // atc
+  wr_dat[35]      =  1'b0;  // wbi_intvl_en
+  wr_dat[34]      =  1'b1;  // wbi_chk
+  wr_dat[33]      =  1'b0;  // fcrd_en
+  wr_dat[32]      =  1'b1;  // qen
+  wr_dat[31:25]   =  7'h0;  // reserved
+  wr_dat[24:17]   =  {4'h0,pfTestIteration[3:0]}; // func_id
+  wr_dat[16]      =  1'b0;  // irq_arm
+  wr_dat[15:0]    =  16'b0; // pidx
+
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h804, wr_dat[31 :0], 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h808, wr_dat[63 :32], 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h80C, wr_dat[95 :64], 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h810, wr_dat[127:96], 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h814, wr_dat[159:128], 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h818, wr_dat[191:160], 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h81C, wr_dat[223:192], 4'hF);
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h820, wr_dat[255:224], 4'hF);
+
+  //-------------- Ind Dire CTXT CMD 0x844 [17:7] Qid : 0 [17:7} : CMD MDMA_CTXT_CMD_WR=1 ---------
+  // [17:7] QID : 2
+  // [6:5 ] MDMA_CTXT_CMD_WR=1 : 01
+  // [4:1]  MDMA_CTXT_SELC_DSC_SW_H2C = 1 : 0001
+  // 0      BUSY : 0
+  //        00000000001_01_0001_0 : 1010_0010 : 0xA2
+  wr_dat = {14'h0,axi_st_q[10:0],7'b0100010};
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'h844, wr_dat[31:0], 4'hF);
+
+  // Program AXI-ST C2H
+  //-------------- Program C2H CMPT timer Trigger to 1 ----------------------------------------------
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'hA00, 32'h00000001, 4'hF);
+
+  //-------------- Program C2H CMPT Counter Threshold to 1 ----------------------------------------------
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'hA40, 32'h00000001, 4'hF);
+
+  //-------------- Program C2H DSC buffer size to 4K ----------------------------------------------
+  board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, 16'hAB0, 32'h00001000, 4'hF);
+  // AXI-ST H2C transfer
+  //
+  // dummy clear H2c match
+  // board.RP.tx_usrapp.TSK_REG_WRITE(user_bar, 32'h0C, 32'h01, 4'hF);   // Dummy clear H2C match
+  //-------------- Start DMA H2C tranfer ------------------------------------------------------
+  $display(" **** Start DMA H2C AXI-ST transfer ***\n");
+
+  fork
+    //-------------- Write Queue 1 of PIDX to 1 to transfer 1 descriptor in H2C ----------------
+    wr_add = QUEUE_PTR_PF_ADDR + (axi_st_q* 16) + 4;  // 32'h00006414
+    board.RP.tx_usrapp.TSK_REG_WRITE(xdma_bar, wr_add[31:0], 32'h1, 4'hF);   // Write 1 PIDX
+
+    //compare H2C data
+    // $display("------Compare H2C AXI-ST Data--------\n");
+    // board.RP.tx_usrapp.COMPARE_TRANS_STATUS(32'h000010F0, 16'h1);
+  join
+
+  // check for if data on user side matched what was expected.
+  // board.RP.tx_usrapp.TSK_REG_READ(user_bar, 32'hB004);   // Read H2C status and Queue info.
+  // $display ("**** H2C Data Match Status = %h\n", P_READ_DATA);
+  // if(P_READ_DATA[0] == 1'b1) begin
+  //   $display ("[%t] : TEST PASSED ---**** Packet sent to CMAC", $realtime);
+  //   // $display("[%t] : Test Completed Successfully for PF{%d}",$realtime,pfTestIteration);
+  // end else begin
+  //   $display ("ERROR: [%t] : TEST FAILED ---****ERROR**** H2C Data Mis-Matches and H2C Q number = %h\n",$realtime, P_READ_DATA[10:4]);
+  //   board.RP.tx_usrapp.test_state =1;
+  // end
+  
+  @(posedge board.EP.m_axis_cmac_tx_sim_tlast);
+  @(posedge user_clk);
+  $display("[%t] : Received packet in CMAC", $realtime);
+  $display("------AXI-ST H2C Completed--------\n");
+  end
+endtask
+
+/************************************************************
+Task : TSK_TX_TYPE0_CONFIGURATION_READ
+Inputs : Tag, PCI/PCI-Express Reg Address, First BypeEn
+Outputs : Transaction Tx Interface Signaling
+Description : Generates a Type 0 Configuration Read TLP
+*************************************************************/
+task TSK_TX_TYPE0_CONFIGURATION_READ;
+  input [7:0]  tag_;         // Tag
+  input [11:0] reg_addr_;    // Register Number
+  input [3:0]  first_dw_be_; // First DW Byte Enable
+begin
+  if(user_lnk_up_n) begin
+    $display("[%t] :  interface is MIA", $realtime);
+    $finish;
+  end
+  TSK_TX_SYNCHRONIZE(0, 0, 0, `SYNC_RQ_RDY);
+  //--------- CFG TYPE-0 Read Transaction :                     -----------\\
+  s_axis_rq_tvalid <= #(Tcq) 1'b1;
+  s_axis_rq_tlast  <= #(Tcq) 1'b1;
+  s_axis_rq_tkeep  <= #(Tcq) 8'h0F; // 2DW Descriptor
+  s_axis_rq_tuser_wo_parity<= #(Tcq) {
+      //(AXISTEN_IF_RQ_PARITY_CHECK ?  s_axis_rq_tparity : 64'b0), // Parity
+      64'b0,       // Parity Bit slot - 64bit
+      6'b101010,   // Seq Number - 6bit
+      6'b101010,   // Seq Number - 6bit
+      16'h0000,    // TPH Steering Tag - 16 bit
+      2'b00,       // TPH indirect Tag Enable - 2bit
+      4'b0000,     // TPH Type - 4 bit
+      2'b00,       // TPH Present - 2 bit
+      1'b0,        // Discontinue
+      4'b0000,     // is_eop1_ptr
+      4'b0000,     // is_eop0_ptr
+      2'b01,       // is_eop[1:0]
+      2'b10,       // is_sop1_ptr[1:0]
+      2'b00,       // is_sop0_ptr[1:0]
+      2'b01,       // is_sop[1:0]
+      2'b00,2'b00, // Byte Lane number in case of Address Aligned mode - 4 bit
+      4'b0000,4'b0000, // Last BE of the Write Data -  8 bit
+      4'b0000,first_dw_be_ // First BE of the Write Data - 8 bit
+    };
+
+  s_axis_rq_tdata <= #(Tcq) {256'b0,128'b0, // 4DW unused             //256
+      1'b0,     // Force ECRC             //128
+      3'b000,   // Attributes {ID Based Ordering, Relaxed Ordering, No Snoop}
+      3'b000,   // Traffic Class
+      1'b1,     // RID Enable to use the Client supplied Bus/Device/Func No
+      EP_BUS_DEV_FNS,  // Completer ID
+      (ATTR_AXISTEN_IF_ENABLE_CLIENT_TAG ? 8'hCC : tag_), // Tag
+      RP_BUS_DEV_FNS,  // Requester ID  //96
+      (set_malformed ? 1'b1 : 1'b0), // Poisoned Req
+      4'b1000,         // Req Type for TYPE0 CFG READ Req
+      11'b00000000001, // DWORD Count
+      32'b0,           // Address *unused*       // 64
+      16'b0,           // Address *unused*       // 32
+      4'b0,            // Address *unused*
+      reg_addr_[11:2], // Extended + Base Register Number
+      2'b00};          // AT -> 00 : Untranslated Address
+
+  pcie_tlp_data <= #(Tcq) {
+      3'b000,   // Fmt for Type 0 Configuration Read Req
+      5'b00100, // Type for Type 0 Configuration Read Req
+      1'b0,     // *reserved*
+      3'b000,   // Traffic Class
+      1'b0,     // *reserved*
+      1'b0,     // Attributes {ID Based Ordering}
+      1'b0,     // *reserved*
+      1'b0,     // TLP Processing Hints
+      1'b0,     // TLP Digest Present
+      (set_malformed ? 1'b1 : 1'b0), // Poisoned Req
+      2'b00,    // Attributes {Relaxed Ordering, No Snoop}
+      2'b00,    // Address Translation
+      10'b0000000001,  // DWORD Count            //32
+      RP_BUS_DEV_FNS,  // Requester ID
+      (ATTR_AXISTEN_IF_ENABLE_CLIENT_TAG ? 8'hCC : tag_), // Tag
+      4'b0000,         // Last DW Byte Enable
+      first_dw_be_,    // First DW Byte Enable   //64
+      EP_BUS_DEV_FNS,  // Completer ID
+      4'b0000,         // *reserved*
+      reg_addr_[11:2], // Extended + Base Register Number
+      2'b00,    // *reserved* //96
+      32'b0 ,   // *unused*   //128
+      128'b0    // *unused*   //256
+    };
+
+  pcie_tlp_rem  <= #(Tcq)  3'b101;
+  set_malformed <= #(Tcq)  1'b0;
+  //-----------------------------------------------------------------------\\
+  TSK_TX_SYNCHRONIZE(1, 1, 1, `SYNC_RQ_RDY);
+  //-----------------------------------------------------------------------\\
+  s_axis_rq_tvalid  <= #(Tcq) 1'b0;
+  s_axis_rq_tlast   <= #(Tcq) 1'b0;
+  s_axis_rq_tkeep   <= #(Tcq) 8'h00;
+  s_axis_rq_tuser_wo_parity<= #(Tcq) 137'b0;
+  s_axis_rq_tdata   <= #(Tcq) 512'b0;
+  pcie_tlp_rem      <= #(Tcq) 3'b000;
+end
+endtask // TSK_TX_TYPE0_CONFIGURATION_READ
+
+/************************************************************
+Task : TSK_TX_TYPE0_CONFIGURATION_WRITE
+Inputs : Tag, PCI/PCI-Express Reg Address, First BypeEn
+Outputs : Transaction Tx Interface Signaling
+Description : Generates a Type 0 Configuration Write TLP
+*************************************************************/
+
+task TSK_TX_TYPE0_CONFIGURATION_WRITE;
+  input  [7:0] tag_; // Tag
+  input [11:0] reg_addr_; // Register Number
+  input [31:0] reg_data_; // Data
+  input  [3:0] first_dw_be_; // First DW Byte Enable
+begin
+  //-----------------------------------------------------------------------\\
+  if(user_lnk_up_n) begin
+    $display("[%t] :  interface is MIA", $realtime);
+    $finish(1);
+  end
+  //-----------------------------------------------------------------------\\
+  TSK_TX_SYNCHRONIZE(0, 0, 0, `SYNC_RQ_RDY);
+  //--------- TYPE-0 CFG Write Transaction :                     -----------\\
+  s_axis_rq_tvalid <= #(Tcq) 1'b1;
+  s_axis_rq_tlast  <= #(Tcq) (AXISTEN_IF_RQ_ALIGNMENT_MODE == "TRUE") ?  1'b0 : 1'b1;
+  s_axis_rq_tkeep  <= #(Tcq) (AXISTEN_IF_RQ_ALIGNMENT_MODE == "TRUE") ?  8'hFF : 8'h1F;       // 2DW Descriptor
+  s_axis_rq_tuser_wo_parity<= #(Tcq) {
+      //(AXISTEN_IF_RQ_PARITY_CHECK ?  s_axis_rq_tparity : 64'b0), // Parity
+      64'b0,       // Parity Bit slot - 64bit
+      6'b101010,   // Seq Number - 6bit
+      6'b101010,   // Seq Number - 6bit
+      16'h0000,    // TPH Steering Tag - 16 bit
+      2'b00,       // TPH indirect Tag Enable - 2bit
+      4'b0000,     // TPH Type - 4 bit
+      2'b00,       // TPH Present - 2 bit
+      1'b0,        // Discontinue
+      4'b0000,     // is_eop1_ptr
+      4'b0000,     // is_eop0_ptr
+      2'b01,       // is_eop[1:0]
+      2'b10,       // is_sop1_ptr[1:0]
+      2'b00,       // is_sop0_ptr[1:0]
+      2'b01,       // is_sop[1:0]
+      2'b00,2'b00, // Byte Lane number in case of Address Aligned mode - 4 bit
+      4'b0000,4'b0000, // Last BE of the Write Data -  8 bit
+      4'b0000,first_dw_be_ // First BE of the Write Data - 8 bit
+    };
+
+    s_axis_rq_tdata <= #(Tcq) {256'b0,96'b0,           // 3 DW unused            //256
+      ((AXISTEN_IF_RQ_ALIGNMENT_MODE=="FALSE")? {reg_data_[31:24], reg_data_[23:16], reg_data_[15:8], reg_data_[7:0]} : 32'h0), // Data
+      1'b0,            // Force ECRC             //128
+      3'b000,          // Attributes {ID Based Ordering, Relaxed Ordering, No Snoop}
+      3'b000,          // Traffic Class
+      1'b1,            // RID Enable to use the Client supplied Bus/Device/Func No
+      EP_BUS_DEV_FNS,  // Completer ID
+      (ATTR_AXISTEN_IF_ENABLE_CLIENT_TAG ? 8'hCC : tag_), // Tag
+      RP_BUS_DEV_FNS,  // Requester ID           //96
+      (set_malformed ? 1'b1 : 1'b0), // Poisoned Req
+      4'b1010,         // Req Type for TYPE0 CFG Write Req
+      11'b00000000001, // DWORD Count
+      32'b0,           // Address *unused*       //64
+      16'b0,           // Address *unused*       //32
+      4'b0,            // Address *unused*
+      reg_addr_[11:2], // Extended + Base Register Number
+      2'b00};          // AT -> 00 : Untranslated Address
+
+    //-----------------------------------------------------------------------\\
+    pcie_tlp_data <= #(Tcq) {
+        3'b010,   // Fmt for Type 0 Configuration Write Req
+        5'b00100, // Type for Type 0 Configuration Write Req
+        1'b0,     // *reserved*
+        3'b000,   // Traffic Class
+        1'b0,     // *reserved*
+        1'b0,     // Attributes {ID Based Ordering}
+        1'b0,     // *reserved*
+        1'b0,     // TLP Processing Hints
+        1'b0,     // TLP Digest Present
+        (set_malformed ? 1'b1 : 1'b0), // Poisoned Req
+        2'b00,    // Attributes {Relaxed Ordering, No Snoop}
+        2'b00,    // Address Translation
+        10'b0000000001,   // DWORD Count           //32
+        RP_BUS_DEV_FNS,   // Requester ID
+        (ATTR_AXISTEN_IF_ENABLE_CLIENT_TAG ? 8'hCC : tag_), // Tag
+        4'b0000,          // Last DW Byte Enable
+        first_dw_be_,     // First DW Byte Enable  //64
+        EP_BUS_DEV_FNS,   // Completer ID
+        4'b0000,          // *reserved*
+        reg_addr_[11:2],  // Extended + Base Register Number
+        2'b00,            // *reserved*            //96
+        reg_data_[7:0],   // Data
+        reg_data_[15:8],  // Data
+        reg_data_[23:16], // Data
+        reg_data_[31:24], // Data //128
+        128'b0      // *unused*  //256
+      };
+
+  pcie_tlp_rem             <= #(Tcq)  3'b100;
+  set_malformed            <= #(Tcq)  1'b0;
+
+  TSK_TX_SYNCHRONIZE(1, 1, 1, `SYNC_RQ_RDY);
+  //-----------------------------------------------------------------------\\
+  if(AXISTEN_IF_RQ_ALIGNMENT_MODE == "TRUE") begin
+     s_axis_rq_tvalid <= #(Tcq) 1'b1;
+     s_axis_rq_tlast  <= #(Tcq) 1'b1;
+     s_axis_rq_tkeep  <= #(Tcq) 8'h01;             // 2DW Descriptor
+     s_axis_rq_tdata  <= #(Tcq) {256'b0,128'b0,
+        32'b0, // *unused* //128
+        32'b0, // *unused* //96
+        32'b0, // *unused* //64
+        reg_data_[31:24], //32
+        reg_data_[23:16],
+        reg_data_[15:8],
+        reg_data_[7:0]
+      };
+
+    // Just call TSK_TX_SYNCHRONIZE to wait for tready but don't log anything, because
+    // the pcie_tlp_data has complete in the previous clock cycle
+    TSK_TX_SYNCHRONIZE(0, 0, 0, `SYNC_RQ_RDY);
+  end
+    //-----------------------------------------------------------------------\\
+    s_axis_rq_tvalid <= #(Tcq) 1'b0;
+    s_axis_rq_tlast  <= #(Tcq) 1'b0;
+    s_axis_rq_tkeep  <= #(Tcq) 8'h00;
+    s_axis_rq_tuser_wo_parity<= #(Tcq) 137'b0;
+    s_axis_rq_tdata  <= #(Tcq) 512'b0;
+    //-----------------------------------------------------------------------\\
+    pcie_tlp_rem <= #(Tcq) 3'b0;
+    //-----------------------------------------------------------------------\\
+end
+endtask // TSK_TX_TYPE0_CONFIGURATION_WRITE
+
+/************************************************************
+Task : TSK_TX_MEMORY_READ_32
+Inputs : Tag, Length, Address, Last Byte En, First Byte En
+Outputs : Transaction Tx Interface Signaling
+Description : Generates a Memory Read 32 TLP
+*************************************************************/
+
+task TSK_TX_MEMORY_READ_32;
+  input [7:0]  tag_;  // Tag
+  input [2:0]  tc_;   // Traffic Class
+  input [10:0] len_;  // Length (in DW)
+  input [31:0] addr_; // Address
+  input [3:0]  last_dw_be_; // Last DW Byte Enable
+  input [3:0]  first_dw_be_; // First DW Byte Enable
+begin
+  //-----------------------------------------------------------------------\\
+  if(user_lnk_up_n) begin
+    $display("[%t] :  interface is MIA", $realtime);
+    $finish(1);
+  end
+  $display("[%t] : Mem32 Read Req @address 0x%0x", $realtime,addr_);
+  //-----------------------------------------------------------------------\\
+  TSK_TX_SYNCHRONIZE(0, 0, 0, `SYNC_RQ_RDY);
+  //-----------------------------------------------------------------------\\
+  s_axis_rq_tvalid <= #(Tcq) 1'b1;
+  s_axis_rq_tlast  <= #(Tcq) 1'b1;
+  s_axis_rq_tkeep  <= #(Tcq) 8'h0F;             // 2DW Descriptor for Memory Transactions alone
+  s_axis_rq_tuser_wo_parity<= #(Tcq) {
+      //(AXISTEN_IF_RQ_PARITY_CHECK ?  s_axis_rq_tparity : 64'b0), // Parity
+      64'b0,     // Parity Bit slot - 64bit
+      6'b101010, // Seq Number - 6bit
+      6'b101010, // Seq Number - 6bit
+      16'h0000,  // TPH Steering Tag - 16 bit
+      2'b00,     // TPH indirect Tag Enable - 2bit
+      4'b0000,   // TPH Type - 4 bit
+      2'b00,     // TPH Present - 2 bit
+      1'b0,      // Discontinue
+      4'b0000,   // is_eop1_ptr
+      4'b0000,   // is_eop0_ptr
+      2'b01,     // is_eop[1:0]
+      2'b10,     // is_sop1_ptr[1:0]
+      2'b00,     // is_sop0_ptr[1:0]
+      2'b01,     // is_sop[1:0]
+      2'b00,2'b00, // Byte Lane number in case of Address Aligned mode - 4 bit
+      4'b0000,last_dw_be_, // Last BE of the Write Data -  8 bit
+      4'b0000,first_dw_be_ // First BE of the Write Data - 8 bit
+    };
+
+  s_axis_rq_tdata <= #(Tcq) {256'b0,128'b0,           // 4 DW unused                                    //256
+      1'b0,   // Force ECRC                                     //128
+      3'b000, // Attributes {ID Based Ordering, Relaxed Ordering, No Snoop}
+      tc_,    // Traffic Class
+      1'b1,   // RID Enable to use the Client supplied Bus/Device/Func No
+      EP_BUS_DEV_FNS, // Completer ID
+      (ATTR_AXISTEN_IF_ENABLE_CLIENT_TAG ? 8'hCC : tag_), // Tag
+      RP_BUS_DEV_FNS,   // Requester ID -- Used only when RID enable = 1  //96
+      (set_malformed ? 1'b1 : 1'b0), // Poisoned Req
+      4'b0000,     // Req Type for MRd Req
+      len_ ,       // DWORD Count
+      32'b0,       // 32-bit Addressing. So, bits[63:32] = 0 //64
+      addr_[31:2], // Memory read address 32-bits //32
+      2'b00};      // AT -> 00 : Untranslated Address
+
+  //-----------------------------------------------------------------------\\
+  pcie_tlp_data <= #(Tcq) {
+      3'b000,   // Fmt for 32-bit MRd Req
+      5'b00000, // Type for 32-bit Mrd Req
+      1'b0,     // *reserved*
+      tc_,      // 3-bit Traffic Class
+      1'b0,     // *reserved*
+      1'b0,     // Attributes {ID Based Ordering}
+      1'b0,     // *reserved*
+      1'b0,     // TLP Processing Hints
+      1'b0,     // TLP Digest Present
+      (set_malformed ? 1'b1 : 1'b0), // Poisoned Req
+      2'b00,    // Attributes {Relaxed Ordering, No Snoop}
+      2'b00,    // Address Translation
+      len_[9:0],// DWORD Count              //32
+      RP_BUS_DEV_FNS,   // Requester ID
+      (ATTR_AXISTEN_IF_ENABLE_CLIENT_TAG ? 8'hCC : tag_), // Tag
+      last_dw_be_,  // Last DW Byte Enable
+      first_dw_be_, // First DW Byte Enable //64
+      addr_[31:2],  // Address
+      2'b00,    // *reserved* //96
+      32'b0,    // *unused*   //128
+      128'b0    // *unused*   //256
+    };
+
+  pcie_tlp_rem <= #(Tcq)  3'b100;
+  //-----------------------------------------------------------------------\\
+  TSK_TX_SYNCHRONIZE(1, 1, 1, `SYNC_RQ_RDY);
+  //-----------------------------------------------------------------------\\
+  s_axis_rq_tvalid <= #(Tcq) 1'b0;
+  s_axis_rq_tlast  <= #(Tcq) 1'b0;
+  s_axis_rq_tkeep  <= #(Tcq) 8'h00;
+  s_axis_rq_tuser_wo_parity<= #(Tcq) 137'b0;
+  s_axis_rq_tdata  <= #(Tcq) 512'b0;
+  //-----------------------------------------------------------------------\\
+  pcie_tlp_rem <= #(Tcq) 3'b0;
+  //-----------------------------------------------------------------------\\
+end
+endtask // TSK_TX_MEMORY_READ_32
+
+/************************************************************
+Task : TSK_TX_MEMORY_READ_64
+Inputs : Tag, Length, Address, Last Byte En, First Byte En
+Outputs : Transaction Tx Interface Signaling
+Description : Generates a Memory Read 64 TLP
+*************************************************************/
+
+task TSK_TX_MEMORY_READ_64;
+  input [7:0]  tag_;  // Tag
+  input [2:0]  tc_;   // Traffic Class
+  input [10:0] len_;  // Length (in DW)
+  input [63:0] addr_; // Address
+  input [3:0]  last_dw_be_;  // Last DW Byte Enable
+  input [3:0]  first_dw_be_; // First DW Byte Enable
+begin
+  //-----------------------------------------------------------------------\\
+  if(user_lnk_up_n) begin
+    $display("[%t] :  interface is MIA", $realtime);
+    $finish(1);
+  end
+  $display("[%t] : Mem64 Read Req @address %x", $realtime,addr_[31:0]);
+  //-----------------------------------------------------------------------\\
+  TSK_TX_SYNCHRONIZE(0, 0, 0, `SYNC_RQ_RDY);
+  //-----------------------------------------------------------------------\\
+  s_axis_rq_tvalid <= #(Tcq) 1'b1;
+  s_axis_rq_tlast  <= #(Tcq) 1'b1;
+  s_axis_rq_tkeep  <= #(Tcq) 8'h0F; // 2DW Descriptor for Memory Transactions alone
+  s_axis_rq_tuser_wo_parity<= #(Tcq) {
+      //(AXISTEN_IF_RQ_PARITY_CHECK ?  s_axis_rq_tparity : 64'b0), // Parity
+      64'b0,     // Parity Bit slot - 64bit
+      6'b101010, // Seq Number - 6bit
+      6'b101010, // Seq Number - 6bit
+      16'h0000,  // TPH Steering Tag - 16 bit
+      2'b00,     // TPH indirect Tag Enable - 2bit
+      4'b0000,   // TPH Type - 4 bit
+      2'b00,     // TPH Present - 2 bit
+      1'b0,      // Discontinue
+      4'b0000,   // is_eop1_ptr
+      4'b0000,   // is_eop0_ptr
+      2'b01,     //is_eop[1:0]
+      2'b10,     //is_sop1_ptr[1:0]
+      2'b00,     //is_sop0_ptr[1:0]
+      2'b01,     //is_sop[1:0]
+      2'b00,2'b00, // Byte Lane number in case of Address Aligned mode - 4 bit
+      4'b0000,last_dw_be_, // Last BE of the Write Data -  8 bit
+      4'b0000,first_dw_be_ // First BE of the Write Data - 8 bit
+    };
+
+  s_axis_rq_tdata <= #(Tcq) {256'b0,128'b0, // 4 DW unused //256
+    1'b0,   // Force ECRC  //128
+    3'b000, // Attributes {ID Based Ordering, Relaxed Ordering, No Snoop}
+    tc_,    // Traffic Class
+    1'b1,   // RID Enable to use the Client supplied Bus/Device/Func No
+    EP_BUS_DEV_FNS,   // Completer ID
+    (ATTR_AXISTEN_IF_ENABLE_CLIENT_TAG ? 8'hCC : tag_), // Tag
+    RP_BUS_DEV_FNS,   // Requester ID -- Used only when RID enable = 1  //96
+    (set_malformed ? 1'b1 : 1'b0), // Poisoned Req
+    4'b0000,     // Req Type for MRd Req
+    len_ ,       // DWORD Count
+    addr_[63:2], // Memory read address 64-bits //64
+    2'b00};      // AT -> 00 : Untranslated Address
+
+  //-----------------------------------------------------------------------\\
+  pcie_tlp_data <= #(Tcq) {
+      3'b001,   // Fmt for 64-bit MRd Req
+      5'b00000, // Type for 64-bit Mrd Req
+      1'b0,     // *reserved*
+      tc_,      // 3-bit Traffic Class
+      1'b0,     // *reserved*
+      1'b0,     // Attributes {ID Based Ordering}
+      1'b0,     // *reserved*
+      1'b0,     // TLP Processing Hints
+      1'b0,     // TLP Digest Present
+      (set_malformed ? 1'b1 : 1'b0), // Poisoned Req
+      2'b00,    // Attributes {Relaxed Ordering, No Snoop}
+      2'b00,    // Address Translation
+      len_[9:0],// DWORD Count                //32
+      RP_BUS_DEV_FNS,   // Requester ID
+      (ATTR_AXISTEN_IF_ENABLE_CLIENT_TAG ? 8'hCC : tag_), // Tag
+      last_dw_be_,  // Last DW Byte Enable
+      first_dw_be_, // First DW Byte Enable   //64
+      addr_[63:2],  // Address
+      2'b00,   // *reserved*  //128
+      128'b0   // *unused*    //256
+    };
+
+  pcie_tlp_rem <= #(Tcq)  3'b100;
+  //-----------------------------------------------------------------------\\
+  TSK_TX_SYNCHRONIZE(1, 1, 1, `SYNC_RQ_RDY);
+  //-----------------------------------------------------------------------\\
+  s_axis_rq_tvalid <= #(Tcq) 1'b0;
+  s_axis_rq_tlast  <= #(Tcq) 1'b0;
+  s_axis_rq_tkeep  <= #(Tcq) 8'h00;
+  s_axis_rq_tuser_wo_parity<= #(Tcq) 137'b0;
+  s_axis_rq_tdata  <= #(Tcq) 512'b0;
+  //-----------------------------------------------------------------------\\
+  pcie_tlp_rem <= #(Tcq) 3'b0;
+  //-----------------------------------------------------------------------\\
+end
+endtask // TSK_TX_MEMORY_READ_64
+
+/************************************************************
+Task : TSK_TX_MEMORY_WRITE_32
+Inputs : Tag, Length, Address, Last Byte En, First Byte En
+Outputs : Transaction Tx Interface Signaling
+Description : Generates a Memory Write 32 TLP
+*************************************************************/
+
+task TSK_TX_MEMORY_WRITE_32;
+  input  [7:0]    tag_;         // Tag
+  input  [2:0]    tc_;          // Traffic Class
+  input  [10:0]   len_;         // Length (in DW)
+  input  [31:0]   addr_;        // Address
+  input  [3:0]    last_dw_be_;  // Last DW Byte Enable
+  input  [3:0]    first_dw_be_; // First DW Byte Enable
+  input           ep_;          // Poisoned Data: Payload is invalid if set
+  reg    [10:0]   _len;         // Length Info on pcie_tlp_data -- Used to count how many times to loop
+  reg    [10:0]   len_i;        // Length Info on s_axis_rq_tdata -- Used to count how many times to loop
+  reg    [2:0]    aa_dw;        // Adjusted DW Count for Address Aligned Mode
+  reg    [255:0]  aa_data;      // Adjusted Data for Address Aligned Mode
+  reg    [31:0]  data_axis_i;   // Data Info for s_axis_rq_tdata changed from 128 bit to 32 bit
+  reg    [511:0] subs_dw;       // adjusted for subsequent DW when len >12
+  reg    [159:0]  data_pcie_i;  // Data Info for pcie_tlp_data
+  reg    [383:0] data_axis_first_beat;
+  integer         _j;           // Byte Index
+  integer         start_addr;   // Start Location for Payload DW0
+begin
+  //-----------------------------------------------------------------------\\
+  if(AXISTEN_IF_RQ_ALIGNMENT_MODE=="TRUE")begin
+    start_addr  = 0;
+    aa_dw       = addr_[4:2];
+  end else begin
+    start_addr  = 48;
+    aa_dw       = 3'b000;
+  end
+
+  len_i = len_ + aa_dw;
+  _len  = len_;
+  //-----------------------------------------------------------------------\\
+  if(user_lnk_up_n) begin
+    $display("[%t] :  interface is MIA", $realtime);
+    $finish(1);
+  end
+  $display("[%t] : Mem32 Write Req @address 0x%0x with data 0x%0x", $realtime,addr_,{DATA_STORE[3], DATA_STORE[2], DATA_STORE[1], DATA_STORE[0]});
+  //-----------------------------------------------------------------------\\
+  TSK_TX_SYNCHRONIZE(0, 0, 0, `SYNC_RQ_RDY);
+  //-----------------------------------------------------------------------\\
+  // Start of First Data Beat
+  data_axis_i = {
+    /*DATA_STORE[15],
+      DATA_STORE[14],
+      DATA_STORE[13],
+      DATA_STORE[12],
+      DATA_STORE[11],
+      DATA_STORE[10],
+      DATA_STORE[9],
+      DATA_STORE[8],
+      DATA_STORE[7],
+      DATA_STORE[6],
+      DATA_STORE[5],
+      DATA_STORE[4],*/
+      DATA_STORE[3],
+      DATA_STORE[2],
+      DATA_STORE[1],
+      DATA_STORE[0]
+    };
+
+  if(len_i > 12 ) begin
+    data_axis_first_beat = {12{data_axis_i}};
+  end else begin
+    case(len_i)
+      0 :  data_axis_first_beat =   384'h0;
+      1 :  data_axis_first_beat =  {352'h0,data_axis_i};
+      2 :  data_axis_first_beat =  {320'h0,{2{data_axis_i}}};
+      3 :  data_axis_first_beat =  {288'h0,{3{data_axis_i}}};
+      4 :  data_axis_first_beat =  {256'h0,{4{data_axis_i}}};
+      5 :  data_axis_first_beat =  {224'h0, {5{data_axis_i}}};
+      6 :  data_axis_first_beat =  {192'h0, {6{data_axis_i}}};
+      7 :  data_axis_first_beat =  {160'h0, {7{data_axis_i}}};
+      8 :  data_axis_first_beat =  {128'h0, {8{data_axis_i}}};
+      9 :  data_axis_first_beat =  {96'h0, {9{data_axis_i}}};
+      10 :  data_axis_first_beat = {64'h0, {10{data_axis_i}}};
+      11 :  data_axis_first_beat = {32'h0, {11{data_axis_i}}};
+      12 :  data_axis_first_beat = {12{data_axis_i}};
+    endcase
+  end
+
+  s_axis_rq_tuser_wo_parity <= #(Tcq) {
+      //(AXISTEN_IF_RQ_PARITY_CHECK ?  s_axis_rq_tparity : 64'b0), // Parity
+      64'b0,     // Parity Bit slot - 64bit
+      6'b101010, // Seq Number - 6bit
+      6'b101010, // Seq Number - 6bit
+      16'h0000,  // TPH Steering Tag - 16 bit
+      2'b00,     // TPH indirect Tag Enable - 2bit
+      4'b0000,   // TPH Type - 4 bit
+      2'b00,     // TPH Present - 2 bit
+      1'b0,      // Discontinue
+      4'b0000,   // is_eop1_ptr
+      4'b1111,   // is_eop0_ptr
+      2'b01,     // is_eop[1:0]
+      2'b00,     // is_sop1_ptr[1:0]
+      2'b00,     // is_sop0_ptr[1:0]
+      2'b01,     // is_sop[1:0]
+      2'b0,aa_dw[1:0],     // Byte Lane number in case of Address Aligned mode - 4 bit
+      4'b0000,last_dw_be_, // Last BE of the Write Data 8 bit
+      4'b0000,first_dw_be_ // First BE of the Write Data 8 bit
+    };
+
+  s_axis_rq_tdata <= #(Tcq) { ((AXISTEN_IF_RQ_ALIGNMENT_MODE == "FALSE" ) ? data_axis_first_beat : 384'h0), // 12 DW write data
+     //128
+      1'b0,   // Force ECRC
+      3'b000, // Attributes {ID Based Ordering, Relaxed Ordering, No Snoop}
+      tc_,    // Traffic Class
+      1'b1,   // RID Enable to use the Client supplied Bus/Device/Func No
+      EP_BUS_DEV_FNS, // Completer ID
+      (ATTR_AXISTEN_IF_ENABLE_CLIENT_TAG ? 8'hCC : tag_), // Tag
+      //96
+      RP_BUS_DEV_FNS, // Requester ID -- Used only when RID enable = 1
+      ep_,     // Poisoned Req
+      4'b0001, // Req Type for MWr Req
+      (set_malformed ? (len_ + 11'h4) : len_), // DWORD Count - length does not include padded zeros
+      //64
+      32'b0,       // High Address *unused*
+      addr_[31:2], // Memory Write address 32-bits
+      2'b00        // AT -> 00 : Untranslated Address
+    };
+  //-----------------------------------------------------------------------\\
+  data_pcie_i = {
+      DATA_STORE[0],
+      DATA_STORE[1],
+      DATA_STORE[2],
+      DATA_STORE[3],
+      DATA_STORE[4],
+      DATA_STORE[5],
+      DATA_STORE[6],
+      DATA_STORE[7],
+      DATA_STORE[8],
+      DATA_STORE[9],
+      DATA_STORE[10],
+      DATA_STORE[11],
+      DATA_STORE[12],
+      DATA_STORE[13],
+      DATA_STORE[14],
+      DATA_STORE[15],
+      DATA_STORE[16],
+      DATA_STORE[17],
+      DATA_STORE[18],
+      DATA_STORE[19]
+    };
+
+  pcie_tlp_data <= #(Tcq) {
+      3'b010,   // Fmt for 32-bit MWr Req
+      5'b00000, // Type for 32-bit MWr Req
+      1'b0,     // *reserved*
+      tc_,      // 3-bit Traffic Class
+      1'b0,     // *reserved*
+      1'b0,     // Attributes {ID Based Ordering}
+      1'b0,     // *reserved*
+      1'b0,     // TLP Processing Hints
+      1'b0,     // TLP Digest Present
+      ep_,      // Poisoned Req
+      2'b00,    // Attributes {Relaxed Ordering, No Snoop}
+      2'b00,    // Address Translation
+      (set_malformed ? (len_[9:0] + 10'h4) : len_[9:0]),  // DWORD Count
+      //32
+      RP_BUS_DEV_FNS, // Requester ID
+      (ATTR_AXISTEN_IF_ENABLE_CLIENT_TAG ? 8'hCC : tag_), // Tag
+      last_dw_be_,   // Last DW Byte Enable
+      first_dw_be_,  // First DW Byte Enable
+      //64
+      addr_[31:2],   // Memory Write address 32-bits
+      2'b00,         // *reserved* or Processing Hint
+      //96
+      data_pcie_i    // Payload Data
+      //256
+    };
+
+  pcie_tlp_rem  <= #(Tcq) (_len > 12) ? 3'b000 : (_len - 12);
+  set_malformed <= #(Tcq) 1'b0;
+  _len = (_len > 12) ? (_len - 11'hC) : 11'b0;
+  //-----------------------------------------------------------------------\\
+  s_axis_rq_tvalid  <= #(Tcq) 1'b1;
+
+  if(len_i > 12 || AXISTEN_IF_RQ_ALIGNMENT_MODE == "TRUE") begin  //changed from 4 to 12
+    s_axis_rq_tlast <= #(Tcq) 1'b0;
+    s_axis_rq_tkeep <= #(Tcq) 16'hFFFF;
+
+    len_i = (AXISTEN_IF_RQ_ALIGNMENT_MODE == "FALSE") ? (len_i - 12) : len_i; // Don't subtract 12 in Address Aligned because
+                                                                              // it's always padded with zeros on first beat
+
+      // pcie_tlp_data doesn't append zero even in Address Aligned mode, so it should mark this cycle as the last beat if it has no more payload to log.
+      // The AXIS RQ interface will need to execute the next cycle, but we're just not going to log that data beat in pcie_tlp_data
+    if(_len == 0)
+      TSK_TX_SYNCHRONIZE(1, 1, 1, `SYNC_RQ_RDY);
+    else
+      TSK_TX_SYNCHRONIZE(1, 1, 0, `SYNC_RQ_RDY);
+
+  end else begin
+    if(len_i == 1)       s_axis_rq_tkeep <= #(Tcq) 16'h001F;
+    else if(len_i == 2)  s_axis_rq_tkeep <= #(Tcq) 16'h003F;
+    else if(len_i == 3)  s_axis_rq_tkeep <= #(Tcq) 16'h007F;
+    else if(len_i == 4)  s_axis_rq_tkeep <= #(Tcq) 16'h00FF;
+    else if(len_i == 5)  s_axis_rq_tkeep <= #(Tcq) 16'h01FF;
+    else if(len_i == 6)  s_axis_rq_tkeep <= #(Tcq) 16'h03FF;
+    else if(len_i == 7)  s_axis_rq_tkeep <= #(Tcq) 16'h07FF;
+    else if(len_i == 9)  s_axis_rq_tkeep <= #(Tcq) 16'h1FFF;
+    else if(len_i == 10) s_axis_rq_tkeep <= #(Tcq) 16'h3FFF;
+    else if(len_i == 11) s_axis_rq_tkeep <= #(Tcq) 16'h7FFF;
+    else                 s_axis_rq_tkeep <= #(Tcq) 16'hFFFF;
+
+    s_axis_rq_tlast <= #(Tcq) 1'b1;
+
+    len_i                     = 0;
+    TSK_TX_SYNCHRONIZE(1, 1, 1, `SYNC_RQ_RDY);
+  end
+  // End of First Data Beat
+  //-----------------------------------------------------------------------\\
+  // Start of Second and Subsequent Data Beat
+  if(len_i != 0 || AXISTEN_IF_RQ_ALIGNMENT_MODE == "TRUE") begin
+    fork
+    begin // Sequential group 1 - AXIS RQ
+      for(_j = start_addr; len_i != 0; _j = _j + 32) begin
+      /*if(_j==start_addr) begin
+          aa_data = {
+              DATA_STORE[_j + 31],
+              DATA_STORE[_j + 30],
+              DATA_STORE[_j + 29],
+              DATA_STORE[_j + 28],
+              DATA_STORE[_j + 27],
+              DATA_STORE[_j + 26],
+              DATA_STORE[_j + 25],
+              DATA_STORE[_j + 24],
+              DATA_STORE[_j + 23],
+              DATA_STORE[_j + 22],
+              DATA_STORE[_j + 21],
+              DATA_STORE[_j + 20],
+              DATA_STORE[_j + 19],
+              DATA_STORE[_j + 18],
+              DATA_STORE[_j + 17],
+              DATA_STORE[_j + 16],
+              DATA_STORE[_j + 15],
+              DATA_STORE[_j + 14],
+              DATA_STORE[_j + 13],
+              DATA_STORE[_j + 12],
+              DATA_STORE[_j + 11],
+              DATA_STORE[_j + 10],
+              DATA_STORE[_j +  9],
+              DATA_STORE[_j +  8],
+              DATA_STORE[_j +  7],
+              DATA_STORE[_j +  6],
+              DATA_STORE[_j +  5],
+              DATA_STORE[_j +  4],
+              DATA_STORE[_j +  3],
+              DATA_STORE[_j +  2],
+              DATA_STORE[_j +  1],
+              DATA_STORE[_j +  0]
+            } << (aa_dw*4*8);
+        end else begin
+          aa_data = {
+              DATA_STORE[_j + 31 - (aa_dw*4)],
+              DATA_STORE[_j + 30 - (aa_dw*4)],
+              DATA_STORE[_j + 29 - (aa_dw*4)],
+              DATA_STORE[_j + 28 - (aa_dw*4)],
+              DATA_STORE[_j + 27 - (aa_dw*4)],
+              DATA_STORE[_j + 26 - (aa_dw*4)],
+              DATA_STORE[_j + 25 - (aa_dw*4)],
+              DATA_STORE[_j + 24 - (aa_dw*4)],
+              DATA_STORE[_j + 23 - (aa_dw*4)],
+              DATA_STORE[_j + 22 - (aa_dw*4)],
+              DATA_STORE[_j + 21 - (aa_dw*4)],
+              DATA_STORE[_j + 20 - (aa_dw*4)],
+              DATA_STORE[_j + 19 - (aa_dw*4)],
+              DATA_STORE[_j + 18 - (aa_dw*4)],
+              DATA_STORE[_j + 17 - (aa_dw*4)],
+              DATA_STORE[_j + 16 - (aa_dw*4)],
+              DATA_STORE[_j + 15 - (aa_dw*4)],
+              DATA_STORE[_j + 14 - (aa_dw*4)],
+              DATA_STORE[_j + 13 - (aa_dw*4)],
+              DATA_STORE[_j + 12 - (aa_dw*4)],
+              DATA_STORE[_j + 11 - (aa_dw*4)],
+              DATA_STORE[_j + 10 - (aa_dw*4)],
+              DATA_STORE[_j +  9 - (aa_dw*4)],
+              DATA_STORE[_j +  8 - (aa_dw*4)],
+              DATA_STORE[_j +  7 - (aa_dw*4)],
+              DATA_STORE[_j +  6 - (aa_dw*4)],
+              DATA_STORE[_j +  5 - (aa_dw*4)],
+              DATA_STORE[_j +  4 - (aa_dw*4)],
+              DATA_STORE[_j +  3 - (aa_dw*4)],
+              DATA_STORE[_j +  2 - (aa_dw*4)],
+              DATA_STORE[_j +  1 - (aa_dw*4)],
+              DATA_STORE[_j +  0 - (aa_dw*4)]
+            };
+        end
+      */
+      if(((len_i-1)/16) == 0) begin
+        case (len_i)
+          1 :  subs_dw = {480'h0, data_axis_i};
+          2 :  subs_dw = {448'h0, {2{data_axis_i}}};
+          3 :  subs_dw = {416'h0, {3{data_axis_i}}};
+          4 :  subs_dw = {384'h0, {4{data_axis_i}}};
+          5 :  subs_dw = {352'h0, {5{data_axis_i}}};
+          6 :  subs_dw = {320'h0, {6{data_axis_i}}};
+          7 :  subs_dw = {288'h0, {7{data_axis_i}}};
+          8 :  subs_dw = {256'h0, {8{data_axis_i}}};
+          9 :  subs_dw = {224'h0, {9{data_axis_i}}};
+          10 : subs_dw = {192'h0, {10{data_axis_i}}};
+          11 : subs_dw = {160'h0, {11{data_axis_i}}};
+          12 : subs_dw = {120'h0, {12{data_axis_i}}};
+          13:  subs_dw = {96'h0,  {13{data_axis_i}}};
+          14 : subs_dw = {64'h0,  {14{data_axis_i}}};
+          15 : subs_dw = {32'h0,  {15{data_axis_i}}};
+          16 : subs_dw = {16{data_axis_i}};
+        endcase
+      end else begin
+        subs_dw = {16{data_axis_i}};
+      end
+			s_axis_rq_tdata <= #(Tcq) subs_dw ;
+
+      if((len_i/16) == 0) begin
+        case (len_i % 16)
+           1 : begin len_i = len_i - 1;  s_axis_rq_tkeep <= #(Tcq) 16'h0001; end  // D0----------------------------------------------------
+           2 : begin len_i = len_i - 2;  s_axis_rq_tkeep <= #(Tcq) 16'h0003; end  // D0-D1-------------------------------------------------
+           3 : begin len_i = len_i - 3;  s_axis_rq_tkeep <= #(Tcq) 16'h0007; end  // D0-D1-D2----------------------------------------------
+           4 : begin len_i = len_i - 4;  s_axis_rq_tkeep <= #(Tcq) 16'h000F; end  // D0-D1-D2-D3-------------------------------------------
+           5 : begin len_i = len_i - 5;  s_axis_rq_tkeep <= #(Tcq) 16'h001F; end  // D0-D1-D2-D3-D4----------------------------------------
+           6 : begin len_i = len_i - 6;  s_axis_rq_tkeep <= #(Tcq) 16'h003F; end  // D0-D1-D2-D3-D4-D5-------------------------------------
+           7 : begin len_i = len_i - 7;  s_axis_rq_tkeep <= #(Tcq) 16'h007F; end  // D0-D1-D2-D3-D4-D5-D6----------------------------------
+           8 : begin len_i = len_i - 8;  s_axis_rq_tkeep <= #(Tcq) 16'h00FF; end  // D0-D1-D2-D3-D4-D5-D6-D7-------------------------------
+           9 : begin len_i = len_i - 9;  s_axis_rq_tkeep <= #(Tcq) 16'h01FF; end  // D0-D1-D2-D3-D4-D5-D6-D7-D8----------------------------
+          10 : begin len_i = len_i - 10; s_axis_rq_tkeep <= #(Tcq) 16'h03FF; end  // D0-D1-D2-D3-D4-D5-D6-D7-D8-D9------------------------
+          11 : begin len_i = len_i - 11; s_axis_rq_tkeep <= #(Tcq) 16'h07FF; end  // D0-D1-D2-D3-D4-D5-D6-D7-D8-D9-D10-------------------
+          12 : begin len_i = len_i - 12; s_axis_rq_tkeep <= #(Tcq) 16'h0FFF; end  // D0-D1-D2-D3-D4-D5-D6-D7-D8-D9-D10-D11----------------
+          13 : begin len_i = len_i - 13; s_axis_rq_tkeep <= #(Tcq) 16'h1FFF; end  // D0-D1-D2-D3-D4-D5-D6-D7-D8-D9-D10-D11-D12------------
+          14 : begin len_i = len_i - 14; s_axis_rq_tkeep <= #(Tcq) 16'h3FFF; end  // D0-D1-D2-D3-D4-D5-D6-D7-D8-D9-D10-D11-D12-D13--------
+          15 : begin len_i = len_i - 15; s_axis_rq_tkeep <= #(Tcq) 16'h7FFF; end  // D0-D1-D2-D3-D4-D5-D6-D7-D8-D9-D10-D11-D12-D13-D14----
+           0 : begin len_i = len_i - 16; s_axis_rq_tkeep <= #(Tcq) 16'hFFFF; end  // D0-D1-D2-D3-D4-D5-D6-D7-D8-D9-D10-D11-D12-D13-D14-D15
+        endcase
+      end else begin
+        len_i = len_i - 16; s_axis_rq_tkeep <= #(Tcq) 16'hFFFF;      // D0-D1-D2-D3-D4-D5-D6-D7-D8-D9-D10-D11-D12-D13-D14-D15
+      end
+
+      if(len_i == 0)
+        s_axis_rq_tlast <= #(Tcq) 1'b1;
+      else
+        s_axis_rq_tlast <= #(Tcq) 1'b0;
+
+      // Call this just to check for the tready, but don't log anything. That's the job for pcie_tlp_data
+      // The reason for splitting the TSK_TX_SYNCHRONIZE task and distribute them in both sequential group
+      // is that in address aligned mode, it's possible that the additional padded zeros cause the AXIS RQ
+      // to be one beat longer than the actual PCIe TLP. When it happens do not log the last clock beat
+      // but just send the packet on AXIS RQ interface
+      TSK_TX_SYNCHRONIZE(0, 0, 0, `SYNC_RQ_RDY);
+
+    end // for loop
+  end // End sequential group 1 - AXIS RQ
+
+  begin // Sequential group 2 - pcie_tlp
+    for (_j = 20; _len != 0; _j = _j + 32) begin
+      pcie_tlp_data <= #(Tcq) {
+          DATA_STORE[_j + 0],
+          DATA_STORE[_j + 1],
+          DATA_STORE[_j + 2],
+          DATA_STORE[_j + 3],
+          DATA_STORE[_j + 4],
+          DATA_STORE[_j + 5],
+          DATA_STORE[_j + 6],
+          DATA_STORE[_j + 7],
+          DATA_STORE[_j + 8],
+          DATA_STORE[_j + 9],
+          DATA_STORE[_j + 10],
+          DATA_STORE[_j + 11],
+          DATA_STORE[_j + 12],
+          DATA_STORE[_j + 13],
+          DATA_STORE[_j + 14],
+          DATA_STORE[_j + 15],
+          DATA_STORE[_j + 16],
+          DATA_STORE[_j + 17],
+          DATA_STORE[_j + 18],
+          DATA_STORE[_j + 19],
+          DATA_STORE[_j + 20],
+          DATA_STORE[_j + 21],
+          DATA_STORE[_j + 22],
+          DATA_STORE[_j + 23],
+          DATA_STORE[_j + 24],
+          DATA_STORE[_j + 25],
+          DATA_STORE[_j + 26],
+          DATA_STORE[_j + 27],
+          DATA_STORE[_j + 28],
+          DATA_STORE[_j + 29],
+          DATA_STORE[_j + 30],
+          DATA_STORE[_j + 31]
+        };
+
+      if((_len/16) == 0) begin
+        case (_len % 16)
+           1 : begin _len = _len - 1; pcie_tlp_rem  <= #(Tcq) 4'b1111; end  // D0--------------------------------------------------
+           2 : begin _len = _len - 2; pcie_tlp_rem  <= #(Tcq) 4'b1110; end  // D0-
+           3 : begin _len = _len - 3; pcie_tlp_rem  <= #(Tcq) 4'b1101; end  // D0-D1-D2-D3-D4-D5-D6-D7-D8-D9-D10-D11-D12-D13-D14-D15
+           4 : begin _len = _len - 4; pcie_tlp_rem  <= #(Tcq) 4'b1100; end  // D0-D1-D2-D3-D4-D5-D6-D7-D8-D9-D10-D11-D12-D13-D14-D15
+           5 : begin _len = _len - 5; pcie_tlp_rem  <= #(Tcq) 4'b1011; end  // D0-D1-D2-D3-D4-D5-D6-D7-D8-D9-D10-D11-D12-D13-D14-D15
+           6 : begin _len = _len - 6; pcie_tlp_rem  <= #(Tcq) 4'b1010; end  // D0-D1-D2-D3-D4-D5-D6-D7-D8-D9-D10-D11-D12-D13-D14-D15
+           7 : begin _len = _len - 7; pcie_tlp_rem  <= #(Tcq) 4'b1001; end  // D0-D1-D2-D3-D4-D5-D6-D7-D8-D9-D10-D11-D12-D13-D14-D15
+           8 : begin _len = _len - 8; pcie_tlp_rem  <= #(Tcq) 4'b1000; end  // D0-D1-D2-D3-D4-D5-D6-D7-D8-D9-D10-D11-D12-D13-D14-D15
+           9 : begin _len = _len - 9; pcie_tlp_rem  <= #(Tcq) 4'b0111; end  // D0-D1-D2-D3-D4-D5-D6-D7-D8-D9-D10-D11-D12-D13-D14-D15
+          10 : begin _len = _len - 10; pcie_tlp_rem  <= #(Tcq) 4'b0110; end  // D0-D1-D2-D3-D4-D5-D6-D7-D8-D9-D10-D11-D12-D13-D14-D15
+          11 : begin _len = _len - 11; pcie_tlp_rem  <= #(Tcq) 4'b0101; end  // D0-D1-D2-D3-D4-D5-D6-D7-D8-D9-D10-D11-D12-D13-D14-D15
+          12 : begin _len = _len - 12; pcie_tlp_rem  <= #(Tcq) 4'b0100; end  // D0-D1-D2-D3-D4-D5-D6-D7-D8-D9-D10-D11-D12-D13-D14-D15
+          13 : begin _len = _len - 13; pcie_tlp_rem  <= #(Tcq) 4'b0011; end  // D0-D1-D2-D3-D4-D5-D6-D7-D8-D9-D10-D11-D12-D13-D14-D15
+          14 : begin _len = _len - 14; pcie_tlp_rem  <= #(Tcq) 4'b0010; end  // D0-D1-D2-D3-D4-D5-D6-D7-D8-D9-D10-D11-D12-D13-D14-D15
+          15 : begin _len = _len - 15; pcie_tlp_rem  <= #(Tcq) 4'b0001; end  // D0-D1-D2-D3-D4-D5-D6-D7-D8-D9-D10-D11-D12-D13-D14-D15
+           0 : begin _len = _len - 16; pcie_tlp_rem  <= #(Tcq) 4'b0000; end  // D0-D1-D2-D3-D4-D5-D6-D7-D8-D9-D10-D11-D12-D13-D14-D15
+        endcase
+      end else begin
+        _len = _len - 16; pcie_tlp_rem   <= #(Tcq) 4'b0000;     // D0-D1-D2-D3-D4-D5-D6-D7
+      end
+
+      if(_len == 0)
+        TSK_TX_SYNCHRONIZE(0, 1, 1, `SYNC_RQ_RDY);
+      else
+        TSK_TX_SYNCHRONIZE(0, 1, 0, `SYNC_RQ_RDY);
+      end // for loop
+    end // End sequential group 2 - pcie_tlp
+    join
+  end  // if
+  // End of Second and Subsequent Data Beat
+  //-----------------------------------------------------------------------\\
+  // Packet Complete - Drive 0s
+  s_axis_rq_tvalid <= #(Tcq) 1'b0;
+  s_axis_rq_tlast  <= #(Tcq) 1'b0;
+  s_axis_rq_tkeep  <= #(Tcq) 8'h00;
+  s_axis_rq_tuser_wo_parity<= #(Tcq) 137'b0;
+  s_axis_rq_tdata  <= #(Tcq) 512'b0;
+  //-----------------------------------------------------------------------\\
+  pcie_tlp_rem <= #(Tcq) 3'b0;
+  //-----------------------------------------------------------------------\\
+end
+endtask // TSK_TX_MEMORY_WRITE_32
+
+/************************************************************
+Task : TSK_TX_MEMORY_WRITE_64
+Inputs : Tag, Length, Address, Last Byte En, First Byte En
+Outputs : Transaction Tx Interface Signaling
+Description : Generates a Memory Write 64 TLP
+*************************************************************/
+
+task TSK_TX_MEMORY_WRITE_64;
+  input  [7:0]    tag_;         // Tag
+  input  [2:0]    tc_;          // Traffic Class
+  input  [10:0]   len_;         // Length (in DW)
+  input  [63:0]   addr_;        // Address
+  input  [3:0]    last_dw_be_;  // Last DW Byte Enable
+  input  [3:0]    first_dw_be_; // First DW Byte Enable
+  input           ep_;          // Poisoned Data: Payload is invalid if set
+  reg    [10:0]   _len;         // Length Info on pcie_tlp_data -- Used to count how many times to loop
+  reg    [10:0]   len_i;        // Length Info on s_axis_rq_tdata -- Used to count how many times to loop
+  reg    [2:0]    aa_dw;        // Adjusted DW Count for Address Aligned Mode
+  reg    [255:0]  aa_data;      // Adjusted Data for Address Aligned Mode
+  reg    [127:0]  data_axis_i;  // Data Info for s_axis_rq_tdata
+  reg    [127:0]  data_pcie_i;  // Data Info for pcie_tlp_data
+  integer         _j;           // Byte Index
+  integer         start_addr;   // Start Location for Payload DW0
+begin
+  //-----------------------------------------------------------------------\\
+  if(AXISTEN_IF_RQ_ALIGNMENT_MODE=="TRUE") begin
+    start_addr  = 0;
+    aa_dw = addr_[4:2];
+  end else begin
+    start_addr  = 48;
+    aa_dw = 3'b000;
+  end
+
+  len_i = len_ + aa_dw;
+  _len  = len_;
+  //-----------------------------------------------------------------------\\
+  if(user_lnk_up_n) begin
+    $display("[%t] :  interface is MIA", $realtime);
+    $finish(1);
+  end
+  $display("[%t] : Mem64 Write Req @address %x", $realtime,addr_[31:0]);
+  //-----------------------------------------------------------------------\\
+  TSK_TX_SYNCHRONIZE(0, 0, 0, `SYNC_RQ_RDY);
+  //-----------------------------------------------------------------------\\
+  // Start of First Data Beat
+  data_axis_i =  {
+      DATA_STORE[15],
+      DATA_STORE[14],
+      DATA_STORE[13],
+      DATA_STORE[12],
+      DATA_STORE[11],
+      DATA_STORE[10],
+      DATA_STORE[9],
+      DATA_STORE[8],
+      DATA_STORE[7],
+      DATA_STORE[6],
+      DATA_STORE[5],
+      DATA_STORE[4],
+      DATA_STORE[3],
+      DATA_STORE[2],
+      DATA_STORE[1],
+      DATA_STORE[0]
+    };
+
+  s_axis_rq_tuser_wo_parity <= #(Tcq) {
+  //(AXISTEN_IF_RQ_PARITY_CHECK ?  s_axis_rq_tparity : 64'b0), // Parity
+    64'b0,     // Parity Bit slot - 64bit
+    6'b101010, // Seq Number - 6bit
+    6'b101010, // Seq Number - 6bit
+    16'h0000,  // TPH Steering Tag - 16 bit
+    2'b00,     // TPH indirect Tag Enable - 2bit
+    4'b0000,   // TPH Type - 4 bit
+    2'b00,     // TPH Present - 2 bit
+    1'b0,      // Discontinue
+    4'b0000,   // is_eop1_ptr
+    4'b1111,   // is_eop0_ptr
+    2'b01,     // is_eop[1:0]
+    2'b00,     // is_sop1_ptr[1:0]
+    2'b00,     // is_sop0_ptr[1:0]
+    2'b01,     // is_sop[1:0]
+    2'b0,aa_dw[1:0],     // Byte Lane number in case of Address Aligned mode - 4 bit
+    4'b0000,last_dw_be_, // Last BE of the Write Data 8 bit
+    4'b0000,first_dw_be_ // First BE of the Write Data 8 bit
+  };
+
+  s_axis_rq_tdata <= #(Tcq) { 256'b0,//256
+      ((AXISTEN_IF_RQ_ALIGNMENT_MODE == "FALSE" ) ?  data_axis_i : 128'h0), // 128-bit write data
+      //128
+      1'b0,   // Force ECRC
+      3'b000, // Attributes {ID Based Ordering, Relaxed Ordering, No Snoop}
+      tc_,    // Traffic Class
+      1'b1,   // RID Enable to use the Client supplied Bus/Device/Func No
+      EP_BUS_DEV_FNS, // Completer ID
+      (ATTR_AXISTEN_IF_ENABLE_CLIENT_TAG ? 8'hCC : tag_), // Tag
+      //96
+      RP_BUS_DEV_FNS, // Requester ID -- Used only when RID enable = 1
+      ep_,    // Poisoned Req
+      4'b0001,// Req Type for MWr Req
+      (set_malformed ? (len_ + 11'h4) : len_),  // DWORD Count
+      //64
+      addr_[63:2], // Memory Write address 64-bits
+      2'b00   // AT -> 00 : Untranslated Address
+    };
+
+  //-----------------------------------------------------------------------\\
+  data_pcie_i = {
+      DATA_STORE[0],
+      DATA_STORE[1],
+      DATA_STORE[2],
+      DATA_STORE[3],
+      DATA_STORE[4],
+      DATA_STORE[5],
+      DATA_STORE[6],
+      DATA_STORE[7],
+      DATA_STORE[8],
+      DATA_STORE[9],
+      DATA_STORE[10],
+      DATA_STORE[11],
+      DATA_STORE[12],
+      DATA_STORE[13],
+      DATA_STORE[14],
+      DATA_STORE[15]
+    };
+
+  pcie_tlp_data <= #(Tcq) {
+      3'b011, // Fmt for 64-bit MWr Req
+      5'b00000, // Type for 64-bit MWr Req
+      1'b0,  // *reserved*
+      tc_,   // 3-bit Traffic Class
+      1'b0,  // *reserved*
+      1'b0,  // Attributes {ID Based Ordering}
+      1'b0,  // *reserved*
+      1'b0,  // TLP Processing Hints
+      1'b0,  // TLP Digest Present
+      ep_,   // Poisoned Req
+      2'b00, // Attributes {Relaxed Ordering, No Snoop}
+      2'b00, // Address Translation
+      (set_malformed ? (len_[9:0] + 10'h4) : len_[9:0]),  // DWORD Count
+      RP_BUS_DEV_FNS, // Requester ID
+      (ATTR_AXISTEN_IF_ENABLE_CLIENT_TAG ? 8'hCC : tag_), // Tag
+      last_dw_be_,   // Last DW Byte Enable
+      first_dw_be_, // First DW Byte Enable
+      //64
+      addr_[63:2], // Memory Write address 64-bits
+      2'b00,      // *reserved*
+      //128
+      data_pcie_i // Payload Data
+      //256
+    };
+
+  pcie_tlp_rem  <= #(Tcq) (_len > 3) ? 3'b000 : (4-_len);
+  set_malformed <= #(Tcq) 1'b0;
+  _len = (_len > 3) ? (_len - 11'h4) : 11'h0;
+  //-----------------------------------------------------------------------\\
+  s_axis_rq_tvalid <= #(Tcq) 1'b1;
+
+  if(len_i > 4 || AXISTEN_IF_RQ_ALIGNMENT_MODE == "TRUE") begin
+    s_axis_rq_tlast <= #(Tcq) 1'b0;
+    s_axis_rq_tkeep <= #(Tcq) 8'hFF;
+
+    len_i = (AXISTEN_IF_RQ_ALIGNMENT_MODE == "FALSE") ? (len_i - 4) : len_i; // Don't subtract 4 in Address Aligned because
+                                                                             // it's always padded with zeros on first beat
+
+    // pcie_tlp_data doesn't append zero even in Address Aligned mode, so it should mark this cycle as the last beat if it has no more payload to log.
+    // The AXIS RQ interface will need to execute the next cycle, but we're just not going to log that data beat in pcie_tlp_data
+    if(_len == 0)
+      TSK_TX_SYNCHRONIZE(1, 1, 1, `SYNC_RQ_RDY);
+    else
+      TSK_TX_SYNCHRONIZE(1, 1, 0, `SYNC_RQ_RDY);
+  end else begin
+    if     (len_i == 1) s_axis_rq_tkeep <= #(Tcq) 8'h1F;
+    else if(len_i == 2) s_axis_rq_tkeep <= #(Tcq) 8'h3F;
+    else if(len_i == 3) s_axis_rq_tkeep <= #(Tcq) 8'h7F;
+    else                s_axis_rq_tkeep <= #(Tcq) 8'hFF;
+
+    s_axis_rq_tlast <= #(Tcq) 1'b1;
+    len_i = 0;
+
+    TSK_TX_SYNCHRONIZE(1, 1, 1, `SYNC_RQ_RDY);
+  end
+
+  // End of First Data Beat
+  //-----------------------------------------------------------------------\\
+  // Start of Second and Subsequent Data Beat
+  if(len_i != 0 || AXISTEN_IF_RQ_ALIGNMENT_MODE == "TRUE") begin
+    fork
+    begin // Sequential group 1 - AXIS RQ
+      for (_j = start_addr; len_i != 0; _j = _j + 32) begin
+        if(_j == start_addr) begin
+          aa_data = {
+              DATA_STORE[_j + 31],
+              DATA_STORE[_j + 30],
+              DATA_STORE[_j + 29],
+              DATA_STORE[_j + 28],
+              DATA_STORE[_j + 27],
+              DATA_STORE[_j + 26],
+              DATA_STORE[_j + 25],
+              DATA_STORE[_j + 24],
+              DATA_STORE[_j + 23],
+              DATA_STORE[_j + 22],
+              DATA_STORE[_j + 21],
+              DATA_STORE[_j + 20],
+              DATA_STORE[_j + 19],
+              DATA_STORE[_j + 18],
+              DATA_STORE[_j + 17],
+              DATA_STORE[_j + 16],
+              DATA_STORE[_j + 15],
+              DATA_STORE[_j + 14],
+              DATA_STORE[_j + 13],
+              DATA_STORE[_j + 12],
+              DATA_STORE[_j + 11],
+              DATA_STORE[_j + 10],
+              DATA_STORE[_j +  9],
+              DATA_STORE[_j +  8],
+              DATA_STORE[_j +  7],
+              DATA_STORE[_j +  6],
+              DATA_STORE[_j +  5],
+              DATA_STORE[_j +  4],
+              DATA_STORE[_j +  3],
+              DATA_STORE[_j +  2],
+              DATA_STORE[_j +  1],
+              DATA_STORE[_j +  0]
+            } << (aa_dw*4*8);
+        end else begin
+          aa_data = {
+              DATA_STORE[_j + 31 - (aa_dw*4)],
+              DATA_STORE[_j + 30 - (aa_dw*4)],
+              DATA_STORE[_j + 29 - (aa_dw*4)],
+              DATA_STORE[_j + 28 - (aa_dw*4)],
+              DATA_STORE[_j + 27 - (aa_dw*4)],
+              DATA_STORE[_j + 26 - (aa_dw*4)],
+              DATA_STORE[_j + 25 - (aa_dw*4)],
+              DATA_STORE[_j + 24 - (aa_dw*4)],
+              DATA_STORE[_j + 23 - (aa_dw*4)],
+              DATA_STORE[_j + 22 - (aa_dw*4)],
+              DATA_STORE[_j + 21 - (aa_dw*4)],
+              DATA_STORE[_j + 20 - (aa_dw*4)],
+              DATA_STORE[_j + 19 - (aa_dw*4)],
+              DATA_STORE[_j + 18 - (aa_dw*4)],
+              DATA_STORE[_j + 17 - (aa_dw*4)],
+              DATA_STORE[_j + 16 - (aa_dw*4)],
+              DATA_STORE[_j + 15 - (aa_dw*4)],
+              DATA_STORE[_j + 14 - (aa_dw*4)],
+              DATA_STORE[_j + 13 - (aa_dw*4)],
+              DATA_STORE[_j + 12 - (aa_dw*4)],
+              DATA_STORE[_j + 11 - (aa_dw*4)],
+              DATA_STORE[_j + 10 - (aa_dw*4)],
+              DATA_STORE[_j +  9 - (aa_dw*4)],
+              DATA_STORE[_j +  8 - (aa_dw*4)],
+              DATA_STORE[_j +  7 - (aa_dw*4)],
+              DATA_STORE[_j +  6 - (aa_dw*4)],
+              DATA_STORE[_j +  5 - (aa_dw*4)],
+              DATA_STORE[_j +  4 - (aa_dw*4)],
+              DATA_STORE[_j +  3 - (aa_dw*4)],
+              DATA_STORE[_j +  2 - (aa_dw*4)],
+              DATA_STORE[_j +  1 - (aa_dw*4)],
+              DATA_STORE[_j +  0 - (aa_dw*4)]
+            };
+        end
+
+        s_axis_rq_tdata <= #(Tcq) aa_data;
+
+        if((len_i)/8 == 0) begin
+          case ((len_i) % 8)
+            1 : begin len_i = len_i - 1; s_axis_rq_tkeep <= #(Tcq) 8'h01; end  // D0---------------------
+            2 : begin len_i = len_i - 2; s_axis_rq_tkeep <= #(Tcq) 8'h03; end  // D0-D1------------------
+            3 : begin len_i = len_i - 3; s_axis_rq_tkeep <= #(Tcq) 8'h07; end  // D0-D1-D2---------------
+            4 : begin len_i = len_i - 4; s_axis_rq_tkeep <= #(Tcq) 8'h0F; end  // D0-D1-D2-D3------------
+            5 : begin len_i = len_i - 5; s_axis_rq_tkeep <= #(Tcq) 8'h1F; end  // D0-D1-D2-D3-D4---------
+            6 : begin len_i = len_i - 6; s_axis_rq_tkeep <= #(Tcq) 8'h3F; end  // D0-D1-D2-D3-D4-D5------
+            7 : begin len_i = len_i - 7; s_axis_rq_tkeep <= #(Tcq) 8'h7F; end  // D0-D1-D2-D3-D4-D5-D6---
+            0 : begin len_i = len_i - 8; s_axis_rq_tkeep <= #(Tcq) 8'hFF; end  // D0-D1-D2-D3-D4-D5-D6-D7
+          endcase
+        end else begin
+          len_i = len_i - 8; s_axis_rq_tkeep <= #(Tcq) 8'hFF;      // D0-D1-D2-D3-D4-D5-D6-D7
+        end
+
+        if(len_i == 0)
+            s_axis_rq_tlast <= #(Tcq) 1'b1;
+        else
+            s_axis_rq_tlast <= #(Tcq) 1'b0;
+
+        // Call this just to check for the tready, but don't log anything. That's the job for pcie_tlp_data
+        // The reason for splitting the TSK_TX_SYNCHRONIZE task and distribute them in both sequential group
+        // is that in address aligned mode, it's possible that the additional padded zeros cause the AXIS RQ
+        // to be one beat longer than the actual PCIe TLP. When it happens do not log the last clock beat
+        // but just send the packet on AXIS RQ interface
+        TSK_TX_SYNCHRONIZE(0, 0, 0, `SYNC_RQ_RDY);
+
+      end // for loop
+    end // End sequential group 1 - AXIS RQ
+
+    begin // Sequential group 2 - pcie_tlp
+      for (_j = 16; _len != 0; _j = _j + 32) begin
+        pcie_tlp_data <= #(Tcq) {
+            DATA_STORE[_j + 0],
+            DATA_STORE[_j + 1],
+            DATA_STORE[_j + 2],
+            DATA_STORE[_j + 3],
+            DATA_STORE[_j + 4],
+            DATA_STORE[_j + 5],
+            DATA_STORE[_j + 6],
+            DATA_STORE[_j + 7],
+            DATA_STORE[_j + 8],
+            DATA_STORE[_j + 9],
+            DATA_STORE[_j + 10],
+            DATA_STORE[_j + 11],
+            DATA_STORE[_j + 12],
+            DATA_STORE[_j + 13],
+            DATA_STORE[_j + 14],
+            DATA_STORE[_j + 15],
+            DATA_STORE[_j + 16],
+            DATA_STORE[_j + 17],
+            DATA_STORE[_j + 18],
+            DATA_STORE[_j + 19],
+            DATA_STORE[_j + 20],
+            DATA_STORE[_j + 21],
+            DATA_STORE[_j + 22],
+            DATA_STORE[_j + 23],
+            DATA_STORE[_j + 24],
+            DATA_STORE[_j + 25],
+            DATA_STORE[_j + 26],
+            DATA_STORE[_j + 27],
+            DATA_STORE[_j + 28],
+            DATA_STORE[_j + 29],
+            DATA_STORE[_j + 30],
+            DATA_STORE[_j + 31]
+          };
+
+        if((_len)/8 == 0) begin
+          case ((_len) % 8)
+            1 : begin _len = _len - 1; pcie_tlp_rem <= #(Tcq) 3'b111; end  // D0---------------------
+            2 : begin _len = _len - 2; pcie_tlp_rem <= #(Tcq) 3'b110; end  // D0-D1------------------
+            3 : begin _len = _len - 3; pcie_tlp_rem <= #(Tcq) 3'b101; end  // D0-D1-D2---------------
+            4 : begin _len = _len - 4; pcie_tlp_rem <= #(Tcq) 3'b100; end  // D0-D1-D2-D3------------
+            5 : begin _len = _len - 5; pcie_tlp_rem <= #(Tcq) 3'b011; end  // D0-D1-D2-D3-D4---------
+            6 : begin _len = _len - 6; pcie_tlp_rem <= #(Tcq) 3'b010; end  // D0-D1-D2-D3-D4-D5------
+            7 : begin _len = _len - 7; pcie_tlp_rem <= #(Tcq) 3'b001; end  // D0-D1-D2-D3-D4-D5-D6---
+            0 : begin _len = _len - 8; pcie_tlp_rem <= #(Tcq) 3'b000; end  // D0-D1-D2-D3-D4-D5-D6-D7
+          endcase
+        end else begin
+          _len               = _len - 8; pcie_tlp_rem <= #(Tcq) 3'b000; // D0-D1-D2-D3-D4-D5-D6-D7
+        end
+
+        if(_len == 0)
+          TSK_TX_SYNCHRONIZE(0, 1, 1, `SYNC_RQ_RDY);
+        else
+          TSK_TX_SYNCHRONIZE(0, 1, 0, `SYNC_RQ_RDY);
+      end // for loop
+    end // End sequential group 2 - pcie_tlp
+
+    join
+  end // if
+  // End of Second and Subsequent Data Beat
+  //-----------------------------------------------------------------------\\
+  // Packet Complete - Drive 0s
+  s_axis_rq_tvalid         <= #(Tcq) 1'b0;
+  s_axis_rq_tlast          <= #(Tcq) 1'b0;
+  s_axis_rq_tkeep          <= #(Tcq) 8'h00;
+  s_axis_rq_tuser_wo_parity<= #(Tcq) 137'b0;
+  s_axis_rq_tdata          <= #(Tcq) 512'b0;
+  //-----------------------------------------------------------------------\\
+  pcie_tlp_rem             <= #(Tcq) 3'b000;
+  //-----------------------------------------------------------------------\\
+end
+endtask // TSK_TX_MEMORY_WRITE_64
+
+/************************************************************
+Task : TSK_TX_COMPLETION_DATA
+Inputs : Tag, TC, Length, Completion ID
+Outputs : Transaction Tx Interface Signaling
+Description : Generates a Completion TLP
+*************************************************************/
+
+task TSK_TX_COMPLETION_DATA;
+  input   [15:0]   req_id_;      // Requester ID
+  input   [7:0]    tag_;         // Tag
+  input   [2:0]    tc_;          // Traffic Class
+  input   [10:0]   len_;         // Length (in DW)
+  input   [11:0]   byte_count_;  // Length (in bytes)
+  input   [15:0]   lower_addr_;  // Lower 7-bits of Address of first valid data
+  input [RP_BAR_SIZE:0] ram_ptr; // RP RAM Read Offset
+  input   [2:0]    comp_status_; // Completion Status. 'b000: Success; 'b001: Unsupported Request; 'b010: Config Request Retry Status;'b100: Completer Abort
+  input            ep_;          // Poisoned Data: Payload is invalid if set
+  input   [2:0]    attr_;        // Attributes. {ID Based Ordering, Relaxed Ordering, No Snoop}
+  reg     [10:0]   _len;         // Length Info on pcie_tlp_data -- Used to count how many times to loop
+  reg     [10:0]   len_i;        // Length Info on s_axis_rq_tdata -- Used to count how many times to loop
+  reg     [2:0]    aa_dw;        // Adjusted DW Count for Address Aligned Mode
+  reg     [511:0]  aa_data;      // Adjusted Data for Address Aligned Mode
+  reg     [415:0]  data_axis_i;  // Data Info for s_axis_rq_tdata
+  reg     [415:0]  data_pcie_i;  // Data Info for pcie_tlp_data
+  reg     [RP_BAR_SIZE:0]   _j;  // Byte Index for aa_data
+  reg     [RP_BAR_SIZE:0]  _jj;  // Byte Index pcie_tlp_data
+  integer          start_addr;   // Start Location for Payload DW0
+
+begin
+  //-----------------------------------------------------------------------\\
+  $display(" ***** TSK_TX_COMPLETION_DATA ****** addr = %d., byte_count =%d, len = %d, comp_status = %d\n", lower_addr_, byte_count_, len_, comp_status_ ) ;
+  //$display("[%t] : CC Data Completion Task Begin", $realtime);
+  if(AXISTEN_IF_CC_ALIGNMENT_MODE=="TRUE") begin
+      start_addr  = 0;
+      aa_dw   = lower_addr_[4:2];
+  end else begin
+      start_addr  = 52;
+      aa_dw   = 3'b000;
+  end
+
+  len_i = len_ + aa_dw;
+  _len  = len_;
+  //-----------------------------------------------------------------------\\
+  if(user_lnk_up_n) begin
+    $display("[%t] :  interface is MIA", $realtime);
+    $finish(1);
+  end
+
+  //-----------------------------------------------------------------------\\
+  TSK_TX_SYNCHRONIZE(0, 0, 0, `SYNC_CC_RDY);
+  //-----------------------------------------------------------------------\\
+  // Start of First Data Beat
+  data_axis_i = {
+      DATA_STORE[lower_addr_ +51], DATA_STORE[lower_addr_ +50], DATA_STORE[lower_addr_ +49],
+      DATA_STORE[lower_addr_ +48], DATA_STORE[lower_addr_ +47], DATA_STORE[lower_addr_ +46],
+      DATA_STORE[lower_addr_ +45], DATA_STORE[lower_addr_ +44], DATA_STORE[lower_addr_ +43],
+      DATA_STORE[lower_addr_ +42], DATA_STORE[lower_addr_ +41], DATA_STORE[lower_addr_ +40],
+      DATA_STORE[lower_addr_ +39], DATA_STORE[lower_addr_ +38], DATA_STORE[lower_addr_ +37],
+      DATA_STORE[lower_addr_ +36], DATA_STORE[lower_addr_ +35], DATA_STORE[lower_addr_ +34],
+      DATA_STORE[lower_addr_ +33], DATA_STORE[lower_addr_ +32], DATA_STORE[lower_addr_ +31],
+      DATA_STORE[lower_addr_ +30], DATA_STORE[lower_addr_ +29], DATA_STORE[lower_addr_ +28],
+      DATA_STORE[lower_addr_ +27], DATA_STORE[lower_addr_ +26], DATA_STORE[lower_addr_ +25],
+      DATA_STORE[lower_addr_ +24], DATA_STORE[lower_addr_ +23], DATA_STORE[lower_addr_ +22],
+      DATA_STORE[lower_addr_ +21], DATA_STORE[lower_addr_ +20], DATA_STORE[lower_addr_ +19],
+      DATA_STORE[lower_addr_ +18], DATA_STORE[lower_addr_ +17], DATA_STORE[lower_addr_ +16],
+      DATA_STORE[lower_addr_ +15], DATA_STORE[lower_addr_ +14], DATA_STORE[lower_addr_ +13],
+      DATA_STORE[lower_addr_ +12], DATA_STORE[lower_addr_ +11], DATA_STORE[lower_addr_ +10],
+      DATA_STORE[lower_addr_ + 9], DATA_STORE[lower_addr_ + 8], DATA_STORE[lower_addr_ + 7],
+      DATA_STORE[lower_addr_ + 6], DATA_STORE[lower_addr_ + 5], DATA_STORE[lower_addr_ + 4],
+      DATA_STORE[lower_addr_ + 3], DATA_STORE[lower_addr_ + 2], DATA_STORE[lower_addr_ + 1],
+      DATA_STORE[lower_addr_ + 0]
+    };
+
+  data_pcie_i = {
+      DATA_STORE[lower_addr_ + 0], DATA_STORE[lower_addr_ + 1], DATA_STORE[lower_addr_ + 2],
+      DATA_STORE[lower_addr_ + 3], DATA_STORE[lower_addr_ + 4], DATA_STORE[lower_addr_ + 5],
+      DATA_STORE[lower_addr_ + 6], DATA_STORE[lower_addr_ + 7], DATA_STORE[lower_addr_ + 8],
+      DATA_STORE[lower_addr_ + 9], DATA_STORE[lower_addr_ +10], DATA_STORE[lower_addr_ +11],
+      DATA_STORE[lower_addr_ +12], DATA_STORE[lower_addr_ +13], DATA_STORE[lower_addr_ +14],
+      DATA_STORE[lower_addr_ +15], DATA_STORE[lower_addr_ +16], DATA_STORE[lower_addr_ +17],
+      DATA_STORE[lower_addr_ +18], DATA_STORE[lower_addr_ +19], DATA_STORE[lower_addr_ +20],
+      DATA_STORE[lower_addr_ +21], DATA_STORE[lower_addr_ +22], DATA_STORE[lower_addr_ +23],
+      DATA_STORE[lower_addr_ +24], DATA_STORE[lower_addr_ +25], DATA_STORE[lower_addr_ +26],
+      DATA_STORE[lower_addr_ +27], DATA_STORE[lower_addr_ +28], DATA_STORE[lower_addr_ +29],
+      DATA_STORE[lower_addr_ +30], DATA_STORE[lower_addr_ +31], DATA_STORE[lower_addr_ +32],
+      DATA_STORE[lower_addr_ +33], DATA_STORE[lower_addr_ +34], DATA_STORE[lower_addr_ +35],
+      DATA_STORE[lower_addr_ +36], DATA_STORE[lower_addr_ +37], DATA_STORE[lower_addr_ +38],
+      DATA_STORE[lower_addr_ +39], DATA_STORE[lower_addr_ +40], DATA_STORE[lower_addr_ +41],
+      DATA_STORE[lower_addr_ +42], DATA_STORE[lower_addr_ +43], DATA_STORE[lower_addr_ +44],
+      DATA_STORE[lower_addr_ +45], DATA_STORE[lower_addr_ +46], DATA_STORE[lower_addr_ +47],
+      DATA_STORE[lower_addr_ +48], DATA_STORE[lower_addr_ +49], DATA_STORE[lower_addr_ +50],
+      DATA_STORE[lower_addr_ +51]
+    };
+
+//s_axis_cc_tuser <= #(Tcq) {(AXISTEN_IF_CC_PARITY_CHECK ? s_axis_cc_tparity : 32'b0),1'b0};
+  s_axis_cc_tuser <= #(Tcq) {/*(AXISTEN_IF_CC_PARITY_CHECK ? s_axis_cc_tparity :*/ 64'b0, // parity 64 bit -[80:17]
+      1'b0,    // Discontinue
+      4'b0000, // is_eop1_ptr
+      4'b1010, // is_eop0_ptr  There are 11 Dwords 0-10, 0xA
+      2'b01,   // is_eop[1:0]
+      2'b00,   // is_sop1_ptr[1:0]
+      2'b00,   // is_sop0_ptr[1:0]
+      2'b01};  // is_sop[1:0]
+
+  s_axis_cc_tdata <= #(Tcq) {
+      ((AXISTEN_IF_CC_ALIGNMENT_MODE == "FALSE" ) ? data_axis_i : 416'h0), // 416-bit completion data
+      1'b0,   // Force ECRC                                  //96
+      attr_,  // Attributes {ID Based Ordering, Relaxed Ordering, No Snoop}
+      tc_,    // Traffic Class
+      1'b1,   // Completer ID to Control Selection of Client
+      RP_BUS_DEV_FNS, // Completer ID
+      tag_ ,  // Tag
+      req_id_,// Requester ID                             //64
+      1'b0,   // *reserved*
+      ep_,    // Poisoned Completion
+      comp_status_,  // Completion Status {0= SC, 1= UR, 2= CRS, 4= CA}
+      len_,   // DWORD Count
+      2'b0,   // *reserved*                               //32
+      1'b0,   // Locked Read Completion
+      1'b0,   // Byte Count MSB
+      byte_count_, // Byte Count
+      6'b0,   // *reserved*
+      2'b0,   // Address Type
+      1'b0,   // *reserved*
+      lower_addr_[6:0] };  // Starting Address of the Completion Data Byte
+  //-----------------------------------------------------------------------\\
+  pcie_tlp_data     <= #(Tcq) {
+       3'b010,   // Fmt for Completion with Data
+       5'b01010, // Type for Completion with Data
+       1'b0,     // *reserved*
+       tc_,      // 3-bit Traffic Class
+       1'b0,     // *reserved*
+       attr_[2], // Attributes {ID Based Ordering}
+       1'b0,     // *reserved*
+       1'b0,     // TLP Processing Hints
+       1'b0,     // TLP Digest Present
+       ep_,      // Poisoned Req
+       attr_[1:0], // Attributes {Relaxed Ordering, No Snoop}
+       2'b00,    // Address Translation
+       len_[9:0],// DWORD Count //32
+       RP_BUS_DEV_FNS, // Completer ID
+       comp_status_,   // Completion Status {0= SC, 1= UR, 2= CRS, 4= CA}
+       1'b0,     // Byte Count Modified (only used in PCI-X)
+       byte_count_,  // Byte Count  //64
+       req_id_,  // Requester ID
+       tag_,     // Tag
+       1'b0,     // *reserved
+       lower_addr_[6:0], // Starting Address of the Completion Data Byte //96
+       data_pcie_i };  // 416-bit completion data //512
+
+  pcie_tlp_rem <= #(Tcq) (_len > 12) ? 4'b0000 : (13-_len);
+  _len = (_len > 12) ? (_len - 11'hD) : 11'h0;
+  //-----------------------------------------------------------------------\\
+  s_axis_cc_tvalid  <= #(Tcq) 1'b1;
+
+  if(len_i > 13 || AXISTEN_IF_CC_ALIGNMENT_MODE == "TRUE") begin
+    s_axis_cc_tlast          <= #(Tcq) 1'b0;
+    s_axis_cc_tkeep          <= #(Tcq) 16'hFFFF;
+
+    len_i = (AXISTEN_IF_CC_ALIGNMENT_MODE == "FALSE") ? (len_i - 11'hD) : len_i; // Don't subtract 13 in Address Aligned because
+                                                                                // it's always padded with zeros on first beat
+
+    // pcie_tlp_data doesn't append zero even in Address Aligned mode, so it should mark this cycle as the last beat if it has no more payload to log.
+    // The AXIS CC interface will need to execute the next cycle, but we're just not going to log that data beat in pcie_tlp_data
+    if(_len == 0)
+      TSK_TX_SYNCHRONIZE(1, 1, 1, `SYNC_CC_RDY);
+    else
+      TSK_TX_SYNCHRONIZE(1, 1, 0, `SYNC_CC_RDY);
+
+  end else begin
+    case (len_i)
+      1 :  begin s_axis_cc_tkeep <= #(Tcq) 16'h000F; end
+      2 :  begin s_axis_cc_tkeep <= #(Tcq) 16'h001F; end
+      3 :  begin s_axis_cc_tkeep <= #(Tcq) 16'h003F; end
+      4 :  begin s_axis_cc_tkeep <= #(Tcq) 16'h007F; end
+      5 :  begin s_axis_cc_tkeep <= #(Tcq) 16'h00FF; end
+      6 :  begin s_axis_cc_tkeep <= #(Tcq) 16'h01FF; end
+      7 :  begin s_axis_cc_tkeep <= #(Tcq) 16'h03FF; end
+      8 :  begin s_axis_cc_tkeep <= #(Tcq) 16'h07FF; end
+      9 :  begin s_axis_cc_tkeep <= #(Tcq) 16'h0FFF; end
+      10 : begin s_axis_cc_tkeep <= #(Tcq) 16'h1FFF; end
+      11 : begin s_axis_cc_tkeep <= #(Tcq) 16'h3FFF; end
+      12 : begin s_axis_cc_tkeep <= #(Tcq) 16'h7FFF; end
+      default: begin s_axis_cc_tkeep <= #(Tcq) 16'hFFFF; end
+    endcase
+
+    s_axis_cc_tlast <= #(Tcq) 1'b1;
+
+    len_i = 0;
+
+    TSK_TX_SYNCHRONIZE(1, 1, 1, `SYNC_CC_RDY);
+  end
+  // End of First Data Beat
+  //-----------------------------------------------------------------------\\
+  // Start of Second and Subsequent Data Beat
+  if(len_i != 0 || AXISTEN_IF_CC_ALIGNMENT_MODE == "TRUE") begin
+    fork
+    begin // Sequential group 1 - AXIS CC
+      for (_j = start_addr; len_i != 0; _j = _j + 64) begin
+        if(_j == start_addr) begin
+          aa_data = {
+              DATA_STORE[lower_addr_ + _j + 63], DATA_STORE[lower_addr_ + _j + 62], DATA_STORE[lower_addr_ + _j + 61],
+              DATA_STORE[lower_addr_ + _j + 60], DATA_STORE[lower_addr_ + _j + 59], DATA_STORE[lower_addr_ + _j + 58],
+              DATA_STORE[lower_addr_ + _j + 57], DATA_STORE[lower_addr_ + _j + 56], DATA_STORE[lower_addr_ + _j + 55],
+              DATA_STORE[lower_addr_ + _j + 54], DATA_STORE[lower_addr_ + _j + 53], DATA_STORE[lower_addr_ + _j + 52],
+              DATA_STORE[lower_addr_ + _j + 51], DATA_STORE[lower_addr_ + _j + 50], DATA_STORE[lower_addr_ + _j + 49],
+              DATA_STORE[lower_addr_ + _j + 48], DATA_STORE[lower_addr_ + _j + 47], DATA_STORE[lower_addr_ + _j + 46],
+              DATA_STORE[lower_addr_ + _j + 45], DATA_STORE[lower_addr_ + _j + 44], DATA_STORE[lower_addr_ + _j + 43],
+              DATA_STORE[lower_addr_ + _j + 42], DATA_STORE[lower_addr_ + _j + 41], DATA_STORE[lower_addr_ + _j + 40],
+              DATA_STORE[lower_addr_ + _j + 39], DATA_STORE[lower_addr_ + _j + 38], DATA_STORE[lower_addr_ + _j + 37],
+              DATA_STORE[lower_addr_ + _j + 36], DATA_STORE[lower_addr_ + _j + 35], DATA_STORE[lower_addr_ + _j + 34],
+              DATA_STORE[lower_addr_ + _j + 33], DATA_STORE[lower_addr_ + _j + 32], DATA_STORE[lower_addr_ + _j + 31],
+              DATA_STORE[lower_addr_ + _j + 30], DATA_STORE[lower_addr_ + _j + 29], DATA_STORE[lower_addr_ + _j + 28],
+              DATA_STORE[lower_addr_ + _j + 27], DATA_STORE[lower_addr_ + _j + 26], DATA_STORE[lower_addr_ + _j + 25],
+              DATA_STORE[lower_addr_ + _j + 24], DATA_STORE[lower_addr_ + _j + 23], DATA_STORE[lower_addr_ + _j + 22],
+              DATA_STORE[lower_addr_ + _j + 21], DATA_STORE[lower_addr_ + _j + 20], DATA_STORE[lower_addr_ + _j + 19],
+              DATA_STORE[lower_addr_ + _j + 18], DATA_STORE[lower_addr_ + _j + 17], DATA_STORE[lower_addr_ + _j + 16],
+              DATA_STORE[lower_addr_ + _j + 15], DATA_STORE[lower_addr_ + _j + 14], DATA_STORE[lower_addr_ + _j + 13],
+              DATA_STORE[lower_addr_ + _j + 12], DATA_STORE[lower_addr_ + _j + 11], DATA_STORE[lower_addr_ + _j + 10],
+              DATA_STORE[lower_addr_ + _j +  9], DATA_STORE[lower_addr_ + _j +  8], DATA_STORE[lower_addr_ + _j +  7],
+              DATA_STORE[lower_addr_ + _j +  6], DATA_STORE[lower_addr_ + _j +  5], DATA_STORE[lower_addr_ + _j +  4],
+              DATA_STORE[lower_addr_ + _j +  3], DATA_STORE[lower_addr_ + _j +  2], DATA_STORE[lower_addr_ + _j +  1],
+              DATA_STORE[lower_addr_ + _j +  0]
+            } << (aa_dw*4*8);
+        end else begin
+          aa_data = {
+              DATA_STORE[lower_addr_ + _j + 63 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j + 62 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j + 61 - (aa_dw*4)],
+              DATA_STORE[lower_addr_ + _j + 60 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j + 59 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j + 58 - (aa_dw*4)],
+              DATA_STORE[lower_addr_ + _j + 57 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j + 56 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j + 55 - (aa_dw*4)],
+              DATA_STORE[lower_addr_ + _j + 54 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j + 53 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j + 52 - (aa_dw*4)],
+              DATA_STORE[lower_addr_ + _j + 51 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j + 50 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j + 49 - (aa_dw*4)],
+              DATA_STORE[lower_addr_ + _j + 48 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j + 47 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j + 46 - (aa_dw*4)],
+              DATA_STORE[lower_addr_ + _j + 45 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j + 44 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j + 43 - (aa_dw*4)],
+              DATA_STORE[lower_addr_ + _j + 42 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j + 41 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j + 40 - (aa_dw*4)],
+              DATA_STORE[lower_addr_ + _j + 39 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j + 38 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j + 37 - (aa_dw*4)],
+              DATA_STORE[lower_addr_ + _j + 36 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j + 35 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j + 34 - (aa_dw*4)],
+              DATA_STORE[lower_addr_ + _j + 33 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j + 32 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j + 31 - (aa_dw*4)],
+              DATA_STORE[lower_addr_ + _j + 30 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j + 29 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j + 28 - (aa_dw*4)],
+              DATA_STORE[lower_addr_ + _j + 27 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j + 26 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j + 25 - (aa_dw*4)],
+              DATA_STORE[lower_addr_ + _j + 24 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j + 23 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j + 22 - (aa_dw*4)],
+              DATA_STORE[lower_addr_ + _j + 21 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j + 20 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j + 19 - (aa_dw*4)],
+              DATA_STORE[lower_addr_ + _j + 18 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j + 17 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j + 16 - (aa_dw*4)],
+              DATA_STORE[lower_addr_ + _j + 15 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j + 14 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j + 13 - (aa_dw*4)],
+              DATA_STORE[lower_addr_ + _j + 12 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j + 11 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j + 10 - (aa_dw*4)],
+              DATA_STORE[lower_addr_ + _j +  9 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j +  8 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j +  7 - (aa_dw*4)],
+              DATA_STORE[lower_addr_ + _j +  6 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j +  5 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j +  4 - (aa_dw*4)],
+              DATA_STORE[lower_addr_ + _j +  3 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j +  2 - (aa_dw*4)], DATA_STORE[lower_addr_ + _j +  1 - (aa_dw*4)],
+              DATA_STORE[lower_addr_ + _j +  0 - (aa_dw*4)]
+            };
+        end
+
+        s_axis_cc_tdata <= #(Tcq) aa_data;
+
+        if((len_i)/16 == 0) begin
+          case (len_i % 16)
+            1 :  begin len_i = len_i - 1;  s_axis_cc_tkeep <= #(Tcq) 16'h0001; end // D0---------------------------------------------------
+            2 :  begin len_i = len_i - 2;  s_axis_cc_tkeep <= #(Tcq) 16'h0003; end // D0-D1------------------------------------------------
+            3 :  begin len_i = len_i - 3;  s_axis_cc_tkeep <= #(Tcq) 16'h0007; end // D0-D1-D2---------------------------------------------
+            4 :  begin len_i = len_i - 4;  s_axis_cc_tkeep <= #(Tcq) 16'h000F; end // D0-D1-D2-D3------------------------------------------
+            5 :  begin len_i = len_i - 5;  s_axis_cc_tkeep <= #(Tcq) 16'h001F; end // D0-D1-D2-D3-D4---------------------------------------
+            6 :  begin len_i = len_i - 6;  s_axis_cc_tkeep <= #(Tcq) 16'h003F; end // D0-D1-D2-D3-D4-D5------------------------------------
+            7 :  begin len_i = len_i - 7;  s_axis_cc_tkeep <= #(Tcq) 16'h007F; end // D0-D1-D2-D3-D4-D5-D6---------------------------------
+            8 :  begin len_i = len_i - 8;  s_axis_cc_tkeep <= #(Tcq) 16'h00FF; end // D0-D1-D2-D3-D4-D5-D6-D7------------------------------
+            9 :  begin len_i = len_i - 9;  s_axis_cc_tkeep <= #(Tcq) 16'h01FF; end // D0-D1-D2-D3-D4-D5-D6-D7-D8---------------------------
+            10 : begin len_i = len_i - 10; s_axis_cc_tkeep <= #(Tcq) 16'h03FF; end // D0-D1-D2-D3-D4-D5-D6-D7-D8-D9------------------------
+            11 : begin len_i = len_i - 11; s_axis_cc_tkeep <= #(Tcq) 16'h07FF; end // D0-D1-D2-D3-D4-D5-D6-D7-D8-D9-D10--------------------
+            12 : begin len_i = len_i - 12; s_axis_cc_tkeep <= #(Tcq) 16'h0FFF; end // D0-D1-D2-D3-D4-D5-D6-D7-D8-D9-D10-D11----------------
+            13 : begin len_i = len_i - 13; s_axis_cc_tkeep <= #(Tcq) 16'h1FFF; end // D0-D1-D2-D3-D4-D5-D6-D7-D8-D9-D10-D11-D12------------
+            14 : begin len_i = len_i - 14; s_axis_cc_tkeep <= #(Tcq) 16'h3FFF; end // D0-D1-D2-D3-D4-D5-D6-D7-D8-D9-D10-D11-D12-D13--------
+            15 : begin len_i = len_i - 15; s_axis_cc_tkeep <= #(Tcq) 16'h7FFF; end // D0-D1-D2-D3-D4-D5-D6-D7-D8-D9-D10-D11-D12-D13-D14----
+            0  : begin len_i = len_i - 16; s_axis_cc_tkeep <= #(Tcq) 16'hFFFF; end // D0-D1-D2-D3-D4-D5-D6-D7-D8-D9-D10-D11-D12-D13-D14-D15
+          endcase
+        end else begin
+          len_i = len_i - 16; s_axis_cc_tkeep <= #(Tcq) 16'hFFFF;     // D0-D1-D2-D3-D4-D5-D6-D7-D8-D9-D10-D11-D12-D13-D14-D15
+        end
+
+        if(len_i == 0)
+          s_axis_cc_tlast <= #(Tcq) 1'b1;
+        else
+          s_axis_cc_tlast <= #(Tcq) 1'b0;
+
+          // Call this just to check for the tready, but don't log anything. That's the job for pcie_tlp_data
+          // The reason for splitting the TSK_TX_SYNCHRONIZE task and distribute them in both sequential group
+          // is that in address aligned mode, it's possible that the additional padded zeros cause the AXIS CC
+          // to be one beat longer than the actual PCIe TLP. When it happens do not log the last clock beat
+          // but just send the packet on AXIS CC interface
+          TSK_TX_SYNCHRONIZE(0, 0, 0, `SYNC_CC_RDY);
+
+      end // for loop
+    end // End sequential group 1 - AXIS CC
+
+    begin // Sequential group 2 - pcie_tlp
+      for (_jj = 52; _len != 0; _jj = _jj + 64) begin
+        pcie_tlp_data <= #(Tcq) {
+            DATA_STORE[lower_addr_ + _jj +  0], DATA_STORE[lower_addr_ + _jj +  1], DATA_STORE[lower_addr_ + _jj +  2],
+            DATA_STORE[lower_addr_ + _jj +  3], DATA_STORE[lower_addr_ + _jj +  4], DATA_STORE[lower_addr_ + _jj +  5],
+            DATA_STORE[lower_addr_ + _jj +  6], DATA_STORE[lower_addr_ + _jj +  7], DATA_STORE[lower_addr_ + _jj +  8],
+            DATA_STORE[lower_addr_ + _jj +  9], DATA_STORE[lower_addr_ + _jj + 10], DATA_STORE[lower_addr_ + _jj + 11],
+            DATA_STORE[lower_addr_ + _jj + 12], DATA_STORE[lower_addr_ + _jj + 13], DATA_STORE[lower_addr_ + _jj + 14],
+            DATA_STORE[lower_addr_ + _jj + 15], DATA_STORE[lower_addr_ + _jj + 16], DATA_STORE[lower_addr_ + _jj + 17],
+            DATA_STORE[lower_addr_ + _jj + 18], DATA_STORE[lower_addr_ + _jj + 19], DATA_STORE[lower_addr_ + _jj + 20],
+            DATA_STORE[lower_addr_ + _jj + 21], DATA_STORE[lower_addr_ + _jj + 22], DATA_STORE[lower_addr_ + _jj + 23],
+            DATA_STORE[lower_addr_ + _jj + 24], DATA_STORE[lower_addr_ + _jj + 25], DATA_STORE[lower_addr_ + _jj + 26],
+            DATA_STORE[lower_addr_ + _jj + 27], DATA_STORE[lower_addr_ + _jj + 28], DATA_STORE[lower_addr_ + _jj + 29],
+            DATA_STORE[lower_addr_ + _jj + 30], DATA_STORE[lower_addr_ + _jj + 31], DATA_STORE[lower_addr_ + _jj + 32],
+            DATA_STORE[lower_addr_ + _jj + 33], DATA_STORE[lower_addr_ + _jj + 34], DATA_STORE[lower_addr_ + _jj + 35],
+            DATA_STORE[lower_addr_ + _jj + 36], DATA_STORE[lower_addr_ + _jj + 37], DATA_STORE[lower_addr_ + _jj + 38],
+            DATA_STORE[lower_addr_ + _jj + 39], DATA_STORE[lower_addr_ + _jj + 40], DATA_STORE[lower_addr_ + _jj + 41],
+            DATA_STORE[lower_addr_ + _jj + 42], DATA_STORE[lower_addr_ + _jj + 43], DATA_STORE[lower_addr_ + _jj + 44],
+            DATA_STORE[lower_addr_ + _jj + 45], DATA_STORE[lower_addr_ + _jj + 46], DATA_STORE[lower_addr_ + _jj + 47],
+            DATA_STORE[lower_addr_ + _jj + 48], DATA_STORE[lower_addr_ + _jj + 49], DATA_STORE[lower_addr_ + _jj + 50],
+            DATA_STORE[lower_addr_ + _jj + 51], DATA_STORE[lower_addr_ + _jj + 52], DATA_STORE[lower_addr_ + _jj + 53],
+            DATA_STORE[lower_addr_ + _jj + 54], DATA_STORE[lower_addr_ + _jj + 55], DATA_STORE[lower_addr_ + _jj + 56],
+            DATA_STORE[lower_addr_ + _jj + 57], DATA_STORE[lower_addr_ + _jj + 58], DATA_STORE[lower_addr_ + _jj + 59],
+            DATA_STORE[lower_addr_ + _jj + 60], DATA_STORE[lower_addr_ + _jj + 61], DATA_STORE[lower_addr_ + _jj + 62],
+            DATA_STORE[lower_addr_ + _jj + 63]
+          };
+
+        if((_len/16) == 0) begin
+          case (_len % 16)
+            1 :  begin _len = _len - 1;  pcie_tlp_rem  <= #(Tcq) 4'b1111; end // D0---------------------------------------------------
+            2 :  begin _len = _len - 2;  pcie_tlp_rem  <= #(Tcq) 4'b1110; end // D0-D1------------------------------------------------
+            3 :  begin _len = _len - 3;  pcie_tlp_rem  <= #(Tcq) 4'b1101; end // D0-D1-D2---------------------------------------------
+            4 :  begin _len = _len - 4;  pcie_tlp_rem  <= #(Tcq) 4'b1100; end // D0-D1-D2-D3------------------------------------------
+            5 :  begin _len = _len - 5;  pcie_tlp_rem  <= #(Tcq) 4'b1011; end // D0-D1-D2-D3-D4---------------------------------------
+            6 :  begin _len = _len - 6;  pcie_tlp_rem  <= #(Tcq) 4'b1010; end // D0-D1-D2-D3-D4-D5------------------------------------
+            7 :  begin _len = _len - 7;  pcie_tlp_rem  <= #(Tcq) 4'b1001; end // D0-D1-D2-D3-D4-D5-D6---------------------------------
+            8 :  begin _len = _len - 8;  pcie_tlp_rem  <= #(Tcq) 4'b1000; end // D0-D1-D2-D3-D4-D5-D6-D7------------------------------
+            9 :  begin _len = _len - 9;  pcie_tlp_rem  <= #(Tcq) 4'b0111; end // D0-D1-D2-D3-D4-D5-D6-D7-D8---------------------------
+            10 : begin _len = _len - 10; pcie_tlp_rem  <= #(Tcq) 4'b0110; end // D0-D1-D2-D3-D4-D5-D6-D7-D8-D9------------------------
+            11 : begin _len = _len - 11; pcie_tlp_rem  <= #(Tcq) 4'b0101; end // D0-D1-D2-D3-D4-D5-D6-D7-D8-D9-D10--------------------
+            12 : begin _len = _len - 12; pcie_tlp_rem  <= #(Tcq) 4'b0100; end // D0-D1-D2-D3-D4-D5-D6-D7-D8-D9-D10-D11----------------
+            13 : begin _len = _len - 13; pcie_tlp_rem  <= #(Tcq) 4'b0011; end // D0-D1-D2-D3-D4-D5-D6-D7-D8-D9-D10-D11-D12------------
+            14 : begin _len = _len - 14; pcie_tlp_rem  <= #(Tcq) 4'b0010; end // D0-D1-D2-D3-D4-D5-D6-D7-D8-D9-D10-D11-D12-D13--------
+            15 : begin _len = _len - 15; pcie_tlp_rem  <= #(Tcq) 4'b0001; end // D0-D1-D2-D3-D4-D5-D6-D7-D8-D9-D10-D11-D12-D13-D14----
+            0  : begin _len = _len - 16; pcie_tlp_rem  <= #(Tcq) 4'b0000; end // D0-D1-D2-D3-D4-D5-D6-D7-D8-D9-D10-D11-D12-D13-D14-D15
+          endcase
+        end else begin
+          _len = _len - 16; pcie_tlp_rem  <= #(Tcq) 4'b0000;     // D0-D1-D2-D3-D4-D5-D6-D7-D8-D9-D10-D11-D12-D13-D14-D15
+        end
+
+        if(_len == 0)
+          TSK_TX_SYNCHRONIZE(0, 1, 1, `SYNC_CC_RDY);
+        else
+          TSK_TX_SYNCHRONIZE(0, 1, 0, `SYNC_CC_RDY);
+        end // for loop
+      end // End sequential group 2 - pcie_tlp
+
+    join
+  end  // if
+  // End of Second and Subsequent Data Beat
+  //-----------------------------------------------------------------------\\
+  // Packet Complete - Drive 0s
+  s_axis_cc_tvalid <= #(Tcq) 1'b0;
+  s_axis_cc_tlast  <= #(Tcq) 1'b0;
+  s_axis_cc_tkeep  <= #(Tcq) 8'h00;
+  s_axis_cc_tuser  <= #(Tcq) 83'b0;
+  s_axis_cc_tdata  <= #(Tcq) 512'b0;
+  //-----------------------------------------------------------------------\\
+  pcie_tlp_rem <= #(Tcq) 4'b0000;
+  //-----------------------------------------------------------------------\\
+end
+endtask // TSK_TX_COMPLETION_DATA
+
+/************************************************************
+Task : TSK_TX_SYNCHRONIZE
+Inputs : None
+Outputs : None
+Description : Synchronize with tx clock and handshake signals
+*************************************************************/
+
+task TSK_TX_SYNCHRONIZE;
+  input first_;     // effectively sof
+  input active_;    // in pkt -- for pcie_tlp_data signaling only
+  input last_call_; // eof
+  input tready_sw_; // A switch to select CC or RQ tready
+
+begin
+  //-----------------------------------------------------------------------\\
+  if(user_lnk_up_n) begin
+    $display("[%t] :  interface is MIA", $realtime);
+    $finish(1);
+  end
+  //-----------------------------------------------------------------------\\
+
+  @(posedge user_clk);
+  if(tready_sw_ == `SYNC_CC_RDY) begin
+    while (s_axis_cc_tready == 1'b0) begin
+      @(posedge user_clk);
+    end
+  end else begin // tready_sw_ == `SYNC_RQ_RDY
+    while (s_axis_rq_tready == 1'b0) begin
+      @(posedge user_clk);
+    end
+  end
+  //-----------------------------------------------------------------------\\
+  if(active_ == 1'b1) begin
+    // read data driven into memory
+    board.RP.com_usrapp.TSK_READ_DATA_512(first_, last_call_,`TX_LOG,pcie_tlp_data,pcie_tlp_rem);
+  end
+  //-----------------------------------------------------------------------\\
+  if(last_call_)
+    board.RP.com_usrapp.TSK_PARSE_FRAME(`TX_LOG);
+  //-----------------------------------------------------------------------\\
+end
+endtask // TSK_TX_SYNCHRONIZE
+
+/************************************************************
+Task : TSK_USR_DATA_SETUP_SEQ
+Inputs : None
+Outputs : None
+Description : Populates scratch pad data area with known good data.
+*************************************************************/
+
+task TSK_USR_DATA_SETUP_SEQ;
+  integer        i_;
+begin
+  for (i_ = 0; i_ <= 4095; i_ = i_ + 1)
+    DATA_STORE[i_] = i_;
+  for (i_ = 0; i_ <= (2**(RP_BAR_SIZE+1))-1; i_ = i_ + 1)
+    DATA_STORE_2[i_] = i_;
+end
+endtask // TSK_USR_DATA_SETUP_SEQ
+
+/************************************************************
+Task : TSK_TX_CLK_EAT
+Inputs : None
+Outputs : None
+Description : Consume clocks.
+*************************************************************/
+
+task TSK_TX_CLK_EAT;
+  input [31:0] clock_count;
+  integer i_;
+begin
+  for (i_ = 0; i_ < clock_count; i_ = i_ + 1) 
+    @(posedge user_clk);    
+end
+endtask // TSK_TX_CLK_EAT
+
+/************************************************************
+Task: TSK_SIMULATION_TIMEOUT
+Description: Set simulation timeout value
+*************************************************************/
+task TSK_SIMULATION_TIMEOUT;
+  input [31:0] timeout;
+begin
+    force board.RP.rx_usrapp.sim_timeout = timeout;
+  end
+endtask
+
+/************************************************************
+Task : TSK_SET_READ_DATA
+Inputs : Data
+Outputs : None
+Description : Called from common app. Common app hands read
+              data to usrapp_tx.
+*************************************************************/
+
+task TSK_SET_READ_DATA;
+  input   [3:0]   be_;   // not implementing be's yet
+  input   [63:0]  data_; // might need to change this to byte
+begin
+  P_READ_DATA   = data_[31:0];
+  P_READ_DATA_2 = data_[63:32];
+  P_READ_DATA_VALID = 1;
+end
+endtask // TSK_SET_READ_DATA
+
+/************************************************************
+Task : TSK_WAIT_FOR_READ_DATA
+Inputs : None
+Outputs : Read data P_READ_DATA will be valid
+Description : Called from tx app. Common app hands read
+              data to usrapp_tx. This task must be executed
+              immediately following a call to
+              TSK_TX_TYPE0_CONFIGURATION_READ in order for the
+              read process to function correctly. Otherwise
+              there is a potential race condition with
+              P_READ_DATA_VALID.
+*************************************************************/
+
+task TSK_WAIT_FOR_READ_DATA;
+  integer j;
+begin
+  j = 30;
+  P_READ_DATA_VALID = 0;
+  fork
+    while ((!P_READ_DATA_VALID) && (cpld_to == 0)) @(posedge user_clk);
+    begin // second process
+      while ((j > 0) && (!P_READ_DATA_VALID))
+      begin
+        TSK_TX_CLK_EAT(500);
+        j = j - 1;
+      end
+      if(!P_READ_DATA_VALID) begin
+        cpld_to = 1;
+        if(cpld_to_finish == 1) begin
+          $display("TEST FAIL: TIMEOUT ERROR in usrapp_tx:TSK_WAIT_FOR_READ_DATA. Completion data never received.");
+          board.RP.tx_usrapp.test_state =1;
+          $finish;
+        end
+      else begin
+        $display("TEST FAIL: TIMEOUT WARNING in usrapp_tx:TSK_WAIT_FOR_READ_DATA. Completion data never received.");
+        board.RP.tx_usrapp.test_state = 1;
+      end
+    end
+  end
+  join
+end
+endtask // TSK_WAIT_FOR_READ_DATA
+
+/************************************************************
+Function : TSK_DISPLAY_PCIE_MAP
+Inputs : none
+Outputs : none
+Description : Displays the Memory Manager's P_MAP calculations
+              based on range values read from PCI_E device.
+*************************************************************/
+
+task TSK_DISPLAY_PCIE_MAP;
+  reg[2:0] ii;
+begin
+  for (ii=0; ii <= 6; ii = ii + 1) begin
+    if(ii !=6) begin
+      $display("\tBAR %x: VALUE = %x RANGE = %x TYPE = %s", ii, BAR_INIT_P_BAR[ii][31:0],
+          BAR_INIT_P_BAR_RANGE[ii], BAR_INIT_MESSAGE[BAR_INIT_P_BAR_ENABLED[ii]]);
+    end
+    else begin
+      $display("\tEROM : VALUE = %x RANGE = %x TYPE = %s", BAR_INIT_P_BAR[6][31:0],
+          BAR_INIT_P_BAR_RANGE[6], BAR_INIT_MESSAGE[BAR_INIT_P_BAR_ENABLED[6]]);
+    end
+  end
+end
+endtask
+
+/************************************************************
+Task : TSK_BUILD_PCIE_MAP
+Inputs :
+Outputs :
+Description : Looks at range values read from config space and
+              builds corresponding mem/io map
+*************************************************************/
+
+task TSK_BUILD_PCIE_MAP;
+  reg[2:0] ii;
+begin
+  $display("[%t] PCI EXPRESS BAR MEMORY/IO MAPPING PROCESS BEGUN...",$realtime);
+
+  // handle bars 0-6 (including erom)
+  for(ii = 0; ii <= 6; ii = ii + 1) begin
+    if(BAR_INIT_P_BAR_RANGE[ii] != 32'h0000_0000) begin
+      if((ii != 6) && (BAR_INIT_P_BAR_RANGE[ii] & 32'h0000_0001)) begin // if not erom and io bit set
+        // bar is io mapped
+        NUMBER_OF_IO_BARS = NUMBER_OF_IO_BARS + 1;
+      //if(pio_check_design && (~BAR_ENABLED[ii])) begin
+        if(pio_check_design && (NUMBER_OF_IO_BARS > 6)) begin
+          $display("[%t] Testbench will disable BAR %x",$realtime, ii);
+              BAR_INIT_P_BAR_ENABLED[ii] = 2'h0; // disable BAR
+        end
+        else begin
+          BAR_INIT_P_BAR_ENABLED[ii] = 2'h1;
+          $display("[%t] Testbench is enabling IO BAR %x",$realtime, ii);
+        end //BAR_INIT_P_BAR_ENABLED[ii] = 2'h1;
+
+        if(!OUT_OF_IO) begin
+          // We need to calculate where the next BAR should start based on the BAR's range
+          BAR_INIT_TEMP = BAR_INIT_P_IO_START & {1'b1,(BAR_INIT_P_BAR_RANGE[ii] & 32'hffff_fff0)};
+
+          if(BAR_INIT_TEMP < BAR_INIT_P_IO_START) begin
+            // Current BAR_INIT_P_IO_START is NOT correct start for new base
+            BAR_INIT_P_BAR[ii] = BAR_INIT_TEMP + FNC_CONVERT_RANGE_TO_SIZE_32(ii);
+            BAR_INIT_P_IO_START = BAR_INIT_P_BAR[ii] + FNC_CONVERT_RANGE_TO_SIZE_32(ii);
+          end
+          else begin
+            // Initial BAR case and Current BAR_INIT_P_IO_START is correct start for new base
+            BAR_INIT_P_BAR[ii] = BAR_INIT_P_IO_START;
+            BAR_INIT_P_IO_START = BAR_INIT_P_IO_START + FNC_CONVERT_RANGE_TO_SIZE_32(ii);
+          end
+          OUT_OF_IO = BAR_INIT_P_BAR[ii][32];
+          if(OUT_OF_IO) begin
+            $display("\tOut of PCI EXPRESS IO SPACE due to BAR %x", ii);
+          end
+        end
+        else begin
+          $display("\tOut of PCI EXPRESS IO SPACE due to BAR %x", ii);
+        end
+     end // bar is io mapped
+     else begin
+      // bar is mem mapped
+      if((ii != 5) && (BAR_INIT_P_BAR_RANGE[ii] & 32'h0000_0004)) begin
+        // bar is mem64 mapped - memManager is not handling out of 64bit memory
+        NUMBER_OF_MEM64_BARS = NUMBER_OF_MEM64_BARS + 1;
+
+      //if(pio_check_design && (~BAR_ENABLED[ii])) begin
+        if(pio_check_design && (NUMBER_OF_MEM64_BARS > 6)) begin
+          $display("[%t] Testbench will disable BAR %x",$realtime, ii);
+          BAR_INIT_P_BAR_ENABLED[ii] = 2'h0; // disable BAR
+        end
+        else begin
+          BAR_INIT_P_BAR_ENABLED[ii] = 2'h3; // bar is mem64 mapped
+          $display("[%t] Testbench is enabling MEM64 BAR %x",$realtime, ii);
+        end
+        if((BAR_INIT_P_BAR_RANGE[ii] & 32'hFFFF_FFF0) == 32'h0000_0000) begin
+          // Mem64 space has range larger than 2 Gigabytes
+          // calculate where the next BAR should start based on the BAR's range
+          BAR_INIT_TEMP = BAR_INIT_P_MEM64_HI_START & BAR_INIT_P_BAR_RANGE[ii+1];
+
+          if(BAR_INIT_TEMP < BAR_INIT_P_MEM64_HI_START) begin
+            // Current MEM32_START is NOT correct start for new base
+            BAR_INIT_P_BAR[ii+1] =      BAR_INIT_TEMP + FNC_CONVERT_RANGE_TO_SIZE_HI32(ii+1);
+            BAR_INIT_P_BAR[ii] =        32'h0000_0000;
+            BAR_INIT_P_MEM64_HI_START = BAR_INIT_P_BAR[ii+1] + FNC_CONVERT_RANGE_TO_SIZE_HI32(ii+1);
+            BAR_INIT_P_MEM64_LO_START = 32'h0000_0000;
+          end
+          else begin
+            // Initial BAR case and Current MEM32_START is correct start for new base
+            BAR_INIT_P_BAR[ii] =        32'h0000_0000;
+            BAR_INIT_P_BAR[ii+1] =      BAR_INIT_P_MEM64_HI_START;
+            BAR_INIT_P_MEM64_HI_START = BAR_INIT_P_MEM64_HI_START + FNC_CONVERT_RANGE_TO_SIZE_HI32(ii+1);
+          end
+       end
+       else begin
+        // Mem64 space has range less than/equal 2 Gigabytes
+        // calculate where the next BAR should start based on the BAR's range
+        BAR_INIT_TEMP = BAR_INIT_P_MEM64_LO_START & (BAR_INIT_P_BAR_RANGE[ii] & 32'hffff_fff0);
+
+        if(BAR_INIT_TEMP < BAR_INIT_P_MEM64_LO_START) begin
+          // Current MEM32_START is NOT correct start for new base
+          BAR_INIT_P_BAR[ii] =        BAR_INIT_TEMP + FNC_CONVERT_RANGE_TO_SIZE_32(ii);
+          BAR_INIT_P_BAR[ii+1] =      BAR_INIT_P_MEM64_HI_START;
+          BAR_INIT_P_MEM64_LO_START = BAR_INIT_P_BAR[ii] + FNC_CONVERT_RANGE_TO_SIZE_32(ii);
+        end
+        else begin
+          // Initial BAR case and Current MEM32_START is correct start for new base
+          BAR_INIT_P_BAR[ii] =        BAR_INIT_P_MEM64_LO_START;
+          BAR_INIT_P_BAR[ii+1] =      BAR_INIT_P_MEM64_HI_START;
+          BAR_INIT_P_MEM64_LO_START = BAR_INIT_P_MEM64_LO_START + FNC_CONVERT_RANGE_TO_SIZE_32(ii);
+        end
+      end
+      // skip over the next bar since it is being used by the 64bit bar
+      ii = ii + 1;
+    end
+    else begin
+      if( (ii != 6) || ((ii == 6) && (BAR_INIT_P_BAR_RANGE[ii] & 32'h0000_0001)) ) begin
+        // handling general mem32 case and erom case
+        // bar is mem32 mapped
+        if(ii != 6) begin
+           NUMBER_OF_MEM32_BARS = NUMBER_OF_MEM32_BARS + 1; // not counting erom space
+
+          //if(pio_check_design && (~BAR_ENABLED[ii])) begin
+            if(pio_check_design && (NUMBER_OF_MEM32_BARS > 6)) begin
+                $display("[%t] Testbench will disable BAR %x",$realtime, ii);
+                BAR_INIT_P_BAR_ENABLED[ii] = 2'h0; // disable BAR
+            end
+            else begin
+                BAR_INIT_P_BAR_ENABLED[ii] = 2'h2; // bar is mem32 mapped
+                $display("[%t] Testbench is enabling MEM32 BAR %x",$realtime, ii);
+            end
+          end
+        else BAR_INIT_P_BAR_ENABLED[ii] = 2'h2; // erom bar is mem32 mapped
+          if(!OUT_OF_LO_MEM) begin
+            // We need to calculate where the next BAR should start based on the BAR's range
+            BAR_INIT_TEMP = BAR_INIT_P_MEM32_START & {1'b1,(BAR_INIT_P_BAR_RANGE[ii] & 32'hffff_fff0)};
+
+            if(BAR_INIT_TEMP < BAR_INIT_P_MEM32_START) begin
+                // Current MEM32_START is NOT correct start for new base
+                BAR_INIT_P_BAR[ii] =     BAR_INIT_TEMP + FNC_CONVERT_RANGE_TO_SIZE_32(ii);
+                BAR_INIT_P_MEM32_START = BAR_INIT_P_BAR[ii] + FNC_CONVERT_RANGE_TO_SIZE_32(ii);
+              end
+              else begin
+                // Initial BAR case and Current MEM32_START is correct start for new base
+                BAR_INIT_P_BAR[ii] =     BAR_INIT_P_MEM32_START;
+                BAR_INIT_P_MEM32_START = BAR_INIT_P_MEM32_START + FNC_CONVERT_RANGE_TO_SIZE_32(ii);
+              end
+              if(ii == 6) begin
+                // make sure to set enable bit if we are mapping the erom space
+                BAR_INIT_P_BAR[ii] = BAR_INIT_P_BAR[ii] | 33'h1;
+              end
+              OUT_OF_LO_MEM = BAR_INIT_P_BAR[ii][32];
+              if(OUT_OF_LO_MEM) begin
+                $display("\tOut of PCI EXPRESS MEMORY 32 SPACE due to BAR %x", ii);
+              end
+            end
+            else begin
+              $display("\tOut of PCI EXPRESS MEMORY 32 SPACE due to BAR %x", ii);
+            end
+          end
+        end
+      end
+    end
+  end
+  if( (OUT_OF_IO) | (OUT_OF_LO_MEM) | (OUT_OF_HI_MEM)) begin
+    TSK_DISPLAY_PCIE_MAP;
+    $display("ERROR: Ending simulation: Memory Manager is out of memory/IO to allocate to PCI Express device");
+    $finish;
+  end
+end
+
+endtask // TSK_BUILD_PCIE_MAP
+
+/************************************************************
+  Task : TSK_BAR_SCAN
+  Inputs : None
+  Outputs : None
+  Description : Scans PCI core's configuration registers.
+*************************************************************/
+
+task TSK_BAR_SCAN;
+begin
+  //--------------------------------------------------------------------------
+  // Write PCI_MASK to bar's space via PCIe fabric interface to find range
+  //--------------------------------------------------------------------------
+  P_ADDRESS_MASK          = 32'hffff_ffff;
+  DEFAULT_TAG         = 0;
+  DEFAULT_TC          = 0;
+
+  $display("[%t] : Inspecting Core Configuration Space...", $realtime);
+
+  // Determine Range for BAR0
+  TSK_TX_TYPE0_CONFIGURATION_WRITE(DEFAULT_TAG, 12'h10, P_ADDRESS_MASK, 4'hF);
+    DEFAULT_TAG = DEFAULT_TAG + 1;
+    TSK_TX_CLK_EAT(100);
+
+  // Read BAR0 Range
+  TSK_TX_TYPE0_CONFIGURATION_READ(DEFAULT_TAG, 12'h10, 4'hF);
+    DEFAULT_TAG = DEFAULT_TAG + 1;
+    TSK_WAIT_FOR_READ_DATA;
+    BAR_INIT_P_BAR_RANGE[0] = P_READ_DATA;
+
+  // Determine Range for BAR1
+  TSK_TX_TYPE0_CONFIGURATION_WRITE(DEFAULT_TAG, 12'h14, P_ADDRESS_MASK, 4'hF);
+  DEFAULT_TAG = DEFAULT_TAG + 1;
+  TSK_TX_CLK_EAT(100);
+
+  // Read BAR1 Range
+  TSK_TX_TYPE0_CONFIGURATION_READ(DEFAULT_TAG, 12'h14, 4'hF);
+  DEFAULT_TAG = DEFAULT_TAG + 1;
+  TSK_WAIT_FOR_READ_DATA;
+  BAR_INIT_P_BAR_RANGE[1] = P_READ_DATA;
+
+  // Determine Range for BAR2
+  TSK_TX_TYPE0_CONFIGURATION_WRITE(DEFAULT_TAG, 12'h18, P_ADDRESS_MASK, 4'hF);
+  DEFAULT_TAG = DEFAULT_TAG + 1;
+  TSK_TX_CLK_EAT(100);
+
+  // Read BAR2 Range
+  TSK_TX_TYPE0_CONFIGURATION_READ(DEFAULT_TAG, 12'h18, 4'hF);
+  DEFAULT_TAG = DEFAULT_TAG + 1;
+  TSK_WAIT_FOR_READ_DATA;
+  BAR_INIT_P_BAR_RANGE[2] = P_READ_DATA;
+
+  // Determine Range for BAR3
+  TSK_TX_TYPE0_CONFIGURATION_WRITE(DEFAULT_TAG, 12'h1C, P_ADDRESS_MASK, 4'hF);
+  DEFAULT_TAG = DEFAULT_TAG + 1;
+  TSK_TX_CLK_EAT(100);
+
+  // Read BAR3 Range
+  TSK_TX_TYPE0_CONFIGURATION_READ(DEFAULT_TAG, 12'h1C, 4'hF);
+  DEFAULT_TAG = DEFAULT_TAG + 1;
+  TSK_WAIT_FOR_READ_DATA;
+  BAR_INIT_P_BAR_RANGE[3] = P_READ_DATA;
+
+  // Determine Range for BAR4
+  TSK_TX_TYPE0_CONFIGURATION_WRITE(DEFAULT_TAG, 12'h20, P_ADDRESS_MASK, 4'hF);
+  DEFAULT_TAG = DEFAULT_TAG + 1;
+  TSK_TX_CLK_EAT(100);
+
+  // Read BAR4 Range
+  TSK_TX_TYPE0_CONFIGURATION_READ(DEFAULT_TAG, 12'h20, 4'hF);
+  DEFAULT_TAG = DEFAULT_TAG + 1;
+  TSK_WAIT_FOR_READ_DATA;
+  BAR_INIT_P_BAR_RANGE[4] = P_READ_DATA;
+
+  // Determine Range for BAR5
+  TSK_TX_TYPE0_CONFIGURATION_WRITE(DEFAULT_TAG, 12'h24, P_ADDRESS_MASK, 4'hF);
+  DEFAULT_TAG = DEFAULT_TAG + 1;
+  TSK_TX_CLK_EAT(100);
+
+  // Read BAR5 Range
+  TSK_TX_TYPE0_CONFIGURATION_READ(DEFAULT_TAG, 12'h24, 4'hF);
+  DEFAULT_TAG = DEFAULT_TAG + 1;
+  TSK_WAIT_FOR_READ_DATA;
+  BAR_INIT_P_BAR_RANGE[5] = P_READ_DATA;
+
+  // Determine Range for Expansion ROM BAR
+  TSK_TX_TYPE0_CONFIGURATION_WRITE(DEFAULT_TAG, 12'h30, P_ADDRESS_MASK, 4'hF);
+  DEFAULT_TAG = DEFAULT_TAG + 1;
+  TSK_TX_CLK_EAT(100);
+
+  // Read Expansion ROM BAR Range
+  TSK_TX_TYPE0_CONFIGURATION_READ(DEFAULT_TAG, 12'h30, 4'hF);
+  DEFAULT_TAG = DEFAULT_TAG + 1;
+  TSK_WAIT_FOR_READ_DATA;
+  BAR_INIT_P_BAR_RANGE[6] = P_READ_DATA;
+
+ end
+endtask // TSK_BAR_SCAN
+//
+//
+/************************************************************
+Task : TSK_BAR_PROGRAM
+Inputs : None
+Outputs : None
+Description : Program's PCI core's configuration registers.
+*************************************************************/
+
+task TSK_BAR_PROGRAM;
+begin
+  //--------------------------------------------------------------------------
+  // Write core configuration space via PCIe fabric interface
+  //--------------------------------------------------------------------------
+
+  DEFAULT_TAG     = 0;
+
+  $display("[%t] : Setting Core Configuration Space...", $realtime);
+
+  // Program BAR0
+  TSK_TX_TYPE0_CONFIGURATION_WRITE(DEFAULT_TAG, 12'h10, BAR_INIT_P_BAR[0][31:0], 4'hF);
+  DEFAULT_TAG = DEFAULT_TAG + 1;
+  TSK_TX_CLK_EAT(100);
+
+  // Program BAR1
+  TSK_TX_TYPE0_CONFIGURATION_WRITE(DEFAULT_TAG, 12'h14, BAR_INIT_P_BAR[1][31:0], 4'hF);
+  DEFAULT_TAG = DEFAULT_TAG + 1;
+  TSK_TX_CLK_EAT(100);
+
+  // Program BAR2
+  TSK_TX_TYPE0_CONFIGURATION_WRITE(DEFAULT_TAG, 12'h18, BAR_INIT_P_BAR[2][31:0], 4'hF);
+  DEFAULT_TAG = DEFAULT_TAG + 1;
+  TSK_TX_CLK_EAT(100);
+
+  // Program BAR3
+  TSK_TX_TYPE0_CONFIGURATION_WRITE(DEFAULT_TAG, 12'h1C, BAR_INIT_P_BAR[3][31:0], 4'hF);
+  DEFAULT_TAG = DEFAULT_TAG + 1;
+  TSK_TX_CLK_EAT(100);
+
+  // Program BAR4
+  TSK_TX_TYPE0_CONFIGURATION_WRITE(DEFAULT_TAG, 12'h20, BAR_INIT_P_BAR[4][31:0], 4'hF);
+  DEFAULT_TAG = DEFAULT_TAG + 1;
+  TSK_TX_CLK_EAT(100);
+
+  // Program BAR5
+  TSK_TX_TYPE0_CONFIGURATION_WRITE(DEFAULT_TAG, 12'h24, BAR_INIT_P_BAR[5][31:0], 4'hF);
+  DEFAULT_TAG = DEFAULT_TAG + 1;
+  TSK_TX_CLK_EAT(100);
+
+  // Program Expansion ROM BAR
+  TSK_TX_TYPE0_CONFIGURATION_WRITE(DEFAULT_TAG, 12'h30, BAR_INIT_P_BAR[6][31:0], 4'hF);
+  DEFAULT_TAG = DEFAULT_TAG + 1;
+  TSK_TX_CLK_EAT(100);
+
+  // Program PCI Command Register
+  TSK_TX_TYPE0_CONFIGURATION_WRITE(DEFAULT_TAG, 12'h04, 32'h00000007, 4'h1);
+  DEFAULT_TAG = DEFAULT_TAG + 1;
+  TSK_TX_CLK_EAT(100);
+
+  // Program PCIe Device Control Register
+  TSK_TX_TYPE0_CONFIGURATION_WRITE(DEFAULT_TAG, DEV_CTRL_REG_ADDR, 32'h0000005f, 4'h1);
+  DEFAULT_TAG = DEFAULT_TAG + 1;
+  TSK_TX_CLK_EAT(1000);
+
+end
+endtask // TSK_BAR_PROGRAM
+
+task TSK_MSIX_EN;
+  reg [31:0] msix_vec_offset;
+  reg [2:0] msix_vec_bar;
+
+begin
+  $display("[%t] :MSIX enable task.", $realtime);
+  TSK_TX_TYPE0_CONFIGURATION_READ(DEFAULT_TAG, MSIX_CTRL_REG_ADDR[11:0], 4'hF);
+  DEFAULT_TAG = DEFAULT_TAG + 1;
+  TSK_WAIT_FOR_READ_DATA;
+
+  TSK_TX_TYPE0_CONFIGURATION_WRITE(DEFAULT_TAG, MSIX_CTRL_REG_ADDR[11:0], (32'h80000000 | P_READ_DATA), 4'hC);
+  DEFAULT_TAG = DEFAULT_TAG + 1;
+  TSK_TX_CLK_EAT(1000);
+
+  // Get the offset of MSIX vector table
+  TSK_TX_TYPE0_CONFIGURATION_READ(DEFAULT_TAG, MSIX_VEC_TABLE_A[11:0], 4'hF);
+  DEFAULT_TAG = DEFAULT_TAG + 1;
+  TSK_WAIT_FOR_READ_DATA;
+  msix_vec_offset = {P_READ_DATA[31:3], 3'b0};
+  msix_vec_bar = P_READ_DATA[2:0];
+  $display("[%t] :   MSIX Vector table offset is %x on BAR %0d", $realtime, msix_vec_offset, msix_vec_bar);
+
+//MSIX_VEC_OFFSET[0] = msix_vec_offset;
+  MSIX_VEC_OFFSET[pfTestIteration] = 32'h0003_0000;
+  MSIX_VEC_BAR[pfTestIteration] = msix_vec_bar;
+end
+endtask
+
+/************************************************************
+Task : TSK_PROGRAM_MSIX_VEC_TABLE
+Inputs : function number
+Outputs : None
+Description : Program the MSIX vector table
+*************************************************************/
+task TSK_PROGRAM_MSIX_VEC_TABLE;
+  input [7:0] fnc_i;
+  integer    i;
+begin
+  EP_BUS_DEV_FNS = {8'b0000_0001, fnc_i};
+
+  for (i=0; i<7; i=i+1) begin
+    TSK_REG_WRITE(xdma_bar, MSIX_VEC_OFFSET[fnc_i]+16*i+0*4, 32'hADD00000 + i*4, 4'hF);
+    TSK_REG_WRITE(xdma_bar, MSIX_VEC_OFFSET[fnc_i]+16*i+1*4, 32'h00000000 + i,   4'hF);
+    TSK_REG_WRITE(xdma_bar, MSIX_VEC_OFFSET[fnc_i]+16*i+2*4, 32'hDEAD0000 + i,   4'hF);
+    TSK_REG_WRITE(xdma_bar, MSIX_VEC_OFFSET[fnc_i]+16*i+3*4, 32'h00000000,       4'hF);
+  end
+end
+endtask // TSK_PROGRAM_MSIX_VEC_TABLE
+
+/************************************************************
+Task : TSK_BAR_INIT
+Inputs : None
+Outputs : None
+Description : Initialize PCI core based on core's configuration.
+*************************************************************/
+
+task TSK_BAR_INIT;
+begin
+  TSK_BAR_SCAN;
+  TSK_BUILD_PCIE_MAP;
+  TSK_DISPLAY_PCIE_MAP;
+  TSK_BAR_PROGRAM;
+  TSK_MSIX_EN;
+end
+endtask // TSK_BAR_INIT
+
+/************************************************************
+Function : FNC_CONVERT_RANGE_TO_SIZE_32
+Inputs : BAR index for 32 bit BAR
+Outputs : 32 bit BAR size
+Description : Called from tx app. Note that the smallest range
+          supported by this function is 16 bytes.
+*************************************************************/
+
+function [31:0] FNC_CONVERT_RANGE_TO_SIZE_32;
+  input [31:0] bar_index;
+  reg   [32:0] return_value;
+begin
+  case (BAR_INIT_P_BAR_RANGE[bar_index] & 32'hFFFF_FFF0) // AND off control bits
+    32'hFFFF_FFF0 : return_value = 33'h0000_0010;
+    32'hFFFF_FFE0 : return_value = 33'h0000_0020;
+    32'hFFFF_FFC0 : return_value = 33'h0000_0040;
+    32'hFFFF_FF80 : return_value = 33'h0000_0080;
+    32'hFFFF_FF00 : return_value = 33'h0000_0100;
+    32'hFFFF_FE00 : return_value = 33'h0000_0200;
+    32'hFFFF_FC00 : return_value = 33'h0000_0400;
+    32'hFFFF_F800 : return_value = 33'h0000_0800;
+    32'hFFFF_F000 : return_value = 33'h0000_1000;
+    32'hFFFF_E000 : return_value = 33'h0000_2000;
+    32'hFFFF_C000 : return_value = 33'h0000_4000;
+    32'hFFFF_8000 : return_value = 33'h0000_8000;
+    32'hFFFF_0000 : return_value = 33'h0001_0000;
+    32'hFFFE_0000 : return_value = 33'h0002_0000;
+    32'hFFFC_0000 : return_value = 33'h0004_0000;
+    32'hFFF8_0000 : return_value = 33'h0008_0000;
+    32'hFFF0_0000 : return_value = 33'h0010_0000;
+    32'hFFE0_0000 : return_value = 33'h0020_0000;
+    32'hFFC0_0000 : return_value = 33'h0040_0000;
+    32'hFF80_0000 : return_value = 33'h0080_0000;
+    32'hFF00_0000 : return_value = 33'h0100_0000;
+    32'hFE00_0000 : return_value = 33'h0200_0000;
+    32'hFC00_0000 : return_value = 33'h0400_0000;
+    32'hF800_0000 : return_value = 33'h0800_0000;
+    32'hF000_0000 : return_value = 33'h1000_0000;
+    32'hE000_0000 : return_value = 33'h2000_0000;
+    32'hC000_0000 : return_value = 33'h4000_0000;
+    32'h8000_0000 : return_value = 33'h8000_0000;
+    default :      return_value = 33'h0000_0000;
+  endcase
+  FNC_CONVERT_RANGE_TO_SIZE_32 = return_value;
+end
+endfunction // FNC_CONVERT_RANGE_TO_SIZE_32
+
+/************************************************************
+Function : FNC_CONVERT_RANGE_TO_SIZE_HI32
+Inputs : BAR index for upper 32 bit BAR of 64 bit address
+Outputs : upper 32 bit BAR size
+Description : Called from tx app.
+*************************************************************/
+
+function [31:0] FNC_CONVERT_RANGE_TO_SIZE_HI32;
+  input [31:0] bar_index;
+  reg   [32:0] return_value;
+begin
+  case (BAR_INIT_P_BAR_RANGE[bar_index])
+    32'hFFFF_FFFF : return_value = 33'h00000_0001;
+    32'hFFFF_FFFE : return_value = 33'h00000_0002;
+    32'hFFFF_FFFC : return_value = 33'h00000_0004;
+    32'hFFFF_FFF8 : return_value = 33'h00000_0008;
+    32'hFFFF_FFF0 : return_value = 33'h00000_0010;
+    32'hFFFF_FFE0 : return_value = 33'h00000_0020;
+    32'hFFFF_FFC0 : return_value = 33'h00000_0040;
+    32'hFFFF_FF80 : return_value = 33'h00000_0080;
+    32'hFFFF_FF00 : return_value = 33'h00000_0100;
+    32'hFFFF_FE00 : return_value = 33'h00000_0200;
+    32'hFFFF_FC00 : return_value = 33'h00000_0400;
+    32'hFFFF_F800 : return_value = 33'h00000_0800;
+    32'hFFFF_F000 : return_value = 33'h00000_1000;
+    32'hFFFF_E000 : return_value = 33'h00000_2000;
+    32'hFFFF_C000 : return_value = 33'h00000_4000;
+    32'hFFFF_8000 : return_value = 33'h00000_8000;
+    32'hFFFF_0000 : return_value = 33'h00001_0000;
+    32'hFFFE_0000 : return_value = 33'h00002_0000;
+    32'hFFFC_0000 : return_value = 33'h00004_0000;
+    32'hFFF8_0000 : return_value = 33'h00008_0000;
+    32'hFFF0_0000 : return_value = 33'h00010_0000;
+    32'hFFE0_0000 : return_value = 33'h00020_0000;
+    32'hFFC0_0000 : return_value = 33'h00040_0000;
+    32'hFF80_0000 : return_value = 33'h00080_0000;
+    32'hFF00_0000 : return_value = 33'h00100_0000;
+    32'hFE00_0000 : return_value = 33'h00200_0000;
+    32'hFC00_0000 : return_value = 33'h00400_0000;
+    32'hF800_0000 : return_value = 33'h00800_0000;
+    32'hF000_0000 : return_value = 33'h01000_0000;
+    32'hE000_0000 : return_value = 33'h02000_0000;
+    32'hC000_0000 : return_value = 33'h04000_0000;
+    32'h8000_0000 : return_value = 33'h08000_0000;
+    default :       return_value = 33'h00000_0000;
+  endcase
+  FNC_CONVERT_RANGE_TO_SIZE_HI32 = return_value;
+end
+endfunction // FNC_CONVERT_RANGE_TO_SIZE_HI32
+
+/************************************************************
+Task : TSK_REG_WRITE
+Input : BAR Number
+Input : Register Address
+Input : data value
+Input : byte_en
+Outputs : None
+Description : Register Writes to any BAR
+*************************************************************/
+
+task TSK_REG_WRITE;
+  input integer bar_num;
+  input [31:0] addr;
+  input [31:0] data;
+  input [3:0] byte_en;
+begin
+  // Store the 32 bit data into the global variable DATA_STORE
+  DATA_STORE[0] = data[7:0];
+  DATA_STORE[1] = data[15:8];
+  DATA_STORE[2] = data[23:16];
+  DATA_STORE[3] = data[31:24];
+
+  $display("[%t] : Sending Data write task at address %h with data %h" ,$realtime, addr, data);
+
+  // Check if it mus perform a 32 or 64 write
+  if(board.RP.tx_usrapp.BAR_INIT_P_BAR_ENABLED[bar_num] == 2'b10) 
+  begin
+    board.RP.tx_usrapp.TSK_TX_MEMORY_WRITE_32(board.RP.tx_usrapp.DEFAULT_TAG,   // Tag
+                                              board.RP.tx_usrapp.DEFAULT_TC,    // Traffic Class
+                                              11'd1,                            // Length (in DW)
+                                              board.RP.tx_usrapp.BAR_INIT_P_BAR[bar_num][31:0]+addr[20:0],// Address
+                                              4'h0,                             // Last DW Byte Enable
+                                              byte_en,                          // First DW Byte Enable
+                                              1'b0);               // Poisoned Data: Payload is invalid if set
+  end 
+  else if(board.RP.tx_usrapp.BAR_INIT_P_BAR_ENABLED[bar_num] == 2'b11) 
+  begin
+    board.RP.tx_usrapp.TSK_TX_MEMORY_WRITE_64(board.RP.tx_usrapp.DEFAULT_TAG,
+    board.RP.tx_usrapp.DEFAULT_TC, 11'd1,{board.RP.tx_usrapp.BAR_INIT_P_BAR[bar_num+1][31:0],
+    board.RP.tx_usrapp.BAR_INIT_P_BAR[bar_num][31:0]+addr[20:0]}, 4'h0, byte_en, 1'b0);
+  end
+  board.RP.tx_usrapp.TSK_TX_CLK_EAT(100);
+  board.RP.tx_usrapp.DEFAULT_TAG = board.RP.tx_usrapp.DEFAULT_TAG + 1;
+
+  $display("[%t] : Done register write!!" ,$realtime);
+end
+endtask
+
+/************************************************************
+Task : TSK_REG_READ
+Input : BAR number
+Input : Register address
+Outputs : None
+Description : Register Reads to any bar
+*************************************************************/
+
+task TSK_REG_READ;
+  input integer bar_num;
+  input [15:0] read_addr;
+begin
+  board.RP.tx_usrapp.P_READ_DATA = 32'hffff_ffff;
+  fork
+    if(board.RP.tx_usrapp.BAR_INIT_P_BAR_ENABLED[bar_num] == 2'b10) begin
+      board.RP.tx_usrapp.TSK_TX_MEMORY_READ_32(board.RP.tx_usrapp.DEFAULT_TAG,
+      board.RP.tx_usrapp.DEFAULT_TC, 11'd1,
+      board.RP.tx_usrapp.BAR_INIT_P_BAR[bar_num][31:0]+read_addr[15:0], 4'h0, 4'hF);
+    end else if(board.RP.tx_usrapp.BAR_INIT_P_BAR_ENABLED[bar_num] == 2'b11) begin
+      board.RP.tx_usrapp.TSK_TX_MEMORY_READ_64(board.RP.tx_usrapp.DEFAULT_TAG,
+      board.RP.tx_usrapp.DEFAULT_TC, 11'd1,{board.RP.tx_usrapp.BAR_INIT_P_BAR[bar_num+1][31:0],
+      board.RP.tx_usrapp.BAR_INIT_P_BAR[bar_num][31:0]+read_addr[15:0]}, 4'h0, 4'hF);
+    end
+    board.RP.tx_usrapp.TSK_WAIT_FOR_READ_DATA;
+  join
+  board.RP.tx_usrapp.TSK_TX_CLK_EAT(10);
+  board.RP.tx_usrapp.DEFAULT_TAG = board.RP.tx_usrapp.DEFAULT_TAG + 1;
+  $display ("[%t] : Data read %h from Address %h",$realtime , board.RP.tx_usrapp.P_READ_DATA, read_addr);
+end
+endtask
+
+
+/************************************************************
+Task : TSK_INIT_QDMA_MM_DATA_H2C
+Inputs : None
+Outputs : None
+Description : Initialize Descriptor and Data
+*************************************************************/
+
+task TSK_INIT_QDMA_MM_DATA_H2C;
+  //input logic [63:0] src_addr;
+  //input logic [63:0] dst_addr;
+  //input logic [15:0] byte_cnt;
+  integer i, j, k;
+  int fp, temp;
+begin
+  $display(" **** TASK QDMA MM H2C DSC POLYBENCH at address 0x%h ***\n", H2C_ADDR);
+
+  $display(" **** Initialize Descriptor data ***\n");  
+  
+  for (i = 0; i<16384; i++)
+    DATA_STORE[i] = 8'h00;
+
+  for (k=0;k<12;k=k+1) begin
+    DATA_STORE[H2C_ADDR+(k*32)+0] = 8'h00; //-- Src_add [31:0] x300
+    DATA_STORE[H2C_ADDR+(k*32)+1] = 8'h03;
+    DATA_STORE[H2C_ADDR+(k*32)+2] = 8'h00;
+    DATA_STORE[H2C_ADDR+(k*32)+3] = 8'h00;
+    DATA_STORE[H2C_ADDR+(k*32)+4] = 8'h00; //-- Src add [63:32]
+    DATA_STORE[H2C_ADDR+(k*32)+5] = 8'h00;
+    DATA_STORE[H2C_ADDR+(k*32)+6] = 8'h00;
+    DATA_STORE[H2C_ADDR+(k*32)+7] = 8'h00;
+    DATA_STORE[H2C_ADDR+(k*32)+8] = DMA_BYTE_CNT[7:0]; // [71:64] len [7:0] 28bits
+    DATA_STORE[H2C_ADDR+(k*32)+9] = DMA_BYTE_CNT[15:8];// [79:72] len [15:8]
+    DATA_STORE[H2C_ADDR+(k*32)+10] = DMA_BYTE_CNT[23:16];            // [87:80] len [23:16]
+    DATA_STORE[H2C_ADDR+(k*32)+11] = 8'h40;            // [96:88] {Rsvd, SDI, EOP, SOP, len[27:24]}. last dsc send S
+    DATA_STORE[H2C_ADDR+(k*32)+12] = 8'h00; // [104:97] Reserved 32bits
+    DATA_STORE[H2C_ADDR+(k*32)+13] = 8'h00;
+    DATA_STORE[H2C_ADDR+(k*32)+14] = 8'h00;
+    DATA_STORE[H2C_ADDR+(k*32)+15] = 8'h00;
+    DATA_STORE[H2C_ADDR+(k*32)+16] = 8'h00; // Dst add 64bits [31:0] 0x0000
+    DATA_STORE[H2C_ADDR+(k*32)+17] = 8'h00;
+    DATA_STORE[H2C_ADDR+(k*32)+18] = 8'h01;
+    DATA_STORE[H2C_ADDR+(k*32)+19] = 8'h40*k;
+    DATA_STORE[H2C_ADDR+(k*32)+20] = k/4; // Dst add 64 bits [63:32]
+    DATA_STORE[H2C_ADDR+(k*32)+21] = 8'h00;
+    DATA_STORE[H2C_ADDR+(k*32)+22] = 8'h00;
+    DATA_STORE[H2C_ADDR+(k*32)+23] = 8'h00;
+    DATA_STORE[H2C_ADDR+(k*32)+24] = 8'h00; // 64 bits Reserved [31:0]
+    DATA_STORE[H2C_ADDR+(k*32)+25] = 8'h00;
+    DATA_STORE[H2C_ADDR+(k*32)+26] = 8'h00;
+    DATA_STORE[H2C_ADDR+(k*32)+27] = 8'h00;
+    DATA_STORE[H2C_ADDR+(k*32)+28] = 8'h00; // Reserved [63:32]
+    DATA_STORE[H2C_ADDR+(k*32)+29] = 8'h00;
+    DATA_STORE[H2C_ADDR+(k*32)+30] = 8'h00;
+    DATA_STORE[H2C_ADDR+(k*32)+31] = 8'h00;
+  end // for (k=0;k<8;k=k+1)
+
+  //Initialize Status write back location to 0's
+  DATA_STORE[H2C_ADDR + (32*15) +0] = 8'h00;
+  DATA_STORE[H2C_ADDR + (32*15) +1] = 8'h00;
+  DATA_STORE[H2C_ADDR + (32*15) +2] = 8'h00;
+  DATA_STORE[H2C_ADDR + (32*15) +3] = 8'h00;
+
+//for (k = 0; k < 32; k = k + 1)  begin
+//  $display(" **** Descriptor data *** data = %h, addr= %d\n", DATA_STORE[H2C_ADDR+k], H2C_ADDR+k);
+//  #(Tcq);
+//end
+ for (k = 0; k < DMA_BYTE_CNT; k = k + 1)  begin
+   #(Tcq) DATA_STORE[768+k] = k;  // 0x1200
+ end
+//$display("MEMORY CONTENT\n");
+//for (int i=0; i<4096; i++)
+//    $display("%x:\t%x", i, DATA_STORE[i]);
+end
+endtask
+
+
+/************************************************************
+Task : TSK_INIT_QDMA_MM_DATA_C2H
+Inputs : None
+Outputs : None
+Description : Initialize Descriptor
+*************************************************************/
+
+task TSK_INIT_QDMA_MM_DATA_C2H;
+  integer k;
+begin
+
+  $display(" **** TASK QDMA MM C2H DSC at address 0x0800 ***\n");
+
+  $display(" **** Initialize Descriptor data ***\n");
+  for (k=0;k<8;k=k+1) begin
+    DATA_STORE[C2H_ADDR+(k*32)+0] = 8'h00; //-- Src_add [31:0]
+    DATA_STORE[C2H_ADDR+(k*32)+1] = 8'h00;
+    DATA_STORE[C2H_ADDR+(k*32)+2] = 8'h01;
+    DATA_STORE[C2H_ADDR+(k*32)+3] = 8'h00;
+    DATA_STORE[C2H_ADDR+(k*32)+4] = 8'h00; //-- Src add [63:32]
+    DATA_STORE[C2H_ADDR+(k*32)+5] = 8'h00;
+    DATA_STORE[C2H_ADDR+(k*32)+6] = 8'h00;
+    DATA_STORE[C2H_ADDR+(k*32)+7] = 8'h00;
+    DATA_STORE[C2H_ADDR+(k*32)+8] = DMA_BYTE_CNT[7:0]; // [71:64] len [7:0] 28bits
+    DATA_STORE[C2H_ADDR+(k*32)+9] = DMA_BYTE_CNT[15:8];// [79:72] len [15:8]
+    DATA_STORE[C2H_ADDR+(k*32)+10] = DMA_BYTE_CNT[23:16];            // [87:80] len [23:16]
+    DATA_STORE[C2H_ADDR+(k*32)+11] = 8'h40;            // [96:88] {Rsvd, SDI, EOP, SOP, len[27:24]}. last dsc send SDI to make DMA send comnpletion
+    DATA_STORE[C2H_ADDR+(k*32)+12] = 8'h00; // [104:97] Reserved 32bits
+    DATA_STORE[C2H_ADDR+(k*32)+13] = 8'h00;
+    DATA_STORE[C2H_ADDR+(k*32)+14] = 8'h00;
+    DATA_STORE[C2H_ADDR+(k*32)+15] = 8'h00;
+    DATA_STORE[C2H_ADDR+(k*32)+16] = 8'h00;//8'h00; // Dst add 64bits [31:0] 0x1600
+    DATA_STORE[C2H_ADDR+(k*32)+17] = 8'h00;//8'h0A;
+    DATA_STORE[C2H_ADDR+(k*32)+18] = 8'h01;//8'h00;
+    DATA_STORE[C2H_ADDR+(k*32)+19] = 8'h00;//8'h00;
+    DATA_STORE[C2H_ADDR+(k*32)+20] = 8'h00; // Dst add 64 bits [63:32]
+    DATA_STORE[C2H_ADDR+(k*32)+21] = 8'h00;
+    DATA_STORE[C2H_ADDR+(k*32)+22] = 8'h00;
+    DATA_STORE[C2H_ADDR+(k*32)+23] = 8'h00;
+    DATA_STORE[C2H_ADDR+(k*32)+24] = 8'h00; // 64 bits Reserved [31:0]
+    DATA_STORE[C2H_ADDR+(k*32)+25] = 8'h00;
+    DATA_STORE[C2H_ADDR+(k*32)+26] = 8'h00;
+    DATA_STORE[C2H_ADDR+(k*32)+27] = 8'h00;
+    DATA_STORE[C2H_ADDR+(k*32)+28] = 8'h00; // Reserved [63:32]
+    DATA_STORE[C2H_ADDR+(k*32)+29] = 8'h00;
+    DATA_STORE[C2H_ADDR+(k*32)+30] = 8'h00;
+    DATA_STORE[C2H_ADDR+(k*32)+31] = 8'h00;
+  end
+
+  //Initialize Status write back location to 0's
+  DATA_STORE[C2H_ADDR + (32*15) +0] = 8'h00;
+  DATA_STORE[C2H_ADDR + (32*15) +1] = 8'h00;
+  DATA_STORE[C2H_ADDR + (32*15) +2] = 8'h00;
+  DATA_STORE[C2H_ADDR + (32*15) +3] = 8'h00;
+
+//for (k = 0; k < 32; k = k + 1)  begin
+//  $display(" **** Descriptor data *** data = %h, addr= %d\n", DATA_STORE[C2H_ADDR+k], C2H_ADDR+k);
+//  #(Tcq);
+//end
+  //for (k = 0; k < DMA_BYTE_CNT; k = k + 1)  begin
+  //  #(Tcq) DATA_STORE[2560+k] = 8'h00;
+  //end
+  for (k = 0; k < DMA_BYTE_CNT; k = k + 1)  begin
+  #(Tcq) DATA_STORE[4096+k] = 8'h00;
+  end
+end
+endtask
+
+
+/************************************************************
+Task : TSK_INIT_QDMA_ST_DATA_H2C
+Inputs : None
+Outputs : None
+Description : Initialize Descriptor and Data
+*************************************************************/
+
+task TSK_INIT_QDMA_ST_DATA_H2C;
+  integer k;
+begin
+  $display(" **** TASK QDMA ST H2C DSC at address 0x%h ***\n", H2C_ADDR);
+
+  $display(" **** Initialize Descriptor data ***\n");
+  DATA_STORE[H2C_ADDR+0] = 8'h00; //-- Src_add [31:0] x0200
+  DATA_STORE[H2C_ADDR+1] = 8'h02;
+  DATA_STORE[H2C_ADDR+2] = 8'h00;
+  DATA_STORE[H2C_ADDR+3] = 8'h00;
+  DATA_STORE[H2C_ADDR+4] = 8'h00; //-- Src add [63:32]
+  DATA_STORE[H2C_ADDR+5] = 8'h00;
+  DATA_STORE[H2C_ADDR+6] = 8'h00;
+  DATA_STORE[H2C_ADDR+7] = 8'h00;
+  DATA_STORE[H2C_ADDR+8] = DMA_BYTE_CNT[7:0]; // [71:64] len [7:0] 28bits
+  DATA_STORE[H2C_ADDR+9] = DMA_BYTE_CNT[15:8];// [79:72] len [15:8]
+  DATA_STORE[H2C_ADDR+10] = DMA_BYTE_CNT[23:16];            // [87:80] len [23:16]
+  DATA_STORE[H2C_ADDR+11] = 8'h70;            // [96:88] {Reserved, EOP, SOP, Dsc vld, len[27:24]}
+  DATA_STORE[H2C_ADDR+12] = 8'h00; // [104:97] Reserved 32bits
+  DATA_STORE[H2C_ADDR+13] = 8'h00;
+  DATA_STORE[H2C_ADDR+14] = 8'h00;
+  DATA_STORE[H2C_ADDR+15] = 8'h00;
+
+  //Initialize Status write back location to 0's
+  DATA_STORE[496+0] = 8'h00;
+  DATA_STORE[496+1] = 8'h00;
+  DATA_STORE[496+2] = 8'h00;
+  DATA_STORE[496+3] = 8'h00;
+
+//for (k = 0; k < 16; k = k + 1)  begin
+//  $display(" **** Descriptor data *** data = %h, addr= %d\n", DATA_STORE[H2C_ADDR+k], H2C_ADDR+k);
+//  #(Tcq);
+//end
+  data_tmp = 0;
+  for (k = 0; k < 256; k = k + 2)  begin
+    DATA_STORE[512+k]   = data_tmp[7:0];
+    DATA_STORE[512+k+1] = data_tmp[15:8];
+    data_tmp[15:0] = data_tmp[15:0]+1;
+  //$display(" ****initial data data_tmp = %h addr 512+k = %d\n", data_tmp[15:0], 512+k);
+  //#(Tcq)
+  end
+
+//for (k = 0; k < 256; k = k + 1)  begin
+//  $display(" **** H2C data *** data = %h, addr= %d\n", DATA_STORE[512+k], 512+k);
+//end
+end
+endtask
+
+/************************************************************
+Task : TSK_INIT_QDMA_ST_DATA_H2C_NEW
+Inputs : None
+Outputs : None
+Description : Initialize Descriptor and Data
+*************************************************************/
+
+task TSK_INIT_QDMA_ST_DATA_H2C_NEW;
+  integer k;
+  integer dsc_num;
+begin
+  $display(" **** TASK QDMA ST H2C DSC at address 0x%h ***\n", H2C_ADDR);
+  $display(" **** Initialize Descriptor data ***\n");
+  dsc_num = 16;
+  for (k=0;k<dsc_num;k=k+1) begin
+    DATA_STORE[H2C_ADDR+(k*16)+0]  = 8'h00; // 32Bits Reserved
+    DATA_STORE[H2C_ADDR+(k*16)+1]  = 8'h00;
+    DATA_STORE[H2C_ADDR+(k*16)+2]  = DMA_BYTE_CNT[7:0]; // Packet length for ST loopback desin
+    DATA_STORE[H2C_ADDR+(k*16)+3]  = DMA_BYTE_CNT[15:8];
+    DATA_STORE[H2C_ADDR+(k*16)+4]  = DMA_BYTE_CNT[7:0];  // Packet length 16 bits [7:0]
+    DATA_STORE[H2C_ADDR+(k*16)+5]  = DMA_BYTE_CNT[15:8]; // Packet length 16 bits [15:8]
+    DATA_STORE[H2C_ADDR+(k*16)+6]  = 8'h03; // Reserved // bot EOP and SOP is set for Dsc bypass to work.
+    DATA_STORE[H2C_ADDR+(k*16)+7]  = 8'h00;
+    DATA_STORE[H2C_ADDR+(k*16)+8]  = 8'h00; //-- Src_add [31:0] x0300
+    DATA_STORE[H2C_ADDR+(k*16)+9]  = 8'h03;
+    DATA_STORE[H2C_ADDR+(k*16)+10] = 8'h00;
+    DATA_STORE[H2C_ADDR+(k*16)+11] = 8'h00;
+    DATA_STORE[H2C_ADDR+(k*16)+12] = 8'h00; //-- Src_add [63:32] x0000
+    DATA_STORE[H2C_ADDR+(k*16)+13] = 8'h00;
+    DATA_STORE[H2C_ADDR+(k*16)+14] = 8'h00;
+    DATA_STORE[H2C_ADDR+(k*16)+15] = 8'h00;
+  end
+
+  //Initialize Status write back location to 0's
+  DATA_STORE[H2C_ADDR + ((dsc_num-1)*16) +0] = 8'h00;
+  DATA_STORE[H2C_ADDR + ((dsc_num-1)*16) +1] = 8'h00;
+  DATA_STORE[H2C_ADDR + ((dsc_num-1)*16) +2] = 8'h00;
+  DATA_STORE[H2C_ADDR + ((dsc_num-1)*16) +3] = 8'h00;
+  data_tmp = 0;
+  for (k = 0; k < 1024; k = k + 2)  begin
+    DATA_STORE[768+k]   = data_tmp[7:0];
+    DATA_STORE[768+k+1] = data_tmp[15:8];
+    data_tmp[15:0] = data_tmp[15:0]+1;
+  //$display(" ****initial data data_tmp = %h addr 768+k = %d\n", data_tmp[15:0], 768+k);
+  end
+end
+endtask
+
+/************************************************************
+Task : TSK_INIT_QDMA_ST_DATA_H2C_64B
+Inputs : None
+Outputs : None
+Description : Initialize Descriptor and Data
+*************************************************************/
+
+task TSK_INIT_QDMA_ST_DATA_H2C_64B;
+  integer k;
+begin
+  $display(" **** TASK QDMA ST H2C DSC at address 0x%h ***\n", H2C_ADDR);
+
+  $display(" **** Initialize Descriptor data ***\n");
+  data_tmp = 0;
+  for (k=0;k<8;k=k+1) begin
+    DATA_STORE[H2C_ADDR+(k*64)+0]  = 8'h00; // 32Bits Reserved
+    DATA_STORE[H2C_ADDR+(k*64)+1]  = data_tmp[7:0]; // data_tmp[7:0];
+    DATA_STORE[H2C_ADDR+(k*64)+2]  = DMA_BYTE_CNT[7:0]; // Packet length for ST loopback desin
+    DATA_STORE[H2C_ADDR+(k*64)+3]  = DMA_BYTE_CNT[15:8];
+    DATA_STORE[H2C_ADDR+(k*64)+4]  = DMA_BYTE_CNT[7:0];  // Packet length 16 bits [7:0]
+    DATA_STORE[H2C_ADDR+(k*64)+5]  = DMA_BYTE_CNT[15:8]; // Packet length 16 bits [15:8]
+    DATA_STORE[H2C_ADDR+(k*64)+6]  = 8'h01; // Reserved // bot EOP and SOP is set for Dsc bypass to work.
+    DATA_STORE[H2C_ADDR+(k*64)+7]  = 8'h02;
+    DATA_STORE[H2C_ADDR+(k*64)+8]  = 8'h03; //-- Src_add [31:0] x0200
+    DATA_STORE[H2C_ADDR+(k*64)+9]  = 8'h04;
+    DATA_STORE[H2C_ADDR+(k*64)+10] = 8'h05;
+    DATA_STORE[H2C_ADDR+(k*64)+11] = 8'h06;
+    DATA_STORE[H2C_ADDR+(k*64)+12] = 8'h07; //-- Src_add [63:32] x0000
+    DATA_STORE[H2C_ADDR+(k*64)+13] = 8'h08;
+    DATA_STORE[H2C_ADDR+(k*64)+14] = 8'h09;
+    DATA_STORE[H2C_ADDR+(k*64)+15] = 8'h0a;
+
+    DATA_STORE[H2C_ADDR+(k*64)+16]  = 8'h0b; // 32Bits Reserved
+    DATA_STORE[H2C_ADDR+(k*64)+17]  = 8'h0c;
+    DATA_STORE[H2C_ADDR+(k*64)+18]  = 8'h0d; // Packet length for ST loopback desin
+    DATA_STORE[H2C_ADDR+(k*64)+19]  = 8'h0e;
+    DATA_STORE[H2C_ADDR+(k*64)+20]  = 8'h0f;  // Packet length 16 bits [7:0]
+    DATA_STORE[H2C_ADDR+(k*64)+21]  = 8'h10; // Packet length 16 bits [15:8]
+    DATA_STORE[H2C_ADDR+(k*64)+22]  = 8'h12; // Reserved // bot EOP and SOP is set for Dsc bypass to work.
+    DATA_STORE[H2C_ADDR+(k*64)+23]  = 8'h13;
+    DATA_STORE[H2C_ADDR+(k*64)+24]  = 8'h14; //-- Src_add [31:0] x0200
+    DATA_STORE[H2C_ADDR+(k*64)+25]  = 8'h15;
+    DATA_STORE[H2C_ADDR+(k*64)+26] = 8'h16;
+    DATA_STORE[H2C_ADDR+(k*64)+27] = 8'h17;
+    DATA_STORE[H2C_ADDR+(k*64)+28] = 8'h18; //-- Src_add [63:32] x0000
+    DATA_STORE[H2C_ADDR+(k*64)+29] = 8'h19;
+    DATA_STORE[H2C_ADDR+(k*64)+30] = 8'h1a;
+    DATA_STORE[H2C_ADDR+(k*64)+31] = 8'h1b;
+
+    DATA_STORE[H2C_ADDR+(k*64)+32]  = 8'h1c; // 32Bits Reserved
+    DATA_STORE[H2C_ADDR+(k*64)+33]  = 8'h1e;
+    DATA_STORE[H2C_ADDR+(k*64)+34]  = 8'h1f; // Packet length for ST loopback desin
+    DATA_STORE[H2C_ADDR+(k*64)+35]  = 8'h20;
+    DATA_STORE[H2C_ADDR+(k*64)+36]  = 8'h21;  // Packet length 16 bits [7:0]
+    DATA_STORE[H2C_ADDR+(k*64)+37]  = 8'h22; // Packet length 16 bits [15:8]
+    DATA_STORE[H2C_ADDR+(k*64)+38]  = 8'h23; // Reserved // bot EOP and SOP is set for Dsc bypass to work.
+    DATA_STORE[H2C_ADDR+(k*64)+39]  = 8'h24;
+    DATA_STORE[H2C_ADDR+(k*64)+40]  = 8'h25; //-- Src_add [31:0] x0200
+    DATA_STORE[H2C_ADDR+(k*64)+41]  = 8'h26;
+    DATA_STORE[H2C_ADDR+(k*64)+42] = 8'h27;
+    DATA_STORE[H2C_ADDR+(k*64)+43] = 8'h28;
+    DATA_STORE[H2C_ADDR+(k*64)+44] = 8'h29; //-- Src_add [63:32] x0000
+    DATA_STORE[H2C_ADDR+(k*64)+45] = 8'h2a;
+    DATA_STORE[H2C_ADDR+(k*64)+46] = 8'h2b;
+    DATA_STORE[H2C_ADDR+(k*64)+47] = 8'h2c;
+
+    DATA_STORE[H2C_ADDR+(k*64)+48]  = 8'h2d; // 32Bits Reserved
+    DATA_STORE[H2C_ADDR+(k*64)+49]  = 8'h2e;
+    DATA_STORE[H2C_ADDR+(k*64)+50]  = 8'h2f; // Packet length for ST loopback desin
+    DATA_STORE[H2C_ADDR+(k*64)+51]  = 8'h30;
+    DATA_STORE[H2C_ADDR+(k*64)+52]  = 8'h31;  // Packet length 16 bits [7:0]
+    DATA_STORE[H2C_ADDR+(k*64)+53]  = 8'h32; // Packet length 16 bits [15:8]
+    DATA_STORE[H2C_ADDR+(k*64)+54]  = 8'h33; // Reserved // bot EOP and SOP is set for Dsc bypass to work.
+    DATA_STORE[H2C_ADDR+(k*64)+55]  = 8'h34;
+    DATA_STORE[H2C_ADDR+(k*64)+56]  = 8'h35; //-- Src_add [31:0] x0200
+    DATA_STORE[H2C_ADDR+(k*64)+57]  = 8'h36;
+    DATA_STORE[H2C_ADDR+(k*64)+58] = 8'h37;
+    DATA_STORE[H2C_ADDR+(k*64)+59] = 8'h38;
+    DATA_STORE[H2C_ADDR+(k*64)+60] = 8'h39; //-- Src_add [63:32] x0000
+    DATA_STORE[H2C_ADDR+(k*64)+61] = 8'h3a;
+    DATA_STORE[H2C_ADDR+(k*64)+62] = 8'h3b;
+    DATA_STORE[H2C_ADDR+(k*64)+63] = 8'h3c;
+
+    data_tmp[15:0] = data_tmp[15:0]+1;
+  end // for (k=0;k<8;k=k+1)
+end
+endtask
+
+/************************************************************
+Task : TSK_INIT_QDMA_ST_DATA_C2H
+Inputs : None
+Outputs : None
+Description : Initialize Descriptor and Data
+*************************************************************/
+
+task TSK_INIT_QDMA_ST_DATA_C2H;
+  integer k;
+  integer dsc_num;
+begin
+  $display(" **** TASK QDMA ST DATA C2H. DSC at address 0x%h ****\n", C2H_ADDR);
+  $display(" **** Initialize Descriptor data #1 ***\n");
+  dsc_num = 16;
+
+  for (k=0;k<dsc_num-1;k=k+1) begin
+    DATA_STORE[C2H_ADDR+(k*8)+0] = 8'h00; //-- Src_add [31:0] xA00
+    DATA_STORE[C2H_ADDR+(k*8)+1] = 8'h0A;
+    DATA_STORE[C2H_ADDR+(k*8)+2] = 8'h00;
+    DATA_STORE[C2H_ADDR+(k*8)+3] = 8'h00;
+    DATA_STORE[C2H_ADDR+(k*8)+4] = 8'h00; //-- Src add [63:32]
+    DATA_STORE[C2H_ADDR+(k*8)+5] = 8'h00;
+    DATA_STORE[C2H_ADDR+(k*8)+6] = 8'h00;
+    DATA_STORE[C2H_ADDR+(k*8)+7] = 8'h00;
+  end
+
+  //Initialize Status write back location to 0's
+  DATA_STORE[C2H_ADDR+ ((dsc_num-1)*8) +0] = 8'h00;
+  DATA_STORE[C2H_ADDR+ ((dsc_num-1)*8) +1] = 8'h00;
+  DATA_STORE[C2H_ADDR+ ((dsc_num-1)*8) +2] = 8'h00;
+  DATA_STORE[C2H_ADDR+ ((dsc_num-1)*8) +3] = 8'h00;
+
+  for (k = 0; k < 8; k = k + 1)  begin
+    $display(" **** Descriptor data *** data = %h, addr= %d\n", DATA_STORE[C2H_ADDR+k], C2H_ADDR+k);
+    #(Tcq);
+  end
+  // for (k = 0; k < (DMA_BYTE_CNT*2); k = k + 1)  begin
+  //   #(Tcq) DATA_STORE[2560+k] = 8'h00;  //0xA00
+  // end
+end
+endtask
+
+/************************************************************
+Task : TSK_INIT_QDMA_ST_CMPT_C2H
+Inputs : None
+Outputs : None
+Description : Initialize Descriptor and Data
+*************************************************************/
+
+task TSK_INIT_QDMA_ST_CMPT_C2H;
+  integer k;
+
+  begin
+    $display(" **** TASK QDMA ST CMPT DATA for C2H at address 0x%h ***\n", CMPT_ADDR);
+
+    // initilize CMPT data for two entries 64bits each
+    for (k = 0; k < 32; k = k + 1)  begin
+       #(Tcq) DATA_STORE[CMPT_ADDR+k] = 8'h00;
+    end
+  end
+endtask
+
+/************************************************************
+Task : COMPARE_DATA_H2C
+Inputs : Number of Payload Bytes
+Outputs : None
+Description : Compare Data received at out of DMA with data sent from RP - user TB
+*************************************************************/
+
+task COMPARE_DATA_H2C;
+  input [31:0]payload_bytes ;
+  input integer address;
+
+  reg [511:0] READ_DATA [(DMA_BYTE_CNT/8):0];
+  reg [511:0] DATA_STORE_512 [(DMA_BYTE_CNT/8):0];
+
+  integer matched_data_counter;
+  integer i, j, k;
+  integer data_beat_count;
+begin
+  matched_data_counter = 0;
+
+  //Calculate number of beats for payload to DMA
+  case (board.C_DATA_WIDTH)
+    64:		data_beat_count = ((payload_bytes % 32'h8) == 0) ? (payload_bytes/32'h8) : ((payload_bytes/32'h8)+32'h1);
+    128:	data_beat_count = ((payload_bytes % 32'h10) == 0) ? (payload_bytes/32'h10) : ((payload_bytes/32'h10)+32'h1);
+    256:	data_beat_count = ((payload_bytes % 32'h20) == 0) ? (payload_bytes/32'h20) : ((payload_bytes/32'h20)+32'h1);
+    512:	data_beat_count = ((payload_bytes % 32'h40) == 0) ? (payload_bytes/32'h40) : ((payload_bytes/32'h40)+32'h1);
+  endcase
+
+  $display ("Enters into compare read data task at %gns\n", $realtime);
+  $display ("payload bytes=%h, data_beat_count =%d\n", payload_bytes, data_beat_count);
+
+  for (i=0; i<data_beat_count; i=i+1)   begin
+    DATA_STORE_512[i] = 512'b0;
+  end
+
+  //Sampling data payload on XDMA
+  @(posedge board.EP.qdma_subsystem_inst.m_axi_wvalid) ; //valid data comes at wvalid
+  for(i=0; i<data_beat_count; i=i+1) begin
+    @(negedge board.EP.qdma_subsystem_inst.axis_aclk); //samples data wvalid and negedge of user_clk
+
+    if( board.EP.qdma_subsystem_inst.m_axi_wready && board.EP.qdma_subsystem_inst.m_axi_wvalid) begin			//check for wready is high before sampling data
+      case (board.C_DATA_WIDTH)
+        64: READ_DATA[i] = {((board.EP.qdma_subsystem_inst.m_axi_wstrb[7] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[63:56] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[6] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[55:48] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[5] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[47:40] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[4] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[39:32] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[3] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[31:24] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[2] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[23:16] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[1] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[15:8] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[0] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[7:0] : 8'h00)};
+        128: READ_DATA[i] = {((board.EP.qdma_subsystem_inst.m_axi_wstrb[15] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[127:120] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[14] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[119:112] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[13] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[111:104] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[12] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[103:96] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[11] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[95:88] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[10] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[87:80] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[9] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[79:72] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[8] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[71:64] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[7] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[63:56] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[6] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[55:48] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[5] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[47:40] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[4] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[39:32] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[3] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[31:24] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[2] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[23:16] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[1] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[15:8] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[0] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[7:0] : 8'h00)};
+        256: READ_DATA[i] = {((board.EP.qdma_subsystem_inst.m_axi_wstrb[31] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[255:248] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[30] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[247:240] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[29] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[239:232] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[28] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[231:224] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[27] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[223:216] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[26] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[215:208] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[25] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[207:200] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[24] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[199:192] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[23] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[191:184] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[22] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[183:176] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[21] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[175:168] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[20] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[167:160] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[19] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[159:152] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[18] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[151:144] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[17] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[143:136] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[16] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[135:128] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[15] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[127:120] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[14] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[119:112] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[13] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[111:104] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[12] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[103:96] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[11] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[95:88] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[10] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[87:80] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[9] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[79:72] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[8] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[71:64] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[7] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[63:56] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[6] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[55:48] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[5] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[47:40] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[4] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[39:32] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[3] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[31:24] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[2] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[23:16] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[1] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[15:8] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[0] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[7:0] : 8'h00)};
+        512: READ_DATA[i] = {((board.EP.qdma_subsystem_inst.m_axi_wstrb[63] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[511:504] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[62] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[503:496] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[61] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[495:488] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[60] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[487:480] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[59] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[479:472] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[58] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[471:464] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[57] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[463:456] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[56] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[455:448] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[55] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[447:440] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[54] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[439:432] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[53] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[431:424] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[52] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[423:416] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[51] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[415:408] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[50] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[407:400] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[49] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[399:392] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[48] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[391:384] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[47] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[383:376] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[46] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[375:368] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[45] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[367:360] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[44] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[359:352] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[43] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[351:344] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[42] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[343:336] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[41] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[335:328] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[40] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[327:320] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[39] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[319:312] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[38] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[311:304] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[37] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[303:296] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[36] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[295:288] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[35] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[287:280] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[34] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[279:272] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[33] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[271:264] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[32] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[263:256] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[31] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[255:248] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[30] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[247:240] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[29] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[239:232] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[28] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[231:224] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[27] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[223:216] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[26] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[215:208] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[25] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[207:200] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[24] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[199:192] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[23] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[191:184] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[22] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[183:176] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[21] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[175:168] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[20] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[167:160] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[19] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[159:152] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[18] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[151:144] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[17] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[143:136] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[16] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[135:128] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[15] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[127:120] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[14] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[119:112] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[13] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[111:104] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[12] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[103:96] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[11] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[95:88] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[10] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[87:80] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[9] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[79:72] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[8] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[71:64] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[7] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[63:56] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[6] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[55:48] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[5] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[47:40] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[4] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[39:32] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[3] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[31:24] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[2] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[23:16] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[1] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[15:8] : 8'h00),
+            ((board.EP.qdma_subsystem_inst.m_axi_wstrb[0] == 1'b1) ? board.EP.qdma_subsystem_inst.m_axi_wdata[7:0] : 8'h00)};
+      endcase
+      $display ("--- H2C data at QDMA = %h ---\n", READ_DATA[i]);
+    end
+    else begin
+      i=i-1;
+    end
+  end
+
+  //Sampling stored data from User TB in reg
+  k = 0;
+  case (board.C_DATA_WIDTH)
+    64:
+    begin
+      for (i = 0; i < data_beat_count; i = i + 1) begin
+        for (j=7; j>=0; j=j-1) begin
+          DATA_STORE_512[i] = {DATA_STORE_512[i], DATA_STORE[address+k+j]};
+        end
+        k=k+8;
+        $display ("--- Data Stored in TB for H2C Transfer = %h ---\n", DATA_STORE_512[i]);
+      end
+    end
+
+    128:
+    begin
+      for (i = 0; i < data_beat_count; i = i + 1)   begin
+        for (j=15; j>=0; j=j-1) begin
+          DATA_STORE_512[i] = {DATA_STORE_512[i], DATA_STORE[address+k+j]};
+        end
+        k=k+16;
+        $display ("-- Data Stored in TB for H2C Transfer = %h--\n", DATA_STORE_512[i]);
+      end
+    end
+
+    256:
+    begin
+      for (i = 0; i < data_beat_count; i = i + 1)   begin
+        for (j=31; j>=0; j=j-1) begin
+          DATA_STORE_512[i] = {DATA_STORE_512[i], DATA_STORE[address+k+j]};
+        end
+        k=k+32;
+        $display ("-- Data Stored in TB for H2C Transfer = %h--\n", DATA_STORE_512[i]);
+      end
+    end
+
+    512:
+    begin
+      for (i = 0; i < data_beat_count; i = i + 1)   begin
+        for (j=63; j>=0; j=j-1) begin
+          DATA_STORE_512[i] = {DATA_STORE_512[i], DATA_STORE[address+k+j]};
+        end
+        k=k+64;
+        $display ("-- Data Stored in TB for H2C Transfer = %h--\n", DATA_STORE_512[i]);
+      end
+    end
+  endcase
+
+  //Compare sampled data from QDMA with stored TB data
+  for (i=0; i<data_beat_count; i=i+1)   begin
+    if(READ_DATA[i] == DATA_STORE_512[i]) begin
+      matched_data_counter = matched_data_counter + 1;
+    end else
+      matched_data_counter = matched_data_counter;
+  end
+
+  if(matched_data_counter == data_beat_count) begin
+    $display ("*** H2C Transfer Data MATCHES ***\n");
+    $display("[%t] : QDMA H2C Test Completed Successfully",$realtime);
+  end else begin
+    $display ("ERROR: [%t] : TEST FAILED ---***ERROR*** H2C Transfer Data MISMATCH ---\n",$realtime);
+    board.RP.tx_usrapp.test_state =1;
+  end
+
+end
+$display("Exiting task COMPARE_DATA_H2C");
+endtask
+
+/************************************************************
+Task : COMPARE_DATA_C2H_
+Inputs : Number of Payload Bytes
+Outputs : None
+Description : Compare Data received and stored at RP - user TB with the data sent for H2C transfer from RP - user TB
+*************************************************************/
+
+task COMPARE_DATA_C2H;
+  input [31:0] payload_bytes ;
+  input integer  address;
+
+  reg [511:0] READ_DATA_C2H_512 [(DMA_BYTE_CNT/8):0];
+  reg [511:0] DATA_STORE_512 [(DMA_BYTE_CNT/8):0];
+
+  integer matched_data_counter;
+  integer i, j, k,t;
+  integer data_beat_count;
+  integer cq_data_beat_count;
+  integer cq_valid_wait_cnt;
+begin
+
+  matched_data_counter = 0; t = 0;
+
+//for (k = 0; k < DMA_BYTE_CNT; k = k + 1)  begin
+//  $display(" **** H2C data *** data = %h, addr= %d\n", DATA_STORE[address+k], address+k);
+//end
+
+  //Calculate number of beats for payload sent
+  data_beat_count = ((payload_bytes % 32'h40) == 0) ? (payload_bytes/32'h40) : ((payload_bytes/32'h40)+32'h1);
+  cq_data_beat_count = ((((payload_bytes-32'h30) % 32'h40) == 0) ? ((payload_bytes-32'h30)/32'h40) : (((payload_bytes-32'h30)/32'h40)+32'h1)) + 32'h1;
+  $display ("payload_bytes = %h, data_beat_count = %h  cq_data_beat_count = %h\n", payload_bytes, data_beat_count, cq_data_beat_count);
+
+  //Sampling CQ data payload on RP
+  if(testname =="dma_stream0") begin
+    cq_valid_wait_cnt = 3;
+  end else begin
+    cq_valid_wait_cnt = 1;
+  end
+
+  for (i=0; i<cq_valid_wait_cnt; i=i+1) begin
+    @(posedge board.RP.m_axis_cq_tvalid); //1st tvalid - Descriptor Read Request
+  end
+  @(posedge board.RP.m_axis_cq_tvalid); //2nd tvalid - CQ on RP receives Data from QDMA
+  for (i=0; i<cq_data_beat_count; i=i+1) begin
+    // $display ("-------------------------starting i = %d--------------------------------------------------------------\n", i);
+    @(negedge user_clk); //Samples data at negedge of user_clk
+    if(board.RP.m_axis_cq_tready && board.RP.m_axis_cq_tvalid) begin	//Samples data when tready is high
+    // $display ("--m_axis_cq_tvalid = %d, m_axis_cq_tready = %d, i = %d--\n", board.RP.m_axis_cq_tvalid, board.RP.m_axis_cq_tready, i);
+      if(i == 0 || t == 1) begin					//First Data Beat
+        if(i != 0 && t == 1)
+        begin
+          i=i-1;
+        end
+        t=0;
+        READ_DATA_C2H_512[i][511:0] = board.RP.m_axis_cq_tdata [511:128];
+      end else begin //Second and Subsequent Data Beat
+      // $display ("m_axis_cq_tkeep = %h\n", board.RP.m_axis_cq_tkeep);
+        case (board.RP.m_axis_cq_tkeep)
+          16'h0001: begin READ_DATA_C2H_512[i-1][511:384] = {96'b0,board.RP.m_axis_cq_tdata [31:0]};  /* $display ("-- CHECKING C2H data at RP = %h-- i = %d t = %d \n", READ_DATA_C2H_512[2*i-1], i , t);*/ end
+          16'h0003: begin READ_DATA_C2H_512[i-1][511:384] = {64'b0,board.RP.m_axis_cq_tdata [63:0]};  /* $display ("-- CHECKING C2H data at RP = %h-- i = %d t = %d \n", READ_DATA_C2H_512[2*i-1], i , t);*/ end
+          16'h0007: begin READ_DATA_C2H_512[i-1][511:384] = {32'b0,board.RP.m_axis_cq_tdata [95:0]};  /* $display ("-- CHECKING C2H data at RP = %h-- i = %d t = %d \n", READ_DATA_C2H_512[2*i-1], i , t);*/ end
+          16'h000F: begin READ_DATA_C2H_512[i-1][511:384] = board.RP.m_axis_cq_tdata [127:0];         /* $display ("-- CHECKING C2H data at RP = %h-- i = %d t = %d \n", READ_DATA_C2H_512[2*i-1], i , t);*/ end
+          16'h001F: begin READ_DATA_C2H_512[i-1][511:384] = board.RP.m_axis_cq_tdata [127:0]; READ_DATA_C2H_512[i] = {480'b0,board.RP.m_axis_cq_tdata [159:128]}; /*$display ("-- CHECKING C2H data at RP = %h-- i = %d t = %d \n", READ_DATA_C2H_512[i-1], i , t);*/ end
+          16'h003F: begin READ_DATA_C2H_512[i-1][511:384] = board.RP.m_axis_cq_tdata [127:0]; READ_DATA_C2H_512[i] = {448'b0,board.RP.m_axis_cq_tdata [191:128]}; /*$display ("-- CHECKING C2H data at RP = %h-- i = %d t = %d \n", READ_DATA_C2H_512[i-1], i , t);*/ end
+          16'h007F: begin READ_DATA_C2H_512[i-1][511:384] = board.RP.m_axis_cq_tdata [127:0]; READ_DATA_C2H_512[i] = {416'b0,board.RP.m_axis_cq_tdata [223:128]}; /*$display ("-- CHECKING C2H data at RP = %h-- i = %d t = %d \n", READ_DATA_C2H_512[i-1], i , t);*/ end
+          16'h00FF: begin READ_DATA_C2H_512[i-1][511:384] = board.RP.m_axis_cq_tdata [127:0]; READ_DATA_C2H_512[i] = {384'b0,board.RP.m_axis_cq_tdata [255:128]}; /*$display ("-- CHECKING C2H data at RP = %h-- i = %d t = %d \n", READ_DATA_C2H_512[i-1], i , t);*/ end
+          16'h01FF: begin READ_DATA_C2H_512[i-1][511:384] = board.RP.m_axis_cq_tdata [127:0]; READ_DATA_C2H_512[i] = {352'b0,board.RP.m_axis_cq_tdata [287:128]}; /*$display ("-- CHECKING C2H data at RP = %h-- i = %d t = %d \n", READ_DATA_C2H_512[i-1], i , t);*/ end
+          16'h03FF: begin READ_DATA_C2H_512[i-1][511:384] = board.RP.m_axis_cq_tdata [127:0]; READ_DATA_C2H_512[i] = {320'b0,board.RP.m_axis_cq_tdata [319:128]}; /*$display ("-- CHECKING C2H data at RP = %h-- i = %d t = %d \n", READ_DATA_C2H_512[i-1], i , t);*/ end
+          16'h07FF: begin READ_DATA_C2H_512[i-1][511:384] = board.RP.m_axis_cq_tdata [127:0]; READ_DATA_C2H_512[i] = {288'b0,board.RP.m_axis_cq_tdata [351:128]}; /*$display ("-- CHECKING C2H data at RP = %h-- i = %d t = %d \n", READ_DATA_C2H_512[i-1], i , t);*/ end
+          16'h0FFF: begin READ_DATA_C2H_512[i-1][511:384] = board.RP.m_axis_cq_tdata [127:0]; READ_DATA_C2H_512[i] = {256'b0,board.RP.m_axis_cq_tdata [383:128]}; /*$display ("-- CHECKING C2H data at RP = %h-- i = %d t = %d \n", READ_DATA_C2H_512[i-1], i , t);*/ end
+          16'h1FFF: begin READ_DATA_C2H_512[i-1][511:384] = board.RP.m_axis_cq_tdata [127:0]; READ_DATA_C2H_512[i] = {224'b0,board.RP.m_axis_cq_tdata [415:128]}; /*$display ("-- CHECKING C2H data at RP = %h-- i = %d t = %d \n", READ_DATA_C2H_512[i-1], i , t);*/ end
+          16'h3FFF: begin READ_DATA_C2H_512[i-1][511:384] = board.RP.m_axis_cq_tdata [127:0]; READ_DATA_C2H_512[i] = {192'b0,board.RP.m_axis_cq_tdata [447:128]}; /*$display ("-- CHECKING C2H data at RP = %h-- i = %d t = %d \n", READ_DATA_C2H_512[i-1], i , t);*/ end
+          16'h7FFF: begin READ_DATA_C2H_512[i-1][511:384] = board.RP.m_axis_cq_tdata [127:0]; READ_DATA_C2H_512[i] = {160'b0,board.RP.m_axis_cq_tdata [479:128]}; /*$display ("-- CHECKING C2H data at RP = %h-- i = %d t = %d \n", READ_DATA_C2H_512[i-1], i , t);*/ end
+          16'hFFFF: begin READ_DATA_C2H_512[i-1][511:384] = board.RP.m_axis_cq_tdata [127:0]; READ_DATA_C2H_512[i] = {128'b0,board.RP.m_axis_cq_tdata [511:128]}; /*$display ("-- CHECKING C2H data at RP = %h-- i = %d t = %d \n", READ_DATA_C2H_512[i-1], i , t);*/ end
+          default: begin READ_DATA_C2H_512[i] = 512'b0;/* $display ("-- C2H data at RP = %h--\n", READ_DATA_C2H_512[2*i]);*/ end
+        endcase
+
+        // $display ("------------------------------------------------------------------------------------------");
+        // $display ("-- CHECKING m_axis_cq_tdata = %h   and i = %d--\n", board.RP.m_axis_cq_tdata [511:0] , i);
+        // $display ("-- CHECKING READ_DATA_C2H_512 = %h   and i = %d--\n", READ_DATA_C2H_512[i-1][511:384] , i);
+        // $display ("-- CHECKING m_axis_cq_tkeep = %h   and i = %d--\n", board.RP.m_axis_cq_tkeep[15:0] , i);
+        if(board.RP.m_axis_cq_tlast)
+        begin
+          t=1;
+        end
+      end
+    end
+    else begin
+      i=i-1;
+    // $display ("-------------------------ending i = %d--------------------------------------------------------------\n", i);
+    end
+  end
+
+  //Sampling stored data from User TB in 256 bit reg
+  k = 0;
+  for (i = 0; i < data_beat_count; i = i + 1)   begin
+    $display ("-- C2H data at RP = %h--\n", READ_DATA_C2H_512[i]);
+  end
+
+  for (i = 0; i < data_beat_count; i = i + 1)   begin
+    for (j=63; j>=0; j=j-1) begin
+      DATA_STORE_512[i] = {DATA_STORE_512[i], DATA_STORE[address+k+j]};
+    // $display ("-- DATA_STORE_512[i] = %h,-- DATA_STORE[address+k+j] = %h,  address = %h, i = %d, j = %d, k = %d\n", DATA_STORE_512[i],DATA_STORE[address+k+j], address+k+j,i,j,k);
+    end
+    k=k+64;
+    $display ("-- Data Stored in TB = %h--\n", DATA_STORE_512[i]);
+  end
+
+  //Compare sampled data from CQ with stored TB data
+
+  for (i=0; i<data_beat_count; i=i+1)   begin
+    if(READ_DATA_C2H_512[i] == DATA_STORE_512[i]) begin
+      matched_data_counter = matched_data_counter + 1;
+    end else
+      matched_data_counter = matched_data_counter;
+  end
+
+  if(matched_data_counter == data_beat_count) begin
+    $display ("*** C2H Transfer Data MATCHES ***\n");
+    $display("[%t] : QDMA C2H Test Completed Successfully",$realtime);
+  end else begin
+    $display ("ERROR: [%t] : TEST FAILED ---***ERROR*** C2H Transfer Data MISMATCH ---\n",$realtime);
+    board.RP.tx_usrapp.test_state =1;
+  end
+end
+endtask
+
+/************************************************************
+Task : COMPARE_TRANS_STATUS
+Inputs : Number of Payload Bytes
+Outputs : None
+Description : Compare Data received and stored at RP - user TB with the data sent for H2C transfer from RP - user TB
+*************************************************************/
+
+task COMPARE_TRANS_STATUS;
+  input [31:0] status_addr ;
+  input [16:0] exp_cidx;
+  integer 	i, j, k;
+  integer 	status_found;
+  integer 	loop_count;
+  reg [15:0] 	cidx;
+begin
+  status_found = 0;
+  loop_count = 0;
+  cidx = 0;
+  while((exp_cidx != cidx) && (loop_count < 10))begin
+    $display("Entered while loop in COMPARE_TRANS_STATUS");
+    $display("Values: cidx=%d, exp_cidx=%d, loop_count=%d, board.RP.m_axis_cq_tvalid=%d", cidx, exp_cidx, loop_count, board.RP.m_axis_cq_tvalid);
+    loop_count = loop_count +1;
+    wait (board.RP.m_axis_cq_tvalid == 1'b1) ; //1st tvalid after data
+    $display("Overcome wait statement in COMPARE_TRANS_STATUS");
+    @(negedge user_clk); //Samples data at negedge of user_clk
+    $display("Overcome negedge of user_clk in COMPARE_TRANS_STATUS");
+    if(board.RP.m_axis_cq_tready) begin
+      if(board.RP.m_axis_cq_tdata [31:0] == status_addr[31:0]) begin  // Address match
+        cidx = cidx + board.RP.m_axis_cq_tdata [159:144];
+      end
+    end
+  end
+  $display("Exited while loop in COMPARE_TRANS_STATUS");
+  if(exp_cidx == cidx )
+    $display ("[%t] : Write Back Status matches expected value : %h\n", $realtime, cidx);
+  else begin
+    $display ("ERROR: [%t] : TEST FAILED ---***ERROR*** Write Back Status NO matches expected value : %h, got %h \n",$realtime, exp_cidx, cidx);
+    board.RP.tx_usrapp.test_state =1;
+  end
+end
+endtask
+
+/************************************************************
+Task : COMPARE_TRANS_C2H_ST_STATUS
+Inputs : Number of Payload Bytes
+Outputs : None
+Description : Compare Data received and stored at RP - user TB with the data sent for H2C transfer from RP - user TB
+*************************************************************/
+
+task COMPARE_TRANS_C2H_ST_STATUS;
+  input integer indx ;
+  input [16:0] exp_pidx;
+  input pkt_type;  // 1 regular packet 0 immediate data
+  input integer cmpt_size;
+  integer 	i, j, k;
+  integer 	status_found;
+  integer 	loop_count;
+  reg [15:0] pidx;
+  reg [21:0] len;
+  reg [31:0] wrb_status_addr ;
+  reg [3:0]  cmpt_ctl;
+begin
+  len = board.RP.m_axis_cq_tdata [147:132];
+  cmpt_ctl =4'h0;
+
+  // get transfere length
+  while(board.RP.m_axis_cq_tdata[31:0] != (CMPT_ADDR+(indx*cmpt_size))) begin
+    wait (board.RP.m_axis_cq_tvalid == 1'b1) ;          //1st tvalid after data
+    @(negedge user_clk);	 						//Samples data at negedge of user_clk
+    if(board.RP.m_axis_cq_tready) begin
+      if(board.RP.m_axis_cq_tdata[31:0] == (CMPT_ADDR+(indx*cmpt_size))) begin  // Address match
+        len = board.RP.m_axis_cq_tdata[147:132];
+        cmpt_ctl = board.RP.m_axis_cq_tdata[131:128];
+      end
+    end
+  end
+
+  if(pkt_type ) begin  // regular packet
+    if(len[15:0] == DMA_BYTE_CNT[15:0] )
+      $display ("*** C2H transfer Length matches with expected value : %h\n", len);
+    else begin
+      $display ("ERROR: [%t] : TEST FAILED ---***ERROR*** C2H transfer length does not matche expected value : %h, got %h \n",$realtime, DMA_BYTE_CNT[15:0], len);
+      board.RP.tx_usrapp.test_state =1;
+    end
+    if(cmpt_ctl[3] )  // desc_used bit
+      $display ("*** C2H transfer is Regular packet and desc_used is set \n");
+    else begin
+      $display ("ERROR: [%t] : TEST FAILED ---***ERROR*** C2H descriptor is not used in Regulart packet tranfer : %h\n",$realtime,cmpt_ctl[3:0]);
+      board.RP.tx_usrapp.test_state =1;
+    end
+  end
+  else begin // immediate data
+    if(~cmpt_ctl[3] )
+      $display ("*** C2H transfer is Immediate data and desc_used is NOT set \n");
+    else begin
+      $display ("ERROR: [%t] : TEST FAILED ---***ERROR*** C2H descriptor is used for Immediate data : %h\n",$realtime,cmpt_ctl[3:0]);
+      board.RP.tx_usrapp.test_state =1;
+    end
+  end
+  if(~cmpt_ctl[2] ) // Err bit
+    $display ("*** C2H transfer erro bit is not set \n");
+  else begin
+    $display ("ERROR: [%t] : TEST FAILED ---***ERROR*** Completion Error bit is set \n",$realtime);
+    board.RP.tx_usrapp.test_state =1;
+  end
+
+  // get writeback Pidx
+  //
+  wrb_status_addr = CMPT_ADDR +(15*cmpt_size);
+//wrb_status_addr = 32'h00001078;
+  status_found = 0;
+  loop_count = 0;
+  pidx = 0;
+  while((exp_pidx != pidx) && (loop_count < 10)) begin
+    loop_count = loop_count +1;
+    wait (board.RP.m_axis_cq_tvalid == 1'b1); //1st tvalid - Descriptor Read Request
+
+    if(board.RP.m_axis_cq_tready) begin
+      if(board.RP.m_axis_cq_tdata[31:0] == wrb_status_addr[31:0]) begin  // Address match
+        pidx = pidx + board.RP.m_axis_cq_tdata[143:128];
+        $display("pidx = 0x%x, exp pidx = 0x%x\n", pidx, exp_pidx);
+      end
+    end
+    @(negedge user_clk); //Samples data at negedge of user_clk
+  end
+
+  if(exp_pidx == pidx ) begin
+    $display ("*** Write Back Status matches expected value : %h and color bit is %h\n", pidx, cmpt_ctl[1]);
+    $display ("*** Test Passed ***\n");
+  end
+  else begin
+    $display ("ERROR: [%t] : TEST FAILED ---***ERROR*** Write Back Status NO matches expected value : %h, got %h \n",$realtime, exp_pidx, pidx);
+    board.RP.tx_usrapp.test_state =1;
+  end
+end
+endtask
+
+/************************************************************
+Task : TSK_FIND_USR_BAR
+Description : Find User BAR
+*************************************************************/
+
+task TSK_FIND_USR_BAR;
+begin
+  board.RP.tx_usrapp.TSK_REG_READ(xdma_bar, 16'h10C);
+  case (P_READ_DATA[5:0])
+    6'b000001 : user_bar =0;
+    6'b000010 : user_bar =1;
+    6'b000100 : user_bar =2;
+    6'b001000 : user_bar =3;
+    6'b010000 : user_bar =4;
+    6'b100000 : user_bar =5;
+    default : user_bar = 0;
+  endcase // case (P_READ_DATA[5:0])
+  $display (" ***** User BAR = %d *****\n", user_bar);
+end
+endtask // TSK_FIND_USR_BAR
+
+// Include all the initialization tasks from a separate file
+`include "initialization.svh"
+
+endmodule // pci_exp_usrapp_tx
diff --git a/src/box_250mhz/box_250mhz.sv b/src/box_250mhz/box_250mhz.sv
old mode 100644
new mode 100755
index 913e86c..bada30f
--- a/src/box_250mhz/box_250mhz.sv
+++ b/src/box_250mhz/box_250mhz.sv
@@ -1,21 +1,11 @@
-// *************************************************************************
+//==============================================================================
+// Copyright (C) 2023, Advanced Micro Devices, Inc. All rights reserved.
+// Copyright (C) 2022, Xilinx, Inc. All rights reserved.
+// SPDX-License-Identifier: MIT
 //
-// Copyright 2020 Xilinx, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-// *************************************************************************
+//==============================================================================
 `timescale 1ns/1ps
+
 module box_250mhz #(
   parameter int MIN_PKT_LEN   = 64,
   parameter int MAX_PKT_LEN   = 1518,
@@ -76,6 +66,87 @@ module box_250mhz #(
   input   [16*NUM_CMAC_PORT-1:0] s_axis_adap_rx_250mhz_tuser_dst,
   output     [NUM_CMAC_PORT-1:0] s_axis_adap_rx_250mhz_tready,
 
+  output                         m_axis_user2rdma_roce_from_cmac_rx_tvalid,
+  output                 [511:0] m_axis_user2rdma_roce_from_cmac_rx_tdata,
+  output                  [63:0] m_axis_user2rdma_roce_from_cmac_rx_tkeep,
+  output                         m_axis_user2rdma_roce_from_cmac_rx_tlast,
+  input                          m_axis_user2rdma_roce_from_cmac_rx_tready,
+
+  input                          s_axis_rdma2user_to_cmac_tx_tvalid,
+  input                  [511:0] s_axis_rdma2user_to_cmac_tx_tdata,
+  input                   [63:0] s_axis_rdma2user_to_cmac_tx_tkeep,
+  input                          s_axis_rdma2user_to_cmac_tx_tlast,
+  output                         s_axis_rdma2user_to_cmac_tx_tready,
+
+  output                         m_axis_user2rdma_from_qdma_tx_tvalid,
+  output                 [511:0] m_axis_user2rdma_from_qdma_tx_tdata,
+  output                  [63:0] m_axis_user2rdma_from_qdma_tx_tkeep,
+  output                         m_axis_user2rdma_from_qdma_tx_tlast,
+  input                          m_axis_user2rdma_from_qdma_tx_tready,
+
+  input                   [63:0] s_axis_rdma2user_ieth_immdt_tdata,
+  input                          s_axis_rdma2user_ieth_immdt_tlast,
+  input                          s_axis_rdma2user_ieth_immdt_tvalid,
+  output                         s_axis_rdma2user_ieth_immdt_trdy,
+
+  input                          s_resp_hndler_i_send_cq_db_cnt_valid,
+  input                   [9 :0] s_resp_hndler_i_send_cq_db_addr,
+  input                   [31:0] s_resp_hndler_i_send_cq_db_cnt,
+  output                         s_resp_hndler_o_send_cq_db_rdy,
+
+  output                  [15:0] m_o_qp_sq_pidb_hndshk,
+  output                  [31:0] m_o_qp_sq_pidb_wr_addr_hndshk,
+  output                         m_o_qp_sq_pidb_wr_valid_hndshk,
+  input                          m_i_qp_sq_pidb_wr_rdy,
+
+  output                  [15:0] m_o_qp_rq_cidb_hndshk,
+  output                  [31:0] m_o_qp_rq_cidb_wr_addr_hndshk,
+  output                         m_o_qp_rq_cidb_wr_valid_hndshk,
+  input                          m_i_qp_rq_cidb_wr_rdy,
+
+  input                          s_rx_pkt_hndler_i_rq_db_data_valid,
+  input                   [9 :0] s_rx_pkt_hndler_i_rq_db_addr,
+  input                   [31:0] s_rx_pkt_hndler_i_rq_db_data,
+  output                         s_rx_pkt_hndler_o_rq_db_rdy,
+
+  output                         m_axi_compute_logic_awid,
+  output                [63 : 0] m_axi_compute_logic_awaddr,
+  output                 [3 : 0] m_axi_compute_logic_awqos,
+  output                 [7 : 0] m_axi_compute_logic_awlen,
+  output                 [2 : 0] m_axi_compute_logic_awsize,
+  output                 [1 : 0] m_axi_compute_logic_awburst,
+  output                 [3 : 0] m_axi_compute_logic_awcache,
+  output                 [2 : 0] m_axi_compute_logic_awprot,
+  output                         m_axi_compute_logic_awvalid,
+  input                          m_axi_compute_logic_awready,
+  output               [511 : 0] m_axi_compute_logic_wdata,
+  output                [63 : 0] m_axi_compute_logic_wstrb,
+  output                         m_axi_compute_logic_wlast,
+  output                         m_axi_compute_logic_wvalid,
+  input                          m_axi_compute_logic_wready,
+  output                         m_axi_compute_logic_awlock,
+  input                          m_axi_compute_logic_bid,
+  input                  [1 : 0] m_axi_compute_logic_bresp,
+  input                          m_axi_compute_logic_bvalid,
+  output                         m_axi_compute_logic_bready,
+  output                         m_axi_compute_logic_arid,
+  output                [63 : 0] m_axi_compute_logic_araddr,
+  output                 [7 : 0] m_axi_compute_logic_arlen,
+  output                 [2 : 0] m_axi_compute_logic_arsize,
+  output                 [1 : 0] m_axi_compute_logic_arburst,
+  output                 [3 : 0] m_axi_compute_logic_arcache,
+  output                 [2 : 0] m_axi_compute_logic_arprot,
+  output                         m_axi_compute_logic_arvalid,
+  input                          m_axi_compute_logic_arready,
+  input                          m_axi_compute_logic_rid,
+  input                [511 : 0] m_axi_compute_logic_rdata,
+  input                  [1 : 0] m_axi_compute_logic_rresp,
+  input                          m_axi_compute_logic_rlast,
+  input                          m_axi_compute_logic_rvalid,
+  output                         m_axi_compute_logic_rready,
+  output                         m_axi_compute_logic_arlock,
+  output                  [3:0]  m_axi_compute_logic_arqos,
+
   input                   [15:0] mod_rstn,
   output                  [15:0] mod_rst_done,
 
@@ -86,34 +157,156 @@ module box_250mhz #(
   input                          axis_aclk
 );
 
-  wire internal_box_rstn;
-
-  generic_reset #(
-    .NUM_INPUT_CLK  (1),
-    .RESET_DURATION (100)
-  ) reset_inst (
-    .mod_rstn     (box_rstn),
-    .mod_rst_done (box_rst_done),
-    .clk          (axil_aclk),
-    .rstn         (internal_box_rstn)
-  );
-
-  `include "box_250mhz_address_map_inst.vh"
-
-  generate if (USE_PHYS_FUNC == 0) begin
-    // Terminate H2C and C2H interfaces of the box
-    assign s_axis_qdma_h2c_tready     = {NUM_PHYS_FUNC{1'b1}};
-
-    assign m_axis_qdma_c2h_tvalid     = 0;
-    assign m_axis_qdma_c2h_tdata      = 0;
-    assign m_axis_qdma_c2h_tkeep      = 0;
-    assign m_axis_qdma_c2h_tlast      = 0;
-    assign m_axis_qdma_c2h_tuser_size = 0;
-    assign m_axis_qdma_c2h_tuser_src  = 0;
-    assign m_axis_qdma_c2h_tuser_dst  = 0;
-  end
-  endgenerate
-
-  `include "user_plugin_250mhz_inst.vh"
+localparam C_NUM_USER_BLOCK = 1;
+
+logic axil_rstn;
+logic axis_rstn;
+
+generic_reset #(
+  .NUM_INPUT_CLK  (2),
+  .RESET_DURATION (100)
+) reset_inst (
+  .mod_rstn     (box_rstn),
+  .mod_rst_done (box_rst_done),
+  .clk          ({axis_aclk, axil_aclk}),
+  .rstn         ({axis_rstn, axil_rstn})
+);
+
+// Make sure for all the unused reset pair, corresponding bits in
+// "mod_rst_done" are tied to 0
+assign mod_rst_done[15:C_NUM_USER_BLOCK] = {(16-C_NUM_USER_BLOCK){1'b1}};
+assign mod_rst_done[0]                   = box_rst_done;
+
+rdma_onic_plugin rdma_onic_plugin_inst (
+  .s_axil_awvalid            (s_axil_awvalid),
+  .s_axil_awaddr             (s_axil_awaddr),
+  .s_axil_awready            (s_axil_awready),
+  .s_axil_wvalid             (s_axil_wvalid),
+  .s_axil_wdata              (s_axil_wdata),
+  .s_axil_wready             (s_axil_wready),
+  .s_axil_bvalid             (s_axil_bvalid),
+  .s_axil_bresp              (s_axil_bresp),
+  .s_axil_bready             (s_axil_bready),
+  .s_axil_arvalid            (s_axil_arvalid),
+  .s_axil_araddr             (s_axil_araddr),
+  .s_axil_arready            (s_axil_arready),
+  .s_axil_rvalid             (s_axil_rvalid),
+  .s_axil_rdata              (s_axil_rdata),
+  .s_axil_rresp              (s_axil_rresp),
+  .s_axil_rready             (s_axil_rready),
+
+  // Receive packets from CMAC RX path
+  .s_axis_cmac_rx_tvalid     (s_axis_adap_rx_250mhz_tvalid),
+  .s_axis_cmac_rx_tdata      (s_axis_adap_rx_250mhz_tdata),
+  .s_axis_cmac_rx_tkeep      (s_axis_adap_rx_250mhz_tkeep),
+  .s_axis_cmac_rx_tlast      (s_axis_adap_rx_250mhz_tlast),
+  .s_axis_cmac_rx_tuser_size (s_axis_adap_rx_250mhz_tuser_size),
+  .s_axis_cmac_rx_tready     (s_axis_adap_rx_250mhz_tready),
+
+  .m_axis_user2rdma_roce_from_cmac_rx_tvalid (m_axis_user2rdma_roce_from_cmac_rx_tvalid),
+  .m_axis_user2rdma_roce_from_cmac_rx_tdata  (m_axis_user2rdma_roce_from_cmac_rx_tdata),
+  .m_axis_user2rdma_roce_from_cmac_rx_tkeep  (m_axis_user2rdma_roce_from_cmac_rx_tkeep),
+  .m_axis_user2rdma_roce_from_cmac_rx_tlast  (m_axis_user2rdma_roce_from_cmac_rx_tlast),
+  .m_axis_user2rdma_roce_from_cmac_rx_tready (m_axis_user2rdma_roce_from_cmac_rx_tready),
+
+  // Send packets to QDMA RX path
+  .m_axis_qdma_c2h_tvalid                    (m_axis_qdma_c2h_tvalid),
+  .m_axis_qdma_c2h_tdata                     (m_axis_qdma_c2h_tdata),
+  .m_axis_qdma_c2h_tkeep                     (m_axis_qdma_c2h_tkeep),
+  .m_axis_qdma_c2h_tlast                     (m_axis_qdma_c2h_tlast),
+  .m_axis_qdma_c2h_tuser_size                (m_axis_qdma_c2h_tuser_size),
+  .m_axis_qdma_c2h_tready                    (m_axis_qdma_c2h_tready),
+
+  // Get packets from QDMA TX path
+  .s_axis_qdma_h2c_tvalid                    (s_axis_qdma_h2c_tvalid),
+  .s_axis_qdma_h2c_tdata                     (s_axis_qdma_h2c_tdata),
+  .s_axis_qdma_h2c_tkeep                     (s_axis_qdma_h2c_tkeep),
+  .s_axis_qdma_h2c_tlast                     (s_axis_qdma_h2c_tlast),
+  .s_axis_qdma_h2c_tuser_size                (s_axis_qdma_h2c_tuser_size),
+  .s_axis_qdma_h2c_tready                    (s_axis_qdma_h2c_tready),
+
+  .m_axis_user2rdma_from_qdma_tx_tvalid      (m_axis_user2rdma_from_qdma_tx_tvalid),
+  .m_axis_user2rdma_from_qdma_tx_tdata       (m_axis_user2rdma_from_qdma_tx_tdata),
+  .m_axis_user2rdma_from_qdma_tx_tkeep       (m_axis_user2rdma_from_qdma_tx_tkeep),
+  .m_axis_user2rdma_from_qdma_tx_tlast       (m_axis_user2rdma_from_qdma_tx_tlast),
+  .m_axis_user2rdma_from_qdma_tx_tready      (m_axis_user2rdma_from_qdma_tx_tready),
+
+  // Send packets to CMAC TX path
+  .m_axis_cmac_tx_tvalid                     (m_axis_adap_tx_250mhz_tvalid),
+  .m_axis_cmac_tx_tdata                      (m_axis_adap_tx_250mhz_tdata),
+  .m_axis_cmac_tx_tkeep                      (m_axis_adap_tx_250mhz_tkeep),
+  .m_axis_cmac_tx_tlast                      (m_axis_adap_tx_250mhz_tlast),
+  .m_axis_cmac_tx_tuser_size                 (m_axis_adap_tx_250mhz_tuser_size),
+  .m_axis_cmac_tx_tready                     (m_axis_adap_tx_250mhz_tready),
+
+  .s_axis_rdma2user_to_cmac_tx_tvalid        (s_axis_rdma2user_to_cmac_tx_tvalid),
+  .s_axis_rdma2user_to_cmac_tx_tdata         (s_axis_rdma2user_to_cmac_tx_tdata),
+  .s_axis_rdma2user_to_cmac_tx_tkeep         (s_axis_rdma2user_to_cmac_tx_tkeep),
+  .s_axis_rdma2user_to_cmac_tx_tlast         (s_axis_rdma2user_to_cmac_tx_tlast),
+  .s_axis_rdma2user_to_cmac_tx_tready        (s_axis_rdma2user_to_cmac_tx_tready),
+
+  .m_axi_compute_logic_awid                  (m_axi_compute_logic_awid),
+  .m_axi_compute_logic_awaddr                (m_axi_compute_logic_awaddr),
+  .m_axi_compute_logic_awqos                 (m_axi_compute_logic_awqos),
+  .m_axi_compute_logic_awlen                 (m_axi_compute_logic_awlen),
+  .m_axi_compute_logic_awsize                (m_axi_compute_logic_awsize),
+  .m_axi_compute_logic_awburst               (m_axi_compute_logic_awburst),
+  .m_axi_compute_logic_awcache               (m_axi_compute_logic_awcache),
+  .m_axi_compute_logic_awprot                (m_axi_compute_logic_awprot),
+  .m_axi_compute_logic_awvalid               (m_axi_compute_logic_awvalid),
+  .m_axi_compute_logic_awready               (m_axi_compute_logic_awready),
+  .m_axi_compute_logic_wdata                 (m_axi_compute_logic_wdata),
+  .m_axi_compute_logic_wstrb                 (m_axi_compute_logic_wstrb),
+  .m_axi_compute_logic_wlast                 (m_axi_compute_logic_wlast),
+  .m_axi_compute_logic_wvalid                (m_axi_compute_logic_wvalid),
+  .m_axi_compute_logic_wready                (m_axi_compute_logic_wready),
+  .m_axi_compute_logic_awlock                (m_axi_compute_logic_awlock),
+  .m_axi_compute_logic_bid                   (m_axi_compute_logic_bid),
+  .m_axi_compute_logic_bresp                 (m_axi_compute_logic_bresp),
+  .m_axi_compute_logic_bvalid                (m_axi_compute_logic_bvalid),
+  .m_axi_compute_logic_bready                (m_axi_compute_logic_bready),
+  .m_axi_compute_logic_arid                  (m_axi_compute_logic_arid),
+  .m_axi_compute_logic_araddr                (m_axi_compute_logic_araddr),
+  .m_axi_compute_logic_arlen                 (m_axi_compute_logic_arlen),
+  .m_axi_compute_logic_arsize                (m_axi_compute_logic_arsize),
+  .m_axi_compute_logic_arburst               (m_axi_compute_logic_arburst),
+  .m_axi_compute_logic_arcache               (m_axi_compute_logic_arcache),
+  .m_axi_compute_logic_arprot                (m_axi_compute_logic_arprot),
+  .m_axi_compute_logic_arvalid               (m_axi_compute_logic_arvalid),
+  .m_axi_compute_logic_arready               (m_axi_compute_logic_arready),
+  .m_axi_compute_logic_rid                   (m_axi_compute_logic_rid),
+  .m_axi_compute_logic_rdata                 (m_axi_compute_logic_rdata),
+  .m_axi_compute_logic_rresp                 (m_axi_compute_logic_rresp),
+  .m_axi_compute_logic_rlast                 (m_axi_compute_logic_rlast),
+  .m_axi_compute_logic_rvalid                (m_axi_compute_logic_rvalid),
+  .m_axi_compute_logic_rready                (m_axi_compute_logic_rready),
+  .m_axi_compute_logic_arlock                (m_axi_compute_logic_arlock),
+  .m_axi_compute_logic_arqos                 (m_axi_compute_logic_arqos),
+
+  .axil_aclk  (axil_aclk),
+  .axil_rstn  (axil_rstn),
+  .axis_aclk  (axis_aclk),
+  .axis_rstn  (box_rstn)
+);
+
+assign m_axis_qdma_c2h_tuser_src = 16'd0;
+assign m_axis_qdma_c2h_tuser_dst = 16'h1 << 0;
+assign m_axis_adap_tx_250mhz_tuser_src = 16'd0;
+assign m_axis_adap_tx_250mhz_tuser_dst = 16'h1 << 6;
+
+// TODO: Disable hardware handshaking for doorbell ringing in the current implementation
+assign s_resp_hndler_o_send_cq_db_rdy = 1'b0;
+assign s_rx_pkt_hndler_o_rq_db_rdy    = 1'b0;
+
+assign m_o_qp_sq_pidb_hndshk          = 0;
+assign m_o_qp_sq_pidb_wr_addr_hndshk  = 0;
+assign m_o_qp_sq_pidb_wr_valid_hndshk = 0;
+
+assign m_o_qp_rq_cidb_hndshk          = 0;
+assign m_o_qp_rq_cidb_wr_addr_hndshk  = 0;
+assign m_o_qp_rq_cidb_wr_valid_hndshk = 0;
+
+// TODO: Disable ieth and immdt data
+assign s_axis_rdma2user_ieth_immdt_trdy = 1'b1;
 
 endmodule: box_250mhz
diff --git a/src/cmac_subsystem/vivado_ip/cmac_usplus_0_au55c.tcl b/src/cmac_subsystem/vivado_ip/cmac_usplus_0_au55c.tcl
new file mode 100644
index 0000000..425b800
--- /dev/null
+++ b/src/cmac_subsystem/vivado_ip/cmac_usplus_0_au55c.tcl
@@ -0,0 +1,47 @@
+# *************************************************************************
+#
+# Copyright 2020 Xilinx, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# *************************************************************************
+set cmac_usplus cmac_usplus_0
+create_ip -name cmac_usplus -vendor xilinx.com -library ip -module_name $cmac_usplus -dir ${ip_build_dir}
+set_property -dict {
+    CONFIG.CMAC_CAUI4_MODE {1}
+    CONFIG.NUM_LANES {4x25}
+    CONFIG.GT_REF_CLK_FREQ {161.1328125}
+    CONFIG.USER_INTERFACE {AXIS}
+    CONFIG.GT_DRP_CLK {125.00}
+    CONFIG.ENABLE_AXI_INTERFACE {1}
+    CONFIG.INCLUDE_STATISTICS_COUNTERS {1}
+    CONFIG.CMAC_CORE_SELECT {CMACE4_X0Y3}
+    CONFIG.GT_GROUP_SELECT {X0Y24~X0Y27}
+    CONFIG.LANE1_GT_LOC {X0Y24}
+    CONFIG.LANE2_GT_LOC {X0Y25}
+    CONFIG.LANE3_GT_LOC {X0Y26}
+    CONFIG.LANE4_GT_LOC {X0Y27}
+    CONFIG.LANE5_GT_LOC {NA}
+    CONFIG.LANE6_GT_LOC {NA}
+    CONFIG.LANE7_GT_LOC {NA}
+    CONFIG.LANE8_GT_LOC {NA}
+    CONFIG.LANE9_GT_LOC {NA}
+    CONFIG.LANE10_GT_LOC {NA}
+    CONFIG.RX_GT_BUFFER {1}
+    CONFIG.GT_RX_BUFFER_BYPASS {0}
+    CONFIG.INS_LOSS_NYQ {20}
+    CONFIG.INCLUDE_RS_FEC {1}
+    CONFIG.ENABLE_PIPELINE_REG {1}
+} [get_ips $cmac_usplus]
+set_property CONFIG.RX_MIN_PACKET_LEN $min_pkt_len [get_ips $cmac_usplus]
+set_property CONFIG.RX_MAX_PACKET_LEN $max_pkt_len [get_ips $cmac_usplus]
diff --git a/src/cmac_subsystem/vivado_ip/cmac_usplus_1_au55c.tcl b/src/cmac_subsystem/vivado_ip/cmac_usplus_1_au55c.tcl
new file mode 100644
index 0000000..a45c1f7
--- /dev/null
+++ b/src/cmac_subsystem/vivado_ip/cmac_usplus_1_au55c.tcl
@@ -0,0 +1,49 @@
+# *************************************************************************
+#
+# Copyright 2020 Xilinx, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# *************************************************************************
+set cmac_usplus cmac_usplus_1
+create_ip -name cmac_usplus -vendor xilinx.com -library ip -module_name $cmac_usplus -dir ${ip_build_dir}
+set_property -dict {
+    CONFIG.CMAC_CAUI4_MODE {1}
+    CONFIG.NUM_LANES {4x25}
+    CONFIG.GT_REF_CLK_FREQ {161.1328125}
+    CONFIG.USER_INTERFACE {AXIS}
+    CONFIG.GT_DRP_CLK {125.00}
+    CONFIG.ENABLE_AXI_INTERFACE {1}
+    CONFIG.INCLUDE_STATISTICS_COUNTERS {1}
+    CONFIG.CMAC_CORE_SELECT {CMACE4_X0Y4}
+    CONFIG.GT_GROUP_SELECT {X0Y28~X0Y31}
+    CONFIG.LANE1_GT_LOC {X0Y28}
+    CONFIG.LANE2_GT_LOC {X0Y29}
+    CONFIG.LANE3_GT_LOC {X0Y30}
+    CONFIG.LANE4_GT_LOC {X0Y31}
+    CONFIG.LANE5_GT_LOC {NA}
+    CONFIG.LANE6_GT_LOC {NA}
+    CONFIG.LANE7_GT_LOC {NA}
+    CONFIG.LANE8_GT_LOC {NA}
+    CONFIG.LANE9_GT_LOC {NA}
+    CONFIG.LANE10_GT_LOC {NA}
+    CONFIG.RX_GT_BUFFER {1}
+    CONFIG.GT_RX_BUFFER_BYPASS {0}
+    CONFIG.INS_LOSS_NYQ {20}
+    CONFIG.INCLUDE_RS_FEC {1}
+    CONFIG.ETHERNET_BOARD_INTERFACE {qsfp1_4x}
+    CONFIG.DIFFCLK_BOARD_INTERFACE {qsfp1_refclk0}
+    CONFIG.ENABLE_PIPELINE_REG {1}
+} [get_ips $cmac_usplus]
+set_property CONFIG.RX_MIN_PACKET_LEN $min_pkt_len [get_ips $cmac_usplus]
+set_property CONFIG.RX_MAX_PACKET_LEN $max_pkt_len [get_ips $cmac_usplus]
diff --git a/src/mem_ctrl/au250/vivado_ip/dev_mem_ddr4_controller_au250.tcl b/src/mem_ctrl/au250/vivado_ip/dev_mem_ddr4_controller_au250.tcl
new file mode 100755
index 0000000..2cd467b
--- /dev/null
+++ b/src/mem_ctrl/au250/vivado_ip/dev_mem_ddr4_controller_au250.tcl
@@ -0,0 +1,170 @@
+# *************************************************************************
+#
+# Copyright 2023 Xilinx, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# *************************************************************************
+set ddr4_controller dev_mem_ddr4_controller
+
+create_ip -name ddr4 -vendor xilinx.com -library ip -module_name $ddr4_controller -dir ${ip_build_dir}
+
+set_property -dict {
+    CONFIG.C0.ControllerType {DDR4_SDRAM}
+    CONFIG.IOPowerReduction {OFF}
+    CONFIG.Enable_SysPorts {true}
+    CONFIG.Phy_Only {Complete_Memory_Controller}
+    CONFIG.RESET_BOARD_INTERFACE {pcie_perstn}
+    CONFIG.C0_CLOCK_BOARD_INTERFACE {default_300mhz_clk0}
+    CONFIG.IS_FROM_PHY {1}
+    CONFIG.RECONFIG_XSDB_SAVE_RESTORE {false}
+    CONFIG.AL_SEL {0}
+    CONFIG.Example_TG {SIMPLE_TG}
+    CONFIG.C0.DDR4_Clamshell {false}
+    CONFIG.C0.MIGRATION {false}
+    CONFIG.TIMING_OP1 {false}
+    CONFIG.TIMING_OP2 {false}
+    CONFIG.TIMING_3DS {false}
+    CONFIG.SET_DW_TO_40 {false}
+    CONFIG.DIFF_TERM_SYSCLK {false}
+    CONFIG.C0_DDR4_BOARD_INTERFACE {ddr4_sdram_c0}
+    CONFIG.C0.DDR4_TimePeriod {833}
+    CONFIG.C0.DDR4_InputClockPeriod {3332}
+    CONFIG.C0.DDR4_Specify_MandD {false}
+    CONFIG.C0.DDR4_CLKFBOUT_MULT {5}
+    CONFIG.C0.DDR4_DIVCLK_DIVIDE {1}
+    CONFIG.C0.DDR4_CLKOUT0_DIVIDE {5}
+    CONFIG.C0.DDR4_PhyClockRatio {4:1}
+    CONFIG.C0.DDR4_MemoryType {RDIMMs}
+    CONFIG.C0.DDR4_MemoryPart {MTA18ASF2G72PZ-2G3}
+    CONFIG.C0.DDR4_Slot {Single}
+    CONFIG.C0.DDR4_MemoryVoltage {1.2V}
+    CONFIG.C0.DDR4_DataWidth {72}
+    CONFIG.C0.DDR4_DataMask {NONE}
+    CONFIG.C0.DDR4_Ecc {true}
+    CONFIG.C0.DDR4_AxiSelection {true}
+    CONFIG.C0.DDR4_AUTO_AP_COL_A3 {true}
+    CONFIG.C0.DDR4_Ordering {Normal}
+    CONFIG.C0.DDR4_BurstLength {8}
+    CONFIG.C0.DDR4_BurstType {Sequential}
+    CONFIG.C0.DDR4_OutputDriverImpedenceControl {RZQ/7}
+    CONFIG.C0.DDR4_OnDieTermination {RZQ/6}
+    CONFIG.C0.DDR4_CasLatency {17}
+    CONFIG.C0.DDR4_CasWriteLatency {12}
+    CONFIG.C0.DDR4_ChipSelect {true}
+    CONFIG.C0.DDR4_isCKEShared {false}
+    CONFIG.C0.DDR4_AxiDataWidth {512}
+    CONFIG.C0.DDR4_AxiArbitrationScheme {RD_PRI_REG}
+    CONFIG.C0.DDR4_AxiNarrowBurst {false}
+    CONFIG.C0.DDR4_AxiAddressWidth {34}
+    CONFIG.C0.DDR4_AxiIDWidth {8}
+    CONFIG.C0.DDR4_Capacity {512}
+    CONFIG.C0.DDR4_Mem_Add_Map {ROW_COLUMN_BANK_INTLV}
+    CONFIG.C0.DDR4_MemoryName {MainMemory}
+    CONFIG.C0.DDR4_AutoPrecharge {false}
+    CONFIG.C0.DDR4_UserRefresh_ZQCS {false}
+    CONFIG.C0.DDR4_CustomParts {no_file_loaded}
+    CONFIG.C0.DDR4_isCustom {false}
+    CONFIG.C0.DDR4_SELF_REFRESH {false}
+    CONFIG.C0.DDR4_SAVE_RESTORE {false}
+    CONFIG.C0.DDR4_RESTORE_CRC {false}
+    CONFIG.ADDN_UI_CLKOUT1_FREQ_HZ {250}
+    CONFIG.ADDN_UI_CLKOUT2_FREQ_HZ {None}
+    CONFIG.ADDN_UI_CLKOUT3_FREQ_HZ {None}
+    CONFIG.ADDN_UI_CLKOUT4_FREQ_HZ {None}
+    CONFIG.CLKOUT6 {false}
+    CONFIG.No_Controller {1}
+    CONFIG.System_Clock {Differential}
+    CONFIG.Reference_Clock {Differential}
+    CONFIG.Debug_Signal {Disable}
+    CONFIG.IO_Power_Reduction {false}
+    CONFIG.DCI_Cascade {false}
+    CONFIG.Default_Bank_Selections {false}
+    CONFIG.Simulation_Mode {BFM}
+    CONFIG.PARTIAL_RECONFIG_FLOW_MIG {false}
+    CONFIG.MCS_DBG_EN {false}
+    CONFIG.C0.DDR4_CK_SKEW_0 {0}
+    CONFIG.C0.DDR4_CK_SKEW_1 {0}
+    CONFIG.C0.DDR4_CK_SKEW_2 {0}
+    CONFIG.C0.DDR4_CK_SKEW_3 {0}
+    CONFIG.C0.DDR4_ADDR_SKEW_0 {0}
+    CONFIG.C0.DDR4_ADDR_SKEW_1 {0}
+    CONFIG.C0.DDR4_ADDR_SKEW_2 {0}
+    CONFIG.C0.DDR4_ADDR_SKEW_3 {0}
+    CONFIG.C0.DDR4_ADDR_SKEW_4 {0}
+    CONFIG.C0.DDR4_ADDR_SKEW_5 {0}
+    CONFIG.C0.DDR4_ADDR_SKEW_6 {0}
+    CONFIG.C0.DDR4_ADDR_SKEW_7 {0}
+    CONFIG.C0.DDR4_ADDR_SKEW_8 {0}
+    CONFIG.C0.DDR4_ADDR_SKEW_9 {0}
+    CONFIG.C0.DDR4_ADDR_SKEW_10 {0}
+    CONFIG.C0.DDR4_ADDR_SKEW_11 {0}
+    CONFIG.C0.DDR4_ADDR_SKEW_12 {0}
+    CONFIG.C0.DDR4_ADDR_SKEW_13 {0}
+    CONFIG.C0.DDR4_ADDR_SKEW_14 {0}
+    CONFIG.C0.DDR4_ADDR_SKEW_15 {0}
+    CONFIG.C0.DDR4_ADDR_SKEW_16 {0}
+    CONFIG.C0.DDR4_ADDR_SKEW_17 {0}
+    CONFIG.C0.DDR4_BA_SKEW_0 {0}
+    CONFIG.C0.DDR4_BA_SKEW_1 {0}
+    CONFIG.C0.DDR4_BG_SKEW_0 {0}
+    CONFIG.C0.DDR4_BG_SKEW_1 {0}
+    CONFIG.C0.DDR4_CS_SKEW_0 {0}
+    CONFIG.C0.DDR4_CS_SKEW_1 {0}
+    CONFIG.C0.DDR4_CS_SKEW_2 {0}
+    CONFIG.C0.DDR4_CS_SKEW_3 {0}
+    CONFIG.C0.DDR4_CKE_SKEW_0 {0}
+    CONFIG.C0.DDR4_CKE_SKEW_1 {0}
+    CONFIG.C0.DDR4_CKE_SKEW_2 {0}
+    CONFIG.C0.DDR4_CKE_SKEW_3 {0}
+    CONFIG.C0.DDR4_ACT_SKEW {0}
+    CONFIG.C0.DDR4_PAR_SKEW {0}
+    CONFIG.C0.DDR4_ODT_SKEW_0 {0}
+    CONFIG.C0.DDR4_ODT_SKEW_1 {0}
+    CONFIG.C0.DDR4_ODT_SKEW_2 {0}
+    CONFIG.C0.DDR4_ODT_SKEW_3 {0}
+    CONFIG.C0.DDR4_LR_SKEW_0 {0}
+    CONFIG.C0.DDR4_LR_SKEW_1 {0}
+    CONFIG.C0.DDR4_TREFI {0}
+    CONFIG.C0.DDR4_TRFC {0}
+    CONFIG.C0.DDR4_TRFC_DLR {0}
+    CONFIG.C0.DDR4_TXPR {0}
+    CONFIG.C0.DDR4_nCK_TREFI {0}
+    CONFIG.C0.DDR4_nCK_TRFC {0}
+    CONFIG.C0.DDR4_nCK_TRFC_DLR {0}
+    CONFIG.C0.DDR4_nCK_TXPR {0}
+    CONFIG.C0.ADDR_WIDTH {17}
+    CONFIG.C0.BANK_GROUP_WIDTH {2}
+    CONFIG.C0.LR_WIDTH {1}
+    CONFIG.C0.CK_WIDTH {1}
+    CONFIG.C0.CKE_WIDTH {1}
+    CONFIG.C0.CS_WIDTH {1}
+    CONFIG.C0.ODT_WIDTH {1}
+    CONFIG.C0.StackHeight {1}
+    CONFIG.PING_PONG_PHY {1}
+    CONFIG.C0.DDR4_Enable_LVAUX {false}
+    CONFIG.C0.DDR4_EN_PARITY {true}
+    CONFIG.EN_PP_4R_MIR {false}
+    CONFIG.MCS_WO_DSP {false}
+    CONFIG.C0_SYS_CLK_I.INSERT_VIP {0}
+    CONFIG.C0_DDR4_S_AXI_CTRL.INSERT_VIP {0}
+    CONFIG.C0_DDR4_S_AXI.INSERT_VIP {0}
+    CONFIG.C0_DDR4_ARESETN.INSERT_VIP {0}
+    CONFIG.C0_DDR4_RESET.INSERT_VIP {0}
+    CONFIG.C0_DDR4_CLOCK.INSERT_VIP {0}
+    CONFIG.ADDN_UI_CLKOUT1.INSERT_VIP {0}
+    CONFIG.ADDN_UI_CLKOUT2.INSERT_VIP {0}
+    CONFIG.ADDN_UI_CLKOUT3.INSERT_VIP {0}
+    CONFIG.ADDN_UI_CLKOUT4.INSERT_VIP {0}
+    CONFIG.SYSTEM_RESET.INSERT_VIP {0}
+} [get_ips $ddr4_controller]
\ No newline at end of file
diff --git a/src/mem_ctrl/au250/vivado_ip/vivado_ip.tcl b/src/mem_ctrl/au250/vivado_ip/vivado_ip.tcl
new file mode 100755
index 0000000..f47097d
--- /dev/null
+++ b/src/mem_ctrl/au250/vivado_ip/vivado_ip.tcl
@@ -0,0 +1,20 @@
+# *************************************************************************
+#
+# Copyright 2020 Xilinx, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# *************************************************************************
+set ips {
+    dev_mem_ddr4_controller
+}
\ No newline at end of file
diff --git a/src/mem_ctrl/hbm_bd.tcl b/src/mem_ctrl/hbm_bd.tcl
new file mode 100644
index 0000000..90b2218
--- /dev/null
+++ b/src/mem_ctrl/hbm_bd.tcl
@@ -0,0 +1,425 @@
+
+################################################################
+# This is a generated script based on design: hbm_bd
+#
+# Though there are limitations about the generated script,
+# the main purpose of this utility is to make learning
+# IP Integrator Tcl commands easier.
+################################################################
+
+namespace eval _tcl {
+proc get_script_folder {} {
+   set script_path [file normalize [info script]]
+   set script_folder [file dirname $script_path]
+   return $script_folder
+}
+}
+variable script_folder
+set script_folder [_tcl::get_script_folder]
+
+################################################################
+# Check if script is running in correct Vivado version.
+################################################################
+set scripts_vivado_version 2024.2
+set current_vivado_version [version -short]
+
+if { [string first $scripts_vivado_version $current_vivado_version] == -1 } {
+   puts ""
+   if { [string compare $scripts_vivado_version $current_vivado_version] > 0 } {
+      catch {common::send_gid_msg -ssname BD::TCL -id 2042 -severity "ERROR" " This script was generated using Vivado <$scripts_vivado_version> and is being run in <$current_vivado_version> of Vivado. Sourcing the script failed since it was created with a future version of Vivado."}
+
+   } else {
+     catch {common::send_gid_msg -ssname BD::TCL -id 2041 -severity "ERROR" "This script was generated using Vivado <$scripts_vivado_version> and is being run in <$current_vivado_version> of Vivado. Please run the script in Vivado <$scripts_vivado_version> then open the design in Vivado <$current_vivado_version>. Upgrade the design by running \"Tools => Report => Report IP Status...\", then run write_bd_tcl to create an updated script."}
+
+   }
+
+   return 1
+}
+
+################################################################
+# START
+################################################################
+
+# To test this script, run the following commands from Vivado Tcl console:
+# source hbm_bd.tcl
+
+# If there is no project opened, this script will create a
+# project, but make sure you do not have an existing project
+# <./myproj/project_1.xpr> in the current working folder.
+
+set list_projs [get_projects -quiet]
+if { $list_projs eq "" } {
+   create_project project_1 myproj -part xcu55c-fsvh2892-2L-e
+   set_property BOARD_PART xilinx.com:au55c:part0:1.0 [current_project]
+}
+
+
+# CHANGE DESIGN NAME HERE
+variable design_name
+set design_name hbm_bd
+
+# If you do not already have an existing IP Integrator design open,
+# you can create a design using the following command:
+#    create_bd_design $design_name
+
+# Creating design if needed
+set errMsg ""
+set nRet 0
+
+set cur_design [current_bd_design -quiet]
+set list_cells [get_bd_cells -quiet]
+
+if { ${design_name} eq "" } {
+   # USE CASES:
+   #    1) Design_name not set
+
+   set errMsg "Please set the variable <design_name> to a non-empty value."
+   set nRet 1
+
+} elseif { ${cur_design} ne "" && ${list_cells} eq "" } {
+   # USE CASES:
+   #    2): Current design opened AND is empty AND names same.
+   #    3): Current design opened AND is empty AND names diff; design_name NOT in project.
+   #    4): Current design opened AND is empty AND names diff; design_name exists in project.
+
+   if { $cur_design ne $design_name } {
+      common::send_gid_msg -ssname BD::TCL -id 2001 -severity "INFO" "Changing value of <design_name> from <$design_name> to <$cur_design> since current design is empty."
+      set design_name [get_property NAME $cur_design]
+   }
+   common::send_gid_msg -ssname BD::TCL -id 2002 -severity "INFO" "Constructing design in IPI design <$cur_design>..."
+
+} elseif { ${cur_design} ne "" && $list_cells ne "" && $cur_design eq $design_name } {
+   # USE CASES:
+   #    5) Current design opened AND has components AND same names.
+
+   set errMsg "Design <$design_name> already exists in your project, please set the variable <design_name> to another value."
+   set nRet 1
+} elseif { [get_files -quiet ${design_name}.bd] ne "" } {
+   # USE CASES:
+   #    6) Current opened design, has components, but diff names, design_name exists in project.
+   #    7) No opened design, design_name exists in project.
+
+   set errMsg "Design <$design_name> already exists in your project, please set the variable <design_name> to another value."
+   set nRet 2
+
+} else {
+   # USE CASES:
+   #    8) No opened design, design_name not in project.
+   #    9) Current opened design, has components, but diff names, design_name not in project.
+
+   common::send_gid_msg -ssname BD::TCL -id 2003 -severity "INFO" "Currently there is no design <$design_name> in project, so creating one..."
+
+   create_bd_design $design_name
+
+   common::send_gid_msg -ssname BD::TCL -id 2004 -severity "INFO" "Making design <$design_name> as current_bd_design."
+   current_bd_design $design_name
+
+}
+
+common::send_gid_msg -ssname BD::TCL -id 2005 -severity "INFO" "Currently the variable <design_name> is equal to \"$design_name\"."
+
+if { $nRet != 0 } {
+   catch {common::send_gid_msg -ssname BD::TCL -id 2006 -severity "ERROR" $errMsg}
+   return $nRet
+}
+
+set bCheckIPsPassed 1
+##################################################################
+# CHECK IPs
+##################################################################
+set bCheckIPs 1
+if { $bCheckIPs == 1 } {
+   set list_check_ips "\
+xilinx.com:ip:hbm:1.0\
+xilinx.com:ip:clk_wiz:6.0\
+xilinx.com:ip:proc_sys_reset:5.0\
+xilinx.com:ip:smartconnect:1.0\
+"
+
+   set list_ips_missing ""
+   common::send_gid_msg -ssname BD::TCL -id 2011 -severity "INFO" "Checking if the following IPs exist in the project's IP catalog: $list_check_ips ."
+
+   foreach ip_vlnv $list_check_ips {
+      set ip_obj [get_ipdefs -all $ip_vlnv]
+      if { $ip_obj eq "" } {
+         lappend list_ips_missing $ip_vlnv
+      }
+   }
+
+   if { $list_ips_missing ne "" } {
+      catch {common::send_gid_msg -ssname BD::TCL -id 2012 -severity "ERROR" "The following IPs are not found in the IP Catalog:\n  $list_ips_missing\n\nResolution: Please add the repository containing the IP(s) to the project." }
+      set bCheckIPsPassed 0
+   }
+
+}
+
+if { $bCheckIPsPassed != 1 } {
+  common::send_gid_msg -ssname BD::TCL -id 2023 -severity "WARNING" "Will not continue with creation of design due to the error(s) above."
+  return 3
+}
+
+##################################################################
+# DESIGN PROCs
+##################################################################
+
+
+
+# Procedure to create entire design; Provide argument to make
+# procedure reusable. If parentCell is "", will use root.
+proc create_root_design { parentCell } {
+
+  variable script_folder
+  variable design_name
+
+  if { $parentCell eq "" } {
+     set parentCell [get_bd_cells /]
+  }
+
+  # Get object for parentCell
+  set parentObj [get_bd_cells $parentCell]
+  if { $parentObj == "" } {
+     catch {common::send_gid_msg -ssname BD::TCL -id 2090 -severity "ERROR" "Unable to find parent cell <$parentCell>!"}
+     return
+  }
+
+  # Make sure parentObj is hier blk
+  set parentType [get_property TYPE $parentObj]
+  if { $parentType ne "hier" } {
+     catch {common::send_gid_msg -ssname BD::TCL -id 2091 -severity "ERROR" "Parent <$parentObj> has TYPE = <$parentType>. Expected to be <hier>."}
+     return
+  }
+
+  # Save current instance; Restore later
+  set oldCurInst [current_bd_instance .]
+
+  # Set parent object as current
+  current_bd_instance $parentObj
+
+
+  # Create interface ports
+  set s_axi_hbm [ create_bd_intf_port -mode Slave -vlnv xilinx.com:interface:aximm_rtl:1.0 s_axi_hbm ]
+  set_property -dict [ list \
+   CONFIG.ADDR_WIDTH {64} \
+   CONFIG.ARUSER_WIDTH {32} \
+   CONFIG.AWUSER_WIDTH {32} \
+   CONFIG.BUSER_WIDTH {0} \
+   CONFIG.DATA_WIDTH {512} \
+   CONFIG.FREQ_HZ {250000000} \
+   CONFIG.HAS_BRESP {1} \
+   CONFIG.HAS_BURST {0} \
+   CONFIG.HAS_CACHE {1} \
+   CONFIG.HAS_LOCK {1} \
+   CONFIG.HAS_PROT {1} \
+   CONFIG.HAS_QOS {0} \
+   CONFIG.HAS_REGION {0} \
+   CONFIG.HAS_RRESP {1} \
+   CONFIG.HAS_WSTRB {1} \
+   CONFIG.ID_WIDTH {4} \
+   CONFIG.MAX_BURST_LENGTH {256} \
+   CONFIG.NUM_READ_OUTSTANDING {32} \
+   CONFIG.NUM_READ_THREADS {1} \
+   CONFIG.NUM_WRITE_OUTSTANDING {32} \
+   CONFIG.NUM_WRITE_THREADS {1} \
+   CONFIG.PROTOCOL {AXI4} \
+   CONFIG.READ_WRITE_MODE {READ_WRITE} \
+   CONFIG.RUSER_BITS_PER_BYTE {0} \
+   CONFIG.RUSER_WIDTH {0} \
+   CONFIG.SUPPORTS_NARROW_BURST {0} \
+   CONFIG.WUSER_BITS_PER_BYTE {0} \
+   CONFIG.WUSER_WIDTH {64} \
+   ] $s_axi_hbm
+
+
+  # Create ports
+  set axi_resetn [ create_bd_port -dir I axi_resetn ]
+  set hbm_ref_clk [ create_bd_port -dir I -type clk -freq_hz 100000000 hbm_ref_clk ]
+  set axi_clk [ create_bd_port -dir I -type clk -freq_hz 250000000 axi_clk ]
+  set_property -dict [ list \
+   CONFIG.ASSOCIATED_BUSIF {s_axi_hbm} \
+   CONFIG.CLK_DOMAIN {qdma_hbm_bd_qdma_0_0_axi_aclk} \
+ ] $axi_clk
+
+  # Create instance: hbm_0, and set properties
+  set hbm_0 [ create_bd_cell -type ip -vlnv xilinx.com:ip:hbm:1.0 hbm_0 ]
+  set_property -dict [list \
+    CONFIG.USER_APB_EN {false} \
+    CONFIG.USER_AXI_INPUT_CLK1_FREQ {250} \
+    CONFIG.USER_AXI_INPUT_CLK_FREQ {250} \
+    CONFIG.USER_HBM_DENSITY {16GB} \
+    CONFIG.USER_MC0_USER_PARITY_EN {false} \
+    CONFIG.USER_SAXI_00 {false} \
+    CONFIG.USER_SAXI_01 {false} \
+    CONFIG.USER_SAXI_02 {false} \
+    CONFIG.USER_SAXI_03 {false} \
+    CONFIG.USER_SAXI_04 {false} \
+    CONFIG.USER_SAXI_05 {false} \
+    CONFIG.USER_SAXI_06 {false} \
+    CONFIG.USER_SAXI_07 {false} \
+    CONFIG.USER_SAXI_08 {false} \
+    CONFIG.USER_SAXI_09 {false} \
+    CONFIG.USER_SAXI_10 {false} \
+    CONFIG.USER_SAXI_11 {false} \
+    CONFIG.USER_SAXI_12 {false} \
+    CONFIG.USER_SAXI_13 {false} \
+    CONFIG.USER_SAXI_14 {false} \
+    CONFIG.USER_SAXI_17 {false} \
+    CONFIG.USER_SAXI_18 {false} \
+    CONFIG.USER_SAXI_19 {false} \
+    CONFIG.USER_SAXI_20 {false} \
+    CONFIG.USER_SAXI_21 {false} \
+    CONFIG.USER_SAXI_22 {false} \
+    CONFIG.USER_SAXI_23 {false} \
+    CONFIG.USER_SAXI_24 {false} \
+    CONFIG.USER_SAXI_25 {false} \
+    CONFIG.USER_SAXI_26 {false} \
+    CONFIG.USER_SAXI_27 {false} \
+    CONFIG.USER_SAXI_28 {false} \
+    CONFIG.USER_SAXI_29 {false} \
+    CONFIG.USER_SAXI_30 {false} \
+    CONFIG.USER_SAXI_31 {false} \
+  ] $hbm_0
+
+
+  # Create instance: clk_wiz_0, and set properties
+  set clk_wiz_0 [ create_bd_cell -type ip -vlnv xilinx.com:ip:clk_wiz:6.0 clk_wiz_0 ]
+  set_property -dict [list \
+    CONFIG.CLKIN1_JITTER_PS {100.0} \
+    CONFIG.CLKOUT1_JITTER {115.831} \
+    CONFIG.CLKOUT1_PHASE_ERROR {87.180} \
+    CONFIG.CLK_IN1_BOARD_INTERFACE {Custom} \
+    CONFIG.MMCM_CLKFBOUT_MULT_F {12.000} \
+    CONFIG.MMCM_CLKIN1_PERIOD {10.000} \
+    CONFIG.MMCM_CLKIN2_PERIOD {10.000} \
+    CONFIG.MMCM_DIVCLK_DIVIDE {1} \
+    CONFIG.PRIM_SOURCE {Single_ended_clock_capable_pin} \
+    CONFIG.RESET_PORT {resetn} \
+    CONFIG.RESET_TYPE {ACTIVE_LOW} \
+  ] $clk_wiz_0
+
+
+  # Create instance: proc_sys_reset_0, and set properties
+  set proc_sys_reset_0 [ create_bd_cell -type ip -vlnv xilinx.com:ip:proc_sys_reset:5.0 proc_sys_reset_0 ]
+
+  # Create instance: smartconnect_0, and set properties
+  set smartconnect_0 [ create_bd_cell -type ip -vlnv xilinx.com:ip:smartconnect:1.0 smartconnect_0 ]
+  set_property -dict [list \
+    CONFIG.NUM_MI {2} \
+    CONFIG.NUM_SI {1} \
+  ] $smartconnect_0
+
+
+  # Create interface connections
+  connect_bd_intf_net -intf_net S00_AXI_0_1 [get_bd_intf_ports s_axi_hbm] [get_bd_intf_pins smartconnect_0/S00_AXI]
+  connect_bd_intf_net -intf_net smartconnect_0_M00_AXI [get_bd_intf_pins smartconnect_0/M00_AXI] [get_bd_intf_pins hbm_0/SAXI_15_8HI]
+  connect_bd_intf_net -intf_net smartconnect_0_M01_AXI [get_bd_intf_pins smartconnect_0/M01_AXI] [get_bd_intf_pins hbm_0/SAXI_16_8HI]
+
+  # Create port connections
+  connect_bd_net -net aclk_0_1  [get_bd_ports axi_clk] \
+  [get_bd_pins smartconnect_0/aclk] \
+  [get_bd_pins hbm_0/AXI_15_ACLK] \
+  [get_bd_pins hbm_0/AXI_16_ACLK]
+  connect_bd_net -net clk_in1_0_1  [get_bd_ports hbm_ref_clk] \
+  [get_bd_pins clk_wiz_0/clk_in1]
+  connect_bd_net -net clk_wiz_0_clk_out1  [get_bd_pins clk_wiz_0/clk_out1] \
+  [get_bd_pins hbm_0/HBM_REF_CLK_0] \
+  [get_bd_pins hbm_0/HBM_REF_CLK_1] \
+  [get_bd_pins hbm_0/APB_0_PCLK] \
+  [get_bd_pins hbm_0/APB_1_PCLK] \
+  [get_bd_pins proc_sys_reset_0/slowest_sync_clk]
+  connect_bd_net -net clk_wiz_0_locked  [get_bd_pins clk_wiz_0/locked] \
+  [get_bd_pins proc_sys_reset_0/dcm_locked]
+  connect_bd_net -net proc_sys_reset_0_peripheral_aresetn  [get_bd_pins proc_sys_reset_0/peripheral_aresetn] \
+  [get_bd_pins hbm_0/APB_0_PRESET_N] \
+  [get_bd_pins hbm_0/APB_1_PRESET_N]
+  connect_bd_net -net qdma_0_axi_aresetn  [get_bd_ports axi_resetn] \
+  [get_bd_pins hbm_0/AXI_15_ARESET_N] \
+  [get_bd_pins hbm_0/AXI_16_ARESET_N] \
+  [get_bd_pins smartconnect_0/aresetn] \
+  [get_bd_pins clk_wiz_0/resetn] \
+  [get_bd_pins proc_sys_reset_0/ext_reset_in]
+
+  # Create address segments
+  assign_bd_address -offset 0x00000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM00] -force
+  assign_bd_address -offset 0x10000000 -range 0x10000000 -with_name SEG_hbm_0_HBM_MEM00_1 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM00] -force
+  assign_bd_address -offset 0x20000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM01] -force
+  assign_bd_address -offset 0x40000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM02] -force
+  assign_bd_address -offset 0x50000000 -range 0x10000000 -with_name SEG_hbm_0_HBM_MEM02_1 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM02] -force
+  assign_bd_address -offset 0x60000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM03] -force
+  assign_bd_address -offset 0x70000000 -range 0x10000000 -with_name SEG_hbm_0_HBM_MEM03_1 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM03] -force
+  assign_bd_address -offset 0x80000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM04] -force
+  assign_bd_address -offset 0x90000000 -range 0x10000000 -with_name SEG_hbm_0_HBM_MEM04_1 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM04] -force
+  assign_bd_address -offset 0xA0000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM05] -force
+  assign_bd_address -offset 0xB0000000 -range 0x10000000 -with_name SEG_hbm_0_HBM_MEM05_1 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM05] -force
+  assign_bd_address -offset 0xC0000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM06] -force
+  assign_bd_address -offset 0xD0000000 -range 0x10000000 -with_name SEG_hbm_0_HBM_MEM06_1 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM06] -force
+  assign_bd_address -offset 0xE0000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM07] -force
+  assign_bd_address -offset 0xF0000000 -range 0x10000000 -with_name SEG_hbm_0_HBM_MEM07_1 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM07] -force
+  assign_bd_address -offset 0x000100000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM08] -force
+  assign_bd_address -offset 0x000110000000 -range 0x10000000 -with_name SEG_hbm_0_HBM_MEM08_1 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM08] -force
+  assign_bd_address -offset 0x000120000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM09] -force
+  assign_bd_address -offset 0x000130000000 -range 0x10000000 -with_name SEG_hbm_0_HBM_MEM09_1 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM09] -force
+  assign_bd_address -offset 0x000140000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM10] -force
+  assign_bd_address -offset 0x000150000000 -range 0x10000000 -with_name SEG_hbm_0_HBM_MEM10_1 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM10] -force
+  assign_bd_address -offset 0x000160000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM11] -force
+  assign_bd_address -offset 0x000170000000 -range 0x10000000 -with_name SEG_hbm_0_HBM_MEM11_1 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM11] -force
+  assign_bd_address -offset 0x000180000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM12] -force
+  assign_bd_address -offset 0x000190000000 -range 0x10000000 -with_name SEG_hbm_0_HBM_MEM12_1 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM12] -force
+  assign_bd_address -offset 0x0001A0000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM13] -force
+  assign_bd_address -offset 0x0001B0000000 -range 0x10000000 -with_name SEG_hbm_0_HBM_MEM13_1 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM13] -force
+  assign_bd_address -offset 0x0001C0000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM14] -force
+  assign_bd_address -offset 0x0001D0000000 -range 0x10000000 -with_name SEG_hbm_0_HBM_MEM14_1 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM14] -force
+  assign_bd_address -offset 0x0001E0000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM15] -force
+  assign_bd_address -offset 0x0001F0000000 -range 0x10000000 -with_name SEG_hbm_0_HBM_MEM15_1 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM15] -force
+  assign_bd_address -offset 0x000200000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM16] -force
+  assign_bd_address -offset 0x000210000000 -range 0x10000000 -with_name SEG_hbm_0_HBM_MEM16_1 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM16] -force
+  assign_bd_address -offset 0x000220000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM17] -force
+  assign_bd_address -offset 0x000230000000 -range 0x10000000 -with_name SEG_hbm_0_HBM_MEM17_1 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM17] -force
+  assign_bd_address -offset 0x000240000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM18] -force
+  assign_bd_address -offset 0x000250000000 -range 0x10000000 -with_name SEG_hbm_0_HBM_MEM18_1 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM18] -force
+  assign_bd_address -offset 0x000260000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM19] -force
+  assign_bd_address -offset 0x000270000000 -range 0x10000000 -with_name SEG_hbm_0_HBM_MEM19_1 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM19] -force
+  assign_bd_address -offset 0x000280000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM20] -force
+  assign_bd_address -offset 0x000290000000 -range 0x10000000 -with_name SEG_hbm_0_HBM_MEM20_1 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM20] -force
+  assign_bd_address -offset 0x0002A0000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM21] -force
+  assign_bd_address -offset 0x0002B0000000 -range 0x10000000 -with_name SEG_hbm_0_HBM_MEM21_1 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM21] -force
+  assign_bd_address -offset 0x0002C0000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM22] -force
+  assign_bd_address -offset 0x0002D0000000 -range 0x10000000 -with_name SEG_hbm_0_HBM_MEM22_1 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM22] -force
+  assign_bd_address -offset 0x0002E0000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM23] -force
+  assign_bd_address -offset 0x0002F0000000 -range 0x10000000 -with_name SEG_hbm_0_HBM_MEM23_1 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM23] -force
+  assign_bd_address -offset 0x000300000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM24] -force
+  assign_bd_address -offset 0x000310000000 -range 0x10000000 -with_name SEG_hbm_0_HBM_MEM24_1 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM24] -force
+  assign_bd_address -offset 0x000320000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM25] -force
+  assign_bd_address -offset 0x000330000000 -range 0x10000000 -with_name SEG_hbm_0_HBM_MEM25_1 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM25] -force
+  assign_bd_address -offset 0x000340000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM26] -force
+  assign_bd_address -offset 0x000350000000 -range 0x10000000 -with_name SEG_hbm_0_HBM_MEM26_1 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM26] -force
+  assign_bd_address -offset 0x000360000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM27] -force
+  assign_bd_address -offset 0x000370000000 -range 0x10000000 -with_name SEG_hbm_0_HBM_MEM27_1 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM27] -force
+  assign_bd_address -offset 0x000380000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM28] -force
+  assign_bd_address -offset 0x000390000000 -range 0x10000000 -with_name SEG_hbm_0_HBM_MEM28_1 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM28] -force
+  assign_bd_address -offset 0x0003A0000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM29] -force
+  assign_bd_address -offset 0x0003B0000000 -range 0x10000000 -with_name SEG_hbm_0_HBM_MEM29_1 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM29] -force
+  assign_bd_address -offset 0x0003C0000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM30] -force
+  assign_bd_address -offset 0x0003D0000000 -range 0x10000000 -with_name SEG_hbm_0_HBM_MEM30_1 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM30] -force
+  assign_bd_address -offset 0x0003E0000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM31] -force
+  assign_bd_address -offset 0x0003F0000000 -range 0x10000000 -with_name SEG_hbm_0_HBM_MEM31_1 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM31] -force
+
+  # Exclude Address Segments
+  exclude_bd_addr_seg -offset 0x000420000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM01]
+
+
+  # Restore current instance
+  current_bd_instance $oldCurInst
+
+  save_bd_design
+}
+# End of create_root_design()
+
+
+##################################################################
+# MAIN FLOW
+##################################################################
+
+create_root_design ""
+
+
+common::send_gid_msg -ssname BD::TCL -id 2053 -severity "WARNING" "This Tcl script was generated from a block design that has not been validated. It is possible that design <$design_name> may result in errors during validation."
diff --git a/src/open_nic_shell.sv b/src/open_nic_shell.sv
index e2f6c3f..5a4c527 100644
--- a/src/open_nic_shell.sv
+++ b/src/open_nic_shell.sv
@@ -1,6 +1,6 @@
 // *************************************************************************
 //
-// Copyright 2020 Xilinx, Inc.
+// Copyright 2023 Xilinx, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -26,13 +26,6 @@ module open_nic_shell #(
   parameter int    NUM_QUEUE       = 512,
   parameter int    NUM_CMAC_PORT   = 1
 ) (
-`ifdef __synthesis__
-`ifdef __au280__
-  output                         hbm_cattrip, // Fix the CATTRIP issue for AU280 custom flow
-`elsif __au50__
-  output                         hbm_cattrip,
-`endif
-
   input                   [15:0] pcie_rxp,
   input                   [15:0] pcie_rxn,
   output                  [15:0] pcie_txp,
@@ -41,6 +34,15 @@ module open_nic_shell #(
   input                          pcie_refclk_n,
   input                          pcie_rstn,
 
+`ifdef __synthesis__
+`ifdef __au280__
+  output                         hbm_cattrip, // Fix the CATTRIP issue for AU280 custom flow
+`elsif __au50__
+  output                         hbm_cattrip,
+`elsif __au55c__
+  output                         hbm_cattrip,
+`endif
+
   input    [4*NUM_CMAC_PORT-1:0] qsfp_rxp,
   input    [4*NUM_CMAC_PORT-1:0] qsfp_rxn,
   output   [4*NUM_CMAC_PORT-1:0] qsfp_txp,
@@ -48,63 +50,6 @@ module open_nic_shell #(
   input      [NUM_CMAC_PORT-1:0] qsfp_refclk_p,
   input      [NUM_CMAC_PORT-1:0] qsfp_refclk_n
 `else // !`ifdef __synthesis__
-  input                          s_axil_sim_awvalid,
-  input                   [31:0] s_axil_sim_awaddr,
-  output                         s_axil_sim_awready,
-  input                          s_axil_sim_wvalid,
-  input                   [31:0] s_axil_sim_wdata,
-  output                         s_axil_sim_wready,
-  output                         s_axil_sim_bvalid,
-  output                   [1:0] s_axil_sim_bresp,
-  input                          s_axil_sim_bready,
-  input                          s_axil_sim_arvalid,
-  input                   [31:0] s_axil_sim_araddr,
-  output                         s_axil_sim_arready,
-  output                         s_axil_sim_rvalid,
-  output                  [31:0] s_axil_sim_rdata,
-  output                   [1:0] s_axil_sim_rresp,
-  input                          s_axil_sim_rready,
-
-  input                          s_axis_qdma_h2c_sim_tvalid,
-  input                  [511:0] s_axis_qdma_h2c_sim_tdata,
-  input                   [31:0] s_axis_qdma_h2c_sim_tcrc,
-  input                          s_axis_qdma_h2c_sim_tlast,
-  input                   [10:0] s_axis_qdma_h2c_sim_tuser_qid,
-  input                    [2:0] s_axis_qdma_h2c_sim_tuser_port_id,
-  input                          s_axis_qdma_h2c_sim_tuser_err,
-  input                   [31:0] s_axis_qdma_h2c_sim_tuser_mdata,
-  input                    [5:0] s_axis_qdma_h2c_sim_tuser_mty,
-  input                          s_axis_qdma_h2c_sim_tuser_zero_byte,
-  output                         s_axis_qdma_h2c_sim_tready,
-
-  output                         m_axis_qdma_c2h_sim_tvalid,
-  output                 [511:0] m_axis_qdma_c2h_sim_tdata,
-  output                  [31:0] m_axis_qdma_c2h_sim_tcrc,
-  output                         m_axis_qdma_c2h_sim_tlast,
-  output                         m_axis_qdma_c2h_sim_ctrl_marker,
-  output                   [2:0] m_axis_qdma_c2h_sim_ctrl_port_id,
-  output                   [6:0] m_axis_qdma_c2h_sim_ctrl_ecc,
-  output                  [15:0] m_axis_qdma_c2h_sim_ctrl_len,
-  output                  [10:0] m_axis_qdma_c2h_sim_ctrl_qid,
-  output                         m_axis_qdma_c2h_sim_ctrl_has_cmpt,
-  output                   [5:0] m_axis_qdma_c2h_sim_mty,
-  input                          m_axis_qdma_c2h_sim_tready,
-
-  output                         m_axis_qdma_cpl_sim_tvalid,
-  output                 [511:0] m_axis_qdma_cpl_sim_tdata,
-  output                   [1:0] m_axis_qdma_cpl_sim_size,
-  output                  [15:0] m_axis_qdma_cpl_sim_dpar,
-  output                  [10:0] m_axis_qdma_cpl_sim_ctrl_qid,
-  output                   [1:0] m_axis_qdma_cpl_sim_ctrl_cmpt_type,
-  output                  [15:0] m_axis_qdma_cpl_sim_ctrl_wait_pld_pkt_id,
-  output                   [2:0] m_axis_qdma_cpl_sim_ctrl_port_id,
-  output                         m_axis_qdma_cpl_sim_ctrl_marker,
-  output                         m_axis_qdma_cpl_sim_ctrl_user_trig,
-  output                   [2:0] m_axis_qdma_cpl_sim_ctrl_col_idx,
-  output                   [2:0] m_axis_qdma_cpl_sim_ctrl_err_idx,
-  output                         m_axis_qdma_cpl_sim_ctrl_no_wrb_marker,
-  input                          m_axis_qdma_cpl_sim_tready,
-
   output     [NUM_CMAC_PORT-1:0] m_axis_cmac_tx_sim_tvalid,
   output [512*NUM_CMAC_PORT-1:0] m_axis_cmac_tx_sim_tdata,
   output  [64*NUM_CMAC_PORT-1:0] m_axis_cmac_tx_sim_tkeep,
@@ -116,9 +61,7 @@ module open_nic_shell #(
   input  [512*NUM_CMAC_PORT-1:0] s_axis_cmac_rx_sim_tdata,
   input   [64*NUM_CMAC_PORT-1:0] s_axis_cmac_rx_sim_tkeep,
   input      [NUM_CMAC_PORT-1:0] s_axis_cmac_rx_sim_tlast,
-  input      [NUM_CMAC_PORT-1:0] s_axis_cmac_rx_sim_tuser_err,
-
-  input                          powerup_rstn
+  input      [NUM_CMAC_PORT-1:0] s_axis_cmac_rx_sim_tuser_err
 `endif
 );
 
@@ -146,31 +89,31 @@ module open_nic_shell #(
     end
   end
 
-`ifdef __synthesis__
-  wire         powerup_rstn;
-  wire         pcie_user_lnk_up;
-  wire         pcie_phy_ready;
+  logic         powerup_rstn;
+  logic         pcie_user_lnk_up;
+  logic         pcie_phy_ready;
 
   // BAR2-mapped master AXI-Lite feeding into system configuration block
-  wire         axil_pcie_awvalid;
-  wire  [31:0] axil_pcie_awaddr;
-  wire         axil_pcie_awready;
-  wire         axil_pcie_wvalid;
-  wire  [31:0] axil_pcie_wdata;
-  wire         axil_pcie_wready;
-  wire         axil_pcie_bvalid;
-  wire   [1:0] axil_pcie_bresp;
-  wire         axil_pcie_bready;
-  wire         axil_pcie_arvalid;
-  wire  [31:0] axil_pcie_araddr;
-  wire         axil_pcie_arready;
-  wire         axil_pcie_rvalid;
-  wire  [31:0] axil_pcie_rdata;
-  wire   [1:0] axil_pcie_rresp;
-  wire         axil_pcie_rready;
+  logic         axil_pcie_awvalid;
+  logic  [31:0] axil_pcie_awaddr;
+  logic         axil_pcie_awready;
+  logic         axil_pcie_wvalid;
+  logic  [31:0] axil_pcie_wdata;
+  logic         axil_pcie_wready;
+  logic         axil_pcie_bvalid;
+  logic   [1:0] axil_pcie_bresp;
+  logic         axil_pcie_bready;
+  logic         axil_pcie_arvalid;
+  logic  [31:0] axil_pcie_araddr;
+  logic         axil_pcie_arready;
+  logic         axil_pcie_rvalid;
+  logic  [31:0] axil_pcie_rdata;
+  logic   [1:0] axil_pcie_rresp;
+  logic         axil_pcie_rready;
 
   IBUF pcie_rstn_ibuf_inst (.I(pcie_rstn), .O(pcie_rstn_int));
 
+`ifdef __synthesis__
 `ifdef __au280__
   // Fix the CATTRIP issue for AU280 custom flow
   //
@@ -180,6 +123,9 @@ module open_nic_shell #(
 `elsif __au50__
   // Same for AU50
   OBUF hbm_cattrip_obuf_inst (.I(1'b0), .O(hbm_cattrip));
+`elsif __au55c__
+  // Same for AU55C
+  OBUF hbm_cattrip_obuf_inst (.I(1'b0), .O(hbm_cattrip));
 `endif
 
 `ifdef __zynq_family__
@@ -187,187 +133,730 @@ module open_nic_shell #(
 `endif
 `endif
 
-  wire                         axil_qdma_awvalid;
-  wire                  [31:0] axil_qdma_awaddr;
-  wire                         axil_qdma_awready;
-  wire                         axil_qdma_wvalid;
-  wire                  [31:0] axil_qdma_wdata;
-  wire                         axil_qdma_wready;
-  wire                         axil_qdma_bvalid;
-  wire                   [1:0] axil_qdma_bresp;
-  wire                         axil_qdma_bready;
-  wire                         axil_qdma_arvalid;
-  wire                  [31:0] axil_qdma_araddr;
-  wire                         axil_qdma_arready;
-  wire                         axil_qdma_rvalid;
-  wire                  [31:0] axil_qdma_rdata;
-  wire                   [1:0] axil_qdma_rresp;
-  wire                         axil_qdma_rready;
-
-  wire     [NUM_CMAC_PORT-1:0] axil_adap_awvalid;
-  wire  [32*NUM_CMAC_PORT-1:0] axil_adap_awaddr;
-  wire     [NUM_CMAC_PORT-1:0] axil_adap_awready;
-  wire     [NUM_CMAC_PORT-1:0] axil_adap_wvalid;
-  wire  [32*NUM_CMAC_PORT-1:0] axil_adap_wdata;
-  wire     [NUM_CMAC_PORT-1:0] axil_adap_wready;
-  wire     [NUM_CMAC_PORT-1:0] axil_adap_bvalid;
-  wire   [2*NUM_CMAC_PORT-1:0] axil_adap_bresp;
-  wire     [NUM_CMAC_PORT-1:0] axil_adap_bready;
-  wire     [NUM_CMAC_PORT-1:0] axil_adap_arvalid;
-  wire  [32*NUM_CMAC_PORT-1:0] axil_adap_araddr;
-  wire     [NUM_CMAC_PORT-1:0] axil_adap_arready;
-  wire     [NUM_CMAC_PORT-1:0] axil_adap_rvalid;
-  wire  [32*NUM_CMAC_PORT-1:0] axil_adap_rdata;
-  wire   [2*NUM_CMAC_PORT-1:0] axil_adap_rresp;
-  wire     [NUM_CMAC_PORT-1:0] axil_adap_rready;
-
-  wire     [NUM_CMAC_PORT-1:0] axil_cmac_awvalid;
-  wire  [32*NUM_CMAC_PORT-1:0] axil_cmac_awaddr;
-  wire     [NUM_CMAC_PORT-1:0] axil_cmac_awready;
-  wire     [NUM_CMAC_PORT-1:0] axil_cmac_wvalid;
-  wire  [32*NUM_CMAC_PORT-1:0] axil_cmac_wdata;
-  wire     [NUM_CMAC_PORT-1:0] axil_cmac_wready;
-  wire     [NUM_CMAC_PORT-1:0] axil_cmac_bvalid;
-  wire   [2*NUM_CMAC_PORT-1:0] axil_cmac_bresp;
-  wire     [NUM_CMAC_PORT-1:0] axil_cmac_bready;
-  wire     [NUM_CMAC_PORT-1:0] axil_cmac_arvalid;
-  wire  [32*NUM_CMAC_PORT-1:0] axil_cmac_araddr;
-  wire     [NUM_CMAC_PORT-1:0] axil_cmac_arready;
-  wire     [NUM_CMAC_PORT-1:0] axil_cmac_rvalid;
-  wire  [32*NUM_CMAC_PORT-1:0] axil_cmac_rdata;
-  wire   [2*NUM_CMAC_PORT-1:0] axil_cmac_rresp;
-  wire     [NUM_CMAC_PORT-1:0] axil_cmac_rready;
-
-  wire                         axil_box0_awvalid;
-  wire                  [31:0] axil_box0_awaddr;
-  wire                         axil_box0_awready;
-  wire                         axil_box0_wvalid;
-  wire                  [31:0] axil_box0_wdata;
-  wire                         axil_box0_wready;
-  wire                         axil_box0_bvalid;
-  wire                   [1:0] axil_box0_bresp;
-  wire                         axil_box0_bready;
-  wire                         axil_box0_arvalid;
-  wire                  [31:0] axil_box0_araddr;
-  wire                         axil_box0_arready;
-  wire                         axil_box0_rvalid;
-  wire                  [31:0] axil_box0_rdata;
-  wire                   [1:0] axil_box0_rresp;
-  wire                         axil_box0_rready;
-
-  wire                         axil_box1_awvalid;
-  wire                  [31:0] axil_box1_awaddr;
-  wire                         axil_box1_awready;
-  wire                         axil_box1_wvalid;
-  wire                  [31:0] axil_box1_wdata;
-  wire                         axil_box1_wready;
-  wire                         axil_box1_bvalid;
-  wire                   [1:0] axil_box1_bresp;
-  wire                         axil_box1_bready;
-  wire                         axil_box1_arvalid;
-  wire                  [31:0] axil_box1_araddr;
-  wire                         axil_box1_arready;
-  wire                         axil_box1_rvalid;
-  wire                  [31:0] axil_box1_rdata;
-  wire                   [1:0] axil_box1_rresp;
-  wire                         axil_box1_rready;
+  logic                         axil_qdma_awvalid;
+  logic                  [31:0] axil_qdma_awaddr;
+  logic                         axil_qdma_awready;
+  logic                         axil_qdma_wvalid;
+  logic                  [31:0] axil_qdma_wdata;
+  logic                         axil_qdma_wready;
+  logic                         axil_qdma_bvalid;
+  logic                   [1:0] axil_qdma_bresp;
+  logic                         axil_qdma_bready;
+  logic                         axil_qdma_arvalid;
+  logic                  [31:0] axil_qdma_araddr;
+  logic                         axil_qdma_arready;
+  logic                         axil_qdma_rvalid;
+  logic                  [31:0] axil_qdma_rdata;
+  logic                   [1:0] axil_qdma_rresp;
+  logic                         axil_qdma_rready;
+
+  logic                         axi_qdma_mm_awready;
+  logic                         axi_qdma_mm_wready;
+  logic                   [3:0] axi_qdma_mm_bid;
+  logic                   [1:0] axi_qdma_mm_bresp;
+  logic                         axi_qdma_mm_bvalid;
+  logic                         axi_qdma_mm_arready;
+  logic                   [3:0] axi_qdma_mm_rid;
+  logic                 [511:0] axi_qdma_mm_rdata;
+  logic                   [1:0] axi_qdma_mm_rresp;
+  logic                         axi_qdma_mm_rlast;
+  logic                         axi_qdma_mm_rvalid;
+  logic                   [3:0] axi_qdma_mm_awid;
+  logic                  [63:0] axi_qdma_mm_awaddr;
+  logic                  [31:0] axi_qdma_mm_awuser;
+  logic                   [7:0] axi_qdma_mm_awlen;
+  logic                   [2:0] axi_qdma_mm_awsize;
+  logic                   [1:0] axi_qdma_mm_awburst;
+  logic                   [2:0] axi_qdma_mm_awprot;
+  logic                         axi_qdma_mm_awvalid;
+  logic                         axi_qdma_mm_awlock;
+  logic                   [3:0] axi_qdma_mm_awcache;
+  logic                 [511:0] axi_qdma_mm_wdata;
+  logic                  [63:0] axi_qdma_mm_wuser;
+  logic                  [63:0] axi_qdma_mm_wstrb;
+  logic                         axi_qdma_mm_wlast;
+  logic                         axi_qdma_mm_wvalid;
+  logic                         axi_qdma_mm_bready;
+  logic                   [3:0] axi_qdma_mm_arid;
+  logic                  [63:0] axi_qdma_mm_araddr;
+  logic                  [31:0] axi_qdma_mm_aruser;
+  logic                   [7:0] axi_qdma_mm_arlen;
+  logic                   [2:0] axi_qdma_mm_arsize;
+  logic                   [1:0] axi_qdma_mm_arburst;
+  logic                   [2:0] axi_qdma_mm_arprot;
+  logic                         axi_qdma_mm_arvalid;
+  logic                         axi_qdma_mm_arlock;
+  logic                   [3:0] axi_qdma_mm_arcache;
+  logic                         axi_qdma_mm_rready;
+
+  // QDMA control/status register interface
+  logic                         qdma_csr_prog_done;
+  logic                  [31:0] axil_qdma_csr_awaddr;
+  logic                         axil_qdma_csr_awvalid;
+  logic                         axil_qdma_csr_awready;
+  logic                  [31:0] axil_qdma_csr_wdata;
+  logic                         axil_qdma_csr_wvalid;
+  logic                         axil_qdma_csr_wready;
+  logic                         axil_qdma_csr_bvalid;
+  logic                   [1:0] axil_qdma_csr_bresp;
+  logic                         axil_qdma_csr_bready;
+  logic                  [31:0] axil_qdma_csr_araddr;
+  logic                         axil_qdma_csr_arvalid;
+  logic                         axil_qdma_csr_arready;
+  logic                  [31:0] axil_qdma_csr_rdata;
+  logic                   [1:0] axil_qdma_csr_rresp;
+  logic                         axil_qdma_csr_rvalid;
+  logic                         axil_qdma_csr_rready;
+
+  logic     [NUM_CMAC_PORT-1:0] axil_adap_awvalid;
+  logic  [32*NUM_CMAC_PORT-1:0] axil_adap_awaddr;
+  logic     [NUM_CMAC_PORT-1:0] axil_adap_awready;
+  logic     [NUM_CMAC_PORT-1:0] axil_adap_wvalid;
+  logic  [32*NUM_CMAC_PORT-1:0] axil_adap_wdata;
+  logic     [NUM_CMAC_PORT-1:0] axil_adap_wready;
+  logic     [NUM_CMAC_PORT-1:0] axil_adap_bvalid;
+  logic   [2*NUM_CMAC_PORT-1:0] axil_adap_bresp;
+  logic     [NUM_CMAC_PORT-1:0] axil_adap_bready;
+  logic     [NUM_CMAC_PORT-1:0] axil_adap_arvalid;
+  logic  [32*NUM_CMAC_PORT-1:0] axil_adap_araddr;
+  logic     [NUM_CMAC_PORT-1:0] axil_adap_arready;
+  logic     [NUM_CMAC_PORT-1:0] axil_adap_rvalid;
+  logic  [32*NUM_CMAC_PORT-1:0] axil_adap_rdata;
+  logic   [2*NUM_CMAC_PORT-1:0] axil_adap_rresp;
+  logic     [NUM_CMAC_PORT-1:0] axil_adap_rready;
+
+  logic     [NUM_CMAC_PORT-1:0] axil_cmac_awvalid;
+  logic  [32*NUM_CMAC_PORT-1:0] axil_cmac_awaddr;
+  logic     [NUM_CMAC_PORT-1:0] axil_cmac_awready;
+  logic     [NUM_CMAC_PORT-1:0] axil_cmac_wvalid;
+  logic  [32*NUM_CMAC_PORT-1:0] axil_cmac_wdata;
+  logic     [NUM_CMAC_PORT-1:0] axil_cmac_wready;
+  logic     [NUM_CMAC_PORT-1:0] axil_cmac_bvalid;
+  logic   [2*NUM_CMAC_PORT-1:0] axil_cmac_bresp;
+  logic     [NUM_CMAC_PORT-1:0] axil_cmac_bready;
+  logic     [NUM_CMAC_PORT-1:0] axil_cmac_arvalid;
+  logic  [32*NUM_CMAC_PORT-1:0] axil_cmac_araddr;
+  logic     [NUM_CMAC_PORT-1:0] axil_cmac_arready;
+  logic     [NUM_CMAC_PORT-1:0] axil_cmac_rvalid;
+  logic  [32*NUM_CMAC_PORT-1:0] axil_cmac_rdata;
+  logic   [2*NUM_CMAC_PORT-1:0] axil_cmac_rresp;
+  logic     [NUM_CMAC_PORT-1:0] axil_cmac_rready;
+
+  // AXIL interface to the RDMA engine
+  logic                         axil_rdma_awvalid;
+  logic                  [31:0] axil_rdma_awaddr;
+  logic                         axil_rdma_awready;
+  logic                         axil_rdma_wvalid;
+  logic                  [31:0] axil_rdma_wdata;
+  logic                         axil_rdma_wready;
+  logic                         axil_rdma_bvalid;
+  logic                   [1:0] axil_rdma_bresp;
+  logic                         axil_rdma_bready;
+  logic                         axil_rdma_arvalid;
+  logic                  [31:0] axil_rdma_araddr;
+  logic                         axil_rdma_arready;
+  logic                         axil_rdma_rvalid;
+  logic                  [31:0] axil_rdma_rdata;
+  logic                   [1:0] axil_rdma_rresp;
+  logic                         axil_rdma_rready;
+
+  logic                         axil_box0_awvalid;
+  logic                  [31:0] axil_box0_awaddr;
+  logic                         axil_box0_awready;
+  logic                         axil_box0_wvalid;
+  logic                  [31:0] axil_box0_wdata;
+  logic                         axil_box0_wready;
+  logic                         axil_box0_bvalid;
+  logic                   [1:0] axil_box0_bresp;
+  logic                         axil_box0_bready;
+  logic                         axil_box0_arvalid;
+  logic                  [31:0] axil_box0_araddr;
+  logic                         axil_box0_arready;
+  logic                         axil_box0_rvalid;
+  logic                  [31:0] axil_box0_rdata;
+  logic                   [1:0] axil_box0_rresp;
+  logic                         axil_box0_rready;
+
+  logic                         axil_box1_awvalid;
+  logic                  [31:0] axil_box1_awaddr;
+  logic                         axil_box1_awready;
+  logic                         axil_box1_wvalid;
+  logic                  [31:0] axil_box1_wdata;
+  logic                         axil_box1_wready;
+  logic                         axil_box1_bvalid;
+  logic                   [1:0] axil_box1_bresp;
+  logic                         axil_box1_bready;
+  logic                         axil_box1_arvalid;
+  logic                  [31:0] axil_box1_araddr;
+  logic                         axil_box1_arready;
+  logic                         axil_box1_rvalid;
+  logic                  [31:0] axil_box1_rdata;
+  logic                   [1:0] axil_box1_rresp;
+  logic                         axil_box1_rready;
 
   // QDMA subsystem interfaces to the box running at 250MHz
-  wire     [NUM_PHYS_FUNC-1:0] axis_qdma_h2c_tvalid;
-  wire [512*NUM_PHYS_FUNC-1:0] axis_qdma_h2c_tdata;
-  wire  [64*NUM_PHYS_FUNC-1:0] axis_qdma_h2c_tkeep;
-  wire     [NUM_PHYS_FUNC-1:0] axis_qdma_h2c_tlast;
-  wire  [16*NUM_PHYS_FUNC-1:0] axis_qdma_h2c_tuser_size;
-  wire  [16*NUM_PHYS_FUNC-1:0] axis_qdma_h2c_tuser_src;
-  wire  [16*NUM_PHYS_FUNC-1:0] axis_qdma_h2c_tuser_dst;
-  wire     [NUM_PHYS_FUNC-1:0] axis_qdma_h2c_tready;
-
-  wire     [NUM_PHYS_FUNC-1:0] axis_qdma_c2h_tvalid;
-  wire [512*NUM_PHYS_FUNC-1:0] axis_qdma_c2h_tdata;
-  wire  [64*NUM_PHYS_FUNC-1:0] axis_qdma_c2h_tkeep;
-  wire     [NUM_PHYS_FUNC-1:0] axis_qdma_c2h_tlast;
-  wire  [16*NUM_PHYS_FUNC-1:0] axis_qdma_c2h_tuser_size;
-  wire  [16*NUM_PHYS_FUNC-1:0] axis_qdma_c2h_tuser_src;
-  wire  [16*NUM_PHYS_FUNC-1:0] axis_qdma_c2h_tuser_dst;
-  wire     [NUM_PHYS_FUNC-1:0] axis_qdma_c2h_tready;
+  logic     [NUM_PHYS_FUNC-1:0] axis_qdma_h2c_tvalid;
+  logic [512*NUM_PHYS_FUNC-1:0] axis_qdma_h2c_tdata;
+  logic  [64*NUM_PHYS_FUNC-1:0] axis_qdma_h2c_tkeep;
+  logic     [NUM_PHYS_FUNC-1:0] axis_qdma_h2c_tlast;
+  logic  [16*NUM_PHYS_FUNC-1:0] axis_qdma_h2c_tuser_size;
+  logic  [16*NUM_PHYS_FUNC-1:0] axis_qdma_h2c_tuser_src;
+  logic  [16*NUM_PHYS_FUNC-1:0] axis_qdma_h2c_tuser_dst;
+  logic     [NUM_PHYS_FUNC-1:0] axis_qdma_h2c_tready;
+  logic     [NUM_PHYS_FUNC-1:0] axis_qdma_c2h_tvalid;
+  logic [512*NUM_PHYS_FUNC-1:0] axis_qdma_c2h_tdata;
+  logic  [64*NUM_PHYS_FUNC-1:0] axis_qdma_c2h_tkeep;
+  logic     [NUM_PHYS_FUNC-1:0] axis_qdma_c2h_tlast;
+  logic  [16*NUM_PHYS_FUNC-1:0] axis_qdma_c2h_tuser_size;
+  logic  [16*NUM_PHYS_FUNC-1:0] axis_qdma_c2h_tuser_src;
+  logic  [16*NUM_PHYS_FUNC-1:0] axis_qdma_c2h_tuser_dst;
+  logic     [NUM_PHYS_FUNC-1:0] axis_qdma_c2h_tready;
 
   // Packet adapter interfaces to the box running at 250MHz
-  wire     [NUM_CMAC_PORT-1:0] axis_adap_tx_250mhz_tvalid;
-  wire [512*NUM_CMAC_PORT-1:0] axis_adap_tx_250mhz_tdata;
-  wire  [64*NUM_CMAC_PORT-1:0] axis_adap_tx_250mhz_tkeep;
-  wire     [NUM_CMAC_PORT-1:0] axis_adap_tx_250mhz_tlast;
-  wire  [16*NUM_CMAC_PORT-1:0] axis_adap_tx_250mhz_tuser_size;
-  wire  [16*NUM_CMAC_PORT-1:0] axis_adap_tx_250mhz_tuser_src;
-  wire  [16*NUM_CMAC_PORT-1:0] axis_adap_tx_250mhz_tuser_dst;
-  wire     [NUM_CMAC_PORT-1:0] axis_adap_tx_250mhz_tready;
-
-  wire     [NUM_CMAC_PORT-1:0] axis_adap_rx_250mhz_tvalid;
-  wire [512*NUM_CMAC_PORT-1:0] axis_adap_rx_250mhz_tdata;
-  wire  [64*NUM_CMAC_PORT-1:0] axis_adap_rx_250mhz_tkeep;
-  wire     [NUM_CMAC_PORT-1:0] axis_adap_rx_250mhz_tlast;
-  wire  [16*NUM_CMAC_PORT-1:0] axis_adap_rx_250mhz_tuser_size;
-  wire  [16*NUM_CMAC_PORT-1:0] axis_adap_rx_250mhz_tuser_src;
-  wire  [16*NUM_CMAC_PORT-1:0] axis_adap_rx_250mhz_tuser_dst;
-  wire     [NUM_CMAC_PORT-1:0] axis_adap_rx_250mhz_tready;
+  logic     [NUM_CMAC_PORT-1:0] axis_adap_tx_250mhz_tvalid;
+  logic [512*NUM_CMAC_PORT-1:0] axis_adap_tx_250mhz_tdata;
+  logic  [64*NUM_CMAC_PORT-1:0] axis_adap_tx_250mhz_tkeep;
+  logic     [NUM_CMAC_PORT-1:0] axis_adap_tx_250mhz_tlast;
+  logic  [16*NUM_CMAC_PORT-1:0] axis_adap_tx_250mhz_tuser_size;
+  logic  [16*NUM_CMAC_PORT-1:0] axis_adap_tx_250mhz_tuser_src;
+  logic  [16*NUM_CMAC_PORT-1:0] axis_adap_tx_250mhz_tuser_dst;
+  logic     [NUM_CMAC_PORT-1:0] axis_adap_tx_250mhz_tready;
+
+  logic     [NUM_CMAC_PORT-1:0] axis_adap_rx_250mhz_tvalid;
+  logic [512*NUM_CMAC_PORT-1:0] axis_adap_rx_250mhz_tdata;
+  logic  [64*NUM_CMAC_PORT-1:0] axis_adap_rx_250mhz_tkeep;
+  logic     [NUM_CMAC_PORT-1:0] axis_adap_rx_250mhz_tlast;
+  logic  [16*NUM_CMAC_PORT-1:0] axis_adap_rx_250mhz_tuser_size;
+  logic  [16*NUM_CMAC_PORT-1:0] axis_adap_rx_250mhz_tuser_src;
+  logic  [16*NUM_CMAC_PORT-1:0] axis_adap_rx_250mhz_tuser_dst;
+  logic     [NUM_CMAC_PORT-1:0] axis_adap_rx_250mhz_tready;
 
   // Packet adapter interfaces to the box running at 322MHz
-  wire     [NUM_CMAC_PORT-1:0] axis_adap_tx_322mhz_tvalid;
-  wire [512*NUM_CMAC_PORT-1:0] axis_adap_tx_322mhz_tdata;
-  wire  [64*NUM_CMAC_PORT-1:0] axis_adap_tx_322mhz_tkeep;
-  wire     [NUM_CMAC_PORT-1:0] axis_adap_tx_322mhz_tlast;
-  wire     [NUM_CMAC_PORT-1:0] axis_adap_tx_322mhz_tuser_err;
-  wire     [NUM_CMAC_PORT-1:0] axis_adap_tx_322mhz_tready;
-
-  wire     [NUM_CMAC_PORT-1:0] axis_adap_rx_322mhz_tvalid;
-  wire [512*NUM_CMAC_PORT-1:0] axis_adap_rx_322mhz_tdata;
-  wire  [64*NUM_CMAC_PORT-1:0] axis_adap_rx_322mhz_tkeep;
-  wire     [NUM_CMAC_PORT-1:0] axis_adap_rx_322mhz_tlast;
-  wire     [NUM_CMAC_PORT-1:0] axis_adap_rx_322mhz_tuser_err;
+  logic     [NUM_CMAC_PORT-1:0] axis_adap_tx_322mhz_tvalid;
+  logic [512*NUM_CMAC_PORT-1:0] axis_adap_tx_322mhz_tdata;
+  logic  [64*NUM_CMAC_PORT-1:0] axis_adap_tx_322mhz_tkeep;
+  logic     [NUM_CMAC_PORT-1:0] axis_adap_tx_322mhz_tlast;
+  logic     [NUM_CMAC_PORT-1:0] axis_adap_tx_322mhz_tuser_err;
+  logic     [NUM_CMAC_PORT-1:0] axis_adap_tx_322mhz_tready;
+
+  logic     [NUM_CMAC_PORT-1:0] axis_adap_rx_322mhz_tvalid;
+  logic [512*NUM_CMAC_PORT-1:0] axis_adap_rx_322mhz_tdata;
+  logic  [64*NUM_CMAC_PORT-1:0] axis_adap_rx_322mhz_tkeep;
+  logic     [NUM_CMAC_PORT-1:0] axis_adap_rx_322mhz_tlast;
+  logic     [NUM_CMAC_PORT-1:0] axis_adap_rx_322mhz_tuser_err;
 
   // CMAC subsystem interfaces to the box running at 322MHz
-  wire     [NUM_CMAC_PORT-1:0] axis_cmac_tx_tvalid;
-  wire [512*NUM_CMAC_PORT-1:0] axis_cmac_tx_tdata;
-  wire  [64*NUM_CMAC_PORT-1:0] axis_cmac_tx_tkeep;
-  wire     [NUM_CMAC_PORT-1:0] axis_cmac_tx_tlast;
-  wire     [NUM_CMAC_PORT-1:0] axis_cmac_tx_tuser_err;
-  wire     [NUM_CMAC_PORT-1:0] axis_cmac_tx_tready;
-
-  wire     [NUM_CMAC_PORT-1:0] axis_cmac_rx_tvalid;
-  wire [512*NUM_CMAC_PORT-1:0] axis_cmac_rx_tdata;
-  wire  [64*NUM_CMAC_PORT-1:0] axis_cmac_rx_tkeep;
-  wire     [NUM_CMAC_PORT-1:0] axis_cmac_rx_tlast;
-  wire     [NUM_CMAC_PORT-1:0] axis_cmac_rx_tuser_err;
-
-  wire                  [31:0] shell_rstn;
-  wire                  [31:0] shell_rst_done;
-  wire                         qdma_rstn;
-  wire                         qdma_rst_done;
-  wire     [NUM_CMAC_PORT-1:0] adap_rstn;
-  wire     [NUM_CMAC_PORT-1:0] adap_rst_done;
-  wire     [NUM_CMAC_PORT-1:0] cmac_rstn;
-  wire     [NUM_CMAC_PORT-1:0] cmac_rst_done;
-
-  wire                  [31:0] user_rstn;
-  wire                  [31:0] user_rst_done;
-  wire                  [15:0] user_250mhz_rstn;
-  wire                  [15:0] user_250mhz_rst_done;
-  wire                   [7:0] user_322mhz_rstn;
-  wire                   [7:0] user_322mhz_rst_done;
-  wire                         box_250mhz_rstn;
-  wire                         box_250mhz_rst_done;
-  wire                         box_322mhz_rstn;
-  wire                         box_322mhz_rst_done;
-
-  wire                         axil_aclk;
-  wire                         axis_aclk;
-  wire     [NUM_CMAC_PORT-1:0] cmac_clk;
+  logic     [NUM_CMAC_PORT-1:0] axis_cmac_tx_tvalid;
+  logic [512*NUM_CMAC_PORT-1:0] axis_cmac_tx_tdata;
+  logic  [64*NUM_CMAC_PORT-1:0] axis_cmac_tx_tkeep;
+  logic     [NUM_CMAC_PORT-1:0] axis_cmac_tx_tlast;
+  logic     [NUM_CMAC_PORT-1:0] axis_cmac_tx_tuser_err;
+  logic     [NUM_CMAC_PORT-1:0] axis_cmac_tx_tready;
+
+  logic     [NUM_CMAC_PORT-1:0] axis_cmac_rx_tvalid;
+  logic [512*NUM_CMAC_PORT-1:0] axis_cmac_rx_tdata;
+  logic  [64*NUM_CMAC_PORT-1:0] axis_cmac_rx_tkeep;
+  logic     [NUM_CMAC_PORT-1:0] axis_cmac_rx_tlast;
+  logic     [NUM_CMAC_PORT-1:0] axis_cmac_rx_tuser_err;
+
+  // RDMA TX interface (including roce and non-roce packets) to CMAC TX path
+  logic [511:0] rdma2cmac_axis_tdata;
+  logic  [63:0] rdma2cmac_axis_tkeep;
+  logic         rdma2cmac_axis_tvalid;
+  logic         rdma2cmac_axis_tlast;
+  logic         rdma2cmac_axis_tready;
+
+  // Non-RDMA packets from QDMA TX bypassing RDMA TX
+  logic [511:0] qdma2rdma_non_roce_axis_tdata;
+  logic  [63:0] qdma2rdma_non_roce_axis_tkeep;
+  logic         qdma2rdma_non_roce_axis_tvalid;
+  logic         qdma2rdma_non_roce_axis_tlast;
+  logic         qdma2rdma_non_roce_axis_tready;
+
+  // RDMA RX interface from CMAC RX, no rx backpressure
+  logic [511:0] cmac2rdma_roce_axis_tdata;
+  logic  [63:0] cmac2rdma_roce_axis_tkeep;
+  logic         cmac2rdma_roce_axis_tvalid;
+  logic         cmac2rdma_roce_axis_tlast;
+  logic         cmac2rdma_roce_axis_tuser;
+  logic         cmac2rdma_roce_axis_tready;
+
+  // invalidate or immediate data from roce IETH/IMMDT header
+  logic  [63:0] rdma2user_ieth_immdt_axis_tdata;
+  logic         rdma2user_ieth_immdt_axis_tlast;
+  logic         rdma2user_ieth_immdt_axis_tvalid;
+  logic         rdma2user_ieth_immdt_axis_trdy;
+
+  // Send WQE completion queue doorbell
+  logic         resp_hndler_o_send_cq_db_cnt_valid;
+  logic   [9:0] resp_hndler_o_send_cq_db_addr;
+  logic  [31:0] resp_hndler_o_send_cq_db_cnt;
+  logic         resp_hndler_i_send_cq_db_rdy;
+
+  // Send WQE producer index doorbell
+  logic  [15:0] i_qp_sq_pidb_hndshk;
+  logic  [31:0] i_qp_sq_pidb_wr_addr_hndshk;
+  logic         i_qp_sq_pidb_wr_valid_hndshk;
+  logic         o_qp_sq_pidb_wr_rdy;
+
+  // RDMA-Send consumer index doorbell
+  logic  [15:0] i_qp_rq_cidb_hndshk;
+  logic  [31:0] i_qp_rq_cidb_wr_addr_hndshk;
+  logic         i_qp_rq_cidb_wr_valid_hndshk;
+  logic         o_qp_rq_cidb_wr_rdy;
+
+  // RDMA-Send producer index doorbell
+  logic  [31:0] rx_pkt_hndler_o_rq_db_data;
+  logic   [9:0] rx_pkt_hndler_o_rq_db_addr;
+  logic         rx_pkt_hndler_o_rq_db_data_valid;
+  logic         rx_pkt_hndler_i_rq_db_rdy;
+
+  logic         rdma_intr;
+
+  // RDMA AXI MM interface used to store payload from RDMA MAD, Send or Write operation
+  logic           axi_rdma_send_write_payload_awid;
+  logic  [63 : 0] axi_rdma_send_write_payload_awaddr;
+  logic  [31 : 0] axi_rdma_send_write_payload_awuser;
+  logic   [3 : 0] axi_rdma_send_write_payload_awqos;
+  logic   [7 : 0] axi_rdma_send_write_payload_awlen;
+  logic   [2 : 0] axi_rdma_send_write_payload_awsize;
+  logic   [1 : 0] axi_rdma_send_write_payload_awburst;
+  logic   [3 : 0] axi_rdma_send_write_payload_awcache;
+  logic   [2 : 0] axi_rdma_send_write_payload_awprot;
+  logic           axi_rdma_send_write_payload_awvalid;
+  logic           axi_rdma_send_write_payload_awready;
+  logic [511 : 0] axi_rdma_send_write_payload_wdata;
+  logic  [63 : 0] axi_rdma_send_write_payload_wstrb;
+  logic           axi_rdma_send_write_payload_wlast;
+  logic           axi_rdma_send_write_payload_wvalid;
+  logic           axi_rdma_send_write_payload_wready;
+  logic           axi_rdma_send_write_payload_awlock;
+  logic           axi_rdma_send_write_payload_bid;
+  logic   [1 : 0] axi_rdma_send_write_payload_bresp;
+  logic           axi_rdma_send_write_payload_bvalid;
+  logic           axi_rdma_send_write_payload_bready;
+  logic           axi_rdma_send_write_payload_arid;
+  logic  [63 : 0] axi_rdma_send_write_payload_araddr;
+  logic   [7 : 0] axi_rdma_send_write_payload_arlen;
+  logic   [2 : 0] axi_rdma_send_write_payload_arsize;
+  logic   [1 : 0] axi_rdma_send_write_payload_arburst;
+  logic   [3 : 0] axi_rdma_send_write_payload_arcache;
+  logic   [2 : 0] axi_rdma_send_write_payload_arprot;
+  logic           axi_rdma_send_write_payload_arvalid;
+  logic           axi_rdma_send_write_payload_arready;
+  logic           axi_rdma_send_write_payload_rid;
+  logic [511 : 0] axi_rdma_send_write_payload_rdata;
+  logic   [1 : 0] axi_rdma_send_write_payload_rresp;
+  logic           axi_rdma_send_write_payload_rlast;
+  logic           axi_rdma_send_write_payload_rvalid;
+  logic           axi_rdma_send_write_payload_rready;
+  logic           axi_rdma_send_write_payload_arlock;
+  logic     [3:0] axi_rdma_send_write_payload_arqos;
+
+  // RDMA AXI MM interface used to store payload from RDMA Read response operation
+  logic           axi_rdma_rsp_payload_awid;
+  logic  [63 : 0] axi_rdma_rsp_payload_awaddr;
+  logic   [3 : 0] axi_rdma_rsp_payload_awqos;
+  logic   [7 : 0] axi_rdma_rsp_payload_awlen;
+  logic   [2 : 0] axi_rdma_rsp_payload_awsize;
+  logic   [1 : 0] axi_rdma_rsp_payload_awburst;
+  logic   [3 : 0] axi_rdma_rsp_payload_awcache;
+  logic   [2 : 0] axi_rdma_rsp_payload_awprot;
+  logic           axi_rdma_rsp_payload_awvalid;
+  logic           axi_rdma_rsp_payload_awready;
+  logic [511 : 0] axi_rdma_rsp_payload_wdata;
+  logic  [63 : 0] axi_rdma_rsp_payload_wstrb;
+  logic           axi_rdma_rsp_payload_wlast;
+  logic           axi_rdma_rsp_payload_wvalid;
+  logic           axi_rdma_rsp_payload_wready;
+  logic           axi_rdma_rsp_payload_awlock;
+  logic           axi_rdma_rsp_payload_bid;
+  logic   [1 : 0] axi_rdma_rsp_payload_bresp;
+  logic           axi_rdma_rsp_payload_bvalid;
+  logic           axi_rdma_rsp_payload_bready;
+  logic           axi_rdma_rsp_payload_arid;
+  logic  [63 : 0] axi_rdma_rsp_payload_araddr;
+  logic   [7 : 0] axi_rdma_rsp_payload_arlen;
+  logic   [2 : 0] axi_rdma_rsp_payload_arsize;
+  logic   [1 : 0] axi_rdma_rsp_payload_arburst;
+  logic   [3 : 0] axi_rdma_rsp_payload_arcache;
+  logic   [2 : 0] axi_rdma_rsp_payload_arprot;
+  logic           axi_rdma_rsp_payload_arvalid;
+  logic           axi_rdma_rsp_payload_arready;
+  logic           axi_rdma_rsp_payload_rid;
+  logic [511 : 0] axi_rdma_rsp_payload_rdata;
+  logic   [1 : 0] axi_rdma_rsp_payload_rresp;
+  logic           axi_rdma_rsp_payload_rlast;
+  logic           axi_rdma_rsp_payload_rvalid;
+  logic           axi_rdma_rsp_payload_rready;
+  logic           axi_rdma_rsp_payload_arlock;
+  logic   [3 : 0] axi_rdma_rsp_payload_arqos;
+
+  // RDMA AXI MM interface used to store payload from RDMA Read response operation
+  logic           axi_compute_logic_awid;
+  logic  [63 : 0] axi_compute_logic_awaddr;
+  logic   [3 : 0] axi_compute_logic_awqos;
+  logic   [7 : 0] axi_compute_logic_awlen;
+  logic   [2 : 0] axi_compute_logic_awsize;
+  logic   [1 : 0] axi_compute_logic_awburst;
+  logic   [3 : 0] axi_compute_logic_awcache;
+  logic   [2 : 0] axi_compute_logic_awprot;
+  logic           axi_compute_logic_awvalid;
+  logic           axi_compute_logic_awready;
+  logic [511 : 0] axi_compute_logic_wdata;
+  logic  [63 : 0] axi_compute_logic_wstrb;
+  logic           axi_compute_logic_wlast;
+  logic           axi_compute_logic_wvalid;
+  logic           axi_compute_logic_wready;
+  logic           axi_compute_logic_awlock;
+  logic           axi_compute_logic_bid;
+  logic   [1 : 0] axi_compute_logic_bresp;
+  logic           axi_compute_logic_bvalid;
+  logic           axi_compute_logic_bready;
+  logic           axi_compute_logic_arid;
+  logic  [63 : 0] axi_compute_logic_araddr;
+  logic   [7 : 0] axi_compute_logic_arlen;
+  logic   [2 : 0] axi_compute_logic_arsize;
+  logic   [1 : 0] axi_compute_logic_arburst;
+  logic   [3 : 0] axi_compute_logic_arcache;
+  logic   [2 : 0] axi_compute_logic_arprot;
+  logic           axi_compute_logic_arvalid;
+  logic           axi_compute_logic_arready;
+  logic           axi_compute_logic_rid;
+  logic [511 : 0] axi_compute_logic_rdata;
+  logic   [1 : 0] axi_compute_logic_rresp;
+  logic           axi_compute_logic_rlast;
+  logic           axi_compute_logic_rvalid;
+  logic           axi_compute_logic_rready;
+  logic           axi_compute_logic_arlock;
+  logic   [3 : 0] axi_compute_logic_arqos;
+
+  // AXI MM interface used to access the device memory
+  logic   [4 : 0] axi_dev_mem_awid;
+  logic  [63 : 0] axi_dev_mem_awaddr;
+  logic   [7 : 0] axi_dev_mem_awlen;
+  logic   [2 : 0] axi_dev_mem_awsize;
+  logic   [1 : 0] axi_dev_mem_awburst;
+  logic           axi_dev_mem_awlock;
+  logic   [3 : 0] axi_dev_mem_awqos;
+  logic   [3 : 0] axi_dev_mem_awregion;
+  logic   [3 : 0] axi_dev_mem_awcache;
+  logic   [2 : 0] axi_dev_mem_awprot;
+  logic           axi_dev_mem_awvalid;
+  logic           axi_dev_mem_awready;
+  logic [511 : 0] axi_dev_mem_wdata;
+  logic  [63 : 0] axi_dev_mem_wstrb;
+  logic           axi_dev_mem_wlast;
+  logic           axi_dev_mem_wvalid;
+  logic           axi_dev_mem_wready;
+  logic   [4 : 0] axi_dev_mem_bid;
+  logic   [1 : 0] axi_dev_mem_bresp;
+  logic           axi_dev_mem_bvalid;
+  logic           axi_dev_mem_bready;
+  logic   [4 : 0] axi_dev_mem_arid;
+  logic  [63 : 0] axi_dev_mem_araddr;
+  logic   [7 : 0] axi_dev_mem_arlen;
+  logic   [2 : 0] axi_dev_mem_arsize;
+  logic   [1 : 0] axi_dev_mem_arburst;
+  logic           axi_dev_mem_arlock;
+  logic   [3 : 0] axi_dev_mem_arqos;
+  logic   [3 : 0] axi_dev_mem_arregion;
+  logic   [3 : 0] axi_dev_mem_arcache;
+  logic   [2 : 0] axi_dev_mem_arprot;
+  logic           axi_dev_mem_arvalid;
+  logic           axi_dev_mem_arready;
+  logic   [4 : 0] axi_dev_mem_rid;
+  logic [511 : 0] axi_dev_mem_rdata;
+  logic   [1 : 0] axi_dev_mem_rresp;
+  logic           axi_dev_mem_rlast;
+  logic           axi_dev_mem_rvalid;
+  logic           axi_dev_mem_rready;
+
+  // RDMA AXI MM interface used to get wqe from system memory
+  logic           axi_rdma_get_wqe_awid;
+  logic  [63 : 0] axi_rdma_get_wqe_awaddr;
+  logic   [3 : 0] axi_rdma_get_wqe_awqos;
+  logic   [7 : 0] axi_rdma_get_wqe_awlen;
+  logic   [2 : 0] axi_rdma_get_wqe_awsize;
+  logic   [1 : 0] axi_rdma_get_wqe_awburst;
+  logic   [3 : 0] axi_rdma_get_wqe_awcache;
+  logic   [2 : 0] axi_rdma_get_wqe_awprot;
+  logic           axi_rdma_get_wqe_awvalid;
+  logic           axi_rdma_get_wqe_awready;
+  logic [511 : 0] axi_rdma_get_wqe_wdata;
+  logic  [63 : 0] axi_rdma_get_wqe_wstrb;
+  logic           axi_rdma_get_wqe_wlast;
+  logic           axi_rdma_get_wqe_wvalid;
+  logic           axi_rdma_get_wqe_wready;
+  logic           axi_rdma_get_wqe_awlock;
+  logic           axi_rdma_get_wqe_bid;
+  logic   [1 : 0] axi_rdma_get_wqe_bresp;
+  logic           axi_rdma_get_wqe_bvalid;
+  logic           axi_rdma_get_wqe_bready;
+  logic           axi_rdma_get_wqe_arid;
+  logic  [63 : 0] axi_rdma_get_wqe_araddr;
+  logic   [7 : 0] axi_rdma_get_wqe_arlen;
+  logic   [2 : 0] axi_rdma_get_wqe_arsize;
+  logic   [1 : 0] axi_rdma_get_wqe_arburst;
+  logic   [3 : 0] axi_rdma_get_wqe_arcache;
+  logic   [2 : 0] axi_rdma_get_wqe_arprot;
+  logic           axi_rdma_get_wqe_arvalid;
+  logic           axi_rdma_get_wqe_arready;
+  logic           axi_rdma_get_wqe_rid;
+  logic [511 : 0] axi_rdma_get_wqe_rdata;
+  logic   [1 : 0] axi_rdma_get_wqe_rresp;
+  logic           axi_rdma_get_wqe_rlast;
+  logic           axi_rdma_get_wqe_rvalid;
+  logic           axi_rdma_get_wqe_rready;
+  logic           axi_rdma_get_wqe_arlock;
+  logic   [3 : 0] axi_rdma_get_wqe_arqos;
+
+  // RDMA AXI MM interface used to get payload from system memory
+  logic           axi_rdma_get_payload_awid;
+  logic  [63 : 0] axi_rdma_get_payload_awaddr;
+  logic   [3 : 0] axi_rdma_get_payload_awqos;
+  logic   [7 : 0] axi_rdma_get_payload_awlen;
+  logic   [2 : 0] axi_rdma_get_payload_awsize;
+  logic   [1 : 0] axi_rdma_get_payload_awburst;
+  logic   [3 : 0] axi_rdma_get_payload_awcache;
+  logic   [2 : 0] axi_rdma_get_payload_awprot;
+  logic           axi_rdma_get_payload_awvalid;
+  logic           axi_rdma_get_payload_awready;
+  logic [511 : 0] axi_rdma_get_payload_wdata;
+  logic  [63 : 0] axi_rdma_get_payload_wstrb;
+  logic           axi_rdma_get_payload_wlast;
+  logic           axi_rdma_get_payload_wvalid;
+  logic           axi_rdma_get_payload_wready;
+  logic           axi_rdma_get_payload_awlock;
+  logic           axi_rdma_get_payload_bid;
+  logic   [1 : 0] axi_rdma_get_payload_bresp;
+  logic           axi_rdma_get_payload_bvalid;
+  logic           axi_rdma_get_payload_bready;
+  logic           axi_rdma_get_payload_arid;
+  logic  [63 : 0] axi_rdma_get_payload_araddr;
+  logic   [7 : 0] axi_rdma_get_payload_arlen;
+  logic   [2 : 0] axi_rdma_get_payload_arsize;
+  logic   [1 : 0] axi_rdma_get_payload_arburst;
+  logic   [3 : 0] axi_rdma_get_payload_arcache;
+  logic   [2 : 0] axi_rdma_get_payload_arprot;
+  logic           axi_rdma_get_payload_arvalid;
+  logic           axi_rdma_get_payload_arready;
+  logic           axi_rdma_get_payload_rid;
+  logic [511 : 0] axi_rdma_get_payload_rdata;
+  logic   [1 : 0] axi_rdma_get_payload_rresp;
+  logic           axi_rdma_get_payload_rlast;
+  logic           axi_rdma_get_payload_rvalid;
+  logic           axi_rdma_get_payload_rready;
+  logic           axi_rdma_get_payload_arlock;
+  logic   [3 : 0] axi_rdma_get_payload_arqos;
+
+  // RDMA AXI MM interface used to update rdma completion to system memory
+  logic           axi_rdma_completion_awid;
+  logic  [63 : 0] axi_rdma_completion_awaddr;
+  logic   [3 : 0] axi_rdma_completion_awqos;
+  logic   [7 : 0] axi_rdma_completion_awlen;
+  logic   [2 : 0] axi_rdma_completion_awsize;
+  logic   [1 : 0] axi_rdma_completion_awburst;
+  logic   [3 : 0] axi_rdma_completion_awcache;
+  logic   [2 : 0] axi_rdma_completion_awprot;
+  logic           axi_rdma_completion_awvalid;
+  logic           axi_rdma_completion_awready;
+  logic [511 : 0] axi_rdma_completion_wdata;
+  logic  [63 : 0] axi_rdma_completion_wstrb;
+  logic           axi_rdma_completion_wlast;
+  logic           axi_rdma_completion_wvalid;
+  logic           axi_rdma_completion_wready;
+  logic           axi_rdma_completion_awlock;
+  logic           axi_rdma_completion_bid;
+  logic   [1 : 0] axi_rdma_completion_bresp;
+  logic           axi_rdma_completion_bvalid;
+  logic           axi_rdma_completion_bready;
+  logic           axi_rdma_completion_arid;
+  logic  [63 : 0] axi_rdma_completion_araddr;
+  logic   [7 : 0] axi_rdma_completion_arlen;
+  logic   [2 : 0] axi_rdma_completion_arsize;
+  logic   [1 : 0] axi_rdma_completion_arburst;
+  logic   [3 : 0] axi_rdma_completion_arcache;
+  logic   [2 : 0] axi_rdma_completion_arprot;
+  logic           axi_rdma_completion_arvalid;
+  logic           axi_rdma_completion_arready;
+  logic           axi_rdma_completion_rid;
+  logic [511 : 0] axi_rdma_completion_rdata;
+  logic   [1 : 0] axi_rdma_completion_rresp;
+  logic           axi_rdma_completion_rlast;
+  logic           axi_rdma_completion_rvalid;
+  logic           axi_rdma_completion_rready;
+  logic           axi_rdma_completion_arlock;
+  logic   [3 : 0] axi_rdma_completion_arqos;
+
+  // AXI MM interface used to access the system memory (s_axib_* of the QDMA IP)
+  logic   [2 : 0] axi_sys_mem_awid;
+  logic  [63 : 0] axi_sys_mem_awaddr;
+  logic   [7 : 0] axi_sys_mem_awlen;
+  logic   [2 : 0] axi_sys_mem_awsize;
+  logic   [1 : 0] axi_sys_mem_awburst;
+  logic           axi_sys_mem_awlock;
+  logic   [3 : 0] axi_sys_mem_awqos;
+  logic   [3 : 0] axi_sys_mem_awregion;
+  logic   [3 : 0] axi_sys_mem_awcache;
+  logic   [2 : 0] axi_sys_mem_awprot;
+  logic           axi_sys_mem_awvalid;
+  logic           axi_sys_mem_awready;
+  logic [511 : 0] axi_sys_mem_wdata;
+  logic  [63 : 0] axi_sys_mem_wstrb;
+  logic           axi_sys_mem_wlast;
+  logic           axi_sys_mem_wvalid;
+  logic           axi_sys_mem_wready;
+  logic   [3 : 0] axi_sys_mem_bid;
+  logic   [1 : 0] axi_sys_mem_bresp;
+  logic           axi_sys_mem_bvalid;
+  logic           axi_sys_mem_bready;
+  logic   [2 : 0] axi_sys_mem_arid;
+  logic  [63 : 0] axi_sys_mem_araddr;
+  logic   [7 : 0] axi_sys_mem_arlen;
+  logic   [2 : 0] axi_sys_mem_arsize;
+  logic   [1 : 0] axi_sys_mem_arburst;
+  logic           axi_sys_mem_arlock;
+  logic   [3 : 0] axi_sys_mem_arqos;
+  logic   [3 : 0] axi_sys_mem_arregion;
+  logic   [3 : 0] axi_sys_mem_arcache;
+  logic   [2 : 0] axi_sys_mem_arprot;
+  logic           axi_sys_mem_arvalid;
+  logic           axi_sys_mem_arready;
+  logic   [3 : 0] axi_sys_mem_rid;
+  logic [511 : 0] axi_sys_mem_rdata;
+  logic   [1 : 0] axi_sys_mem_rresp;
+  logic           axi_sys_mem_rlast;
+  logic           axi_sys_mem_rvalid;
+  logic           axi_sys_mem_rready;
+  logic  [63 : 0] axi_sys_mem_wuser;
+  logic  [63 : 0] axi_sys_mem_ruser;
+  logic  [11 : 0] axi_sys_mem_awuser;
+  logic  [11 : 0] axi_sys_mem_aruser;
+
+  //AXI interface between system mem crossbar and device mem crossbar
+  logic   [2 : 0] axi_from_sys_to_dev_crossbar_awid;
+  logic  [63 : 0] axi_from_sys_to_dev_crossbar_awaddr;
+  //logic  [31 : 0] axi_from_sys_to_dev_crossbar_awuser;
+  logic   [3 : 0] axi_from_sys_to_dev_crossbar_awqos;
+  logic   [7 : 0] axi_from_sys_to_dev_crossbar_awlen;
+  logic   [2 : 0] axi_from_sys_to_dev_crossbar_awsize;
+  logic   [1 : 0] axi_from_sys_to_dev_crossbar_awburst;
+  logic   [3 : 0] axi_from_sys_to_dev_crossbar_awcache;
+  logic   [2 : 0] axi_from_sys_to_dev_crossbar_awprot;
+  logic           axi_from_sys_to_dev_crossbar_awvalid;
+  logic           axi_from_sys_to_dev_crossbar_awready;
+  logic [511 : 0] axi_from_sys_to_dev_crossbar_wdata;
+  logic  [63 : 0] axi_from_sys_to_dev_crossbar_wstrb;
+  logic           axi_from_sys_to_dev_crossbar_wlast;
+  logic           axi_from_sys_to_dev_crossbar_wvalid;
+  logic           axi_from_sys_to_dev_crossbar_wready;
+  logic           axi_from_sys_to_dev_crossbar_awlock;
+  logic   [4 : 0] axi_from_sys_to_dev_crossbar_bid;
+  logic   [1 : 0] axi_from_sys_to_dev_crossbar_bresp;
+  logic           axi_from_sys_to_dev_crossbar_bvalid;
+  logic           axi_from_sys_to_dev_crossbar_bready;
+  logic   [2 : 0] axi_from_sys_to_dev_crossbar_arid;
+  logic  [63 : 0] axi_from_sys_to_dev_crossbar_araddr;
+  logic   [7 : 0] axi_from_sys_to_dev_crossbar_arlen;
+  logic   [2 : 0] axi_from_sys_to_dev_crossbar_arsize;
+  logic   [1 : 0] axi_from_sys_to_dev_crossbar_arburst;
+  logic   [3 : 0] axi_from_sys_to_dev_crossbar_arcache;
+  logic   [2 : 0] axi_from_sys_to_dev_crossbar_arprot;
+  logic           axi_from_sys_to_dev_crossbar_arvalid;
+  logic           axi_from_sys_to_dev_crossbar_arready;
+  logic   [4 : 0] axi_from_sys_to_dev_crossbar_rid;
+  logic [511 : 0] axi_from_sys_to_dev_crossbar_rdata;
+  logic   [1 : 0] axi_from_sys_to_dev_crossbar_rresp;
+  logic           axi_from_sys_to_dev_crossbar_rlast;
+  logic           axi_from_sys_to_dev_crossbar_rvalid;
+  logic           axi_from_sys_to_dev_crossbar_rready;
+  logic           axi_from_sys_to_dev_crossbar_arlock;
+  logic   [3 : 0] axi_from_sys_to_dev_crossbar_arqos;
+
+  wire   [63 : 0] axi_from_clk_converter_to_ddr4_awaddr;
+  wire    [7 : 0] axi_from_clk_converter_to_ddr4_awlen;
+  wire    [2 : 0] axi_from_clk_converter_to_ddr4_awsize;
+  wire    [1 : 0] axi_from_clk_converter_to_ddr4_awburst;
+  wire    [0 : 0] axi_from_clk_converter_to_ddr4_awlock;
+  wire    [3 : 0] axi_from_clk_converter_to_ddr4_awcache;
+  wire    [2 : 0] axi_from_clk_converter_to_ddr4_awprot;
+  wire    [3 : 0] axi_from_clk_converter_to_ddr4_awregion;
+  wire    [3 : 0] axi_from_clk_converter_to_ddr4_awqos;
+  wire            axi_from_clk_converter_to_ddr4_awvalid;
+  wire            axi_from_clk_converter_to_ddr4_awready;
+  wire  [511 : 0] axi_from_clk_converter_to_ddr4_wdata;
+  wire   [63 : 0] axi_from_clk_converter_to_ddr4_wstrb;
+  wire            axi_from_clk_converter_to_ddr4_wlast;
+  wire            axi_from_clk_converter_to_ddr4_wvalid;
+  wire            axi_from_clk_converter_to_ddr4_wready;
+  wire    [1 : 0] axi_from_clk_converter_to_ddr4_bresp;
+  wire            axi_from_clk_converter_to_ddr4_bvalid;
+  wire            axi_from_clk_converter_to_ddr4_bready;
+  wire   [63 : 0] axi_from_clk_converter_to_ddr4_araddr;
+  wire    [7 : 0] axi_from_clk_converter_to_ddr4_arlen;
+  wire    [2 : 0] axi_from_clk_converter_to_ddr4_arsize;
+  wire    [1 : 0] axi_from_clk_converter_to_ddr4_arburst;
+  wire    [0 : 0] axi_from_clk_converter_to_ddr4_arlock;
+  wire    [3 : 0] axi_from_clk_converter_to_ddr4_arcache;
+  wire    [2 : 0] axi_from_clk_converter_to_ddr4_arprot;
+  wire    [3 : 0] axi_from_clk_converter_to_ddr4_arregion;
+  wire    [3 : 0] axi_from_clk_converter_to_ddr4_arqos;
+  wire            axi_from_clk_converter_to_ddr4_arvalid;
+  wire            axi_from_clk_converter_to_ddr4_arready;
+  wire  [511 : 0] axi_from_clk_converter_to_ddr4_rdata;
+  wire    [1 : 0] axi_from_clk_converter_to_ddr4_rresp;
+  wire            axi_from_clk_converter_to_ddr4_rlast;
+  wire            axi_from_clk_converter_to_ddr4_rvalid;
+  wire            axi_from_clk_converter_to_ddr4_rready;
+  wire    [4 : 0] axi_from_clk_converter_to_ddr4_awid;
+  wire    [4 : 0] axi_from_clk_converter_to_ddr4_rid;
+  wire    [4 : 0] axi_from_clk_converter_to_ddr4_arid;
+  wire    [4 : 0] axi_from_clk_converter_to_ddr4_bid;
+
+  wire            c0_ddr4_ui_clk;
+  wire            c0_ddr4_ui_clk_sync_rst;
+
+  wire            c0_init_calib_complete;
+
+
+  logic                  [31:0] shell_rstn;
+  logic                  [31:0] shell_rst_done;
+  logic                         qdma_rstn;
+  logic                         qdma_rst_done;
+  logic     [NUM_CMAC_PORT-1:0] adap_rstn;
+  logic     [NUM_CMAC_PORT-1:0] adap_rst_done;
+  logic     [NUM_CMAC_PORT-1:0] cmac_rstn;
+  logic     [NUM_CMAC_PORT-1:0] cmac_rst_done;
+  logic                         rdma_rstn;
+  logic                         rdma_rst_done;
+
+  logic                  [31:0] user_rstn;
+  logic                  [31:0] user_rst_done;
+  logic                  [15:0] user_250mhz_rstn;
+  logic                  [15:0] user_250mhz_rst_done;
+  logic                   [7:0] user_322mhz_rstn;
+  logic                   [7:0] user_322mhz_rst_done;
+  logic                         box_250mhz_rstn;
+  logic                         box_250mhz_rst_done;
+  logic                         box_322mhz_rstn;
+  logic                         box_322mhz_rst_done;
+
+  logic                         hbm_ref_clk;
+  logic                         axil_aclk;
+  logic                         axis_aclk;
+  logic     [NUM_CMAC_PORT-1:0] cmac_clk;
 
   // Unused reset pairs must have their "reset_done" tied to 1
 
   // First 4-bit for QDMA subsystem
   assign qdma_rstn           = shell_rstn[0];
   assign shell_rst_done[0]   = qdma_rst_done;
-  assign shell_rst_done[3:1] = 3'b111;
+  assign rdma_rstn           = shell_rstn[1];
+  assign shell_rst_done[1]   = rdma_rst_done;
+  assign shell_rst_done[2]   = qdma_csr_prog_done;
+  assign shell_rst_done[3]   = 1'b1;
+  //assign shell_rst_done[3:2] = 2'b11;
 
   // For each CMAC port, use the subsequent 4-bit: bit 0 for CMAC subsystem and
   // bit 1 for the corresponding adapter
@@ -406,7 +895,6 @@ module open_nic_shell #(
     .BUILD_TIMESTAMP (BUILD_TIMESTAMP),
     .NUM_CMAC_PORT   (NUM_CMAC_PORT)
   ) system_config_inst (
-`ifdef __synthesis__
     .s_axil_awvalid      (axil_pcie_awvalid),
     .s_axil_awaddr       (axil_pcie_awaddr),
     .s_axil_awready      (axil_pcie_awready),
@@ -423,24 +911,6 @@ module open_nic_shell #(
     .s_axil_rdata        (axil_pcie_rdata),
     .s_axil_rresp        (axil_pcie_rresp),
     .s_axil_rready       (axil_pcie_rready),
-`else // !`ifdef __synthesis__
-    .s_axil_awvalid      (s_axil_sim_awvalid),
-    .s_axil_awaddr       (s_axil_sim_awaddr),
-    .s_axil_awready      (s_axil_sim_awready),
-    .s_axil_wvalid       (s_axil_sim_wvalid),
-    .s_axil_wdata        (s_axil_sim_wdata),
-    .s_axil_wready       (s_axil_sim_wready),
-    .s_axil_bvalid       (s_axil_sim_bvalid),
-    .s_axil_bresp        (s_axil_sim_bresp),
-    .s_axil_bready       (s_axil_sim_bready),
-    .s_axil_arvalid      (s_axil_sim_arvalid),
-    .s_axil_araddr       (s_axil_sim_araddr),
-    .s_axil_arready      (s_axil_sim_arready),
-    .s_axil_rvalid       (s_axil_sim_rvalid),
-    .s_axil_rdata        (s_axil_sim_rdata),
-    .s_axil_rresp        (s_axil_sim_rresp),
-    .s_axil_rready       (s_axil_sim_rready),
-`endif
 
     .m_axil_qdma_awvalid (axil_qdma_awvalid),
     .m_axil_qdma_awaddr  (axil_qdma_awaddr),
@@ -459,6 +929,24 @@ module open_nic_shell #(
     .m_axil_qdma_rresp   (axil_qdma_rresp),
     .m_axil_qdma_rready  (axil_qdma_rready),
 
+    .m_axil_qdma_csr_awaddr (axil_qdma_csr_awaddr),
+    .m_axil_qdma_csr_awvalid(axil_qdma_csr_awvalid),
+    // Only allowed to program axil csr interface when qdma_csr_prog_done is 1'b1
+    .m_axil_qdma_csr_awready(axil_qdma_csr_awready && qdma_csr_prog_done),
+    .m_axil_qdma_csr_wdata  (axil_qdma_csr_wdata),
+    .m_axil_qdma_csr_wvalid (axil_qdma_csr_wvalid),
+    .m_axil_qdma_csr_wready (axil_qdma_csr_wready),
+    .m_axil_qdma_csr_bvalid (axil_qdma_csr_bvalid),
+    .m_axil_qdma_csr_bresp  (axil_qdma_csr_bresp),
+    .m_axil_qdma_csr_bready (axil_qdma_csr_bready),
+    .m_axil_qdma_csr_araddr (axil_qdma_csr_araddr),
+    .m_axil_qdma_csr_arvalid(axil_qdma_csr_arvalid),
+    .m_axil_qdma_csr_arready(axil_qdma_csr_arready),
+    .m_axil_qdma_csr_rdata  (axil_qdma_csr_rdata),
+    .m_axil_qdma_csr_rresp  (axil_qdma_csr_rresp),
+    .m_axil_qdma_csr_rvalid (axil_qdma_csr_rvalid),
+    .m_axil_qdma_csr_rready (axil_qdma_csr_rready),
+
     .m_axil_adap_awvalid (axil_adap_awvalid),
     .m_axil_adap_awaddr  (axil_adap_awaddr),
     .m_axil_adap_awready (axil_adap_awready),
@@ -493,6 +981,23 @@ module open_nic_shell #(
     .m_axil_cmac_rresp   (axil_cmac_rresp),
     .m_axil_cmac_rready  (axil_cmac_rready),
 
+    .m_axil_rdma_awvalid (axil_rdma_awvalid),
+    .m_axil_rdma_awaddr  (axil_rdma_awaddr),
+    .m_axil_rdma_awready (axil_rdma_awready),
+    .m_axil_rdma_wvalid  (axil_rdma_wvalid),
+    .m_axil_rdma_wdata   (axil_rdma_wdata),
+    .m_axil_rdma_wready  (axil_rdma_wready),
+    .m_axil_rdma_bvalid  (axil_rdma_bvalid),
+    .m_axil_rdma_bresp   (axil_rdma_bresp),
+    .m_axil_rdma_bready  (axil_rdma_bready),
+    .m_axil_rdma_arvalid (axil_rdma_arvalid),
+    .m_axil_rdma_araddr  (axil_rdma_araddr),
+    .m_axil_rdma_arready (axil_rdma_arready),
+    .m_axil_rdma_rvalid  (axil_rdma_rvalid),
+    .m_axil_rdma_rdata   (axil_rdma_rdata),
+    .m_axil_rdma_rresp   (axil_rdma_rresp),
+    .m_axil_rdma_rready  (axil_rdma_rready),
+
     .m_axil_box0_awvalid (axil_box0_awvalid),
     .m_axil_box0_awaddr  (axil_box0_awaddr),
     .m_axil_box0_awready (axil_box0_awready),
@@ -578,7 +1083,46 @@ module open_nic_shell #(
     .s_axis_c2h_tuser_dst                 (axis_qdma_c2h_tuser_dst),
     .s_axis_c2h_tready                    (axis_qdma_c2h_tready),
 
-`ifdef __synthesis__
+    // QDMA DMA Engine - AXI MM interface
+    .m_axi_awready                        (axi_qdma_mm_awready),
+    .m_axi_wready                         (axi_qdma_mm_wready),
+    .m_axi_bid                            (axi_qdma_mm_bid),
+    .m_axi_bresp                          (axi_qdma_mm_bresp),
+    .m_axi_bvalid                         (axi_qdma_mm_bvalid),
+    .m_axi_arready                        (axi_qdma_mm_arready),
+    .m_axi_rid                            (axi_qdma_mm_rid),
+    .m_axi_rdata                          (axi_qdma_mm_rdata),
+    .m_axi_rresp                          (axi_qdma_mm_rresp),
+    .m_axi_rlast                          (axi_qdma_mm_rlast),
+    .m_axi_rvalid                         (axi_qdma_mm_rvalid),
+    .m_axi_awid                           (axi_qdma_mm_awid),
+    .m_axi_awaddr                         (axi_qdma_mm_awaddr),
+    .m_axi_awuser                         (axi_qdma_mm_awuser),
+    .m_axi_awlen                          (axi_qdma_mm_awlen),
+    .m_axi_awsize                         (axi_qdma_mm_awsize),
+    .m_axi_awburst                        (axi_qdma_mm_awburst),
+    .m_axi_awprot                         (axi_qdma_mm_awprot),
+    .m_axi_awvalid                        (axi_qdma_mm_awvalid),
+    .m_axi_awlock                         (axi_qdma_mm_awlock),
+    .m_axi_awcache                        (axi_qdma_mm_awcache),
+    .m_axi_wdata                          (axi_qdma_mm_wdata),
+    .m_axi_wuser                          (axi_qdma_mm_wuser),
+    .m_axi_wstrb                          (axi_qdma_mm_wstrb),
+    .m_axi_wlast                          (axi_qdma_mm_wlast),
+    .m_axi_wvalid                         (axi_qdma_mm_wvalid),
+    .m_axi_bready                         (axi_qdma_mm_bready),
+    .m_axi_arid                           (axi_qdma_mm_arid),
+    .m_axi_araddr                         (axi_qdma_mm_araddr),
+    .m_axi_aruser                         (axi_qdma_mm_aruser),
+    .m_axi_arlen                          (axi_qdma_mm_arlen),
+    .m_axi_arsize                         (axi_qdma_mm_arsize),
+    .m_axi_arburst                        (axi_qdma_mm_arburst),
+    .m_axi_arprot                         (axi_qdma_mm_arprot),
+    .m_axi_arvalid                        (axi_qdma_mm_arvalid),
+    .m_axi_arlock                         (axi_qdma_mm_arlock),
+    .m_axi_arcache                        (axi_qdma_mm_arcache),
+    .m_axi_rready                         (axi_qdma_mm_rready),
+
     .pcie_rxp                             (pcie_rxp),
     .pcie_rxn                             (pcie_rxn),
     .pcie_txp                             (pcie_txp),
@@ -607,51 +1151,68 @@ module open_nic_shell #(
     .user_lnk_up                          (pcie_user_lnk_up),
     .phy_ready                            (pcie_phy_ready),
     .powerup_rstn                         (powerup_rstn),
-`else // !`ifdef __synthesis__
-    .s_axis_qdma_h2c_tvalid               (s_axis_qdma_h2c_sim_tvalid),
-    .s_axis_qdma_h2c_tdata                (s_axis_qdma_h2c_sim_tdata),
-    .s_axis_qdma_h2c_tcrc                 (s_axis_qdma_h2c_sim_tcrc),
-    .s_axis_qdma_h2c_tlast                (s_axis_qdma_h2c_sim_tlast),
-    .s_axis_qdma_h2c_tuser_qid            (s_axis_qdma_h2c_sim_tuser_qid),
-    .s_axis_qdma_h2c_tuser_port_id        (s_axis_qdma_h2c_sim_tuser_port_id),
-    .s_axis_qdma_h2c_tuser_err            (s_axis_qdma_h2c_sim_tuser_err),
-    .s_axis_qdma_h2c_tuser_mdata          (s_axis_qdma_h2c_sim_tuser_mdata),
-    .s_axis_qdma_h2c_tuser_mty            (s_axis_qdma_h2c_sim_tuser_mty),
-    .s_axis_qdma_h2c_tuser_zero_byte      (s_axis_qdma_h2c_sim_tuser_zero_byte),
-    .s_axis_qdma_h2c_tready               (s_axis_qdma_h2c_sim_tready),
-
-    .m_axis_qdma_c2h_tvalid               (m_axis_qdma_c2h_sim_tvalid),
-    .m_axis_qdma_c2h_tdata                (m_axis_qdma_c2h_sim_tdata),
-    .m_axis_qdma_c2h_tcrc                 (m_axis_qdma_c2h_sim_tcrc),
-    .m_axis_qdma_c2h_tlast                (m_axis_qdma_c2h_sim_tlast),
-    .m_axis_qdma_c2h_ctrl_marker          (m_axis_qdma_c2h_sim_ctrl_marker),
-    .m_axis_qdma_c2h_ctrl_port_id         (m_axis_qdma_c2h_sim_ctrl_port_id),
-    .m_axis_qdma_c2h_ctrl_ecc             (m_axis_qdma_c2h_sim_ctrl_ecc),
-    .m_axis_qdma_c2h_ctrl_len             (m_axis_qdma_c2h_sim_ctrl_len),
-    .m_axis_qdma_c2h_ctrl_qid             (m_axis_qdma_c2h_sim_ctrl_qid),
-    .m_axis_qdma_c2h_ctrl_has_cmpt        (m_axis_qdma_c2h_sim_ctrl_has_cmpt),
-    .m_axis_qdma_c2h_mty                  (m_axis_qdma_c2h_sim_mty),
-    .m_axis_qdma_c2h_tready               (m_axis_qdma_c2h_sim_tready),
-
-    .m_axis_qdma_cpl_tvalid               (m_axis_qdma_cpl_sim_tvalid),
-    .m_axis_qdma_cpl_tdata                (m_axis_qdma_cpl_sim_tdata),
-    .m_axis_qdma_cpl_size                 (m_axis_qdma_cpl_sim_size),
-    .m_axis_qdma_cpl_dpar                 (m_axis_qdma_cpl_sim_dpar),
-    .m_axis_qdma_cpl_ctrl_qid             (m_axis_qdma_cpl_sim_ctrl_qid),
-    .m_axis_qdma_cpl_ctrl_cmpt_type       (m_axis_qdma_cpl_sim_ctrl_cmpt_type),
-    .m_axis_qdma_cpl_ctrl_wait_pld_pkt_id (m_axis_qdma_cpl_sim_ctrl_wait_pld_pkt_id),
-    .m_axis_qdma_cpl_ctrl_port_id         (m_axis_qdma_cpl_sim_ctrl_port_id),
-    .m_axis_qdma_cpl_ctrl_marker          (m_axis_qdma_cpl_sim_ctrl_marker),
-    .m_axis_qdma_cpl_ctrl_user_trig       (m_axis_qdma_cpl_sim_ctrl_user_trig),
-    .m_axis_qdma_cpl_ctrl_col_idx         (m_axis_qdma_cpl_sim_ctrl_col_idx),
-    .m_axis_qdma_cpl_ctrl_err_idx         (m_axis_qdma_cpl_sim_ctrl_err_idx),
-    .m_axis_qdma_cpl_ctrl_no_wrb_marker   (m_axis_qdma_cpl_sim_ctrl_no_wrb_marker),
-    .m_axis_qdma_cpl_tready               (m_axis_qdma_cpl_sim_tready),
-`endif
+
+    .s_csr_prog_done                      (qdma_csr_prog_done),
+    .s_axil_csr_awaddr                    (axil_qdma_csr_awaddr),
+    .s_axil_csr_awprot                    (3'd0),
+    .s_axil_csr_awvalid                   (axil_qdma_csr_awvalid),
+    .s_axil_csr_awready                   (axil_qdma_csr_awready),
+    .s_axil_csr_wdata                     (axil_qdma_csr_wdata),
+    .s_axil_csr_wstrb                     (4'hf),
+    .s_axil_csr_wvalid                    (axil_qdma_csr_wvalid),
+    .s_axil_csr_wready                    (axil_qdma_csr_wready),
+    .s_axil_csr_bvalid                    (axil_qdma_csr_bvalid),
+    .s_axil_csr_bresp                     (axil_qdma_csr_bresp),
+    .s_axil_csr_bready                    (axil_qdma_csr_bready),
+    .s_axil_csr_araddr                    (axil_qdma_csr_araddr),
+    .s_axil_csr_arprot                    (3'd0),
+    .s_axil_csr_arvalid                   (axil_qdma_csr_arvalid),
+    .s_axil_csr_arready                   (axil_qdma_csr_arready),
+    .s_axil_csr_rdata                     (axil_qdma_csr_rdata),
+    .s_axil_csr_rresp                     (axil_qdma_csr_rresp),
+    .s_axil_csr_rvalid                    (axil_qdma_csr_rvalid),
+    .s_axil_csr_rready                    (axil_qdma_csr_rready),
+
+    .s_axib_awid                          ({1'd0,axi_sys_mem_awid}),
+    .s_axib_awaddr                        (axi_sys_mem_awaddr),
+    .s_axib_awregion                      (axi_sys_mem_awregion),
+    .s_axib_awlen                         (axi_sys_mem_awlen),
+    .s_axib_awsize                        (axi_sys_mem_awsize),
+    .s_axib_awburst                       (axi_sys_mem_awburst),
+    .s_axib_awvalid                       (axi_sys_mem_awvalid),
+    .s_axib_wdata                         (axi_sys_mem_wdata),
+    .s_axib_wstrb                         (axi_sys_mem_wstrb),
+    .s_axib_wlast                         (axi_sys_mem_wlast),
+    .s_axib_wvalid                        (axi_sys_mem_wvalid),
+    .s_axib_wuser                         (axi_sys_mem_wuser),
+    .s_axib_ruser                         (axi_sys_mem_ruser),
+    .s_axib_bready                        (axi_sys_mem_bready),
+    .s_axib_arid                          ({1'd0,axi_sys_mem_arid}),
+    .s_axib_araddr                        (axi_sys_mem_araddr),
+    .s_axib_aruser                        (axi_sys_mem_aruser),
+    .s_axib_awuser                        (axi_sys_mem_awuser),
+    .s_axib_arregion                      (axi_sys_mem_arregion),
+    .s_axib_arlen                         (axi_sys_mem_arlen),
+    .s_axib_arsize                        (axi_sys_mem_arsize),
+    .s_axib_arburst                       (axi_sys_mem_arburst),
+    .s_axib_arvalid                       (axi_sys_mem_arvalid),
+    .s_axib_rready                        (axi_sys_mem_rready),
+    .s_axib_awready                       (axi_sys_mem_awready),
+    .s_axib_wready                        (axi_sys_mem_wready),
+    .s_axib_bid                           (axi_sys_mem_bid),
+    .s_axib_bresp                         (axi_sys_mem_bresp),
+    .s_axib_bvalid                        (axi_sys_mem_bvalid),
+    .s_axib_arready                       (axi_sys_mem_arready),
+    .s_axib_rid                           (axi_sys_mem_rid),
+    .s_axib_rdata                         (axi_sys_mem_rdata),
+    .s_axib_rresp                         (axi_sys_mem_rresp),
+    .s_axib_rlast                         (axi_sys_mem_rlast),
+    .s_axib_rvalid                        (axi_sys_mem_rvalid),
 
     .mod_rstn                             (qdma_rstn),
     .mod_rst_done                         (qdma_rst_done),
 
+    .ref_clk_100mhz                       (hbm_ref_clk),
     .axil_aclk                            (axil_aclk),
     .axis_aclk                            (axis_aclk)
   );
@@ -786,6 +1347,809 @@ module open_nic_shell #(
   end: cmac_port
   endgenerate
 
+  // RDMA subsystem
+  // TODO: retry buffer and hardware handshaking are not supported at the moment
+  rdma_subsystem_wrapper rdma_subsystem_inst (
+    // AXIL interface for RDMA control register
+    .s_axil_awaddr    (axil_rdma_awaddr),
+    .s_axil_awvalid   (axil_rdma_awvalid),
+    .s_axil_awready   (axil_rdma_awready),
+    .s_axil_wdata     (axil_rdma_wdata),
+    .s_axil_wstrb     (4'hf),
+    .s_axil_wvalid    (axil_rdma_wvalid),
+    .s_axil_wready    (axil_rdma_wready),
+    .s_axil_araddr    (axil_rdma_araddr),
+    .s_axil_arvalid   (axil_rdma_arvalid),
+    .s_axil_arready   (axil_rdma_arready),
+    .s_axil_rdata     (axil_rdma_rdata),
+    .s_axil_rvalid    (axil_rdma_rvalid),
+    .s_axil_rresp     (axil_rdma_rresp),
+    .s_axil_rready    (axil_rdma_rready),
+    .s_axil_bresp     (axil_rdma_bresp),
+    .s_axil_bvalid    (axil_rdma_bvalid),
+    .s_axil_bready    (axil_rdma_bready),
+
+    // RDMA TX interface (including roce and non-roce packets) to CMAC TX path
+    .m_rdma2cmac_axis_tdata  (rdma2cmac_axis_tdata),
+    .m_rdma2cmac_axis_tkeep  (rdma2cmac_axis_tkeep),
+    .m_rdma2cmac_axis_tvalid (rdma2cmac_axis_tvalid),
+    .m_rdma2cmac_axis_tlast  (rdma2cmac_axis_tlast),
+    .m_rdma2cmac_axis_tready (rdma2cmac_axis_tready),
+
+    // Non-RDMA packets from QDMA TX bypassing RDMA TX
+    .s_qdma2rdma_non_roce_axis_tdata    (qdma2rdma_non_roce_axis_tdata),
+    .s_qdma2rdma_non_roce_axis_tkeep    (qdma2rdma_non_roce_axis_tkeep),
+    .s_qdma2rdma_non_roce_axis_tvalid   (qdma2rdma_non_roce_axis_tvalid),
+    .s_qdma2rdma_non_roce_axis_tlast    (qdma2rdma_non_roce_axis_tlast),
+    .s_qdma2rdma_non_roce_axis_tready   (qdma2rdma_non_roce_axis_tready),
+
+    // RDMA RX interface from CMAC RX, no rx backpressure
+    .s_cmac2rdma_roce_axis_tdata        (cmac2rdma_roce_axis_tdata),
+    .s_cmac2rdma_roce_axis_tkeep        (cmac2rdma_roce_axis_tkeep),
+    .s_cmac2rdma_roce_axis_tvalid       (cmac2rdma_roce_axis_tvalid),
+    .s_cmac2rdma_roce_axis_tlast        (cmac2rdma_roce_axis_tlast),
+    .s_cmac2rdma_roce_axis_tuser        (cmac2rdma_roce_axis_tuser),
+
+    // Non-RDMA packets from CMAC RX bypassing RDMA, no rx backpressure
+    .s_cmac2rdma_non_roce_axis_tdata    (512'd0),
+    .s_cmac2rdma_non_roce_axis_tkeep    (64'd0),
+    .s_cmac2rdma_non_roce_axis_tvalid   (1'b0),
+    .s_cmac2rdma_non_roce_axis_tlast    (1'b0),
+    .s_cmac2rdma_non_roce_axis_tuser    (1'b0),
+
+    // Non-RDMA packets bypassing RDMA to QDMA RX
+    .m_rdma2qdma_non_roce_axis_tdata    (),
+    .m_rdma2qdma_non_roce_axis_tkeep    (),
+    .m_rdma2qdma_non_roce_axis_tvalid   (),
+    .m_rdma2qdma_non_roce_axis_tlast    (),
+    .m_rdma2qdma_non_roce_axis_tready   (1'b1),
+
+    // invalidate or immediate data from roce IETH/IMMDT header
+    .m_rdma2user_ieth_immdt_axis_tdata  (rdma2user_ieth_immdt_axis_tdata),
+    .m_rdma2user_ieth_immdt_axis_tlast  (rdma2user_ieth_immdt_axis_tlast),
+    .m_rdma2user_ieth_immdt_axis_tvalid (rdma2user_ieth_immdt_axis_tvalid),
+    .m_rdma2user_ieth_immdt_axis_trdy   (rdma2user_ieth_immdt_axis_trdy),
+
+    // RDMA AXI MM interface used to store payload from RDMA MAD, Send or Write operation
+    .m_axi_rdma_send_write_payload_store_awid    (axi_rdma_send_write_payload_awid),
+    .m_axi_rdma_send_write_payload_store_awaddr  (axi_rdma_send_write_payload_awaddr),
+    .m_axi_rdma_send_write_payload_store_awuser  (axi_rdma_send_write_payload_awuser),
+    .m_axi_rdma_send_write_payload_store_awlen   (axi_rdma_send_write_payload_awlen),
+    .m_axi_rdma_send_write_payload_store_awsize  (axi_rdma_send_write_payload_awsize),
+    .m_axi_rdma_send_write_payload_store_awburst (axi_rdma_send_write_payload_awburst),
+    .m_axi_rdma_send_write_payload_store_awcache (axi_rdma_send_write_payload_awcache),
+    .m_axi_rdma_send_write_payload_store_awprot  (axi_rdma_send_write_payload_awprot),
+    .m_axi_rdma_send_write_payload_store_awvalid (axi_rdma_send_write_payload_awvalid),
+    .m_axi_rdma_send_write_payload_store_awready (axi_rdma_send_write_payload_awready),
+    .m_axi_rdma_send_write_payload_store_wdata   (axi_rdma_send_write_payload_wdata),
+    .m_axi_rdma_send_write_payload_store_wstrb   (axi_rdma_send_write_payload_wstrb),
+    .m_axi_rdma_send_write_payload_store_wlast   (axi_rdma_send_write_payload_wlast),
+    .m_axi_rdma_send_write_payload_store_wvalid  (axi_rdma_send_write_payload_wvalid),
+    .m_axi_rdma_send_write_payload_store_wready  (axi_rdma_send_write_payload_wready),
+    .m_axi_rdma_send_write_payload_store_awlock  (axi_rdma_send_write_payload_awlock),
+    .m_axi_rdma_send_write_payload_store_bid     (axi_rdma_send_write_payload_bid),
+    .m_axi_rdma_send_write_payload_store_bresp   (axi_rdma_send_write_payload_bresp),
+    .m_axi_rdma_send_write_payload_store_bvalid  (axi_rdma_send_write_payload_bvalid),
+    .m_axi_rdma_send_write_payload_store_bready  (axi_rdma_send_write_payload_bready),
+    .m_axi_rdma_send_write_payload_store_arid    (axi_rdma_send_write_payload_arid),
+    .m_axi_rdma_send_write_payload_store_araddr  (axi_rdma_send_write_payload_araddr),
+    .m_axi_rdma_send_write_payload_store_arlen   (axi_rdma_send_write_payload_arlen),
+    .m_axi_rdma_send_write_payload_store_arsize  (axi_rdma_send_write_payload_arsize),
+    .m_axi_rdma_send_write_payload_store_arburst (axi_rdma_send_write_payload_arburst),
+    .m_axi_rdma_send_write_payload_store_arcache (axi_rdma_send_write_payload_arcache),
+    .m_axi_rdma_send_write_payload_store_arprot  (axi_rdma_send_write_payload_arprot),
+    .m_axi_rdma_send_write_payload_store_arvalid (axi_rdma_send_write_payload_arvalid),
+    .m_axi_rdma_send_write_payload_store_arready (axi_rdma_send_write_payload_arready),
+    .m_axi_rdma_send_write_payload_store_rid     (axi_rdma_send_write_payload_rid),
+    .m_axi_rdma_send_write_payload_store_rdata   (axi_rdma_send_write_payload_rdata),
+    .m_axi_rdma_send_write_payload_store_rresp   (axi_rdma_send_write_payload_rresp),
+    .m_axi_rdma_send_write_payload_store_rlast   (axi_rdma_send_write_payload_rlast),
+    .m_axi_rdma_send_write_payload_store_rvalid  (axi_rdma_send_write_payload_rvalid),
+    .m_axi_rdma_send_write_payload_store_rready  (axi_rdma_send_write_payload_rready),
+    .m_axi_rdma_send_write_payload_store_arlock  (axi_rdma_send_write_payload_arlock),
+
+    // RDMA AXI MM interface used to store payload from RDMA Read response operation
+    .m_axi_rdma_rsp_payload_awid          (axi_rdma_rsp_payload_awid),
+    .m_axi_rdma_rsp_payload_awaddr        (axi_rdma_rsp_payload_awaddr),
+    .m_axi_rdma_rsp_payload_awlen         (axi_rdma_rsp_payload_awlen),
+    .m_axi_rdma_rsp_payload_awsize        (axi_rdma_rsp_payload_awsize),
+    .m_axi_rdma_rsp_payload_awburst       (axi_rdma_rsp_payload_awburst),
+    .m_axi_rdma_rsp_payload_awcache       (axi_rdma_rsp_payload_awcache),
+    .m_axi_rdma_rsp_payload_awprot        (axi_rdma_rsp_payload_awprot),
+    .m_axi_rdma_rsp_payload_awvalid       (axi_rdma_rsp_payload_awvalid),
+    .m_axi_rdma_rsp_payload_awready       (axi_rdma_rsp_payload_awready),
+    .m_axi_rdma_rsp_payload_wdata         (axi_rdma_rsp_payload_wdata),
+    .m_axi_rdma_rsp_payload_wstrb         (axi_rdma_rsp_payload_wstrb),
+    .m_axi_rdma_rsp_payload_wlast         (axi_rdma_rsp_payload_wlast),
+    .m_axi_rdma_rsp_payload_wvalid        (axi_rdma_rsp_payload_wvalid),
+    .m_axi_rdma_rsp_payload_wready        (axi_rdma_rsp_payload_wready),
+    .m_axi_rdma_rsp_payload_awlock        (axi_rdma_rsp_payload_awlock),
+    .m_axi_rdma_rsp_payload_bid           (axi_rdma_rsp_payload_bid),
+    .m_axi_rdma_rsp_payload_bresp         (axi_rdma_rsp_payload_bresp),
+    .m_axi_rdma_rsp_payload_bvalid        (axi_rdma_rsp_payload_bvalid),
+    .m_axi_rdma_rsp_payload_bready        (axi_rdma_rsp_payload_bready),
+    .m_axi_rdma_rsp_payload_arid          (axi_rdma_rsp_payload_arid),
+    .m_axi_rdma_rsp_payload_araddr        (axi_rdma_rsp_payload_araddr),
+    .m_axi_rdma_rsp_payload_arlen         (axi_rdma_rsp_payload_arlen),
+    .m_axi_rdma_rsp_payload_arsize        (axi_rdma_rsp_payload_arsize),
+    .m_axi_rdma_rsp_payload_arburst       (axi_rdma_rsp_payload_arburst),
+    .m_axi_rdma_rsp_payload_arcache       (axi_rdma_rsp_payload_arcache),
+    .m_axi_rdma_rsp_payload_arprot        (axi_rdma_rsp_payload_arprot),
+    .m_axi_rdma_rsp_payload_arvalid       (axi_rdma_rsp_payload_arvalid),
+    .m_axi_rdma_rsp_payload_arready       (axi_rdma_rsp_payload_arready),
+    .m_axi_rdma_rsp_payload_rid           (axi_rdma_rsp_payload_rid),
+    .m_axi_rdma_rsp_payload_rdata         (axi_rdma_rsp_payload_rdata),
+    .m_axi_rdma_rsp_payload_rresp         (axi_rdma_rsp_payload_rresp),
+    .m_axi_rdma_rsp_payload_rlast         (axi_rdma_rsp_payload_rlast),
+    .m_axi_rdma_rsp_payload_rvalid        (axi_rdma_rsp_payload_rvalid),
+    .m_axi_rdma_rsp_payload_rready        (axi_rdma_rsp_payload_rready),
+    .m_axi_rdma_rsp_payload_arlock        (axi_rdma_rsp_payload_arlock),
+
+    // RDMA AXI MM interface used to fetch WQE entries in the senq queue from DDR by the QP manager
+    .m_axi_qp_get_wqe_awid                (axi_rdma_get_wqe_awid),
+    .m_axi_qp_get_wqe_awaddr              (axi_rdma_get_wqe_awaddr),
+    .m_axi_qp_get_wqe_awlen               (axi_rdma_get_wqe_awlen),
+    .m_axi_qp_get_wqe_awsize              (axi_rdma_get_wqe_awsize),
+    .m_axi_qp_get_wqe_awburst             (axi_rdma_get_wqe_awburst),
+    .m_axi_qp_get_wqe_awcache             (axi_rdma_get_wqe_awcache),
+    .m_axi_qp_get_wqe_awprot              (axi_rdma_get_wqe_awprot),
+    .m_axi_qp_get_wqe_awvalid             (axi_rdma_get_wqe_awvalid),
+    .m_axi_qp_get_wqe_awready             (axi_rdma_get_wqe_awready),
+    .m_axi_qp_get_wqe_wdata               (axi_rdma_get_wqe_wdata),
+    .m_axi_qp_get_wqe_wstrb               (axi_rdma_get_wqe_wstrb),
+    .m_axi_qp_get_wqe_wlast               (axi_rdma_get_wqe_wlast),
+    .m_axi_qp_get_wqe_wvalid              (axi_rdma_get_wqe_wvalid),
+    .m_axi_qp_get_wqe_wready              (axi_rdma_get_wqe_wready),
+    .m_axi_qp_get_wqe_awlock              (axi_rdma_get_wqe_awlock),
+    .m_axi_qp_get_wqe_bid                 (axi_rdma_get_wqe_bid),
+    .m_axi_qp_get_wqe_bresp               (axi_rdma_get_wqe_bresp),
+    .m_axi_qp_get_wqe_bvalid              (axi_rdma_get_wqe_bvalid),
+    .m_axi_qp_get_wqe_bready              (axi_rdma_get_wqe_bready),
+    .m_axi_qp_get_wqe_arid                (axi_rdma_get_wqe_arid),
+    .m_axi_qp_get_wqe_araddr              (axi_rdma_get_wqe_araddr),
+    .m_axi_qp_get_wqe_arlen               (axi_rdma_get_wqe_arlen),
+    .m_axi_qp_get_wqe_arsize              (axi_rdma_get_wqe_arsize),
+    .m_axi_qp_get_wqe_arburst             (axi_rdma_get_wqe_arburst),
+    .m_axi_qp_get_wqe_arcache             (axi_rdma_get_wqe_arcache),
+    .m_axi_qp_get_wqe_arprot              (axi_rdma_get_wqe_arprot),
+    .m_axi_qp_get_wqe_arvalid             (axi_rdma_get_wqe_arvalid),
+    .m_axi_qp_get_wqe_arready             (axi_rdma_get_wqe_arready),
+    .m_axi_qp_get_wqe_rid                 (axi_rdma_get_wqe_rid),
+    .m_axi_qp_get_wqe_rdata               (axi_rdma_get_wqe_rdata),
+    .m_axi_qp_get_wqe_rresp               (axi_rdma_get_wqe_rresp),
+    .m_axi_qp_get_wqe_rlast               (axi_rdma_get_wqe_rlast),
+    .m_axi_qp_get_wqe_rvalid              (axi_rdma_get_wqe_rvalid),
+    .m_axi_qp_get_wqe_rready              (axi_rdma_get_wqe_rready),
+    .m_axi_qp_get_wqe_arlock              (axi_rdma_get_wqe_arlock),
+
+    // TODO: In the current implementation, we do not consider retry buffer
+    // RDMA AXI MM interface used to store payload of an outgoing RDMA write packet to a retry buffer
+    .m_axi_payload_to_retry_buf_awid     (),
+    .m_axi_payload_to_retry_buf_awaddr   (),
+    .m_axi_payload_to_retry_buf_awlen    (),
+    .m_axi_payload_to_retry_buf_awsize   (),
+    .m_axi_payload_to_retry_buf_awburst  (),
+    .m_axi_payload_to_retry_buf_awcache  (),
+    .m_axi_payload_to_retry_buf_awprot   (),
+    .m_axi_payload_to_retry_buf_awvalid  (),
+    .m_axi_payload_to_retry_buf_awready  (1'b1),
+    .m_axi_payload_to_retry_buf_wdata    (),
+    .m_axi_payload_to_retry_buf_wstrb    (),
+    .m_axi_payload_to_retry_buf_wlast    (),
+    .m_axi_payload_to_retry_buf_wvalid   (),
+    .m_axi_payload_to_retry_buf_wready   (1'b1),
+    .m_axi_payload_to_retry_buf_awlock   (),
+    .m_axi_payload_to_retry_buf_bid      (1'b0),
+    .m_axi_payload_to_retry_buf_bresp    (2'd0),
+    .m_axi_payload_to_retry_buf_bvalid   (1'b0),
+    .m_axi_payload_to_retry_buf_bready   (),
+    .m_axi_payload_to_retry_buf_arid     (),
+    .m_axi_payload_to_retry_buf_araddr   (),
+    .m_axi_payload_to_retry_buf_arlen    (),
+    .m_axi_payload_to_retry_buf_arsize   (),
+    .m_axi_payload_to_retry_buf_arburst  (),
+    .m_axi_payload_to_retry_buf_arcache  (),
+    .m_axi_payload_to_retry_buf_arprot   (),
+    .m_axi_payload_to_retry_buf_arvalid  (),
+    .m_axi_payload_to_retry_buf_arready  (1'b1),
+    .m_axi_payload_to_retry_buf_rid      (1'b0),
+    .m_axi_payload_to_retry_buf_rdata    (512'd0),
+    .m_axi_payload_to_retry_buf_rresp    (2'd0),
+    .m_axi_payload_to_retry_buf_rlast    (1'b0),
+    .m_axi_payload_to_retry_buf_rvalid   (1'b0),
+    .m_axi_payload_to_retry_buf_rready   (),
+    .m_axi_payload_to_retry_buf_arlock   (),
+
+    // RDMA AXI MM interface used to get payload of an outgoing RDMA send/write and read response packets
+    .m_axi_pktgen_get_payload_awid       (axi_rdma_get_payload_awid),
+    .m_axi_pktgen_get_payload_awaddr     (axi_rdma_get_payload_awaddr),
+    .m_axi_pktgen_get_payload_awlen      (axi_rdma_get_payload_awlen),
+    .m_axi_pktgen_get_payload_awsize     (axi_rdma_get_payload_awsize),
+    .m_axi_pktgen_get_payload_awburst    (axi_rdma_get_payload_awburst),
+    .m_axi_pktgen_get_payload_awcache    (axi_rdma_get_payload_awcache),
+    .m_axi_pktgen_get_payload_awprot     (axi_rdma_get_payload_awprot),
+    .m_axi_pktgen_get_payload_awvalid    (axi_rdma_get_payload_awvalid),
+    .m_axi_pktgen_get_payload_awready    (axi_rdma_get_payload_awready),
+    .m_axi_pktgen_get_payload_wdata      (axi_rdma_get_payload_wdata),
+    .m_axi_pktgen_get_payload_wstrb      (axi_rdma_get_payload_wstrb),
+    .m_axi_pktgen_get_payload_wlast      (axi_rdma_get_payload_wlast),
+    .m_axi_pktgen_get_payload_wvalid     (axi_rdma_get_payload_wvalid),
+    .m_axi_pktgen_get_payload_wready     (axi_rdma_get_payload_wready),
+    .m_axi_pktgen_get_payload_awlock     (axi_rdma_get_payload_awlock),
+    .m_axi_pktgen_get_payload_bid        (axi_rdma_get_payload_bid),
+    .m_axi_pktgen_get_payload_bresp      (axi_rdma_get_payload_bresp),
+    .m_axi_pktgen_get_payload_bvalid     (axi_rdma_get_payload_bvalid),
+    .m_axi_pktgen_get_payload_bready     (axi_rdma_get_payload_bready),
+    .m_axi_pktgen_get_payload_arid       (axi_rdma_get_payload_arid),
+    .m_axi_pktgen_get_payload_araddr     (axi_rdma_get_payload_araddr),
+    .m_axi_pktgen_get_payload_arlen      (axi_rdma_get_payload_arlen),
+    .m_axi_pktgen_get_payload_arsize     (axi_rdma_get_payload_arsize),
+    .m_axi_pktgen_get_payload_arburst    (axi_rdma_get_payload_arburst),
+    .m_axi_pktgen_get_payload_arcache    (axi_rdma_get_payload_arcache),
+    .m_axi_pktgen_get_payload_arprot     (axi_rdma_get_payload_arprot),
+    .m_axi_pktgen_get_payload_arvalid    (axi_rdma_get_payload_arvalid),
+    .m_axi_pktgen_get_payload_arready    (axi_rdma_get_payload_arready),
+    .m_axi_pktgen_get_payload_rid        (axi_rdma_get_payload_rid),
+    .m_axi_pktgen_get_payload_rdata      (axi_rdma_get_payload_rdata),
+    .m_axi_pktgen_get_payload_rresp      (axi_rdma_get_payload_rresp),
+    .m_axi_pktgen_get_payload_rlast      (axi_rdma_get_payload_rlast),
+    .m_axi_pktgen_get_payload_rvalid     (axi_rdma_get_payload_rvalid),
+    .m_axi_pktgen_get_payload_rready     (axi_rdma_get_payload_rready),
+    .m_axi_pktgen_get_payload_arlock     (axi_rdma_get_payload_arlock),
+
+    // RDMA AXI MM interface used to write completion entries to a completion queue in the DDR
+    .m_axi_write_completion_awid         (axi_rdma_completion_awid),
+    .m_axi_write_completion_awaddr       (axi_rdma_completion_awaddr),
+    .m_axi_write_completion_awlen        (axi_rdma_completion_awlen),
+    .m_axi_write_completion_awsize       (axi_rdma_completion_awsize),
+    .m_axi_write_completion_awburst      (axi_rdma_completion_awburst),
+    .m_axi_write_completion_awcache      (axi_rdma_completion_awcache),
+    .m_axi_write_completion_awprot       (axi_rdma_completion_awprot),
+    .m_axi_write_completion_awvalid      (axi_rdma_completion_awvalid),
+    .m_axi_write_completion_awready      (axi_rdma_completion_awready),
+    .m_axi_write_completion_wdata        (axi_rdma_completion_wdata),
+    .m_axi_write_completion_wstrb        (axi_rdma_completion_wstrb),
+    .m_axi_write_completion_wlast        (axi_rdma_completion_wlast),
+    .m_axi_write_completion_wvalid       (axi_rdma_completion_wvalid),
+    .m_axi_write_completion_wready       (axi_rdma_completion_wready),
+    .m_axi_write_completion_awlock       (axi_rdma_completion_awlock),
+    .m_axi_write_completion_bid          (axi_rdma_completion_bid),
+    .m_axi_write_completion_bresp        (axi_rdma_completion_bresp),
+    .m_axi_write_completion_bvalid       (axi_rdma_completion_bvalid),
+    .m_axi_write_completion_bready       (axi_rdma_completion_bready),
+    .m_axi_write_completion_arid         (axi_rdma_completion_arid),
+    .m_axi_write_completion_araddr       (axi_rdma_completion_araddr),
+    .m_axi_write_completion_arlen        (axi_rdma_completion_arlen),
+    .m_axi_write_completion_arsize       (axi_rdma_completion_arsize),
+    .m_axi_write_completion_arburst      (axi_rdma_completion_arburst),
+    .m_axi_write_completion_arcache      (axi_rdma_completion_arcache),
+    .m_axi_write_completion_arprot       (axi_rdma_completion_arprot),
+    .m_axi_write_completion_arvalid      (axi_rdma_completion_arvalid),
+    .m_axi_write_completion_arready      (axi_rdma_completion_arready),
+    .m_axi_write_completion_rid          (axi_rdma_completion_rid),
+    .m_axi_write_completion_rdata        (axi_rdma_completion_rdata),
+    .m_axi_write_completion_rresp        (axi_rdma_completion_rresp),
+    .m_axi_write_completion_rlast        (axi_rdma_completion_rlast),
+    .m_axi_write_completion_rvalid       (axi_rdma_completion_rvalid),
+    .m_axi_write_completion_rready       (axi_rdma_completion_rready),
+    .m_axi_write_completion_arlock       (axi_rdma_completion_arlock),
+
+    // TODO: In the current implementation, we do not consider hardware handshaking from user logic
+    // HW handshaking from user logic: Send WQE completion queue doorbell
+    .resp_hndler_o_send_cq_db_cnt_valid(resp_hndler_o_send_cq_db_cnt_valid),
+    .resp_hndler_o_send_cq_db_addr     (resp_hndler_o_send_cq_db_addr),
+    .resp_hndler_o_send_cq_db_cnt      (resp_hndler_o_send_cq_db_cnt),
+    .resp_hndler_i_send_cq_db_rdy      (resp_hndler_i_send_cq_db_rdy),
+
+    // HW handshaking from user logic: Send WQE producer index doorbell
+    .i_qp_sq_pidb_hndshk               (i_qp_sq_pidb_hndshk),
+    .i_qp_sq_pidb_wr_addr_hndshk       (i_qp_sq_pidb_wr_addr_hndshk),
+    .i_qp_sq_pidb_wr_valid_hndshk      (i_qp_sq_pidb_wr_valid_hndshk),
+    .o_qp_sq_pidb_wr_rdy               (o_qp_sq_pidb_wr_rdy),
+
+    // HW handshaking from user logic: RDMA-Send consumer index doorbell
+    .i_qp_rq_cidb_hndshk               (i_qp_rq_cidb_hndshk),
+    .i_qp_rq_cidb_wr_addr_hndshk       (i_qp_rq_cidb_wr_addr_hndshk),
+    .i_qp_rq_cidb_wr_valid_hndshk      (i_qp_rq_cidb_wr_valid_hndshk),
+    .o_qp_rq_cidb_wr_rdy               (o_qp_rq_cidb_wr_rdy),
+
+    // HW handshaking from user logic: RDMA-Send producer index doorbell
+    .rx_pkt_hndler_o_rq_db_data        (rx_pkt_hndler_o_rq_db_data),
+    .rx_pkt_hndler_o_rq_db_addr        (rx_pkt_hndler_o_rq_db_addr),
+    .rx_pkt_hndler_o_rq_db_data_valid  (rx_pkt_hndler_o_rq_db_data_valid),
+    .rx_pkt_hndler_i_rq_db_rdy         (rx_pkt_hndler_i_rq_db_rdy),
+
+    .rnic_intr    (rdma_intr),
+
+    .mod_rstn     (rdma_rstn),
+    .mod_rst_done (rdma_rst_done),
+    //.rdma_resetn_done (rdma_resetn_done),
+    .axil_clk     (axil_aclk),
+    .axis_clk     (axis_aclk)
+  );
+
+  axi_3to1_interconnect_to_dev_mem axi_interconnect_to_dev_mem_inst(
+    .s_axi_qdma_mm_awid                    ({1'd0,axi_qdma_mm_awid}),
+    .s_axi_qdma_mm_awaddr                  (axi_qdma_mm_awaddr),
+    .s_axi_qdma_mm_awqos                   (axi_qdma_mm_awqos),
+    .s_axi_qdma_mm_awlen                   (axi_qdma_mm_awlen),
+    .s_axi_qdma_mm_awsize                  (axi_qdma_mm_awsize),
+    .s_axi_qdma_mm_awburst                 (axi_qdma_mm_awburst),
+    .s_axi_qdma_mm_awcache                 (axi_qdma_mm_awcache),
+    .s_axi_qdma_mm_awprot                  (axi_qdma_mm_awprot),
+    .s_axi_qdma_mm_awvalid                 (axi_qdma_mm_awvalid),
+    .s_axi_qdma_mm_awready                 (axi_qdma_mm_awready),
+    .s_axi_qdma_mm_wdata                   (axi_qdma_mm_wdata),
+    .s_axi_qdma_mm_wstrb                   (axi_qdma_mm_wstrb),
+    .s_axi_qdma_mm_wlast                   (axi_qdma_mm_wlast),
+    .s_axi_qdma_mm_wvalid                  (axi_qdma_mm_wvalid),
+    .s_axi_qdma_mm_wready                  (axi_qdma_mm_wready),
+    .s_axi_qdma_mm_awlock                  (axi_qdma_mm_awlock),
+    .s_axi_qdma_mm_bid                     (axi_qdma_mm_bid),
+    .s_axi_qdma_mm_bresp                   (axi_qdma_mm_bresp),
+    .s_axi_qdma_mm_bvalid                  (axi_qdma_mm_bvalid),
+    .s_axi_qdma_mm_bready                  (axi_qdma_mm_bready),
+    .s_axi_qdma_mm_arid                    ({1'd0,axi_qdma_mm_arid}),
+    .s_axi_qdma_mm_araddr                  (axi_qdma_mm_araddr),
+    .s_axi_qdma_mm_arlen                   (axi_qdma_mm_arlen),
+    .s_axi_qdma_mm_arsize                  (axi_qdma_mm_arsize),
+    .s_axi_qdma_mm_arburst                 (axi_qdma_mm_arburst),
+    .s_axi_qdma_mm_arcache                 (axi_qdma_mm_arcache),
+    .s_axi_qdma_mm_arprot                  (axi_qdma_mm_arprot),
+    .s_axi_qdma_mm_arvalid                 (axi_qdma_mm_arvalid),
+    .s_axi_qdma_mm_arready                 (axi_qdma_mm_arready),
+    .s_axi_qdma_mm_rid                     (axi_qdma_mm_rid),
+    .s_axi_qdma_mm_rdata                   (axi_qdma_mm_rdata),
+    .s_axi_qdma_mm_rresp                   (axi_qdma_mm_rresp),
+    .s_axi_qdma_mm_rlast                   (axi_qdma_mm_rlast),
+    .s_axi_qdma_mm_rvalid                  (axi_qdma_mm_rvalid),
+    .s_axi_qdma_mm_rready                  (axi_qdma_mm_rready),
+    .s_axi_qdma_mm_arlock                  (axi_qdma_mm_arlock),
+    .s_axi_qdma_mm_arqos                   (axi_qdma_mm_arqos),
+
+    .s_axi_compute_logic_awid              (axi_compute_logic_awid),
+    .s_axi_compute_logic_awaddr            (axi_compute_logic_awaddr),
+    .s_axi_compute_logic_awqos             (axi_compute_logic_awqos),
+    .s_axi_compute_logic_awlen             (axi_compute_logic_awlen),
+    .s_axi_compute_logic_awsize            (axi_compute_logic_awsize),
+    .s_axi_compute_logic_awburst           (axi_compute_logic_awburst),
+    .s_axi_compute_logic_awcache           (axi_compute_logic_awcache),
+    .s_axi_compute_logic_awprot            (axi_compute_logic_awprot),
+    .s_axi_compute_logic_awvalid           (axi_compute_logic_awvalid),
+    .s_axi_compute_logic_awready           (axi_compute_logic_awready),
+    .s_axi_compute_logic_wdata             (axi_compute_logic_wdata),
+    .s_axi_compute_logic_wstrb             (axi_compute_logic_wstrb),
+    .s_axi_compute_logic_wlast             (axi_compute_logic_wlast),
+    .s_axi_compute_logic_wvalid            (axi_compute_logic_wvalid),
+    .s_axi_compute_logic_wready            (axi_compute_logic_wready),
+    .s_axi_compute_logic_awlock            (axi_compute_logic_awlock),
+    .s_axi_compute_logic_bid               (axi_compute_logic_bid),
+    .s_axi_compute_logic_bresp             (axi_compute_logic_bresp),
+    .s_axi_compute_logic_bvalid            (axi_compute_logic_bvalid),
+    .s_axi_compute_logic_bready            (axi_compute_logic_bready),
+    .s_axi_compute_logic_arid              (axi_compute_logic_arid),
+    .s_axi_compute_logic_araddr            (axi_compute_logic_araddr),
+    .s_axi_compute_logic_arlen             (axi_compute_logic_arlen),
+    .s_axi_compute_logic_arsize            (axi_compute_logic_arsize),
+    .s_axi_compute_logic_arburst           (axi_compute_logic_arburst),
+    .s_axi_compute_logic_arcache           (axi_compute_logic_arcache),
+    .s_axi_compute_logic_arprot            (axi_compute_logic_arprot),
+    .s_axi_compute_logic_arvalid           (axi_compute_logic_arvalid),
+    .s_axi_compute_logic_arready           (axi_compute_logic_arready),
+    .s_axi_compute_logic_rid               (axi_compute_logic_rid),
+    .s_axi_compute_logic_rdata             (axi_compute_logic_rdata),
+    .s_axi_compute_logic_rresp             (axi_compute_logic_rresp),
+    .s_axi_compute_logic_rlast             (axi_compute_logic_rlast),
+    .s_axi_compute_logic_rvalid            (axi_compute_logic_rvalid),
+    .s_axi_compute_logic_rready            (axi_compute_logic_rready),
+    .s_axi_compute_logic_arlock            (axi_compute_logic_arlock),
+    .s_axi_compute_logic_arqos             (axi_compute_logic_arqos),
+
+    .s_axi_from_sys_crossbar_awid          ({2'd0,axi_from_sys_to_dev_crossbar_awid}),
+    .s_axi_from_sys_crossbar_awaddr        (axi_from_sys_to_dev_crossbar_awaddr),
+    .s_axi_from_sys_crossbar_awqos         (axi_from_sys_to_dev_crossbar_awqos),
+    .s_axi_from_sys_crossbar_awlen         (axi_from_sys_to_dev_crossbar_awlen),
+    .s_axi_from_sys_crossbar_awsize        (axi_from_sys_to_dev_crossbar_awsize),
+    .s_axi_from_sys_crossbar_awburst       (axi_from_sys_to_dev_crossbar_awburst),
+    .s_axi_from_sys_crossbar_awcache       (axi_from_sys_to_dev_crossbar_awcache),
+    .s_axi_from_sys_crossbar_awprot        (axi_from_sys_to_dev_crossbar_awprot),
+    .s_axi_from_sys_crossbar_awvalid       (axi_from_sys_to_dev_crossbar_awvalid),
+    .s_axi_from_sys_crossbar_awready       (axi_from_sys_to_dev_crossbar_awready),
+    .s_axi_from_sys_crossbar_wdata         (axi_from_sys_to_dev_crossbar_wdata),
+    .s_axi_from_sys_crossbar_wstrb         (axi_from_sys_to_dev_crossbar_wstrb),
+    .s_axi_from_sys_crossbar_wlast         (axi_from_sys_to_dev_crossbar_wlast),
+    .s_axi_from_sys_crossbar_wvalid        (axi_from_sys_to_dev_crossbar_wvalid),
+    .s_axi_from_sys_crossbar_wready        (axi_from_sys_to_dev_crossbar_wready),
+    .s_axi_from_sys_crossbar_awlock        (axi_from_sys_to_dev_crossbar_awlock),
+    .s_axi_from_sys_crossbar_bid           (axi_from_sys_to_dev_crossbar_bid),
+    .s_axi_from_sys_crossbar_bresp         (axi_from_sys_to_dev_crossbar_bresp),
+    .s_axi_from_sys_crossbar_bvalid        (axi_from_sys_to_dev_crossbar_bvalid),
+    .s_axi_from_sys_crossbar_bready        (axi_from_sys_to_dev_crossbar_bready),
+    .s_axi_from_sys_crossbar_arid          ({2'd0,axi_from_sys_to_dev_crossbar_arid}),
+    .s_axi_from_sys_crossbar_araddr        (axi_from_sys_to_dev_crossbar_araddr),
+    .s_axi_from_sys_crossbar_arlen         (axi_from_sys_to_dev_crossbar_arlen),
+    .s_axi_from_sys_crossbar_arsize        (axi_from_sys_to_dev_crossbar_arsize),
+    .s_axi_from_sys_crossbar_arburst       (axi_from_sys_to_dev_crossbar_arburst),
+    .s_axi_from_sys_crossbar_arcache       (axi_from_sys_to_dev_crossbar_arcache),
+    .s_axi_from_sys_crossbar_arprot        (axi_from_sys_to_dev_crossbar_arprot),
+    .s_axi_from_sys_crossbar_arvalid       (axi_from_sys_to_dev_crossbar_arvalid),
+    .s_axi_from_sys_crossbar_arready       (axi_from_sys_to_dev_crossbar_arready),
+    .s_axi_from_sys_crossbar_rid           (axi_from_sys_to_dev_crossbar_rid),
+    .s_axi_from_sys_crossbar_rdata         (axi_from_sys_to_dev_crossbar_rdata),
+    .s_axi_from_sys_crossbar_rresp         (axi_from_sys_to_dev_crossbar_rresp),
+    .s_axi_from_sys_crossbar_rlast         (axi_from_sys_to_dev_crossbar_rlast),
+    .s_axi_from_sys_crossbar_rvalid        (axi_from_sys_to_dev_crossbar_rvalid),
+    .s_axi_from_sys_crossbar_rready        (axi_from_sys_to_dev_crossbar_rready),
+    .s_axi_from_sys_crossbar_arlock        (axi_from_sys_to_dev_crossbar_arlock),
+    .s_axi_from_sys_crossbar_arqos         (axi_from_sys_to_dev_crossbar_arqos),
+
+    .m_axi_dev_mem_awaddr                  (axi_dev_mem_awaddr),
+    .m_axi_dev_mem_awprot                  (axi_dev_mem_awprot),
+    .m_axi_dev_mem_awvalid                 (axi_dev_mem_awvalid),
+    .m_axi_dev_mem_awready                 (axi_dev_mem_awready),
+    .m_axi_dev_mem_awsize                  (axi_dev_mem_awsize),
+    .m_axi_dev_mem_awburst                 (axi_dev_mem_awburst),
+    .m_axi_dev_mem_awcache                 (axi_dev_mem_awcache),
+    .m_axi_dev_mem_awlen                   (axi_dev_mem_awlen),
+    .m_axi_dev_mem_awlock                  (axi_dev_mem_awlock),
+    .m_axi_dev_mem_awqos                   (axi_dev_mem_awqos),
+    .m_axi_dev_mem_awregion                (axi_dev_mem_awregion),
+    .m_axi_dev_mem_awid                    (axi_dev_mem_awid),
+    .m_axi_dev_mem_wdata                   (axi_dev_mem_wdata),
+    .m_axi_dev_mem_wstrb                   (axi_dev_mem_wstrb),
+    .m_axi_dev_mem_wvalid                  (axi_dev_mem_wvalid),
+    .m_axi_dev_mem_wready                  (axi_dev_mem_wready),
+    .m_axi_dev_mem_wlast                   (axi_dev_mem_wlast),
+    .m_axi_dev_mem_bresp                   (axi_dev_mem_bresp),
+    .m_axi_dev_mem_bvalid                  (axi_dev_mem_bvalid),
+    .m_axi_dev_mem_bready                  (axi_dev_mem_bready),
+    .m_axi_dev_mem_bid                     (axi_dev_mem_bid),
+    .m_axi_dev_mem_araddr                  (axi_dev_mem_araddr),
+    .m_axi_dev_mem_arprot                  (axi_dev_mem_arprot),
+    .m_axi_dev_mem_arvalid                 (axi_dev_mem_arvalid),
+    .m_axi_dev_mem_arready                 (axi_dev_mem_arready),
+    .m_axi_dev_mem_arsize                  (axi_dev_mem_arsize),
+    .m_axi_dev_mem_arburst                 (axi_dev_mem_arburst),
+    .m_axi_dev_mem_arcache                 (axi_dev_mem_arcache),
+    .m_axi_dev_mem_arlock                  (axi_dev_mem_arlock),
+    .m_axi_dev_mem_arlen                   (axi_dev_mem_arlen),
+    .m_axi_dev_mem_arqos                   (axi_dev_mem_arqos),
+    .m_axi_dev_mem_arregion                (axi_dev_mem_arregion),
+    .m_axi_dev_mem_arid                    (axi_dev_mem_arid),
+    .m_axi_dev_mem_rdata                   (axi_dev_mem_rdata),
+    .m_axi_dev_mem_rresp                   (axi_dev_mem_rresp),
+    .m_axi_dev_mem_rvalid                  (axi_dev_mem_rvalid),
+    .m_axi_dev_mem_rready                  (axi_dev_mem_rready),
+    .m_axi_dev_mem_rlast                   (axi_dev_mem_rlast),
+    .m_axi_dev_mem_rid                     (axi_dev_mem_rid),
+
+    .axis_aclk                             (axis_aclk),
+    .axis_arestn                           (qdma_rstn)
+);
+
+axi_5to2_interconnect_to_sys_mem axi_interconnect_to_sys_mem_inst(
+    .s_axi_rdma_get_wqe_awid               (axi_rdma_get_wqe_awid),
+    .s_axi_rdma_get_wqe_awaddr             (axi_rdma_get_wqe_awaddr),
+    .s_axi_rdma_get_wqe_awqos              (axi_rdma_get_wqe_awqos),
+    .s_axi_rdma_get_wqe_awlen              (axi_rdma_get_wqe_awlen),
+    .s_axi_rdma_get_wqe_awsize             (axi_rdma_get_wqe_awsize),
+    .s_axi_rdma_get_wqe_awburst            (axi_rdma_get_wqe_awburst),
+    .s_axi_rdma_get_wqe_awcache            (axi_rdma_get_wqe_awcache),
+    .s_axi_rdma_get_wqe_awprot             (axi_rdma_get_wqe_awprot),
+    .s_axi_rdma_get_wqe_awvalid            (axi_rdma_get_wqe_awvalid),
+    .s_axi_rdma_get_wqe_awready            (axi_rdma_get_wqe_awready),
+    .s_axi_rdma_get_wqe_wdata              (axi_rdma_get_wqe_wdata),
+    .s_axi_rdma_get_wqe_wstrb              (axi_rdma_get_wqe_wstrb),
+    .s_axi_rdma_get_wqe_wlast              (axi_rdma_get_wqe_wlast),
+    .s_axi_rdma_get_wqe_wvalid             (axi_rdma_get_wqe_wvalid),
+    .s_axi_rdma_get_wqe_wready             (axi_rdma_get_wqe_wready),
+    .s_axi_rdma_get_wqe_awlock             (axi_rdma_get_wqe_awlock),
+    .s_axi_rdma_get_wqe_bid                (axi_rdma_get_wqe_bid),
+    .s_axi_rdma_get_wqe_bresp              (axi_rdma_get_wqe_bresp),
+    .s_axi_rdma_get_wqe_bvalid             (axi_rdma_get_wqe_bvalid),
+    .s_axi_rdma_get_wqe_bready             (axi_rdma_get_wqe_bready),
+    .s_axi_rdma_get_wqe_arid               (axi_rdma_get_wqe_arid),
+    .s_axi_rdma_get_wqe_araddr             (axi_rdma_get_wqe_araddr),
+    .s_axi_rdma_get_wqe_arlen              (axi_rdma_get_wqe_arlen),
+    .s_axi_rdma_get_wqe_arsize             (axi_rdma_get_wqe_arsize),
+    .s_axi_rdma_get_wqe_arburst            (axi_rdma_get_wqe_arburst),
+    .s_axi_rdma_get_wqe_arcache            (axi_rdma_get_wqe_arcache),
+    .s_axi_rdma_get_wqe_arprot             (axi_rdma_get_wqe_arprot),
+    .s_axi_rdma_get_wqe_arvalid            (axi_rdma_get_wqe_arvalid),
+    .s_axi_rdma_get_wqe_arready            (axi_rdma_get_wqe_arready),
+    .s_axi_rdma_get_wqe_rid                (axi_rdma_get_wqe_rid),
+    .s_axi_rdma_get_wqe_rdata              (axi_rdma_get_wqe_rdata),
+    .s_axi_rdma_get_wqe_rresp              (axi_rdma_get_wqe_rresp),
+    .s_axi_rdma_get_wqe_rlast              (axi_rdma_get_wqe_rlast),
+    .s_axi_rdma_get_wqe_rvalid             (axi_rdma_get_wqe_rvalid),
+    .s_axi_rdma_get_wqe_rready             (axi_rdma_get_wqe_rready),
+    .s_axi_rdma_get_wqe_arlock             (axi_rdma_get_wqe_arlock),
+    .s_axi_rdma_get_wqe_arqos              (axi_rdma_get_wqe_arqos),
+
+    .s_axi_rdma_get_payload_awid           (axi_rdma_get_payload_awid),
+    .s_axi_rdma_get_payload_awaddr         (axi_rdma_get_payload_awaddr),
+    .s_axi_rdma_get_payload_awqos          (axi_rdma_get_payload_awqos),
+    .s_axi_rdma_get_payload_awlen          (axi_rdma_get_payload_awlen),
+    .s_axi_rdma_get_payload_awsize         (axi_rdma_get_payload_awsize),
+    .s_axi_rdma_get_payload_awburst        (axi_rdma_get_payload_awburst),
+    .s_axi_rdma_get_payload_awcache        (axi_rdma_get_payload_awcache),
+    .s_axi_rdma_get_payload_awprot         (axi_rdma_get_payload_awprot),
+    .s_axi_rdma_get_payload_awvalid        (axi_rdma_get_payload_awvalid),
+    .s_axi_rdma_get_payload_awready        (axi_rdma_get_payload_awready),
+    .s_axi_rdma_get_payload_wdata          (axi_rdma_get_payload_wdata),
+    .s_axi_rdma_get_payload_wstrb          (axi_rdma_get_payload_wstrb),
+    .s_axi_rdma_get_payload_wlast          (axi_rdma_get_payload_wlast),
+    .s_axi_rdma_get_payload_wvalid         (axi_rdma_get_payload_wvalid),
+    .s_axi_rdma_get_payload_wready         (axi_rdma_get_payload_wready),
+    .s_axi_rdma_get_payload_awlock         (axi_rdma_get_payload_awlock),
+    .s_axi_rdma_get_payload_bid            (axi_rdma_get_payload_bid),
+    .s_axi_rdma_get_payload_bresp          (axi_rdma_get_payload_bresp),
+    .s_axi_rdma_get_payload_bvalid         (axi_rdma_get_payload_bvalid),
+    .s_axi_rdma_get_payload_bready         (axi_rdma_get_payload_bready),
+    .s_axi_rdma_get_payload_arid           (axi_rdma_get_payload_arid),
+    .s_axi_rdma_get_payload_araddr         (axi_rdma_get_payload_araddr),
+    .s_axi_rdma_get_payload_arlen          (axi_rdma_get_payload_arlen),
+    .s_axi_rdma_get_payload_arsize         (axi_rdma_get_payload_arsize),
+    .s_axi_rdma_get_payload_arburst        (axi_rdma_get_payload_arburst),
+    .s_axi_rdma_get_payload_arcache        (axi_rdma_get_payload_arcache),
+    .s_axi_rdma_get_payload_arprot         (axi_rdma_get_payload_arprot),
+    .s_axi_rdma_get_payload_arvalid        (axi_rdma_get_payload_arvalid),
+    .s_axi_rdma_get_payload_arready        (axi_rdma_get_payload_arready),
+    .s_axi_rdma_get_payload_rid            (axi_rdma_get_payload_rid),
+    .s_axi_rdma_get_payload_rdata          (axi_rdma_get_payload_rdata),
+    .s_axi_rdma_get_payload_rresp          (axi_rdma_get_payload_rresp),
+    .s_axi_rdma_get_payload_rlast          (axi_rdma_get_payload_rlast),
+    .s_axi_rdma_get_payload_rvalid         (axi_rdma_get_payload_rvalid),
+    .s_axi_rdma_get_payload_rready         (axi_rdma_get_payload_rready),
+    .s_axi_rdma_get_payload_arlock         (axi_rdma_get_payload_arlock),
+    .s_axi_rdma_get_payload_arqos          (axi_rdma_get_payload_arqos),
+
+    .s_axi_rdma_completion_awid            (axi_rdma_completion_awid),
+    .s_axi_rdma_completion_awaddr          (axi_rdma_completion_awaddr),
+    .s_axi_rdma_completion_awqos           (axi_rdma_completion_awqos),
+    .s_axi_rdma_completion_awlen           (axi_rdma_completion_awlen),
+    .s_axi_rdma_completion_awsize          (axi_rdma_completion_awsize),
+    .s_axi_rdma_completion_awburst         (axi_rdma_completion_awburst),
+    .s_axi_rdma_completion_awcache         (axi_rdma_completion_awcache),
+    .s_axi_rdma_completion_awprot          (axi_rdma_completion_awprot),
+    .s_axi_rdma_completion_awvalid         (axi_rdma_completion_awvalid),
+    .s_axi_rdma_completion_awready         (axi_rdma_completion_awready),
+    .s_axi_rdma_completion_wdata           (axi_rdma_completion_wdata),
+    .s_axi_rdma_completion_wstrb           (axi_rdma_completion_wstrb),
+    .s_axi_rdma_completion_wlast           (axi_rdma_completion_wlast),
+    .s_axi_rdma_completion_wvalid          (axi_rdma_completion_wvalid),
+    .s_axi_rdma_completion_wready          (axi_rdma_completion_wready),
+    .s_axi_rdma_completion_awlock          (axi_rdma_completion_awlock),
+    .s_axi_rdma_completion_bid             (axi_rdma_completion_bid),
+    .s_axi_rdma_completion_bresp           (axi_rdma_completion_bresp),
+    .s_axi_rdma_completion_bvalid          (axi_rdma_completion_bvalid),
+    .s_axi_rdma_completion_bready          (axi_rdma_completion_bready),
+    .s_axi_rdma_completion_arid            (axi_rdma_completion_arid),
+    .s_axi_rdma_completion_araddr          (axi_rdma_completion_araddr),
+    .s_axi_rdma_completion_arlen           (axi_rdma_completion_arlen),
+    .s_axi_rdma_completion_arsize          (axi_rdma_completion_arsize),
+    .s_axi_rdma_completion_arburst         (axi_rdma_completion_arburst),
+    .s_axi_rdma_completion_arcache         (axi_rdma_completion_arcache),
+    .s_axi_rdma_completion_arprot          (axi_rdma_completion_arprot),
+    .s_axi_rdma_completion_arvalid         (axi_rdma_completion_arvalid),
+    .s_axi_rdma_completion_arready         (axi_rdma_completion_arready),
+    .s_axi_rdma_completion_rid             (axi_rdma_completion_rid),
+    .s_axi_rdma_completion_rdata           (axi_rdma_completion_rdata),
+    .s_axi_rdma_completion_rresp           (axi_rdma_completion_rresp),
+    .s_axi_rdma_completion_rlast           (axi_rdma_completion_rlast),
+    .s_axi_rdma_completion_rvalid          (axi_rdma_completion_rvalid),
+    .s_axi_rdma_completion_rready          (axi_rdma_completion_rready),
+    .s_axi_rdma_completion_arlock          (axi_rdma_completion_arlock),
+    .s_axi_rdma_completion_arqos           (axi_rdma_completion_arqos),
+
+    .s_axi_rdma_send_write_payload_awid    (axi_rdma_send_write_payload_awid),
+    .s_axi_rdma_send_write_payload_awaddr  (axi_rdma_send_write_payload_awaddr),
+    .s_axi_rdma_send_write_payload_awqos   (axi_rdma_send_write_payload_awqos),
+    .s_axi_rdma_send_write_payload_awlen   (axi_rdma_send_write_payload_awlen),
+    .s_axi_rdma_send_write_payload_awsize  (axi_rdma_send_write_payload_awsize),
+    .s_axi_rdma_send_write_payload_awburst (axi_rdma_send_write_payload_awburst),
+    .s_axi_rdma_send_write_payload_awcache (axi_rdma_send_write_payload_awcache),
+    .s_axi_rdma_send_write_payload_awprot  (axi_rdma_send_write_payload_awprot),
+    .s_axi_rdma_send_write_payload_awvalid (axi_rdma_send_write_payload_awvalid),
+    .s_axi_rdma_send_write_payload_awready (axi_rdma_send_write_payload_awready),
+    .s_axi_rdma_send_write_payload_wdata   (axi_rdma_send_write_payload_wdata),
+    .s_axi_rdma_send_write_payload_wstrb   (axi_rdma_send_write_payload_wstrb),
+    .s_axi_rdma_send_write_payload_wlast   (axi_rdma_send_write_payload_wlast),
+    .s_axi_rdma_send_write_payload_wvalid  (axi_rdma_send_write_payload_wvalid),
+    .s_axi_rdma_send_write_payload_wready  (axi_rdma_send_write_payload_wready),
+    .s_axi_rdma_send_write_payload_awlock  (axi_rdma_send_write_payload_awlock),
+    .s_axi_rdma_send_write_payload_bid     (axi_rdma_send_write_payload_bid),
+    .s_axi_rdma_send_write_payload_bresp   (axi_rdma_send_write_payload_bresp),
+    .s_axi_rdma_send_write_payload_bvalid  (axi_rdma_send_write_payload_bvalid),
+    .s_axi_rdma_send_write_payload_bready  (axi_rdma_send_write_payload_bready),
+    .s_axi_rdma_send_write_payload_arid    (axi_rdma_send_write_payload_arid),
+    .s_axi_rdma_send_write_payload_araddr  (axi_rdma_send_write_payload_araddr),
+    .s_axi_rdma_send_write_payload_arlen   (axi_rdma_send_write_payload_arlen),
+    .s_axi_rdma_send_write_payload_arsize  (axi_rdma_send_write_payload_arsize),
+    .s_axi_rdma_send_write_payload_arburst (axi_rdma_send_write_payload_arburst),
+    .s_axi_rdma_send_write_payload_arcache (axi_rdma_send_write_payload_arcache),
+    .s_axi_rdma_send_write_payload_arprot  (axi_rdma_send_write_payload_arprot),
+    .s_axi_rdma_send_write_payload_arvalid (axi_rdma_send_write_payload_arvalid),
+    .s_axi_rdma_send_write_payload_arready (axi_rdma_send_write_payload_arready),
+    .s_axi_rdma_send_write_payload_rid     (axi_rdma_send_write_payload_rid),
+    .s_axi_rdma_send_write_payload_rdata   (axi_rdma_send_write_payload_rdata),
+    .s_axi_rdma_send_write_payload_rresp   (axi_rdma_send_write_payload_rresp),
+    .s_axi_rdma_send_write_payload_rlast   (axi_rdma_send_write_payload_rlast),
+    .s_axi_rdma_send_write_payload_rvalid  (axi_rdma_send_write_payload_rvalid),
+    .s_axi_rdma_send_write_payload_rready  (axi_rdma_send_write_payload_rready),
+    .s_axi_rdma_send_write_payload_arlock  (axi_rdma_send_write_payload_arlock),
+    .s_axi_rdma_send_write_payload_arqos   (axi_rdma_send_write_payload_arqos),
+
+    .s_axi_rdma_rsp_payload_awid           (axi_rdma_rsp_payload_awid),
+    .s_axi_rdma_rsp_payload_awaddr         (axi_rdma_rsp_payload_awaddr),
+    .s_axi_rdma_rsp_payload_awqos          (axi_rdma_rsp_payload_awqos),
+    .s_axi_rdma_rsp_payload_awlen          (axi_rdma_rsp_payload_awlen),
+    .s_axi_rdma_rsp_payload_awsize         (axi_rdma_rsp_payload_awsize),
+    .s_axi_rdma_rsp_payload_awburst        (axi_rdma_rsp_payload_awburst),
+    .s_axi_rdma_rsp_payload_awcache        (axi_rdma_rsp_payload_awcache),
+    .s_axi_rdma_rsp_payload_awprot         (axi_rdma_rsp_payload_awprot),
+    .s_axi_rdma_rsp_payload_awvalid        (axi_rdma_rsp_payload_awvalid),
+    .s_axi_rdma_rsp_payload_awready        (axi_rdma_rsp_payload_awready),
+    .s_axi_rdma_rsp_payload_wdata          (axi_rdma_rsp_payload_wdata),
+    .s_axi_rdma_rsp_payload_wstrb          (axi_rdma_rsp_payload_wstrb),
+    .s_axi_rdma_rsp_payload_wlast          (axi_rdma_rsp_payload_wlast),
+    .s_axi_rdma_rsp_payload_wvalid         (axi_rdma_rsp_payload_wvalid),
+    .s_axi_rdma_rsp_payload_wready         (axi_rdma_rsp_payload_wready),
+    .s_axi_rdma_rsp_payload_awlock         (axi_rdma_rsp_payload_awlock),
+    .s_axi_rdma_rsp_payload_bid            (axi_rdma_rsp_payload_bid),
+    .s_axi_rdma_rsp_payload_bresp          (axi_rdma_rsp_payload_bresp),
+    .s_axi_rdma_rsp_payload_bvalid         (axi_rdma_rsp_payload_bvalid),
+    .s_axi_rdma_rsp_payload_bready         (axi_rdma_rsp_payload_bready),
+    .s_axi_rdma_rsp_payload_arid           (axi_rdma_rsp_payload_arid),
+    .s_axi_rdma_rsp_payload_araddr         (axi_rdma_rsp_payload_araddr),
+    .s_axi_rdma_rsp_payload_arlen          (axi_rdma_rsp_payload_arlen),
+    .s_axi_rdma_rsp_payload_arsize         (axi_rdma_rsp_payload_arsize),
+    .s_axi_rdma_rsp_payload_arburst        (axi_rdma_rsp_payload_arburst),
+    .s_axi_rdma_rsp_payload_arcache        (axi_rdma_rsp_payload_arcache),
+    .s_axi_rdma_rsp_payload_arprot         (axi_rdma_rsp_payload_arprot),
+    .s_axi_rdma_rsp_payload_arvalid        (axi_rdma_rsp_payload_arvalid),
+    .s_axi_rdma_rsp_payload_arready        (axi_rdma_rsp_payload_arready),
+    .s_axi_rdma_rsp_payload_rid            (axi_rdma_rsp_payload_rid),
+    .s_axi_rdma_rsp_payload_rdata          (axi_rdma_rsp_payload_rdata),
+    .s_axi_rdma_rsp_payload_rresp          (axi_rdma_rsp_payload_rresp),
+    .s_axi_rdma_rsp_payload_rlast          (axi_rdma_rsp_payload_rlast),
+    .s_axi_rdma_rsp_payload_rvalid         (axi_rdma_rsp_payload_rvalid),
+    .s_axi_rdma_rsp_payload_rready         (axi_rdma_rsp_payload_rready),
+    .s_axi_rdma_rsp_payload_arlock         (axi_rdma_rsp_payload_arlock),
+    .s_axi_rdma_rsp_payload_arqos          (axi_rdma_rsp_payload_arqos),
+
+    .m_axi_sys_mem_awaddr                  (axi_sys_mem_awaddr),
+    .m_axi_sys_mem_awprot                  (axi_sys_mem_awprot),
+    .m_axi_sys_mem_awvalid                 (axi_sys_mem_awvalid),
+    .m_axi_sys_mem_awready                 (axi_sys_mem_awready),
+    .m_axi_sys_mem_awsize                  (axi_sys_mem_awsize),
+    .m_axi_sys_mem_awburst                 (axi_sys_mem_awburst),
+    .m_axi_sys_mem_awcache                 (axi_sys_mem_awcache),
+    .m_axi_sys_mem_awlen                   (axi_sys_mem_awlen),
+    .m_axi_sys_mem_awlock                  (axi_sys_mem_awlock),
+    .m_axi_sys_mem_awqos                   (axi_sys_mem_awqos),
+    .m_axi_sys_mem_awregion                (axi_sys_mem_awregion),
+    .m_axi_sys_mem_awid                    (axi_sys_mem_awid),
+    .m_axi_sys_mem_wdata                   (axi_sys_mem_wdata),
+    .m_axi_sys_mem_wstrb                   (axi_sys_mem_wstrb),
+    .m_axi_sys_mem_wvalid                  (axi_sys_mem_wvalid),
+    .m_axi_sys_mem_wready                  (axi_sys_mem_wready),
+    .m_axi_sys_mem_wlast                   (axi_sys_mem_wlast),
+    .m_axi_sys_mem_bresp                   (axi_sys_mem_bresp),
+    .m_axi_sys_mem_bvalid                  (axi_sys_mem_bvalid),
+    .m_axi_sys_mem_bready                  (axi_sys_mem_bready),
+    .m_axi_sys_mem_bid                     (axi_sys_mem_bid[2:0]),
+    .m_axi_sys_mem_araddr                  (axi_sys_mem_araddr),
+    .m_axi_sys_mem_arprot                  (axi_sys_mem_arprot),
+    .m_axi_sys_mem_arvalid                 (axi_sys_mem_arvalid),
+    .m_axi_sys_mem_arready                 (axi_sys_mem_arready),
+    .m_axi_sys_mem_arsize                  (axi_sys_mem_arsize),
+    .m_axi_sys_mem_arburst                 (axi_sys_mem_arburst),
+    .m_axi_sys_mem_arcache                 (axi_sys_mem_arcache),
+    .m_axi_sys_mem_arlock                  (axi_sys_mem_arlock),
+    .m_axi_sys_mem_arlen                   (axi_sys_mem_arlen),
+    .m_axi_sys_mem_arqos                   (axi_sys_mem_arqos),
+    .m_axi_sys_mem_arregion                (axi_sys_mem_arregion),
+    .m_axi_sys_mem_arid                    (axi_sys_mem_arid),
+    .m_axi_sys_mem_rdata                   (axi_sys_mem_rdata),
+    .m_axi_sys_mem_rresp                   (axi_sys_mem_rresp),
+    .m_axi_sys_mem_rvalid                  (axi_sys_mem_rvalid),
+    .m_axi_sys_mem_rready                  (axi_sys_mem_rready),
+    .m_axi_sys_mem_rlast                   (axi_sys_mem_rlast),
+    .m_axi_sys_mem_rid                     (axi_sys_mem_rid[2:0]),
+
+    .m_axi_sys_to_dev_crossbar_awaddr      (axi_from_sys_to_dev_crossbar_awaddr),
+    .m_axi_sys_to_dev_crossbar_awprot      (axi_from_sys_to_dev_crossbar_awprot),
+    .m_axi_sys_to_dev_crossbar_awvalid     (axi_from_sys_to_dev_crossbar_awvalid),
+    .m_axi_sys_to_dev_crossbar_awready     (axi_from_sys_to_dev_crossbar_awready),
+    .m_axi_sys_to_dev_crossbar_awsize      (axi_from_sys_to_dev_crossbar_awsize),
+    .m_axi_sys_to_dev_crossbar_awburst     (axi_from_sys_to_dev_crossbar_awburst),
+    .m_axi_sys_to_dev_crossbar_awcache     (axi_from_sys_to_dev_crossbar_awcache),
+    .m_axi_sys_to_dev_crossbar_awlen       (axi_from_sys_to_dev_crossbar_awlen),
+    .m_axi_sys_to_dev_crossbar_awlock      (axi_from_sys_to_dev_crossbar_awlock),
+    .m_axi_sys_to_dev_crossbar_awqos       (axi_from_sys_to_dev_crossbar_awqos),
+    .m_axi_sys_to_dev_crossbar_awregion    (axi_from_sys_to_dev_crossbar_awregion),
+    .m_axi_sys_to_dev_crossbar_awid        (axi_from_sys_to_dev_crossbar_awid),
+    .m_axi_sys_to_dev_crossbar_wdata       (axi_from_sys_to_dev_crossbar_wdata),
+    .m_axi_sys_to_dev_crossbar_wstrb       (axi_from_sys_to_dev_crossbar_wstrb),
+    .m_axi_sys_to_dev_crossbar_wvalid      (axi_from_sys_to_dev_crossbar_wvalid),
+    .m_axi_sys_to_dev_crossbar_wready      (axi_from_sys_to_dev_crossbar_wready),
+    .m_axi_sys_to_dev_crossbar_wlast       (axi_from_sys_to_dev_crossbar_wlast),
+    .m_axi_sys_to_dev_crossbar_bresp       (axi_from_sys_to_dev_crossbar_bresp),
+    .m_axi_sys_to_dev_crossbar_bvalid      (axi_from_sys_to_dev_crossbar_bvalid),
+    .m_axi_sys_to_dev_crossbar_bready      (axi_from_sys_to_dev_crossbar_bready),
+    .m_axi_sys_to_dev_crossbar_bid         (axi_from_sys_to_dev_crossbar_bid[2:0]),
+    .m_axi_sys_to_dev_crossbar_araddr      (axi_from_sys_to_dev_crossbar_araddr),
+    .m_axi_sys_to_dev_crossbar_arprot      (axi_from_sys_to_dev_crossbar_arprot),
+    .m_axi_sys_to_dev_crossbar_arvalid     (axi_from_sys_to_dev_crossbar_arvalid),
+    .m_axi_sys_to_dev_crossbar_arready     (axi_from_sys_to_dev_crossbar_arready),
+    .m_axi_sys_to_dev_crossbar_arsize      (axi_from_sys_to_dev_crossbar_arsize),
+    .m_axi_sys_to_dev_crossbar_arburst     (axi_from_sys_to_dev_crossbar_arburst),
+    .m_axi_sys_to_dev_crossbar_arcache     (axi_from_sys_to_dev_crossbar_arcache),
+    .m_axi_sys_to_dev_crossbar_arlock      (axi_from_sys_to_dev_crossbar_arlock),
+    .m_axi_sys_to_dev_crossbar_arlen       (axi_from_sys_to_dev_crossbar_arlen),
+    .m_axi_sys_to_dev_crossbar_arqos       (axi_from_sys_to_dev_crossbar_arqos),
+    .m_axi_sys_to_dev_crossbar_arregion    (axi_from_sys_to_dev_crossbar_arregion),
+    .m_axi_sys_to_dev_crossbar_arid        (axi_from_sys_to_dev_crossbar_arid),
+    .m_axi_sys_to_dev_crossbar_rdata       (axi_from_sys_to_dev_crossbar_rdata),
+    .m_axi_sys_to_dev_crossbar_rresp       (axi_from_sys_to_dev_crossbar_rresp),
+    .m_axi_sys_to_dev_crossbar_rvalid      (axi_from_sys_to_dev_crossbar_rvalid),
+    .m_axi_sys_to_dev_crossbar_rready      (axi_from_sys_to_dev_crossbar_rready),
+    .m_axi_sys_to_dev_crossbar_rlast       (axi_from_sys_to_dev_crossbar_rlast),
+    .m_axi_sys_to_dev_crossbar_rid         (axi_from_sys_to_dev_crossbar_rid[2:0]),
+
+    .axis_aclk                             (axis_aclk),
+    .axis_arestn                           (qdma_rstn)
+);
+
+  hbm_bd_wrapper hbm_inst (
+    .s_axi_hbm_araddr                    (axi_dev_mem_araddr),
+    .s_axi_hbm_arburst                   (axi_dev_mem_arburst),
+    .s_axi_hbm_arcache                   (axi_dev_mem_arcache),
+    .s_axi_hbm_arid                      (axi_dev_mem_arid),
+    .s_axi_hbm_arlen                     (axi_dev_mem_arlen),
+    .s_axi_hbm_arlock                    (axi_dev_mem_arlock),
+    .s_axi_hbm_arprot                    (axi_dev_mem_arprot),
+    .s_axi_hbm_arqos                     (axi_dev_mem_arqos),
+    .s_axi_hbm_arready                   (axi_dev_mem_arready),
+    .s_axi_hbm_arsize                    (axi_dev_mem_arsize),
+    .s_axi_hbm_aruser                    (axi_dev_mem_aruser),
+    .s_axi_hbm_arvalid                   (axi_dev_mem_arvalid),
+    .s_axi_hbm_awaddr                    (axi_dev_mem_awaddr),
+    .s_axi_hbm_awburst                   (axi_dev_mem_awburst),
+    .s_axi_hbm_awcache                   (axi_dev_mem_awcache),
+    .s_axi_hbm_awid                      (axi_dev_mem_awid),
+    .s_axi_hbm_awlen                     (axi_dev_mem_awlen),
+    .s_axi_hbm_awlock                    (axi_dev_mem_awlock),
+    .s_axi_hbm_awprot                    (axi_dev_mem_awprot),
+    .s_axi_hbm_awqos                     (axi_dev_mem_awqos),
+    .s_axi_hbm_awready                   (axi_dev_mem_awready),
+    .s_axi_hbm_awsize                    (axi_dev_mem_awsize),
+    .s_axi_hbm_awuser                    (axi_dev_mem_awuser),
+    .s_axi_hbm_awvalid                   (axi_dev_mem_awvalid),
+    .s_axi_hbm_bid                       (axi_dev_mem_bid),
+    .s_axi_hbm_bready                    (axi_dev_mem_bready),
+    .s_axi_hbm_bresp                     (axi_dev_mem_bresp),
+    .s_axi_hbm_bvalid                    (axi_dev_mem_bvalid),
+    .s_axi_hbm_rdata                     (axi_dev_mem_rdata),
+    .s_axi_hbm_rid                       (axi_dev_mem_rid),
+    .s_axi_hbm_rlast                     (axi_dev_mem_rlast),
+    .s_axi_hbm_rready                    (axi_dev_mem_rready),
+    .s_axi_hbm_rresp                     (axi_dev_mem_rresp),
+    .s_axi_hbm_rvalid                    (axi_dev_mem_rvalid),
+    .s_axi_hbm_wdata                     (axi_dev_mem_wdata),
+    .s_axi_hbm_wlast                     (axi_dev_mem_wlast),
+    .s_axi_hbm_wready                    (axi_dev_mem_wready),
+    .s_axi_hbm_wstrb                     (axi_dev_mem_wstrb),
+    .s_axi_hbm_wuser                     (axi_dev_mem_wuser),
+    .s_axi_hbm_wvalid                    (axi_dev_mem_wvalid),
+
+    .axi_clk                             (axis_aclk),
+    .axi_resetn                          (powerup_rstn),
+    .hbm_ref_clk                         (hbm_ref_clk)
+  );
+
+  // User logic boxes
   box_250mhz #(
     .MIN_PKT_LEN   (MIN_PKT_LEN),
     .MAX_PKT_LEN   (MAX_PKT_LEN),
@@ -846,14 +2210,104 @@ module open_nic_shell #(
     .s_axis_adap_rx_250mhz_tuser_dst  (axis_adap_rx_250mhz_tuser_dst),
     .s_axis_adap_rx_250mhz_tready     (axis_adap_rx_250mhz_tready),
 
-    .mod_rstn                         (user_250mhz_rstn),
-    .mod_rst_done                     (user_250mhz_rst_done),
-
-    .box_rstn                         (box_250mhz_rstn),
-    .box_rst_done                     (box_250mhz_rst_done),
-
-    .axil_aclk                        (axil_aclk),
-    .axis_aclk                        (axis_aclk)
+    // RoCEv2 packets from user logic box to rdma
+    .m_axis_user2rdma_roce_from_cmac_rx_tvalid (cmac2rdma_roce_axis_tvalid),
+    .m_axis_user2rdma_roce_from_cmac_rx_tdata  (cmac2rdma_roce_axis_tdata),
+    .m_axis_user2rdma_roce_from_cmac_rx_tkeep  (cmac2rdma_roce_axis_tkeep),
+    .m_axis_user2rdma_roce_from_cmac_rx_tlast  (cmac2rdma_roce_axis_tlast),
+    .m_axis_user2rdma_roce_from_cmac_rx_tready (cmac2rdma_roce_axis_tready),
+
+    // packets from rdma to user logic
+    .s_axis_rdma2user_to_cmac_tx_tvalid        (rdma2cmac_axis_tvalid),
+    .s_axis_rdma2user_to_cmac_tx_tdata         (rdma2cmac_axis_tdata),
+    .s_axis_rdma2user_to_cmac_tx_tkeep         (rdma2cmac_axis_tkeep),
+    .s_axis_rdma2user_to_cmac_tx_tlast         (rdma2cmac_axis_tlast),
+    .s_axis_rdma2user_to_cmac_tx_tready        (rdma2cmac_axis_tready),
+
+    // packets from user logic to rdma
+    .m_axis_user2rdma_from_qdma_tx_tvalid      (qdma2rdma_non_roce_axis_tvalid),
+    .m_axis_user2rdma_from_qdma_tx_tdata       (qdma2rdma_non_roce_axis_tdata),
+    .m_axis_user2rdma_from_qdma_tx_tkeep       (qdma2rdma_non_roce_axis_tkeep),
+    .m_axis_user2rdma_from_qdma_tx_tlast       (qdma2rdma_non_roce_axis_tlast),
+    .m_axis_user2rdma_from_qdma_tx_tready      (qdma2rdma_non_roce_axis_tready),
+
+    // ieth or immdt data from rdma packets
+    .s_axis_rdma2user_ieth_immdt_tdata         (rdma2user_ieth_immdt_axis_tdata),
+    .s_axis_rdma2user_ieth_immdt_tlast         (rdma2user_ieth_immdt_axis_tlast),
+    .s_axis_rdma2user_ieth_immdt_tvalid        (rdma2user_ieth_immdt_axis_tvalid),
+    .s_axis_rdma2user_ieth_immdt_trdy          (rdma2user_ieth_immdt_axis_trdy),
+
+    // HW handshaking from user logic: Send WQE completion queue doorbell
+    .s_resp_hndler_i_send_cq_db_cnt_valid(resp_hndler_o_send_cq_db_cnt_valid),
+    .s_resp_hndler_i_send_cq_db_addr     (resp_hndler_o_send_cq_db_addr),
+    .s_resp_hndler_i_send_cq_db_cnt      (resp_hndler_o_send_cq_db_cnt),
+    .s_resp_hndler_o_send_cq_db_rdy      (resp_hndler_i_send_cq_db_rdy),
+
+    // HW handshaking from user logic: Send WQE producer index doorbell
+    .m_o_qp_sq_pidb_hndshk               (i_qp_sq_pidb_hndshk),
+    .m_o_qp_sq_pidb_wr_addr_hndshk       (i_qp_sq_pidb_wr_addr_hndshk),
+    .m_o_qp_sq_pidb_wr_valid_hndshk      (i_qp_sq_pidb_wr_valid_hndshk),
+    .m_i_qp_sq_pidb_wr_rdy               (o_qp_sq_pidb_wr_rdy),
+
+    // HW handshaking from user logic: RDMA-Send consumer index doorbell
+    .m_o_qp_rq_cidb_hndshk               (i_qp_rq_cidb_hndshk),
+    .m_o_qp_rq_cidb_wr_addr_hndshk       (i_qp_rq_cidb_wr_addr_hndshk),
+    .m_o_qp_rq_cidb_wr_valid_hndshk      (i_qp_rq_cidb_wr_valid_hndshk),
+    .m_i_qp_rq_cidb_wr_rdy               (o_qp_rq_cidb_wr_rdy),
+
+    // HW handshaking from user logic: RDMA-Send producer index doorbell
+    .s_rx_pkt_hndler_i_rq_db_data        (rx_pkt_hndler_o_rq_db_data),
+    .s_rx_pkt_hndler_i_rq_db_addr        (rx_pkt_hndler_o_rq_db_addr),
+    .s_rx_pkt_hndler_i_rq_db_data_valid  (rx_pkt_hndler_o_rq_db_data_valid),
+    .s_rx_pkt_hndler_o_rq_db_rdy         (rx_pkt_hndler_i_rq_db_rdy),
+
+    // AXI interface from the Compute Logic
+    .m_axi_compute_logic_awid            (axi_compute_logic_awid),
+    .m_axi_compute_logic_awaddr          (axi_compute_logic_awaddr),
+    .m_axi_compute_logic_awqos           (axi_compute_logic_awqos),
+    .m_axi_compute_logic_awlen           (axi_compute_logic_awlen),
+    .m_axi_compute_logic_awsize          (axi_compute_logic_awsize),
+    .m_axi_compute_logic_awburst         (axi_compute_logic_awburst),
+    .m_axi_compute_logic_awcache         (axi_compute_logic_awcache),
+    .m_axi_compute_logic_awprot          (axi_compute_logic_awprot),
+    .m_axi_compute_logic_awvalid         (axi_compute_logic_awvalid),
+    .m_axi_compute_logic_awready         (axi_compute_logic_awready),
+    .m_axi_compute_logic_wdata           (axi_compute_logic_wdata),
+    .m_axi_compute_logic_wstrb           (axi_compute_logic_wstrb),
+    .m_axi_compute_logic_wlast           (axi_compute_logic_wlast),
+    .m_axi_compute_logic_wvalid          (axi_compute_logic_wvalid),
+    .m_axi_compute_logic_wready          (axi_compute_logic_wready),
+    .m_axi_compute_logic_awlock          (axi_compute_logic_awlock),
+    .m_axi_compute_logic_bid             (axi_compute_logic_bid),
+    .m_axi_compute_logic_bresp           (axi_compute_logic_bresp),
+    .m_axi_compute_logic_bvalid          (axi_compute_logic_bvalid),
+    .m_axi_compute_logic_bready          (axi_compute_logic_bready),
+    .m_axi_compute_logic_arid            (axi_compute_logic_arid),
+    .m_axi_compute_logic_araddr          (axi_compute_logic_araddr),
+    .m_axi_compute_logic_arlen           (axi_compute_logic_arlen),
+    .m_axi_compute_logic_arsize          (axi_compute_logic_arsize),
+    .m_axi_compute_logic_arburst         (axi_compute_logic_arburst),
+    .m_axi_compute_logic_arcache         (axi_compute_logic_arcache),
+    .m_axi_compute_logic_arprot          (axi_compute_logic_arprot),
+    .m_axi_compute_logic_arvalid         (axi_compute_logic_arvalid),
+    .m_axi_compute_logic_arready         (axi_compute_logic_arready),
+    .m_axi_compute_logic_rid             (axi_compute_logic_rid),
+    .m_axi_compute_logic_rdata           (axi_compute_logic_rdata),
+    .m_axi_compute_logic_rresp           (axi_compute_logic_rresp),
+    .m_axi_compute_logic_rlast           (axi_compute_logic_rlast),
+    .m_axi_compute_logic_rvalid          (axi_compute_logic_rvalid),
+    .m_axi_compute_logic_rready          (axi_compute_logic_rready),
+    .m_axi_compute_logic_arlock          (axi_compute_logic_arlock),
+    .m_axi_compute_logic_arqos           (axi_compute_logic_arqos),
+
+    .mod_rstn     (user_250mhz_rstn),
+    .mod_rst_done (user_250mhz_rst_done),
+
+    .box_rstn     (box_250mhz_rstn),
+    .box_rst_done (box_250mhz_rst_done),
+
+    .axil_aclk    (axil_aclk),
+    .axis_aclk    (axis_aclk)
   );
 
   box_322mhz #(
@@ -914,4 +2368,25 @@ module open_nic_shell #(
     .cmac_clk                        (cmac_clk)
   );
 
-endmodule: open_nic_shell
+  assign axi_rdma_send_write_payload_awqos = 16'd0;
+  assign axi_rdma_send_write_payload_arqos = 16'd0;
+  assign axi_rdma_rsp_payload_awqos = 4'd0;
+  assign axi_rdma_rsp_payload_arqos = 4'd0;
+  assign axi_qdma_mm_awqos  = 4'd0;
+  assign axi_qdma_mm_arqos  = 4'd0;
+
+  assign axi_rdma_get_wqe_awqos     = 4'd0;
+  assign axi_rdma_get_wqe_arqos     = 4'd0;
+  assign axi_rdma_get_payload_awqos = 4'd0;
+  assign axi_rdma_get_payload_arqos = 4'd0;
+  assign axi_rdma_completion_awqos  = 4'd0;
+  assign axi_rdma_completion_arqos  = 4'd0;
+
+  assign cmac2rdma_roce_axis_tready = 1'b1;
+  assign cmac2rdma_roce_axis_tuser  = 1'b1;
+
+  assign axi_sys_mem_wuser  = 64'd0;
+  assign axi_sys_mem_aruser = 12'd0;
+  assign axi_sys_mem_awuser = 12'd0;
+
+endmodule: open_nic_shell
\ No newline at end of file
diff --git a/src/packet_adapter/packet_adapter_register.v b/src/packet_adapter/packet_adapter_register.v
index 7ce55e9..2543c1a 100644
--- a/src/packet_adapter/packet_adapter_register.v
+++ b/src/packet_adapter/packet_adapter_register.v
@@ -140,7 +140,7 @@ module packet_adapter_register (
     .DATA_W        (32)
   ) axil_reg_inst (
     .s_axil_awvalid (s_axil_awvalid),
-    .s_axil_awaddr  (s_axil_awaddr),
+    .s_axil_awaddr  (s_axil_awaddr[C_ADDR_W-1:0]),
     .s_axil_awready (s_axil_awready),
     .s_axil_wvalid  (s_axil_wvalid),
     .s_axil_wdata   (s_axil_wdata),
@@ -149,7 +149,7 @@ module packet_adapter_register (
     .s_axil_bresp   (s_axil_bresp),
     .s_axil_bready  (s_axil_bready),
     .s_axil_arvalid (s_axil_arvalid),
-    .s_axil_araddr  (s_axil_araddr),
+    .s_axil_araddr  (s_axil_araddr[C_ADDR_W-1:0]),
     .s_axil_arready (s_axil_arready),
     .s_axil_rvalid  (s_axil_rvalid),
     .s_axil_rdata   (s_axil_rdata),
diff --git a/src/qdma_subsystem/qdma_subsystem.sv b/src/qdma_subsystem/qdma_subsystem.sv
index e46dcb9..be57a06 100644
--- a/src/qdma_subsystem/qdma_subsystem.sv
+++ b/src/qdma_subsystem/qdma_subsystem.sv
@@ -59,7 +59,46 @@ module qdma_subsystem #(
   input   [16*NUM_PHYS_FUNC-1:0] s_axis_c2h_tuser_dst,
   output     [NUM_PHYS_FUNC-1:0] s_axis_c2h_tready,
 
-`ifdef __synthesis__
+  // QDMA DMA Engine - AXI MM interface
+  input                          m_axi_awready,
+  input                          m_axi_wready,
+  input                  [3:0]   m_axi_bid,
+  input                  [1:0]   m_axi_bresp,
+  input                          m_axi_bvalid,
+  input                          m_axi_arready,
+  input                  [3:0]   m_axi_rid,
+  input                  [511:0] m_axi_rdata,
+  input                  [1:0]   m_axi_rresp,
+  input                          m_axi_rlast,
+  input                          m_axi_rvalid,
+  output                 [3:0]   m_axi_awid,
+  output                 [63:0]  m_axi_awaddr,
+  output                 [31:0]  m_axi_awuser,
+  output                 [7:0]   m_axi_awlen,
+  output                 [2:0]   m_axi_awsize,
+  output                 [1:0]   m_axi_awburst,
+  output                 [2:0]   m_axi_awprot,
+  output                         m_axi_awvalid,
+  output                         m_axi_awlock,
+  output                 [3:0]   m_axi_awcache,
+  output                 [511:0] m_axi_wdata,
+  output                 [63:0]  m_axi_wuser,
+  output                 [63:0]  m_axi_wstrb,
+  output                         m_axi_wlast,
+  output                         m_axi_wvalid,
+  output                         m_axi_bready,
+  output                 [3:0]   m_axi_arid,
+  output                 [63:0]  m_axi_araddr,
+  output                 [31:0]  m_axi_aruser,
+  output                 [7:0]   m_axi_arlen,
+  output                 [2:0]   m_axi_arsize,
+  output                 [1:0]   m_axi_arburst,
+  output                 [2:0]   m_axi_arprot,
+  output                         m_axi_arvalid,
+  output                         m_axi_arlock,
+  output                 [3:0]   m_axi_arcache,
+  output                         m_axi_rready,
+
   input                   [15:0] pcie_rxp,
   input                   [15:0] pcie_rxn,
   output                  [15:0] pcie_txp,
@@ -93,58 +132,86 @@ module qdma_subsystem #(
   // routed into the `system_config` submodule to generate proper reset signals
   // for each submodule.
   output                         powerup_rstn,
-`else // !`ifdef __synthesis__
-  input                          s_axis_qdma_h2c_tvalid,
-  input                  [511:0] s_axis_qdma_h2c_tdata,
-  input                   [31:0] s_axis_qdma_h2c_tcrc,
-  input                          s_axis_qdma_h2c_tlast,
-  input                   [10:0] s_axis_qdma_h2c_tuser_qid,
-  input                    [2:0] s_axis_qdma_h2c_tuser_port_id,
-  input                          s_axis_qdma_h2c_tuser_err,
-  input                   [31:0] s_axis_qdma_h2c_tuser_mdata,
-  input                    [5:0] s_axis_qdma_h2c_tuser_mty,
-  input                          s_axis_qdma_h2c_tuser_zero_byte,
-  output                         s_axis_qdma_h2c_tready,
-
-  output                         m_axis_qdma_c2h_tvalid,
-  output                 [511:0] m_axis_qdma_c2h_tdata,
-  output                  [31:0] m_axis_qdma_c2h_tcrc,
-  output                         m_axis_qdma_c2h_tlast,
-  output                         m_axis_qdma_c2h_ctrl_marker,
-  output                   [2:0] m_axis_qdma_c2h_ctrl_port_id,
-  output                   [6:0] m_axis_qdma_c2h_ctrl_ecc,
-  output                  [15:0] m_axis_qdma_c2h_ctrl_len,
-  output                  [10:0] m_axis_qdma_c2h_ctrl_qid,
-  output                         m_axis_qdma_c2h_ctrl_has_cmpt,
-  output                   [5:0] m_axis_qdma_c2h_mty,
-  input                          m_axis_qdma_c2h_tready,
-
-  output                         m_axis_qdma_cpl_tvalid,
-  output                 [511:0] m_axis_qdma_cpl_tdata,
-  output                   [1:0] m_axis_qdma_cpl_size,
-  output                  [15:0] m_axis_qdma_cpl_dpar,
-  output                  [10:0] m_axis_qdma_cpl_ctrl_qid,
-  output                   [1:0] m_axis_qdma_cpl_ctrl_cmpt_type,
-  output                  [15:0] m_axis_qdma_cpl_ctrl_wait_pld_pkt_id,
-  output                   [2:0] m_axis_qdma_cpl_ctrl_port_id,
-  output                         m_axis_qdma_cpl_ctrl_marker,
-  output                         m_axis_qdma_cpl_ctrl_user_trig,
-  output                   [2:0] m_axis_qdma_cpl_ctrl_col_idx,
-  output                   [2:0] m_axis_qdma_cpl_ctrl_err_idx,
-  output                         m_axis_qdma_cpl_ctrl_no_wrb_marker,
-  input                          m_axis_qdma_cpl_tready,
-`endif
+
+  // QDMA control/status register interface
+  output                         s_csr_prog_done,
+  input                   [31:0] s_axil_csr_awaddr,
+  input                    [2:0] s_axil_csr_awprot,
+  input                          s_axil_csr_awvalid,
+  output                         s_axil_csr_awready,
+  input                   [31:0] s_axil_csr_wdata,
+  input                   [3:0]  s_axil_csr_wstrb,
+  input                          s_axil_csr_wvalid,
+  output                         s_axil_csr_wready,
+  output                         s_axil_csr_bvalid,
+  output                   [1:0] s_axil_csr_bresp,
+  input                          s_axil_csr_bready,
+  input                   [31:0] s_axil_csr_araddr,
+  input                    [2:0] s_axil_csr_arprot,
+  input                          s_axil_csr_arvalid,
+  output                         s_axil_csr_arready,
+  output                  [31:0] s_axil_csr_rdata,
+  output                   [1:0] s_axil_csr_rresp,
+  output                         s_axil_csr_rvalid,
+  input                          s_axil_csr_rready,
+
+  // QDMA bridge slave interface
+  input                    [3:0] s_axib_awid,
+  input                   [63:0] s_axib_awaddr,
+  input                    [3:0] s_axib_awregion,
+  input                    [7:0] s_axib_awlen,
+  input                    [2:0] s_axib_awsize,
+  input                    [1:0] s_axib_awburst,
+  input                          s_axib_awvalid,
+  input                  [511:0] s_axib_wdata,
+  input                   [63:0] s_axib_wstrb,
+  input                          s_axib_wlast,
+  input                          s_axib_wvalid,
+  input                   [63:0] s_axib_wuser,
+  output                  [63:0] s_axib_ruser,
+  input                          s_axib_bready,
+  input                    [3:0] s_axib_arid,
+  input                   [63:0] s_axib_araddr,
+  input                   [11:0] s_axib_aruser,
+  input                   [11:0] s_axib_awuser,
+  input                    [3:0] s_axib_arregion,
+  input                    [7:0] s_axib_arlen,
+  input                    [2:0] s_axib_arsize,
+  input                    [1:0] s_axib_arburst,
+  input                          s_axib_arvalid,
+  input                          s_axib_rready,
+  output                         s_axib_awready,
+  output                         s_axib_wready,
+  output                   [3:0] s_axib_bid,
+  output                   [1:0] s_axib_bresp,
+  output                         s_axib_bvalid,
+  output                         s_axib_arready,
+  output                   [3:0] s_axib_rid,
+  output                 [511:0] s_axib_rdata,
+  output                   [1:0] s_axib_rresp,
+  output                         s_axib_rlast,
+  output                         s_axib_rvalid,
 
   input                          mod_rstn,
   output                         mod_rst_done,
 
-`ifdef __synthesis__
+`ifdef __au55n__
+  output                        ref_clk_100mhz,
+`elsif __au55c__
+  output                        ref_clk_100mhz,
+`elsif __au50__
+  output                        ref_clk_100mhz,
+`elsif __au280__
+  output                        ref_clk_100mhz,
+`endif
+
+// `ifdef __synthesis__
   output                         axil_aclk,
   output                         axis_aclk
-`else
-  output reg                     axil_aclk,
-  output reg                     axis_aclk
-`endif
+// `else
+//   output reg                     axil_aclk,
+//   output reg                     axis_aclk
+// `endif
 );
 
   wire         axis_qdma_h2c_tvalid;
@@ -172,6 +239,47 @@ module qdma_subsystem #(
   wire   [5:0] axis_qdma_c2h_mty;
   wire         axis_qdma_c2h_tready;
 
+  /*
+  wire         axi_qdma_mm_awready;
+  wire         axi_qdma_mm_wready;
+  wire [3:0]   axi_qdma_mm_bid;
+  wire [1:0]   axi_qdma_mm_bresp;
+  wire         axi_qdma_mm_bvalid;
+  wire         axi_qdma_mm_arready;
+  wire [3:0]   axi_qdma_mm_rid;
+  wire [511:0] axi_qdma_mm_rdata;
+  wire [1:0]   axi_qdma_mm_rresp;
+  wire         axi_qdma_mm_rlast;
+  wire         axi_qdma_mm_rvalid;
+  wire [3:0]   axi_qdma_mm_awid;
+  wire [63:0]  axi_qdma_mm_awaddr;
+  wire [31:0]  axi_qdma_mm_awuser;
+  wire [7:0]   axi_qdma_mm_awlen;
+  wire [2:0]   axi_qdma_mm_awsize;
+  wire [1:0]   axi_qdma_mm_awburst;
+  wire [2:0]   axi_qdma_mm_awprot;
+  wire         axi_qdma_mm_awvalid;
+  wire         axi_qdma_mm_awlock;
+  wire [3:0]   axi_qdma_mm_awcache;
+  wire [511:0] axi_qdma_mm_wdata;
+  wire [63:0]  axi_qdma_mm_wuser;
+  wire [63:0]  axi_qdma_mm_wstrb;
+  wire         axi_qdma_mm_wlast;
+  wire         axi_qdma_mm_wvalid;
+  wire         axi_qdma_mm_bready;
+  wire [3:0]   axi_qdma_mm_arid;
+  wire [63:0]  axi_qdma_mm_araddr;
+  wire [31:0]  axi_qdma_mm_aruser;
+  wire [7:0]   axi_qdma_mm_arlen;
+  wire [2:0]   axi_qdma_mm_arsize;
+  wire [1:0]   axi_qdma_mm_arburst;
+  wire [2:0]   axi_qdma_mm_arprot;
+  wire         axi_qdma_mm_arvalid;
+  wire         axi_qdma_mm_arlock;
+  wire [3:0]   axi_qdma_mm_arcache;
+  wire         axi_qdma_mm_rready;
+  */
+
   wire         axis_qdma_cpl_tvalid;
   wire [511:0] axis_qdma_cpl_tdata;
   wire   [1:0] axis_qdma_cpl_size;
@@ -214,6 +322,20 @@ module qdma_subsystem #(
   wire         h2c_byp_in_st_no_dma;
   wire         h2c_byp_in_st_rdy;
 
+  wire  [63:0] h2c_byp_in_mm_radr;
+  wire  [63:0] h2c_byp_in_mm_wadr;
+  wire  [15:0] h2c_byp_in_mm_len;
+  wire         h2c_byp_in_mm_mrkr_req;
+  wire  [2:0]  h2c_byp_in_mm_port_id;
+  wire         h2c_byp_in_mm_sdi;
+  wire  [10:0] h2c_byp_in_mm_qid;
+  wire         h2c_byp_in_mm_error;
+  wire  [7:0]  h2c_byp_in_mm_func;
+  wire  [15:0] h2c_byp_in_mm_cidx;
+  wire         h2c_byp_in_mm_no_dma;
+  wire         h2c_byp_in_mm_vld;
+  wire         h2c_byp_in_mm_rdy;
+
   wire         c2h_byp_out_vld;
   wire [255:0] c2h_byp_out_dsc;
   wire         c2h_byp_out_st_mm;
@@ -236,6 +358,20 @@ module qdma_subsystem #(
   wire   [6:0] c2h_byp_in_st_csh_pfch_tag;
   wire         c2h_byp_in_st_csh_rdy;
 
+  wire  [63:0] c2h_byp_in_mm_radr;
+  wire  [63:0] c2h_byp_in_mm_wadr;
+  wire  [15:0] c2h_byp_in_mm_len;
+  wire         c2h_byp_in_mm_mrkr_req;
+  wire  [2:0]  c2h_byp_in_mm_port_id;
+  wire         c2h_byp_in_mm_sdi;
+  wire  [10:0] c2h_byp_in_mm_qid;
+  wire         c2h_byp_in_mm_error;
+  wire  [7:0]  c2h_byp_in_mm_func;
+  wire  [15:0] c2h_byp_in_mm_cidx;
+  wire         c2h_byp_in_mm_vld;
+  wire         c2h_byp_in_mm_no_dma;
+  wire         c2h_byp_in_mm_rdy;
+
   wire         axil_aresetn;
 
   // Reset is clocked by the 125MHz AXI-Lite clock
@@ -249,7 +385,6 @@ module qdma_subsystem #(
     .rstn         (axil_aresetn)
   );
 
-`ifdef __synthesis__
   wire         pcie_refclk_gt;
   wire         pcie_refclk;
 
@@ -276,6 +411,19 @@ module qdma_subsystem #(
   assign h2c_byp_in_st_cidx         = 0;
   assign h2c_byp_in_st_no_dma       = 1'b0;
 
+  assign h2c_byp_in_mm_radr         = 0;
+  assign h2c_byp_in_mm_wadr         = 0;
+  assign h2c_byp_in_mm_len          = 0;
+  assign h2c_byp_in_mm_mrkr_req     = 1'b0;
+  assign h2c_byp_in_mm_port_id      = 0;
+  assign h2c_byp_in_mm_sdi          = 1'b0;
+  assign h2c_byp_in_mm_qid          = 0;
+  assign h2c_byp_in_mm_error        = 1'b0;
+  assign h2c_byp_in_mm_func         = 0;
+  assign h2c_byp_in_mm_cidx         = 0;
+  assign h2c_byp_in_mm_no_dma       = 1'b0;
+  assign h2c_byp_in_mm_vld          = 1'b0;
+
   assign c2h_byp_out_rdy            = 1'b1;
   assign c2h_byp_in_st_csh_vld      = 1'b0;
   assign c2h_byp_in_st_csh_addr     = 0;
@@ -285,6 +433,19 @@ module qdma_subsystem #(
   assign c2h_byp_in_st_csh_func     = 0;
   assign c2h_byp_in_st_csh_pfch_tag = 0;
 
+  assign c2h_byp_in_mm_radr         = 0;
+  assign c2h_byp_in_mm_wadr         = 0;
+  assign c2h_byp_in_mm_len          = 0;
+  assign c2h_byp_in_mm_mrkr_req     = 1'b0;
+  assign c2h_byp_in_mm_port_id      = 0;
+  assign c2h_byp_in_mm_sdi          = 1'b0;
+  assign c2h_byp_in_mm_qid          = 0;
+  assign c2h_byp_in_mm_error        = 1'b0;
+  assign c2h_byp_in_mm_func         = 0;
+  assign c2h_byp_in_mm_cidx         = 0;
+  assign c2h_byp_in_mm_vld          = 1'b0;
+  assign c2h_byp_in_mm_no_dma       = 1'b0;
+
   qdma_subsystem_qdma_wrapper qdma_wrapper_inst (
     .pcie_rxp                        (pcie_rxp),
     .pcie_rxn                        (pcie_rxn),
@@ -308,6 +469,45 @@ module qdma_subsystem #(
     .m_axil_rresp                    (m_axil_pcie_rresp),
     .m_axil_rready                   (m_axil_pcie_rready),
 
+    .m_axi_awready                   (m_axi_awready),
+    .m_axi_wready                    (m_axi_wready),
+    .m_axi_bid                       (m_axi_bid),
+    .m_axi_bresp                     (m_axi_bresp),
+    .m_axi_bvalid                    (m_axi_bvalid),
+    .m_axi_arready                   (m_axi_arready),
+    .m_axi_rid                       (m_axi_rid),
+    .m_axi_rdata                     (m_axi_rdata),
+    .m_axi_rresp                     (m_axi_rresp),
+    .m_axi_rlast                     (m_axi_rlast),
+    .m_axi_rvalid                    (m_axi_rvalid),
+    .m_axi_awid                      (m_axi_awid),
+    .m_axi_awaddr                    (m_axi_awaddr),
+    .m_axi_awuser                    (m_axi_awuser),
+    .m_axi_awlen                     (m_axi_awlen),
+    .m_axi_awsize                    (m_axi_awsize),
+    .m_axi_awburst                   (m_axi_awburst),
+    .m_axi_awprot                    (m_axi_awprot),
+    .m_axi_awvalid                   (m_axi_awvalid),
+    .m_axi_awlock                    (m_axi_awlock),
+    .m_axi_awcache                   (m_axi_awcache),
+    .m_axi_wdata                     (m_axi_wdata),
+    .m_axi_wuser                     (m_axi_wuser),
+    .m_axi_wstrb                     (m_axi_wstrb),
+    .m_axi_wlast                     (m_axi_wlast),
+    .m_axi_wvalid                    (m_axi_wvalid),
+    .m_axi_bready                    (m_axi_bready),
+    .m_axi_arid                      (m_axi_arid),
+    .m_axi_araddr                    (m_axi_araddr),
+    .m_axi_aruser                    (m_axi_aruser),
+    .m_axi_arlen                     (m_axi_arlen),
+    .m_axi_arsize                    (m_axi_arsize),
+    .m_axi_arburst                   (m_axi_arburst),
+    .m_axi_arprot                    (m_axi_arprot),
+    .m_axi_arvalid                   (m_axi_arvalid),
+    .m_axi_arlock                    (m_axi_arlock),
+    .m_axi_arcache                   (m_axi_arcache),
+    .m_axi_rready                    (m_axi_rready),
+
     .m_axis_h2c_tvalid               (axis_qdma_h2c_tvalid),
     .m_axis_h2c_tdata                (axis_qdma_h2c_tdata),
     .m_axis_h2c_tcrc                 (axis_qdma_h2c_tcrc),
@@ -375,6 +575,20 @@ module qdma_subsystem #(
     .h2c_byp_in_st_no_dma            (h2c_byp_in_st_no_dma),
     .h2c_byp_in_st_rdy               (h2c_byp_in_st_rdy),
 
+    .h2c_byp_in_mm_radr              (h2c_byp_in_mm_radr),
+    .h2c_byp_in_mm_wadr              (h2c_byp_in_mm_wadr),
+    .h2c_byp_in_mm_len               (h2c_byp_in_mm_len),
+    .h2c_byp_in_mm_mrkr_req          (h2c_byp_in_mm_mrkr_req),
+    .h2c_byp_in_mm_port_id           (h2c_byp_in_mm_port_id),
+    .h2c_byp_in_mm_sdi               (h2c_byp_in_mm_sdi),
+    .h2c_byp_in_mm_qid               (h2c_byp_in_mm_qid),
+    .h2c_byp_in_mm_error             (h2c_byp_in_mm_error),
+    .h2c_byp_in_mm_func              (h2c_byp_in_mm_func),
+    .h2c_byp_in_mm_cidx              (h2c_byp_in_mm_cidx),
+    .h2c_byp_in_mm_no_dma            (h2c_byp_in_mm_no_dma),
+    .h2c_byp_in_mm_vld               (h2c_byp_in_mm_vld),
+    .h2c_byp_in_mm_rdy               (h2c_byp_in_mm_rdy),
+
     .c2h_byp_out_vld                 (c2h_byp_out_vld),
     .c2h_byp_out_dsc                 (c2h_byp_out_dsc),
     .c2h_byp_out_st_mm               (c2h_byp_out_st_mm),
@@ -397,6 +611,77 @@ module qdma_subsystem #(
     .c2h_byp_in_st_csh_pfch_tag      (c2h_byp_in_st_csh_pfch_tag),
     .c2h_byp_in_st_csh_rdy           (c2h_byp_in_st_csh_rdy),
 
+    .c2h_byp_in_mm_radr              (c2h_byp_in_mm_radr),
+    .c2h_byp_in_mm_wadr              (c2h_byp_in_mm_wadr),
+    .c2h_byp_in_mm_len               (c2h_byp_in_mm_len),
+    .c2h_byp_in_mm_mrkr_req          (c2h_byp_in_mm_mrkr_req),
+    .c2h_byp_in_mm_port_id           (c2h_byp_in_mm_port_id),
+    .c2h_byp_in_mm_sdi               (c2h_byp_in_mm_sdi),
+    .c2h_byp_in_mm_qid               (c2h_byp_in_mm_qid),
+    .c2h_byp_in_mm_error             (c2h_byp_in_mm_error),
+    .c2h_byp_in_mm_func              (c2h_byp_in_mm_func),
+    .c2h_byp_in_mm_cidx              (c2h_byp_in_mm_cidx),
+    .c2h_byp_in_mm_vld               (c2h_byp_in_mm_vld),
+    .c2h_byp_in_mm_no_dma            (c2h_byp_in_mm_no_dma),
+    .c2h_byp_in_mm_rdy               (c2h_byp_in_mm_rdy),
+
+    .s_csr_prog_done                 (s_csr_prog_done),
+    .s_axil_csr_awaddr               (s_axil_csr_awaddr),
+    .s_axil_csr_awprot               (s_axil_csr_awprot),
+    .s_axil_csr_awvalid              (s_axil_csr_awvalid),
+    .s_axil_csr_awready              (s_axil_csr_awready),
+    .s_axil_csr_wdata                (s_axil_csr_wdata),
+    .s_axil_csr_wstrb                (s_axil_csr_wstrb),
+    .s_axil_csr_wvalid               (s_axil_csr_wvalid),
+    .s_axil_csr_wready               (s_axil_csr_wready),
+    .s_axil_csr_bvalid               (s_axil_csr_bvalid),
+    .s_axil_csr_bresp                (s_axil_csr_bresp),
+    .s_axil_csr_bready               (s_axil_csr_bready),
+    .s_axil_csr_araddr               (s_axil_csr_araddr),
+    .s_axil_csr_arprot               (s_axil_csr_arprot),
+    .s_axil_csr_arvalid              (s_axil_csr_arvalid),
+    .s_axil_csr_arready              (s_axil_csr_arready),
+    .s_axil_csr_rdata                (s_axil_csr_rdata),
+    .s_axil_csr_rresp                (s_axil_csr_rresp),
+    .s_axil_csr_rvalid               (s_axil_csr_rvalid),
+    .s_axil_csr_rready               (s_axil_csr_rready),
+
+    .s_axib_awid                     (s_axib_awid),
+    .s_axib_awaddr                   (s_axib_awaddr),
+    .s_axib_awregion                 (s_axib_awregion),
+    .s_axib_awlen                    (s_axib_awlen),
+    .s_axib_awsize                   (s_axib_awsize),
+    .s_axib_awburst                  (s_axib_awburst),
+    .s_axib_awvalid                  (s_axib_awvalid),
+    .s_axib_wdata                    (s_axib_wdata),
+    .s_axib_wstrb                    (s_axib_wstrb),
+    .s_axib_wlast                    (s_axib_wlast),
+    .s_axib_wvalid                   (s_axib_wvalid),
+    .s_axib_wuser                    (s_axib_wuser),
+    .s_axib_ruser                    (s_axib_ruser),
+    .s_axib_bready                   (s_axib_bready),
+    .s_axib_arid                     (s_axib_arid),
+    .s_axib_araddr                   (s_axib_araddr),
+    .s_axib_aruser                   (s_axib_aruser),
+    .s_axib_awuser                   (s_axib_awuser),
+    .s_axib_arregion                 (s_axib_arregion),
+    .s_axib_arlen                    (s_axib_arlen),
+    .s_axib_arsize                   (s_axib_arsize),
+    .s_axib_arburst                  (s_axib_arburst),
+    .s_axib_arvalid                  (s_axib_arvalid),
+    .s_axib_rready                   (s_axib_rready),
+    .s_axib_awready                  (s_axib_awready),
+    .s_axib_wready                   (s_axib_wready),
+    .s_axib_bid                      (s_axib_bid),
+    .s_axib_bresp                    (s_axib_bresp),
+    .s_axib_bvalid                   (s_axib_bvalid),
+    .s_axib_arready                  (s_axib_arready),
+    .s_axib_rid                      (s_axib_rid),
+    .s_axib_rdata                    (s_axib_rdata),
+    .s_axib_rresp                    (s_axib_rresp),
+    .s_axib_rlast                    (s_axib_rlast),
+    .s_axib_rvalid                   (s_axib_rvalid),
+
     .pcie_refclk                     (pcie_refclk),
     .pcie_refclk_gt                  (pcie_refclk_gt),
     .pcie_rstn                       (pcie_rstn),
@@ -407,57 +692,19 @@ module qdma_subsystem #(
 
     .axil_aclk                       (axil_aclk),
     .axis_aclk                       (axis_aclk),
+
+  `ifdef __au55n__
+    .ref_clk_100mhz                  (ref_clk_100mhz),
+  `elsif __au55c__
+    .ref_clk_100mhz                  (ref_clk_100mhz),
+  `elsif __au50__
+    .ref_clk_100mhz                  (ref_clk_100mhz),
+  `elsif __au280__
+    .ref_clk_100mhz                  (ref_clk_100mhz),
+  `endif
+
     .aresetn                         (powerup_rstn)
   );
-`else // !`ifdef __synthesis__
-  initial begin
-    axil_aclk = 1'b1;
-    axis_aclk = 1'b1;
-  end
-
-  always #4000ps axil_aclk = ~axil_aclk;
-  always #2000ps axis_aclk = ~axis_aclk;
-
-  assign axis_qdma_h2c_tvalid                 = s_axis_qdma_h2c_tvalid;
-  assign axis_qdma_h2c_tdata                  = s_axis_qdma_h2c_tdata;
-  assign axis_qdma_h2c_tcrc                   = s_axis_qdma_h2c_tcrc;
-  assign axis_qdma_h2c_tlast                  = s_axis_qdma_h2c_tlast;
-  assign axis_qdma_h2c_tuser_qid              = s_axis_qdma_h2c_tuser_qid;
-  assign axis_qdma_h2c_tuser_port_id          = s_axis_qdma_h2c_tuser_port_id;
-  assign axis_qdma_h2c_tuser_err              = s_axis_qdma_h2c_tuser_err;
-  assign axis_qdma_h2c_tuser_mdata            = s_axis_qdma_h2c_tuser_mdata;
-  assign axis_qdma_h2c_tuser_mty              = s_axis_qdma_h2c_tuser_mty;
-  assign axis_qdma_h2c_tuser_zero_byte        = s_axis_qdma_h2c_tuser_zero_byte;
-  assign s_axis_qdma_h2c_tready               = axis_qdma_h2c_tready;
-
-  assign m_axis_qdma_c2h_tvalid               = axis_qdma_c2h_tvalid;
-  assign m_axis_qdma_c2h_tdata                = axis_qdma_c2h_tdata;
-  assign m_axis_qdma_c2h_tcrc                 = axis_qdma_c2h_tcrc;
-  assign m_axis_qdma_c2h_tlast                = axis_qdma_c2h_tlast;
-  assign m_axis_qdma_c2h_ctrl_marker          = axis_qdma_c2h_ctrl_marker;
-  assign m_axis_qdma_c2h_ctrl_port_id         = axis_qdma_c2h_ctrl_port_id;
-  assign m_axis_qdma_c2h_ctrl_ecc             = axis_qdma_c2h_ctrl_ecc;
-  assign m_axis_qdma_c2h_ctrl_len             = axis_qdma_c2h_ctrl_len;
-  assign m_axis_qdma_c2h_ctrl_qid             = axis_qdma_c2h_ctrl_qid;
-  assign m_axis_qdma_c2h_ctrl_has_cmpt        = axis_qdma_c2h_ctrl_has_cmpt;
-  assign m_axis_qdma_c2h_mty                  = axis_qdma_c2h_mty;
-  assign axis_qdma_c2h_tready                 = m_axis_qdma_c2h_tready;
-
-  assign m_axis_qdma_cpl_tvalid               = axis_qdma_cpl_tvalid;
-  assign m_axis_qdma_cpl_tdata                = axis_qdma_cpl_tdata;
-  assign m_axis_qdma_cpl_size                 = axis_qdma_cpl_size;
-  assign m_axis_qdma_cpl_dpar                 = axis_qdma_cpl_dpar;
-  assign m_axis_qdma_cpl_ctrl_qid             = axis_qdma_cpl_ctrl_qid;
-  assign m_axis_qdma_cpl_ctrl_cmpt_type       = axis_qdma_cpl_ctrl_cmpt_type;
-  assign m_axis_qdma_cpl_ctrl_wait_pld_pkt_id = axis_qdma_cpl_ctrl_wait_pld_pkt_id;
-  assign m_axis_qdma_cpl_ctrl_port_id         = axis_qdma_cpl_ctrl_port_id;
-  assign m_axis_qdma_cpl_ctrl_marker          = axis_qdma_cpl_ctrl_marker;
-  assign m_axis_qdma_cpl_ctrl_user_trig       = axis_qdma_cpl_ctrl_user_trig;
-  assign m_axis_qdma_cpl_ctrl_col_idx         = axis_qdma_cpl_ctrl_col_idx;
-  assign m_axis_qdma_cpl_ctrl_err_idx         = axis_qdma_cpl_ctrl_err_idx;
-  assign m_axis_qdma_cpl_ctrl_no_wrb_marker   = axis_qdma_cpl_ctrl_no_wrb_marker;
-  assign axis_qdma_cpl_tready                 = m_axis_qdma_cpl_tready;
-`endif
 
   generate if (USE_PHYS_FUNC == 0) begin
     // Terminate the AXI-lite interface for QDMA subsystem registers
@@ -801,7 +1048,26 @@ module qdma_subsystem #(
         .axil_aresetn          (axil_aresetn)
       );
     end
-  end
+
+    (* mark_debug = "true" *) logic [47:0] qdma_h2c_pkt_cnt;
+    (* mark_debug = "true" *) logic [47:0] qdma_c2h_pkt_cnt;
+
+    always_ff @(posedge axis_aclk)
+      if(!axil_aresetn) begin
+        qdma_h2c_pkt_cnt <= 0;
+        qdma_c2h_pkt_cnt <= 0;
+      end
+      else begin
+        if ((m_axis_h2c_tvalid != 0) && (m_axis_h2c_tready != 0) && (m_axis_h2c_tlast != 0)) begin
+          qdma_h2c_pkt_cnt <= qdma_h2c_pkt_cnt + 1;
+        end
+
+        if ((s_axis_c2h_tvalid != 0) && (s_axis_c2h_tready != 0) && (axis_c2h_tlast !=0)) begin
+          qdma_c2h_pkt_cnt <= qdma_c2h_pkt_cnt + 1;
+        end
+      end
+    end
+
   endgenerate
 
 endmodule: qdma_subsystem
diff --git a/src/qdma_subsystem/qdma_subsystem_c2h.sv b/src/qdma_subsystem/qdma_subsystem_c2h.sv
index 50e9082..b230c82 100644
--- a/src/qdma_subsystem/qdma_subsystem_c2h.sv
+++ b/src/qdma_subsystem/qdma_subsystem_c2h.sv
@@ -277,10 +277,14 @@ module qdma_subsystem_c2h #(
   assign m_axis_qdma_cpl_tdata[511:256]       = 0;
   assign m_axis_qdma_cpl_tdata[255:128]       = 0;
   assign m_axis_qdma_cpl_tdata[127:64]        = 0;
-  assign m_axis_qdma_cpl_tdata[63:32]         = cpl_fifo_dout[31:0];
+  // patch
+  assign m_axis_qdma_cpl_tdata[63:20]         = 0;
+  assign m_axis_qdma_cpl_tdata[19:4]          = cpl_fifo_dout[15:0];
+  assign m_axis_qdma_cpl_tdata[3:0]           = 4'b1000;
+/*  assign m_axis_qdma_cpl_tdata[63:32]         = cpl_fifo_dout[31:0];
   assign m_axis_qdma_cpl_tdata[31:27]         = 0;
   assign m_axis_qdma_cpl_tdata[26:16]         = cpl_fifo_dout[42:32];
-  assign m_axis_qdma_cpl_tdata[15:0]          = 0;
+  assign m_axis_qdma_cpl_tdata[15:0]          = 0;*/
 
   assign m_axis_qdma_cpl_ctrl_no_wrb_marker   = 1'b0;
   assign m_axis_qdma_cpl_ctrl_col_idx         = 0;
diff --git a/src/qdma_subsystem/qdma_subsystem_h2c.sv b/src/qdma_subsystem/qdma_subsystem_h2c.sv
index 6a7ee26..4b183c5 100644
--- a/src/qdma_subsystem/qdma_subsystem_h2c.sv
+++ b/src/qdma_subsystem/qdma_subsystem_h2c.sv
@@ -71,7 +71,8 @@ module qdma_subsystem_h2c #(
     .s_axis_tdata  (s_axis_qdma_h2c_tdata),
     .s_axis_tkeep  ({64{1'b1}}),
     .s_axis_tlast  (s_axis_qdma_h2c_tlast),
-    .s_axis_tuser  ({s_axis_qdma_h2c_tuser_mdata[15:0],
+  .s_axis_tuser  ({s_axis_qdma_h2c_tuser_mdata[31:16], // patch
+//    .s_axis_tuser  ({s_axis_qdma_h2c_tuser_mdata[15:0],
                      s_axis_qdma_h2c_tuser_mty,
                      s_axis_qdma_h2c_tuser_qid}),
     .s_axis_tid    (0),
diff --git a/src/qdma_subsystem/qdma_subsystem_qdma_wrapper.v b/src/qdma_subsystem/qdma_subsystem_qdma_wrapper.v
index cfd0dca..6cfbf05 100644
--- a/src/qdma_subsystem/qdma_subsystem_qdma_wrapper.v
+++ b/src/qdma_subsystem/qdma_subsystem_qdma_wrapper.v
@@ -42,6 +42,45 @@ module qdma_subsystem_qdma_wrapper (
   input    [1:0] m_axil_rresp,
   output         m_axil_rready,
 
+  input          m_axi_awready,
+  input          m_axi_wready,
+  input  [3:0]   m_axi_bid,
+  input  [1:0]   m_axi_bresp,
+  input          m_axi_bvalid,
+  input          m_axi_arready,
+  input  [3:0]   m_axi_rid,
+  input  [511:0] m_axi_rdata,
+  input  [1:0]   m_axi_rresp,
+  input          m_axi_rlast,
+  input          m_axi_rvalid,
+  output [3:0]   m_axi_awid,
+  output [63:0]  m_axi_awaddr,
+  output [31:0]  m_axi_awuser,
+  output [7:0]   m_axi_awlen,
+  output [2:0]   m_axi_awsize,
+  output [1:0]   m_axi_awburst,
+  output [2:0]   m_axi_awprot,
+  output         m_axi_awvalid,
+  output         m_axi_awlock,
+  output [3:0]   m_axi_awcache,
+  output [511:0] m_axi_wdata,
+  output [63:0]  m_axi_wuser,
+  output [63:0]  m_axi_wstrb,
+  output         m_axi_wlast,
+  output         m_axi_wvalid,
+  output         m_axi_bready,
+  output [3:0]   m_axi_arid,
+  output [63:0]  m_axi_araddr,
+  output [31:0]  m_axi_aruser,
+  output [7:0]   m_axi_arlen,
+  output [2:0]   m_axi_arsize,
+  output [1:0]   m_axi_arburst,
+  output [2:0]   m_axi_arprot,
+  output         m_axi_arvalid,
+  output         m_axi_arlock,
+  output [3:0]   m_axi_arcache,
+  output         m_axi_rready,
+
   output         m_axis_h2c_tvalid,
   output [511:0] m_axis_h2c_tdata,
   output  [31:0] m_axis_h2c_tcrc,
@@ -109,6 +148,20 @@ module qdma_subsystem_qdma_wrapper (
   input          h2c_byp_in_st_no_dma,
   output         h2c_byp_in_st_rdy,
 
+  input  [63:0]  h2c_byp_in_mm_radr,
+  input  [63:0]  h2c_byp_in_mm_wadr,
+  input  [15:0]  h2c_byp_in_mm_len,
+  input          h2c_byp_in_mm_mrkr_req,
+  input  [2:0]   h2c_byp_in_mm_port_id,
+  input          h2c_byp_in_mm_sdi,
+  input  [10:0]  h2c_byp_in_mm_qid,
+  input          h2c_byp_in_mm_error,
+  input  [7:0]   h2c_byp_in_mm_func,
+  input  [15:0]  h2c_byp_in_mm_cidx,
+  input          h2c_byp_in_mm_no_dma,
+  input          h2c_byp_in_mm_vld,
+  output         h2c_byp_in_mm_rdy,
+
   output         c2h_byp_out_vld,
   output [255:0] c2h_byp_out_dsc,
   output         c2h_byp_out_st_mm,
@@ -131,6 +184,79 @@ module qdma_subsystem_qdma_wrapper (
   input    [6:0] c2h_byp_in_st_csh_pfch_tag,
   output         c2h_byp_in_st_csh_rdy,
 
+  input   [63:0] c2h_byp_in_mm_radr,
+  input   [63:0] c2h_byp_in_mm_wadr,
+  input   [15:0] c2h_byp_in_mm_len,
+  input          c2h_byp_in_mm_mrkr_req,
+  input   [2:0]  c2h_byp_in_mm_port_id,
+  input          c2h_byp_in_mm_sdi,
+  input   [10:0] c2h_byp_in_mm_qid,
+  input          c2h_byp_in_mm_error,
+  input   [7:0]  c2h_byp_in_mm_func,
+  input   [15:0] c2h_byp_in_mm_cidx,
+  input          c2h_byp_in_mm_vld,
+  input          c2h_byp_in_mm_no_dma,
+  output         c2h_byp_in_mm_rdy,
+
+  // QDMA control/status register interface
+  output         s_csr_prog_done,
+  input   [31:0] s_axil_csr_awaddr,
+  input    [2:0] s_axil_csr_awprot,
+  input          s_axil_csr_awvalid,
+  output         s_axil_csr_awready,
+  input   [31:0] s_axil_csr_wdata,
+  input   [3:0]  s_axil_csr_wstrb,
+  input          s_axil_csr_wvalid,
+  output         s_axil_csr_wready,
+  output         s_axil_csr_bvalid,
+  output   [1:0] s_axil_csr_bresp,
+  input          s_axil_csr_bready,
+  input   [31:0] s_axil_csr_araddr,
+  input    [2:0] s_axil_csr_arprot,
+  input          s_axil_csr_arvalid,
+  output         s_axil_csr_arready,
+  output  [31:0] s_axil_csr_rdata,
+  output   [1:0] s_axil_csr_rresp,
+  output         s_axil_csr_rvalid,
+  input          s_axil_csr_rready,
+
+  // QDMA bridge slave interface
+  (* mark_debug = "true" *) input    [3:0] s_axib_awid,
+  (* mark_debug = "true" *) input   [63:0] s_axib_awaddr,
+  (* mark_debug = "true" *) input    [3:0] s_axib_awregion,
+  (* mark_debug = "true" *) input    [7:0] s_axib_awlen,
+  (* mark_debug = "true" *) input    [2:0] s_axib_awsize,
+  (* mark_debug = "true" *) input    [1:0] s_axib_awburst,
+  (* mark_debug = "true" *) input          s_axib_awvalid,
+  (* mark_debug = "true" *) input  [511:0] s_axib_wdata,
+  (* mark_debug = "true" *) input   [63:0] s_axib_wstrb,
+  (* mark_debug = "true" *) input          s_axib_wlast,
+  (* mark_debug = "true" *) input          s_axib_wvalid,
+  (* mark_debug = "true" *) input   [63:0] s_axib_wuser,
+  (* mark_debug = "true" *) output  [63:0] s_axib_ruser,
+  (* mark_debug = "true" *) input          s_axib_bready,
+  (* mark_debug = "true" *) input    [3:0] s_axib_arid,
+  (* mark_debug = "true" *) input   [63:0] s_axib_araddr,
+  (* mark_debug = "true" *) input   [11:0] s_axib_aruser,
+  (* mark_debug = "true" *) input   [11:0] s_axib_awuser,
+  (* mark_debug = "true" *) input    [3:0] s_axib_arregion,
+  (* mark_debug = "true" *) input    [7:0] s_axib_arlen,
+  (* mark_debug = "true" *) input    [2:0] s_axib_arsize,
+  (* mark_debug = "true" *) input    [1:0] s_axib_arburst,
+  (* mark_debug = "true" *) input          s_axib_arvalid,
+  (* mark_debug = "true" *) input          s_axib_rready,
+  (* mark_debug = "true" *) output         s_axib_awready,
+  (* mark_debug = "true" *) output         s_axib_wready,
+  (* mark_debug = "true" *) output   [3:0] s_axib_bid,
+  (* mark_debug = "true" *) output   [1:0] s_axib_bresp,
+  (* mark_debug = "true" *) output         s_axib_bvalid,
+  (* mark_debug = "true" *) output         s_axib_arready,
+  (* mark_debug = "true" *) output   [3:0] s_axib_rid,
+  (* mark_debug = "true" *) output [511:0] s_axib_rdata,
+  (* mark_debug = "true" *) output   [1:0] s_axib_rresp,
+  (* mark_debug = "true" *) output         s_axib_rlast,
+  (* mark_debug = "true" *) output         s_axib_rvalid,
+
   input          pcie_refclk,
   input          pcie_refclk_gt,
   input          pcie_rstn,
@@ -141,6 +267,19 @@ module qdma_subsystem_qdma_wrapper (
 
   output         axis_aclk,
   output         axil_aclk,
+
+  // For AU55N, AU55C, AU50, and AU280, we generate 100MHz reference clock which is needed when HBM IP is instantiated
+  // in user-defined logic.
+  `ifdef __au55n__
+    output         ref_clk_100mhz,
+  `elsif __au55c__
+    output         ref_clk_100mhz,
+  `elsif __au50__
+    output         ref_clk_100mhz,
+  `elsif __au280__
+    output         ref_clk_100mhz,
+  `endif
+
   output         aresetn
 );
 
@@ -150,6 +289,27 @@ module qdma_subsystem_qdma_wrapper (
 
   reg   [1:0] aresetn_sync = 2'b11;
 
+  (* mark_debug = "true" *) wire         qdma_csr_prog_done;
+  (* mark_debug = "true" *) wire  [31:0] qdma_axil_csr_awaddr;
+  (* mark_debug = "true" *) wire   [2:0] qdma_axil_csr_awprot;
+  (* mark_debug = "true" *) wire         qdma_axil_csr_awvalid;
+  (* mark_debug = "true" *) wire         qdma_axil_csr_awready;
+  (* mark_debug = "true" *) wire  [31:0] qdma_axil_csr_wdata;
+  (* mark_debug = "true" *) wire  [3:0]  qdma_axil_csr_wstrb;
+  (* mark_debug = "true" *) wire         qdma_axil_csr_wvalid;
+  (* mark_debug = "true" *) wire         qdma_axil_csr_wready;
+  (* mark_debug = "true" *) wire         qdma_axil_csr_bvalid;
+  (* mark_debug = "true" *) wire   [1:0] qdma_axil_csr_bresp;
+  (* mark_debug = "true" *) wire         qdma_axil_csr_bready;
+  (* mark_debug = "true" *) wire  [31:0] qdma_axil_csr_araddr;
+  (* mark_debug = "true" *) wire   [2:0] qdma_axil_csr_arprot;
+  (* mark_debug = "true" *) wire         qdma_axil_csr_arvalid;
+  (* mark_debug = "true" *) wire         qdma_axil_csr_arready;
+  (* mark_debug = "true" *) wire  [31:0] qdma_axil_csr_rdata;
+  (* mark_debug = "true" *) wire   [1:0] qdma_axil_csr_rresp;
+  (* mark_debug = "true" *) wire         qdma_axil_csr_rvalid;
+  (* mark_debug = "true" *) wire         qdma_axil_csr_rready;
+
   wire        qdma_axil_awvalid;
   wire [31:0] qdma_axil_awaddr;
   wire  [2:0] qdma_axil_awprot;
@@ -198,11 +358,11 @@ module qdma_subsystem_qdma_wrapper (
 
   assign axis_aclk = aclk_250mhz;
 
-  // Generate 125MHz 'axil_aclk'
+  // Generate 125MHz 'axil_aclk' and 100MHz 'ref_clk_100mhz'.
   qdma_subsystem_clk_div clk_div_inst (
     .clk_in1  (axis_aclk),
     .clk_out1 (axil_aclk),
-    .locked   ()
+    .clk_out2 (ref_clk_100mhz)
   );
 
   // Generate reset w.r.t. the 125MHz clock
@@ -260,6 +420,66 @@ module qdma_subsystem_qdma_wrapper (
     .m_axi_aresetn (aresetn)
   );
 
+  qdma_subsystem_axi_csr_cdc axi_csr_cdc_inst (
+    .s_axi_awvalid (s_axil_csr_awvalid),
+    .s_axi_awaddr  (s_axil_csr_awaddr),
+    .s_axi_awprot  (s_axil_csr_awprot),
+    .s_axi_awready (s_axil_csr_awready),
+    .s_axi_wvalid  (s_axil_csr_wvalid),
+    .s_axi_wdata   (s_axil_csr_wdata),
+    .s_axi_wstrb   (s_axil_csr_wstrb),
+    .s_axi_wready  (s_axil_csr_wready),
+    .s_axi_bvalid  (s_axil_csr_bvalid),
+    .s_axi_bresp   (s_axil_csr_bresp),
+    .s_axi_bready  (s_axil_csr_bready),
+    .s_axi_arvalid (s_axil_csr_arvalid),
+    .s_axi_araddr  (s_axil_csr_araddr),
+    .s_axi_arprot  (s_axil_csr_arprot),
+    .s_axi_arready (s_axil_csr_arready),
+    .s_axi_rvalid  (s_axil_csr_rvalid),
+    .s_axi_rdata   (s_axil_csr_rdata),
+    .s_axi_rresp   (s_axil_csr_rresp),
+    .s_axi_rready  (s_axil_csr_rready),
+
+    .m_axi_awvalid (qdma_axil_csr_awvalid),
+    .m_axi_awaddr  (qdma_axil_csr_awaddr),
+    .m_axi_awprot  (qdma_axil_csr_awprot),
+    .m_axi_awready (qdma_axil_csr_awready),
+    .m_axi_wvalid  (qdma_axil_csr_wvalid),
+    .m_axi_wdata   (qdma_axil_csr_wdata),
+    .m_axi_wstrb   (qdma_axil_csr_wstrb),
+    .m_axi_wready  (qdma_axil_csr_wready),
+    .m_axi_bvalid  (qdma_axil_csr_bvalid),
+    .m_axi_bresp   (qdma_axil_csr_bresp),
+    .m_axi_bready  (qdma_axil_csr_bready),
+    .m_axi_arvalid (qdma_axil_csr_arvalid),
+    .m_axi_araddr  (qdma_axil_csr_araddr),
+    .m_axi_arprot  (qdma_axil_csr_arprot),
+    .m_axi_arready (qdma_axil_csr_arready),
+    .m_axi_rvalid  (qdma_axil_csr_rvalid),
+    .m_axi_rdata   (qdma_axil_csr_rdata),
+    .m_axi_rresp   (qdma_axil_csr_rresp),
+    .m_axi_rready  (qdma_axil_csr_rready),
+
+    .s_axi_aclk    (axil_aclk),
+    .s_axi_aresetn (aresetn),
+    .m_axi_aclk    (axis_aclk),
+    .m_axi_aresetn (aresetn_250mhz)
+  );
+
+  // Convert signals @ axis_aclk to axil_aclk
+  xpm_cdc_single #(
+    .DEST_SYNC_FF(4), // DECIMAL; range: 2-10
+    .INIT_SYNC_FF(0), // DECIMAL; 0=disable simulation init values, 1=enable simulation init values
+    .SIM_ASSERT_CHK(1), // DECIMAL; 0=disable simulation messages, 1=enable simulation messages
+    .SRC_INPUT_REG(1) // DECIMAL; 0=do not register input, 1=register input
+  ) roce_pkt_recved_cdc (
+    .dest_out(s_csr_prog_done),
+    .dest_clk(axil_aclk),
+    .src_clk(axis_aclk),
+    .src_in(qdma_csr_prog_done)
+  );
+
   assign usr_irq_in_vld    = 1'b0;
   assign usr_irq_in_vec    = 0;
   assign usr_irq_in_fnc    = 0;
@@ -335,6 +555,20 @@ module qdma_subsystem_qdma_wrapper (
     .h2c_byp_in_st_no_dma                 (h2c_byp_in_st_no_dma),
     .h2c_byp_in_st_rdy                    (h2c_byp_in_st_rdy),
 
+    .h2c_byp_in_mm_radr                   (h2c_byp_in_mm_radr),
+    .h2c_byp_in_mm_wadr                   (h2c_byp_in_mm_wadr),
+    .h2c_byp_in_mm_len                    (h2c_byp_in_mm_len),
+    .h2c_byp_in_mm_mrkr_req               (h2c_byp_in_mm_mrkr_req),
+    .h2c_byp_in_mm_port_id                (h2c_byp_in_mm_port_id),
+    .h2c_byp_in_mm_sdi                    (h2c_byp_in_mm_sdi),
+    .h2c_byp_in_mm_qid                    (h2c_byp_in_mm_qid),
+    .h2c_byp_in_mm_error                  (h2c_byp_in_mm_error),
+    .h2c_byp_in_mm_func                   (h2c_byp_in_mm_func),
+    .h2c_byp_in_mm_cidx                   (h2c_byp_in_mm_cidx),
+    .h2c_byp_in_mm_no_dma                 (h2c_byp_in_mm_no_dma),
+    .h2c_byp_in_mm_vld                    (h2c_byp_in_mm_vld),
+    .h2c_byp_in_mm_rdy                    (h2c_byp_in_mm_rdy),
+
     .c2h_byp_out_vld                      (c2h_byp_out_vld),
     .c2h_byp_out_dsc                      (c2h_byp_out_dsc),
     .c2h_byp_out_st_mm                    (c2h_byp_out_st_mm),
@@ -357,12 +591,31 @@ module qdma_subsystem_qdma_wrapper (
     .c2h_byp_in_st_csh_pfch_tag           (c2h_byp_in_st_csh_pfch_tag),
     .c2h_byp_in_st_csh_rdy                (c2h_byp_in_st_csh_rdy),
 
+    .c2h_byp_in_mm_radr                   (c2h_byp_in_mm_radr),
+    .c2h_byp_in_mm_wadr                   (c2h_byp_in_mm_wadr),
+    .c2h_byp_in_mm_len                    (c2h_byp_in_mm_len),
+    .c2h_byp_in_mm_mrkr_req               (c2h_byp_in_mm_mrkr_req),
+    .c2h_byp_in_mm_port_id                (c2h_byp_in_mm_port_id),
+    .c2h_byp_in_mm_sdi                    (c2h_byp_in_mm_sdi),
+    .c2h_byp_in_mm_qid                    (c2h_byp_in_mm_qid),
+    .c2h_byp_in_mm_error                  (c2h_byp_in_mm_error),
+    .c2h_byp_in_mm_func                   (c2h_byp_in_mm_func),
+    .c2h_byp_in_mm_cidx                   (c2h_byp_in_mm_cidx),
+    .c2h_byp_in_mm_vld                    (c2h_byp_in_mm_vld),
+    .c2h_byp_in_mm_no_dma                 (c2h_byp_in_mm_no_dma),
+    .c2h_byp_in_mm_rdy                    (c2h_byp_in_mm_rdy),
+
     .usr_irq_in_vld                       (usr_irq_in_vld),
     .usr_irq_in_vec                       (usr_irq_in_vec),
     .usr_irq_in_fnc                       (usr_irq_in_fnc),
     .usr_irq_out_ack                      (usr_irq_out_ack),
     .usr_irq_out_fail                     (usr_irq_out_fail),
 
+    .st_rx_msg_rdy                        (1'b1),
+    .st_rx_msg_valid                      (),
+    .st_rx_msg_last                       (),
+    .st_rx_msg_data                       (),
+
     .tm_dsc_sts_vld                       (tm_dsc_sts_vld),
     .tm_dsc_sts_port_id                   (tm_dsc_sts_port_id),
     .tm_dsc_sts_qen                       (tm_dsc_sts_qen),
@@ -384,6 +637,86 @@ module qdma_subsystem_qdma_wrapper (
     .dsc_crdt_in_fence                    (dsc_crdt_in_fence),
     .dsc_crdt_in_rdy                      (dsc_crdt_in_rdy),
 
+    .m_axi_awready                        (m_axi_awready),
+    .m_axi_wready                         (m_axi_wready),
+    .m_axi_bid                            (m_axi_bid),
+    .m_axi_bresp                          (m_axi_bresp),
+    .m_axi_bvalid                         (m_axi_bvalid),
+    .m_axi_arready                        (m_axi_arready),
+    .m_axi_rid                            (m_axi_rid),
+    .m_axi_rdata                          (m_axi_rdata),
+    .m_axi_rresp                          (m_axi_rresp),
+    .m_axi_rlast                          (m_axi_rlast),
+    .m_axi_rvalid                         (m_axi_rvalid),
+    .m_axi_awid                           (m_axi_awid),
+    .m_axi_awaddr                         (m_axi_awaddr),
+    .m_axi_awuser                         (m_axi_awuser),
+    .m_axi_awlen                          (m_axi_awlen),
+    .m_axi_awsize                         (m_axi_awsize),
+    .m_axi_awburst                        (m_axi_awburst),
+    .m_axi_awprot                         (m_axi_awprot),
+    .m_axi_awvalid                        (m_axi_awvalid),
+    .m_axi_awlock                         (m_axi_awlock),
+    .m_axi_awcache                        (m_axi_awcache),
+    .m_axi_wdata                          (m_axi_wdata),
+    .m_axi_wuser                          (m_axi_wuser),
+    .m_axi_wstrb                          (m_axi_wstrb),
+    .m_axi_wlast                          (m_axi_wlast),
+    .m_axi_wvalid                         (m_axi_wvalid),
+    .m_axi_bready                         (m_axi_bready),
+    .m_axi_arid                           (m_axi_arid),
+    .m_axi_araddr                         (m_axi_araddr),
+    .m_axi_aruser                         (m_axi_aruser),
+    .m_axi_arlen                          (m_axi_arlen),
+    .m_axi_arsize                         (m_axi_arsize),
+    .m_axi_arburst                        (m_axi_arburst),
+    .m_axi_arprot                         (m_axi_arprot),
+    .m_axi_arvalid                        (m_axi_arvalid),
+    .m_axi_arlock                         (m_axi_arlock),
+    .m_axi_arcache                        (m_axi_arcache),
+    .m_axi_rready                         (m_axi_rready),
+
+    /*
+    // No need to connect Master AXI Bridge signals
+    .m_axib_awid                          (),
+    .m_axib_awaddr                        (),
+    .m_axib_awlen                         (),
+    .m_axib_awuser                        (),
+    .m_axib_awsize                        (),
+    .m_axib_awburst                       (),
+    .m_axib_awprot                        (),
+    .m_axib_awvalid                       (),
+    .m_axib_awready                       (1'b0),
+    .m_axib_awlock                        (),
+    .m_axib_awcache                       (),
+    .m_axib_wdata                         (),
+    .m_axib_wstrb                         (),
+    .m_axib_wlast                         (),
+    .m_axib_wvalid                        (),
+    .m_axib_wready                        (1'b0),
+    .m_axib_bid                           (4'd0),
+    .m_axib_bresp                         (2'd0),
+    .m_axib_bvalid                        (1'b0),
+    .m_axib_bready                        (),
+    .m_axib_arid                          (),
+    .m_axib_araddr                        (),
+    .m_axib_arlen                         (),
+    .m_axib_aruser                        (),
+    .m_axib_arsize                        (),
+    .m_axib_arburst                       (),
+    .m_axib_arprot                        (),
+    .m_axib_arvalid                       (),
+    .m_axib_arready                       (1'b0),
+    .m_axib_arlock                        (),
+    .m_axib_arcache                       (),
+    .m_axib_rid                           (4'd0),
+    .m_axib_rdata                         (512'd0),
+    .m_axib_rresp                         (2'd0),
+    .m_axib_rlast                         (1'b0),
+    .m_axib_rvalid                        (1'b0),
+    .m_axib_rready                        (),
+    */
+
     .m_axis_h2c_tvalid                    (m_axis_h2c_tvalid),
     .m_axis_h2c_tdata                     (m_axis_h2c_tdata),
     .m_axis_h2c_tcrc                      (m_axis_h2c_tcrc),
@@ -424,6 +757,65 @@ module qdma_subsystem_qdma_wrapper (
     .s_axis_c2h_cmpt_ctrl_no_wrb_marker   (s_axis_cpl_ctrl_no_wrb_marker),
     .s_axis_c2h_cmpt_tready               (s_axis_cpl_tready),
 
+    // Control status register interface
+    .csr_prog_done                        (qdma_csr_prog_done),
+    .s_axil_csr_awaddr                    (qdma_axil_csr_awaddr),
+    .s_axil_csr_awprot                    (qdma_axil_csr_awprot),
+    .s_axil_csr_awvalid                   (qdma_axil_csr_awvalid),
+    .s_axil_csr_awready                   (qdma_axil_csr_awready),
+    .s_axil_csr_wdata                     (qdma_axil_csr_wdata),
+    .s_axil_csr_wstrb                     (qdma_axil_csr_wstrb),
+    .s_axil_csr_wvalid                    (qdma_axil_csr_wvalid),
+    .s_axil_csr_wready                    (qdma_axil_csr_wready),
+    .s_axil_csr_bvalid                    (qdma_axil_csr_bvalid),
+    .s_axil_csr_bresp                     (qdma_axil_csr_bresp),
+    .s_axil_csr_bready                    (qdma_axil_csr_bready),
+    .s_axil_csr_araddr                    (qdma_axil_csr_araddr),
+    .s_axil_csr_arprot                    (qdma_axil_csr_arprot),
+    .s_axil_csr_arvalid                   (qdma_axil_csr_arvalid),
+    .s_axil_csr_arready                   (qdma_axil_csr_arready),
+    .s_axil_csr_rdata                     (qdma_axil_csr_rdata),
+    .s_axil_csr_rresp                     (qdma_axil_csr_rresp),
+    .s_axil_csr_rvalid                    (qdma_axil_csr_rvalid),
+    .s_axil_csr_rready                    (qdma_axil_csr_rready),
+
+    // AXI bridge interface used to access host memory
+    .s_axib_awid                          (s_axib_awid),
+    .s_axib_awaddr                        (s_axib_awaddr),
+    .s_axib_awregion                      (s_axib_awregion),
+    .s_axib_awlen                         (s_axib_awlen),
+    .s_axib_awsize                        (s_axib_awsize),
+    .s_axib_awburst                       (s_axib_awburst),
+    .s_axib_awvalid                       (s_axib_awvalid),
+    .s_axib_wdata                         (s_axib_wdata),
+    .s_axib_wstrb                         (s_axib_wstrb),
+    .s_axib_wlast                         (s_axib_wlast),
+    .s_axib_wvalid                        (s_axib_wvalid),
+    .s_axib_wuser                         (s_axib_wuser),
+    .s_axib_ruser                         (s_axib_ruser),
+    .s_axib_bready                        (s_axib_bready),
+    .s_axib_arid                          (s_axib_arid),
+    .s_axib_araddr                        (s_axib_araddr),
+    .s_axib_aruser                        (s_axib_aruser),
+    .s_axib_awuser                        (s_axib_awuser),
+    .s_axib_arregion                      (s_axib_arregion),
+    .s_axib_arlen                         (s_axib_arlen),
+    .s_axib_arsize                        (s_axib_arsize),
+    .s_axib_arburst                       (s_axib_arburst),
+    .s_axib_arvalid                       (s_axib_arvalid),
+    .s_axib_rready                        (s_axib_rready),
+    .s_axib_awready                       (s_axib_awready),
+    .s_axib_wready                        (s_axib_wready),
+    .s_axib_bid                           (s_axib_bid),
+    .s_axib_bresp                         (s_axib_bresp),
+    .s_axib_bvalid                        (s_axib_bvalid),
+    .s_axib_arready                       (s_axib_arready),
+    .s_axib_rid                           (s_axib_rid),
+    .s_axib_rdata                         (s_axib_rdata),
+    .s_axib_rresp                         (s_axib_rresp),
+    .s_axib_rlast                         (s_axib_rlast),
+    .s_axib_rvalid                        (s_axib_rvalid),
+
     .axis_c2h_status_drop                 (),     // output wire axis_c2h_status_drop
     .axis_c2h_status_valid                (),     // output wire axis_c2h_status_valid
     .axis_c2h_status_cmp                  (),     // output wire axis_c2h_status_cmp
diff --git a/src/qdma_subsystem/vivado_ip/axi_mm_bram.tcl b/src/qdma_subsystem/vivado_ip/axi_mm_bram.tcl
new file mode 100755
index 0000000..50220a1
--- /dev/null
+++ b/src/qdma_subsystem/vivado_ip/axi_mm_bram.tcl
@@ -0,0 +1,30 @@
+# *************************************************************************
+#
+# Copyright 2020 Xilinx, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# *************************************************************************
+set axi_mm_mem axi_mm_bram
+create_ip -name axi_bram_ctrl -vendor xilinx.com -library ip -module_name $axi_mm_mem -dir ${ip_build_dir}
+set_property -dict {
+    CONFIG.DATA_WIDTH {512}
+    CONFIG.SUPPORTS_NARROW_BURST {1}
+    CONFIG.SINGLE_PORT_BRAM {0}
+    CONFIG.ECC_TYPE {0}
+    CONFIG.Component_Name {$axi_mm_mem}
+    CONFIG.BMG_INSTANCE {INTERNAL}
+    CONFIG.MEM_DEPTH {8192}
+    CONFIG.ID_WIDTH {5}
+    CONFIG.RD_CMD_OPTIMIZATION {0}
+} [get_ips $axi_mm_mem]
\ No newline at end of file
diff --git a/src/qdma_subsystem/vivado_ip/qdma_no_sriov_au200.tcl b/src/qdma_subsystem/vivado_ip/qdma_no_sriov_au200.tcl
index 07b1095..2e1c63e 100644
--- a/src/qdma_subsystem/vivado_ip/qdma_no_sriov_au200.tcl
+++ b/src/qdma_subsystem/vivado_ip/qdma_no_sriov_au200.tcl
@@ -17,7 +17,7 @@
 # *************************************************************************
 set qdma qdma_no_sriov
 create_ip -name qdma -vendor xilinx.com -library ip -module_name $qdma -dir ${ip_build_dir}
-set_property -dict { 
+set_property -dict {
     CONFIG.mode_selection {Advanced}
     CONFIG.pl_link_cap_max_link_width {X16}
     CONFIG.pl_link_cap_max_link_speed {8.0_GT/s}
diff --git a/src/qdma_subsystem/vivado_ip/qdma_no_sriov_au250.tcl b/src/qdma_subsystem/vivado_ip/qdma_no_sriov_au250.tcl
index 9a87ceb..206b760 100644
--- a/src/qdma_subsystem/vivado_ip/qdma_no_sriov_au250.tcl
+++ b/src/qdma_subsystem/vivado_ip/qdma_no_sriov_au250.tcl
@@ -17,34 +17,23 @@
 # *************************************************************************
 set qdma qdma_no_sriov
 create_ip -name qdma -vendor xilinx.com -library ip -module_name $qdma -dir ${ip_build_dir}
-set_property -dict { 
+set_property -dict {
     CONFIG.mode_selection {Advanced}
-    CONFIG.pl_link_cap_max_link_width {X16}
-    CONFIG.pl_link_cap_max_link_speed {8.0_GT/s}
-    CONFIG.en_transceiver_status_ports {false}
+    CONFIG.en_gt_selection {true}
+    CONFIG.csr_axilite_slave {true}
     CONFIG.dsc_byp_mode {Descriptor_bypass_and_internal}
-    CONFIG.testname {st}
-    CONFIG.pf1_pciebar2axibar_2 {0x0000000000000000}
-    CONFIG.pf2_pciebar2axibar_2 {0x0000000000000000}
-    CONFIG.pf3_pciebar2axibar_2 {0x0000000000000000}
+    CONFIG.axibar_highaddr_0 {0x000000FFFFFFFFFF}
     CONFIG.dma_reset_source_sel {Phy_Ready}
     CONFIG.pf0_bar2_scale_qdma {Megabytes}
-    CONFIG.pf0_bar2_size_qdma {4}
     CONFIG.pf1_bar2_scale_qdma {Megabytes}
-    CONFIG.pf1_bar2_size_qdma {4}
     CONFIG.pf2_bar2_scale_qdma {Megabytes}
-    CONFIG.pf2_bar2_size_qdma {4}
     CONFIG.pf3_bar2_scale_qdma {Megabytes}
-    CONFIG.pf3_bar2_size_qdma {4}
-    CONFIG.PF0_MSIX_CAP_TABLE_SIZE_qdma {009}
-    CONFIG.PF1_MSIX_CAP_TABLE_SIZE_qdma {008}
-    CONFIG.PF2_MSIX_CAP_TABLE_SIZE_qdma {008}
-    CONFIG.PF3_MSIX_CAP_TABLE_SIZE_qdma {008}
-    CONFIG.dma_intf_sel_qdma {AXI_Stream_with_Completion}
-    CONFIG.en_axi_mm_qdma {false}
-    CONFIG.SYS_RST_N_BOARD_INTERFACE {pcie_perstn}
-    CONFIG.PCIE_BOARD_INTERFACE {pci_express_x16}
-    CONFIG.xlnx_ref_board {AU250}
+    CONFIG.en_bridge_slv {true}
+    CONFIG.dma_intf_sel_qdma {AXI_MM_and_AXI_Stream_with_Completion}
+    CONFIG.en_axi_mm_qdma {true}
+    CONFIG.axibar_notranslate {false}
+    CONFIG.vdm_en {1}
 } [get_ips $qdma]
+
 set_property CONFIG.tl_pf_enable_reg $num_phys_func [get_ips $qdma]
 set_property CONFIG.num_queues $num_queue [get_ips $qdma]
diff --git a/src/qdma_subsystem/vivado_ip/qdma_no_sriov_au280.tcl b/src/qdma_subsystem/vivado_ip/qdma_no_sriov_au280.tcl
index 5bb9b5c..4b7e1f7 100644
--- a/src/qdma_subsystem/vivado_ip/qdma_no_sriov_au280.tcl
+++ b/src/qdma_subsystem/vivado_ip/qdma_no_sriov_au280.tcl
@@ -23,7 +23,7 @@ set_property -dict {
     CONFIG.pl_link_cap_max_link_speed {8.0_GT/s}
     CONFIG.en_transceiver_status_ports {false}
     CONFIG.dsc_byp_mode {Descriptor_bypass_and_internal}
-    CONFIG.testname {st}
+    CONFIG.testname {mm_st}
     CONFIG.pf1_pciebar2axibar_2 {0x0000000000000000}
     CONFIG.pf2_pciebar2axibar_2 {0x0000000000000000}
     CONFIG.pf3_pciebar2axibar_2 {0x0000000000000000}
@@ -40,8 +40,8 @@ set_property -dict {
     CONFIG.PF1_MSIX_CAP_TABLE_SIZE_qdma {008}
     CONFIG.PF2_MSIX_CAP_TABLE_SIZE_qdma {008}
     CONFIG.PF3_MSIX_CAP_TABLE_SIZE_qdma {008}
-    CONFIG.dma_intf_sel_qdma {AXI_Stream_with_Completion}
-    CONFIG.en_axi_mm_qdma {false}
+    CONFIG.dma_intf_sel_qdma {AXI_MM_and_AXI_Stream_with_Completion}
+    CONFIG.en_axi_mm_qdma {true}
     CONFIG.SYS_RST_N_BOARD_INTERFACE {pcie_perstn}
     CONFIG.PCIE_BOARD_INTERFACE {pci_express_x16}
     CONFIG.xlnx_ref_board {AU280}
diff --git a/src/qdma_subsystem/vivado_ip/qdma_no_sriov_au55c.tcl b/src/qdma_subsystem/vivado_ip/qdma_no_sriov_au55c.tcl
new file mode 100644
index 0000000..1f5c3df
--- /dev/null
+++ b/src/qdma_subsystem/vivado_ip/qdma_no_sriov_au55c.tcl
@@ -0,0 +1,40 @@
+# *************************************************************************
+#
+# Copyright 2020 Xilinx, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# *************************************************************************
+set qdma qdma_no_sriov
+create_ip -name qdma -vendor xilinx.com -library ip -module_name $qdma -dir ${ip_build_dir}
+set_property -dict {
+    CONFIG.mode_selection {Advanced}
+    CONFIG.en_gt_selection {true}
+    CONFIG.csr_axilite_slave {true}
+    CONFIG.dsc_byp_mode {Descriptor_bypass_and_internal}
+    CONFIG.axibar_highaddr_0 {0x000000FFFFFFFFFF}
+    CONFIG.dma_reset_source_sel {Phy_Ready}
+    CONFIG.pf0_bar2_scale_qdma {Megabytes}
+    CONFIG.pf1_bar2_scale_qdma {Megabytes}
+    CONFIG.pf2_bar2_scale_qdma {Megabytes}
+    CONFIG.pf3_bar2_scale_qdma {Megabytes}
+    CONFIG.en_bridge_slv {true}
+    CONFIG.dma_intf_sel_qdma {AXI_MM_and_AXI_Stream_with_Completion}
+    CONFIG.en_axi_mm_qdma {true}
+    CONFIG.axibar_notranslate {false}
+    CONFIG.vdm_en {1}
+    CONFIG.xlnx_ref_board {AU55C}
+} [get_ips $qdma]
+
+set_property CONFIG.tl_pf_enable_reg $num_phys_func [get_ips $qdma]
+set_property CONFIG.num_queues $num_queue [get_ips $qdma]
diff --git a/src/qdma_subsystem/vivado_ip/qdma_subsystem_axi_crossbar.tcl b/src/qdma_subsystem/vivado_ip/qdma_subsystem_axi_crossbar.tcl
index 20082af..6a88fca 100644
--- a/src/qdma_subsystem/vivado_ip/qdma_subsystem_axi_crossbar.tcl
+++ b/src/qdma_subsystem/vivado_ip/qdma_subsystem_axi_crossbar.tcl
@@ -24,7 +24,7 @@ for {set i 0} {$i < $num_phys_func} {incr i} {
 }
 set_property "CONFIG.M0${num_phys_func}_A00_BASE_ADDR" {0x0000000000004000} [get_ips $axi_crossbar]
 set_property "CONFIG.M0${num_phys_func}_A00_ADDR_WIDTH" {12} [get_ips $axi_crossbar]
-set_property -dict { 
+set_property -dict {
     CONFIG.PROTOCOL {AXI4LITE}
     CONFIG.CONNECTIVITY_MODE {SASD}
     CONFIG.R_REGISTER {1}
diff --git a/src/qdma_subsystem/vivado_ip/qdma_subsystem_axi_csr_cdc.tcl b/src/qdma_subsystem/vivado_ip/qdma_subsystem_axi_csr_cdc.tcl
new file mode 100755
index 0000000..7ee3692
--- /dev/null
+++ b/src/qdma_subsystem/vivado_ip/qdma_subsystem_axi_csr_cdc.tcl
@@ -0,0 +1,34 @@
+# *************************************************************************
+#
+# Copyright 2020 Xilinx, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# *************************************************************************
+set axi_clock_converter qdma_subsystem_axi_csr_cdc
+create_ip -name axi_clock_converter -vendor xilinx.com -library ip -module_name $axi_clock_converter -dir ${ip_build_dir}
+set_property -dict {
+    CONFIG.PROTOCOL {AXI4LITE}
+    CONFIG.DATA_WIDTH {32}
+    CONFIG.ID_WIDTH {0}
+    CONFIG.AWUSER_WIDTH {0}
+    CONFIG.ARUSER_WIDTH {0}
+    CONFIG.RUSER_WIDTH {0}
+    CONFIG.WUSER_WIDTH {0}
+    CONFIG.BUSER_WIDTH {0}
+    CONFIG.SI_CLK.FREQ_HZ {125000000}
+    CONFIG.MI_CLK.FREQ_HZ {250000000}
+    CONFIG.ACLK_ASYNC {1}
+    CONFIG.SYNCHRONIZATION_STAGES {2}
+    CONFIG.ACLK_RATIO {1:2}
+} [get_ips $axi_clock_converter]
diff --git a/src/qdma_subsystem/vivado_ip/qdma_subsystem_c2h_ecc.tcl b/src/qdma_subsystem/vivado_ip/qdma_subsystem_c2h_ecc.tcl
index 0922cba..511ceec 100644
--- a/src/qdma_subsystem/vivado_ip/qdma_subsystem_c2h_ecc.tcl
+++ b/src/qdma_subsystem/vivado_ip/qdma_subsystem_c2h_ecc.tcl
@@ -51,7 +51,7 @@
 # *************************************************************************
 set ecc qdma_subsystem_c2h_ecc
 create_ip -name ecc -vendor xilinx.com -library ip -module_name $ecc -dir ${ip_build_dir}
-set_property -dict { 
+set_property -dict {
     CONFIG.C_USE_CLK_ENABLE {true}
     CONFIG.C_REG_OUTPUT {true}
     CONFIG.C_REG_INPUT {false}
diff --git a/src/qdma_subsystem/vivado_ip/qdma_subsystem_clk_div.tcl b/src/qdma_subsystem/vivado_ip/qdma_subsystem_clk_div.tcl
index ee5a370..bba9cd6 100644
--- a/src/qdma_subsystem/vivado_ip/qdma_subsystem_clk_div.tcl
+++ b/src/qdma_subsystem/vivado_ip/qdma_subsystem_clk_div.tcl
@@ -18,30 +18,39 @@
 set clk_wiz qdma_subsystem_clk_div
 create_ip -name clk_wiz -vendor xilinx.com -library ip -module_name $clk_wiz -dir ${ip_build_dir}
 set_property -dict {
-  CONFIG.PRIMITIVE {Auto}
-  CONFIG.USE_PHASE_ALIGNMENT {true}
-  CONFIG.PRIM_IN_FREQ {250}
-  CONFIG.SECONDARY_SOURCE {Single_ended_clock_capable_pin}
-  CONFIG.CLKIN1_JITTER_PS {40.0}
-  CONFIG.CLKOUT1_REQUESTED_OUT_FREQ {125}
-  CONFIG.CLKOUT1_DRIVES {Buffer}
-  CONFIG.CLKOUT2_DRIVES {Buffer}
-  CONFIG.CLKOUT3_DRIVES {Buffer}
-  CONFIG.CLKOUT4_DRIVES {Buffer}
-  CONFIG.CLKOUT5_DRIVES {Buffer}
-  CONFIG.CLKOUT6_DRIVES {Buffer}
-  CONFIG.CLKOUT7_DRIVES {Buffer}
-  CONFIG.FEEDBACK_SOURCE {FDBK_AUTO}
-  CONFIG.USE_LOCKED {true}
-  CONFIG.USE_RESET {false}
-  CONFIG.MMCM_DIVCLK_DIVIDE {2}
-  CONFIG.MMCM_BANDWIDTH {OPTIMIZED}
-  CONFIG.MMCM_CLKFBOUT_MULT_F {9.625}
-  CONFIG.MMCM_CLKIN1_PERIOD {4.000}
-  CONFIG.MMCM_CLKIN2_PERIOD {10.0}
-  CONFIG.MMCM_COMPENSATION {AUTO}
-  CONFIG.MMCM_CLKOUT0_DIVIDE_F {9.625}
-  CONFIG.AUTO_PRIMITIVE {MMCM}
-  CONFIG.CLKOUT1_JITTER {106.624}
-  CONFIG.CLKOUT1_PHASE_ERROR {85.285}
+    CONFIG.PRIMITIVE {Auto}
+    CONFIG.USE_FREQ_SYNTH {true}
+    CONFIG.USE_PHASE_ALIGNMENT {true}
+    CONFIG.PRIM_IN_FREQ {250.000}
+    CONFIG.JITTER_OPTIONS {PS}
+    CONFIG.CLKOUT2_USED {true}
+    CONFIG.CLKOUT1_REQUESTED_OUT_FREQ {125.000}
+    CONFIG.CLKOUT2_REQUESTED_OUT_FREQ {100.000}
+    CONFIG.SECONDARY_SOURCE {Single_ended_clock_capable_pin}
+    CONFIG.CLKIN1_JITTER_PS {40.000}
+    CONFIG.CLKOUT1_DRIVES {Buffer}
+    CONFIG.CLKOUT2_DRIVES {Buffer}
+    CONFIG.CLKOUT3_DRIVES {Buffer}
+    CONFIG.CLKOUT4_DRIVES {Buffer}
+    CONFIG.CLKOUT5_DRIVES {Buffer}
+    CONFIG.CLKOUT6_DRIVES {Buffer}
+    CONFIG.CLKOUT7_DRIVES {Buffer}
+    CONFIG.FEEDBACK_SOURCE {FDBK_AUTO}
+    CONFIG.USE_LOCKED {false}
+    CONFIG.USE_RESET {false}
+    CONFIG.MMCM_DIVCLK_DIVIDE {1}
+    CONFIG.MMCM_BANDWIDTH {OPTIMIZED}
+    CONFIG.MMCM_CLKFBOUT_MULT_F {4.000}
+    CONFIG.MMCM_CLKIN1_PERIOD {4.000}
+    CONFIG.MMCM_CLKIN2_PERIOD {10.0}
+    CONFIG.MMCM_COMPENSATION {AUTO}
+    CONFIG.MMCM_REF_JITTER2 {0.010}
+    CONFIG.MMCM_CLKOUT0_DIVIDE_F {8.000}
+    CONFIG.MMCM_CLKOUT1_DIVIDE {10}
+    CONFIG.NUM_OUT_CLKS {2}
+    CONFIG.CLKOUT1_JITTER {102.531}
+    CONFIG.CLKOUT1_PHASE_ERROR {85.928}
+    CONFIG.CLKOUT2_JITTER {107.111}
+    CONFIG.CLKOUT2_PHASE_ERROR {85.928}
+    CONFIG.AUTO_PRIMITIVE {MMCM}
 } [get_ips $clk_wiz]
diff --git a/src/qdma_subsystem/vivado_ip/vivado_ip.tcl b/src/qdma_subsystem/vivado_ip/vivado_ip.tcl
index 1159969..3f0c1b7 100644
--- a/src/qdma_subsystem/vivado_ip/vivado_ip.tcl
+++ b/src/qdma_subsystem/vivado_ip/vivado_ip.tcl
@@ -19,6 +19,8 @@ set ips {
     qdma_no_sriov
     qdma_subsystem_clk_div
     qdma_subsystem_axi_cdc
+    qdma_subsystem_axi_csr_cdc
     qdma_subsystem_axi_crossbar
     qdma_subsystem_c2h_ecc
+    axi_mm_bram
 }
diff --git a/src/rdma_subsystem/rdma_subsystem.sv b/src/rdma_subsystem/rdma_subsystem.sv
new file mode 100644
index 0000000..e4b5e7d
--- /dev/null
+++ b/src/rdma_subsystem/rdma_subsystem.sv
@@ -0,0 +1,672 @@
+// *************************************************************************
+//
+// Copyright 2022 Xilinx, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// *************************************************************************
+`timescale 1ns/1ps
+
+module rdma_subsystem #(
+  parameter  C_AXIS_DATA_WIDTH = 512,
+  parameter  C_AXIS_KEEP_WIDTH = 64,
+  parameter C_AXIS_IMMDT_WIDTH = 64
+) (
+  // AXIL interface for RDMA control register
+  input  [31:0] s_axil_awaddr,
+  input         s_axil_awvalid,
+  output        s_axil_awready,
+  input  [31:0] s_axil_wdata,
+  input   [3:0] s_axil_wstrb,
+  input         s_axil_wvalid,
+  output        s_axil_wready,
+  input  [31:0] s_axil_araddr,
+  input         s_axil_arvalid,
+  output        s_axil_arready,
+  output [31:0] s_axil_rdata,
+  output        s_axil_rvalid,
+  output  [1:0] s_axil_rresp,
+  input         s_axil_rready,
+  output  [1:0] s_axil_bresp,
+  output        s_axil_bvalid,
+  input         s_axil_bready,
+
+  // RDMA TX interface (including roce and non-roce packets) to CMAC TX path
+  output [C_AXIS_DATA_WIDTH-1:0] m_rdma2cmac_axis_tdata,
+  output [C_AXIS_KEEP_WIDTH-1:0] m_rdma2cmac_axis_tkeep,
+  output                         m_rdma2cmac_axis_tvalid,
+  output                         m_rdma2cmac_axis_tlast,
+  input                          m_rdma2cmac_axis_tready,
+
+  // Non-RDMA packets from QDMA TX bypassing RDMA TX
+  input  [C_AXIS_DATA_WIDTH-1:0] s_qdma2rdma_non_roce_axis_tdata,
+  input  [C_AXIS_KEEP_WIDTH-1:0] s_qdma2rdma_non_roce_axis_tkeep,
+  input                          s_qdma2rdma_non_roce_axis_tvalid,
+  input                          s_qdma2rdma_non_roce_axis_tlast,
+  output                         s_qdma2rdma_non_roce_axis_tready,
+
+  // RDMA RX interface from CMAC RX, no rx backpressure
+  input  [C_AXIS_DATA_WIDTH-1:0] s_cmac2rdma_roce_axis_tdata,
+  input  [C_AXIS_KEEP_WIDTH-1:0] s_cmac2rdma_roce_axis_tkeep,
+  input                          s_cmac2rdma_roce_axis_tvalid,
+  input                          s_cmac2rdma_roce_axis_tlast,
+  input                          s_cmac2rdma_roce_axis_tuser,
+
+  // Non-RDMA packets from CMAC RX bypassing RDMA, no rx backpressure
+  input  [C_AXIS_DATA_WIDTH-1:0] s_cmac2rdma_non_roce_axis_tdata,
+  input  [C_AXIS_KEEP_WIDTH-1:0] s_cmac2rdma_non_roce_axis_tkeep,
+  input                          s_cmac2rdma_non_roce_axis_tvalid,
+  input                          s_cmac2rdma_non_roce_axis_tlast,
+  input                          s_cmac2rdma_non_roce_axis_tuser,
+
+  // Non-RDMA packets bypassing RDMA to QDMA RX
+  output [C_AXIS_DATA_WIDTH-1:0] m_rdma2qdma_non_roce_axis_tdata,
+  output [C_AXIS_KEEP_WIDTH-1:0] m_rdma2qdma_non_roce_axis_tkeep,
+  output                         m_rdma2qdma_non_roce_axis_tvalid,
+  output                         m_rdma2qdma_non_roce_axis_tlast,
+  input                          m_rdma2qdma_non_roce_axis_tready,
+
+  // invalidate or immediate data from roce IETH/IMMDT header
+  output [C_AXIS_IMMDT_WIDTH-1:0] m_rdma2user_ieth_immdt_axis_tdata,
+  output                          m_rdma2user_ieth_immdt_axis_tlast,
+  output                          m_rdma2user_ieth_immdt_axis_tvalid,
+  input                           m_rdma2user_ieth_immdt_axis_trdy,
+
+  // RDMA AXI MM interface used to store payload from RDMA MAD, Send or Write operation
+  output           m_axi_rdma_send_write_payload_store_awid,
+  output  [63 : 0] m_axi_rdma_send_write_payload_store_awaddr,
+  output  [31 : 0] m_axi_rdma_send_write_payload_store_awuser,
+  output   [7 : 0] m_axi_rdma_send_write_payload_store_awlen,
+  output   [2 : 0] m_axi_rdma_send_write_payload_store_awsize,
+  output   [1 : 0] m_axi_rdma_send_write_payload_store_awburst,
+  output   [3 : 0] m_axi_rdma_send_write_payload_store_awcache,
+  output   [2 : 0] m_axi_rdma_send_write_payload_store_awprot,
+  output           m_axi_rdma_send_write_payload_store_awvalid,
+  input            m_axi_rdma_send_write_payload_store_awready,
+  output [511 : 0] m_axi_rdma_send_write_payload_store_wdata,
+  output  [63 : 0] m_axi_rdma_send_write_payload_store_wstrb,
+  output           m_axi_rdma_send_write_payload_store_wlast,
+  output           m_axi_rdma_send_write_payload_store_wvalid,
+  input            m_axi_rdma_send_write_payload_store_wready,
+  output           m_axi_rdma_send_write_payload_store_awlock,
+  input            m_axi_rdma_send_write_payload_store_bid,
+  input    [1 : 0] m_axi_rdma_send_write_payload_store_bresp,
+  input            m_axi_rdma_send_write_payload_store_bvalid,
+  output           m_axi_rdma_send_write_payload_store_bready,
+  output           m_axi_rdma_send_write_payload_store_arid,
+  output  [63 : 0] m_axi_rdma_send_write_payload_store_araddr,
+  output   [7 : 0] m_axi_rdma_send_write_payload_store_arlen,
+  output   [2 : 0] m_axi_rdma_send_write_payload_store_arsize,
+  output   [1 : 0] m_axi_rdma_send_write_payload_store_arburst,
+  output   [3 : 0] m_axi_rdma_send_write_payload_store_arcache,
+  output   [2 : 0] m_axi_rdma_send_write_payload_store_arprot,
+  output           m_axi_rdma_send_write_payload_store_arvalid,
+  input            m_axi_rdma_send_write_payload_store_arready,
+  input            m_axi_rdma_send_write_payload_store_rid,
+  input  [511 : 0] m_axi_rdma_send_write_payload_store_rdata,
+  input    [1 : 0] m_axi_rdma_send_write_payload_store_rresp,
+  input            m_axi_rdma_send_write_payload_store_rlast,
+  input            m_axi_rdma_send_write_payload_store_rvalid,
+  output           m_axi_rdma_send_write_payload_store_rready,
+  output           m_axi_rdma_send_write_payload_store_arlock,
+
+  // RDMA AXI MM interface used to store payload from RDMA Read response operation
+  output           m_axi_rdma_rsp_payload_awid,
+  output  [63 : 0] m_axi_rdma_rsp_payload_awaddr,
+  output   [7 : 0] m_axi_rdma_rsp_payload_awlen,
+  output   [2 : 0] m_axi_rdma_rsp_payload_awsize,
+  output   [1 : 0] m_axi_rdma_rsp_payload_awburst,
+  output   [3 : 0] m_axi_rdma_rsp_payload_awcache,
+  output   [2 : 0] m_axi_rdma_rsp_payload_awprot,
+  output           m_axi_rdma_rsp_payload_awvalid,
+  input            m_axi_rdma_rsp_payload_awready,
+  output [511 : 0] m_axi_rdma_rsp_payload_wdata,
+  output  [63 : 0] m_axi_rdma_rsp_payload_wstrb,
+  output           m_axi_rdma_rsp_payload_wlast,
+  output           m_axi_rdma_rsp_payload_wvalid,
+  input            m_axi_rdma_rsp_payload_wready,
+  output           m_axi_rdma_rsp_payload_awlock,
+  input            m_axi_rdma_rsp_payload_bid,
+  input    [1 : 0] m_axi_rdma_rsp_payload_bresp,
+  input            m_axi_rdma_rsp_payload_bvalid,
+  output           m_axi_rdma_rsp_payload_bready,
+  output           m_axi_rdma_rsp_payload_arid,
+  output  [63 : 0] m_axi_rdma_rsp_payload_araddr,
+  output   [7 : 0] m_axi_rdma_rsp_payload_arlen,
+  output   [2 : 0] m_axi_rdma_rsp_payload_arsize,
+  output   [1 : 0] m_axi_rdma_rsp_payload_arburst,
+  output   [3 : 0] m_axi_rdma_rsp_payload_arcache,
+  output   [2 : 0] m_axi_rdma_rsp_payload_arprot,
+  output           m_axi_rdma_rsp_payload_arvalid,
+  input            m_axi_rdma_rsp_payload_arready,
+  input            m_axi_rdma_rsp_payload_rid,
+  input  [511 : 0] m_axi_rdma_rsp_payload_rdata,
+  input    [1 : 0] m_axi_rdma_rsp_payload_rresp,
+  input            m_axi_rdma_rsp_payload_rlast,
+  input            m_axi_rdma_rsp_payload_rvalid,
+  output           m_axi_rdma_rsp_payload_rready,
+  output           m_axi_rdma_rsp_payload_arlock,
+
+  // RDMA AXI MM interface used to fetch WQE entries in the senq queue from DDR by the QP manager
+  output           m_axi_qp_get_wqe_awid,
+  output  [63 : 0] m_axi_qp_get_wqe_awaddr,
+  output   [7 : 0] m_axi_qp_get_wqe_awlen,
+  output   [2 : 0] m_axi_qp_get_wqe_awsize,
+  output   [1 : 0] m_axi_qp_get_wqe_awburst,
+  output   [3 : 0] m_axi_qp_get_wqe_awcache,
+  output   [2 : 0] m_axi_qp_get_wqe_awprot,
+  output           m_axi_qp_get_wqe_awvalid,
+  input            m_axi_qp_get_wqe_awready,
+  output [511 : 0] m_axi_qp_get_wqe_wdata,
+  output  [63 : 0] m_axi_qp_get_wqe_wstrb,
+  output           m_axi_qp_get_wqe_wlast,
+  output           m_axi_qp_get_wqe_wvalid,
+  input            m_axi_qp_get_wqe_wready,
+  output           m_axi_qp_get_wqe_awlock,
+  input            m_axi_qp_get_wqe_bid,
+  input    [1 : 0] m_axi_qp_get_wqe_bresp,
+  input            m_axi_qp_get_wqe_bvalid,
+  output           m_axi_qp_get_wqe_bready,
+  output           m_axi_qp_get_wqe_arid,
+  output  [63 : 0] m_axi_qp_get_wqe_araddr,
+  output   [7 : 0] m_axi_qp_get_wqe_arlen,
+  output   [2 : 0] m_axi_qp_get_wqe_arsize,
+  output   [1 : 0] m_axi_qp_get_wqe_arburst,
+  output   [3 : 0] m_axi_qp_get_wqe_arcache,
+  output   [2 : 0] m_axi_qp_get_wqe_arprot,
+  output           m_axi_qp_get_wqe_arvalid,
+  input            m_axi_qp_get_wqe_arready,
+  input            m_axi_qp_get_wqe_rid,
+  input  [511 : 0] m_axi_qp_get_wqe_rdata,
+  input    [1 : 0] m_axi_qp_get_wqe_rresp,
+  input            m_axi_qp_get_wqe_rlast,
+  input            m_axi_qp_get_wqe_rvalid,
+  output           m_axi_qp_get_wqe_rready,
+  output           m_axi_qp_get_wqe_arlock,
+
+  // RDMA AXI MM interface used to store payload of an outgoing RDMA write packet to a retry buffer
+  output           m_axi_payload_to_retry_buf_awid,
+  output  [63 : 0] m_axi_payload_to_retry_buf_awaddr,
+  output   [7 : 0] m_axi_payload_to_retry_buf_awlen,
+  output   [2 : 0] m_axi_payload_to_retry_buf_awsize,
+  output   [1 : 0] m_axi_payload_to_retry_buf_awburst,
+  output   [3 : 0] m_axi_payload_to_retry_buf_awcache,
+  output   [2 : 0] m_axi_payload_to_retry_buf_awprot,
+  output           m_axi_payload_to_retry_buf_awvalid,
+  input            m_axi_payload_to_retry_buf_awready,
+  output [511 : 0] m_axi_payload_to_retry_buf_wdata,
+  output  [63 : 0] m_axi_payload_to_retry_buf_wstrb,
+  output           m_axi_payload_to_retry_buf_wlast,
+  output           m_axi_payload_to_retry_buf_wvalid,
+  input            m_axi_payload_to_retry_buf_wready,
+  output           m_axi_payload_to_retry_buf_awlock,
+  input            m_axi_payload_to_retry_buf_bid,
+  input    [1 : 0] m_axi_payload_to_retry_buf_bresp,
+  input            m_axi_payload_to_retry_buf_bvalid,
+  output           m_axi_payload_to_retry_buf_bready,
+  output           m_axi_payload_to_retry_buf_arid,
+  output  [63 : 0] m_axi_payload_to_retry_buf_araddr,
+  output   [7 : 0] m_axi_payload_to_retry_buf_arlen,
+  output   [2 : 0] m_axi_payload_to_retry_buf_arsize,
+  output   [1 : 0] m_axi_payload_to_retry_buf_arburst,
+  output   [3 : 0] m_axi_payload_to_retry_buf_arcache,
+  output   [2 : 0] m_axi_payload_to_retry_buf_arprot,
+  output           m_axi_payload_to_retry_buf_arvalid,
+  input            m_axi_payload_to_retry_buf_arready,
+  input            m_axi_payload_to_retry_buf_rid,
+  input  [511 : 0] m_axi_payload_to_retry_buf_rdata,
+  input    [1 : 0] m_axi_payload_to_retry_buf_rresp,
+  input            m_axi_payload_to_retry_buf_rlast,
+  input            m_axi_payload_to_retry_buf_rvalid,
+  output           m_axi_payload_to_retry_buf_rready,
+  output           m_axi_payload_to_retry_buf_arlock,
+
+  // RDMA AXI MM interface used to get payload of an outgoing RDMA send/write and read response packets
+  output           m_axi_pktgen_get_payload_awid,
+  output  [63 : 0] m_axi_pktgen_get_payload_awaddr,
+  output   [7 : 0] m_axi_pktgen_get_payload_awlen,
+  output   [2 : 0] m_axi_pktgen_get_payload_awsize,
+  output   [1 : 0] m_axi_pktgen_get_payload_awburst,
+  output   [3 : 0] m_axi_pktgen_get_payload_awcache,
+  output   [2 : 0] m_axi_pktgen_get_payload_awprot,
+  output           m_axi_pktgen_get_payload_awvalid,
+  input            m_axi_pktgen_get_payload_awready,
+  output [511 : 0] m_axi_pktgen_get_payload_wdata,
+  output  [63 : 0] m_axi_pktgen_get_payload_wstrb,
+  output           m_axi_pktgen_get_payload_wlast,
+  output           m_axi_pktgen_get_payload_wvalid,
+  input            m_axi_pktgen_get_payload_wready,
+  output           m_axi_pktgen_get_payload_awlock,
+  input            m_axi_pktgen_get_payload_bid,
+  input    [1 : 0] m_axi_pktgen_get_payload_bresp,
+  input            m_axi_pktgen_get_payload_bvalid,
+  output           m_axi_pktgen_get_payload_bready,
+  output           m_axi_pktgen_get_payload_arid,
+  output  [63 : 0] m_axi_pktgen_get_payload_araddr,
+  output   [7 : 0] m_axi_pktgen_get_payload_arlen,
+  output   [2 : 0] m_axi_pktgen_get_payload_arsize,
+  output   [1 : 0] m_axi_pktgen_get_payload_arburst,
+  output   [3 : 0] m_axi_pktgen_get_payload_arcache,
+  output   [2 : 0] m_axi_pktgen_get_payload_arprot,
+  output           m_axi_pktgen_get_payload_arvalid,
+  input            m_axi_pktgen_get_payload_arready,
+  input            m_axi_pktgen_get_payload_rid,
+  input  [511 : 0] m_axi_pktgen_get_payload_rdata,
+  input    [1 : 0] m_axi_pktgen_get_payload_rresp,
+  input            m_axi_pktgen_get_payload_rlast,
+  input            m_axi_pktgen_get_payload_rvalid,
+  output           m_axi_pktgen_get_payload_rready,
+  output           m_axi_pktgen_get_payload_arlock,
+
+  // RDMA AXI MM interface used to write completion entries to a completion queue in the DDR
+  output           m_axi_write_completion_awid,
+  output  [63 : 0] m_axi_write_completion_awaddr,
+  output   [7 : 0] m_axi_write_completion_awlen,
+  output   [2 : 0] m_axi_write_completion_awsize,
+  output   [1 : 0] m_axi_write_completion_awburst,
+  output   [3 : 0] m_axi_write_completion_awcache,
+  output   [2 : 0] m_axi_write_completion_awprot,
+  output           m_axi_write_completion_awvalid,
+  input            m_axi_write_completion_awready,
+  output [511 : 0] m_axi_write_completion_wdata,
+  output  [63 : 0] m_axi_write_completion_wstrb,
+  output           m_axi_write_completion_wlast,
+  output           m_axi_write_completion_wvalid,
+  input            m_axi_write_completion_wready,
+  output           m_axi_write_completion_awlock,
+  input            m_axi_write_completion_bid,
+  input    [1 : 0] m_axi_write_completion_bresp,
+  input            m_axi_write_completion_bvalid,
+  output           m_axi_write_completion_bready,
+  output           m_axi_write_completion_arid,
+  output  [63 : 0] m_axi_write_completion_araddr,
+  output   [7 : 0] m_axi_write_completion_arlen,
+  output   [2 : 0] m_axi_write_completion_arsize,
+  output   [1 : 0] m_axi_write_completion_arburst,
+  output   [3 : 0] m_axi_write_completion_arcache,
+  output   [2 : 0] m_axi_write_completion_arprot,
+  output           m_axi_write_completion_arvalid,
+  input            m_axi_write_completion_arready,
+  input            m_axi_write_completion_rid,
+  input  [511 : 0] m_axi_write_completion_rdata,
+  input    [1 : 0] m_axi_write_completion_rresp,
+  input            m_axi_write_completion_rlast,
+  input            m_axi_write_completion_rvalid,
+  output           m_axi_write_completion_rready,
+  output           m_axi_write_completion_arlock,
+
+  // Send WQE completion queue doorbell
+  output           resp_hndler_o_send_cq_db_cnt_valid,
+  output     [9:0] resp_hndler_o_send_cq_db_addr,
+  output    [31:0] resp_hndler_o_send_cq_db_cnt,
+  input            resp_hndler_i_send_cq_db_rdy,
+
+  // Send WQE producer index doorbell
+  input     [15:0] i_qp_sq_pidb_hndshk,
+  input     [31:0] i_qp_sq_pidb_wr_addr_hndshk,
+  input            i_qp_sq_pidb_wr_valid_hndshk,
+  output           o_qp_sq_pidb_wr_rdy,
+
+  // RDMA-Send consumer index doorbell
+  input     [15:0] i_qp_rq_cidb_hndshk,
+  input     [31:0] i_qp_rq_cidb_wr_addr_hndshk,
+  input            i_qp_rq_cidb_wr_valid_hndshk,
+  output           o_qp_rq_cidb_wr_rdy,
+
+  // RDMA-Send producer index doorbell
+  output    [31:0] rx_pkt_hndler_o_rq_db_data,
+  output     [9:0] rx_pkt_hndler_o_rq_db_addr,
+  output           rx_pkt_hndler_o_rq_db_data_valid,
+  input            rx_pkt_hndler_i_rq_db_rdy,
+
+  output           rnic_intr,
+  input      [8:0] stat_rx_pause_req,
+  output     [8:0] ctl_tx_pause_req,
+  output           ctl_tx_resend_pause,
+
+  output           o_global_dbg_cnt_en,
+  output           o_global_dbg_cnt_clr,
+
+  input  axil_rstn,
+  input  axis_rstn,
+  input  axil_clk,
+  input  axis_clk,
+  output rdma_resetn_done
+);
+
+rdma_core rdma_inst (
+  .s_axi_lite_aclk                   (axil_clk),
+  .s_axi_lite_aresetn                (axil_rstn),
+  .m_axi_aclk                        (axis_clk),
+  .m_axi_aresetn                     (axis_rstn),
+  .cmac_rx_clk                       (axis_clk),
+  .cmac_rx_rst                       (~axis_rstn),
+  .cmac_tx_clk                       (axis_clk),
+  .cmac_tx_rst                       (~axis_rstn),
+  .system_resetn                     (rdma_resetn_done),
+
+  .s_axi_lite_awaddr                 (s_axil_awaddr),
+  .s_axi_lite_awready                (s_axil_awready),
+  .s_axi_lite_awvalid                (s_axil_awvalid),
+  .s_axi_lite_araddr                 (s_axil_araddr),
+  .s_axi_lite_arready                (s_axil_arready),
+  .s_axi_lite_arvalid                (s_axil_arvalid),
+  .s_axi_lite_wdata                  (s_axil_wdata),
+  .s_axi_lite_wstrb                  (s_axil_wstrb),
+  .s_axi_lite_wready                 (s_axil_wready),
+  .s_axi_lite_wvalid                 (s_axil_wvalid),
+  .s_axi_lite_rdata                  (s_axil_rdata),
+  .s_axi_lite_rresp                  (s_axil_rresp),
+  .s_axi_lite_rready                 (s_axil_rready),
+  .s_axi_lite_rvalid                 (s_axil_rvalid),
+  .s_axi_lite_bresp                  (s_axil_bresp),
+  .s_axi_lite_bready                 (s_axil_bready),
+  .s_axi_lite_bvalid                 (s_axil_bvalid),
+
+  // RDMA AXI MM interface used to store payload from RDMA MAD, Send or Write operation
+  .rx_pkt_hndler_ddr_m_axi_awid      (m_axi_rdma_send_write_payload_store_awid),
+  .rx_pkt_hndler_ddr_m_axi_awaddr    (m_axi_rdma_send_write_payload_store_awaddr),
+  .rx_pkt_hndler_ddr_m_axi_awuser    (m_axi_rdma_send_write_payload_store_awuser),
+  .rx_pkt_hndler_ddr_m_axi_awlen     (m_axi_rdma_send_write_payload_store_awlen),
+  .rx_pkt_hndler_ddr_m_axi_awsize    (m_axi_rdma_send_write_payload_store_awsize),
+  .rx_pkt_hndler_ddr_m_axi_awburst   (m_axi_rdma_send_write_payload_store_awburst),
+  .rx_pkt_hndler_ddr_m_axi_awcache   (m_axi_rdma_send_write_payload_store_awcache),
+  .rx_pkt_hndler_ddr_m_axi_awprot    (m_axi_rdma_send_write_payload_store_awprot),
+  .rx_pkt_hndler_ddr_m_axi_awvalid   (m_axi_rdma_send_write_payload_store_awvalid),
+  .rx_pkt_hndler_ddr_m_axi_awready   (m_axi_rdma_send_write_payload_store_awready),
+  .rx_pkt_hndler_ddr_m_axi_wdata     (m_axi_rdma_send_write_payload_store_wdata),
+  .rx_pkt_hndler_ddr_m_axi_wstrb     (m_axi_rdma_send_write_payload_store_wstrb),
+  .rx_pkt_hndler_ddr_m_axi_wlast     (m_axi_rdma_send_write_payload_store_wlast),
+  .rx_pkt_hndler_ddr_m_axi_wvalid    (m_axi_rdma_send_write_payload_store_wvalid),
+  .rx_pkt_hndler_ddr_m_axi_wready    (m_axi_rdma_send_write_payload_store_wready),
+  .rx_pkt_hndler_ddr_m_axi_awlock    (m_axi_rdma_send_write_payload_store_awlock),
+  .rx_pkt_hndler_ddr_m_axi_bid       (m_axi_rdma_send_write_payload_store_bid),
+  .rx_pkt_hndler_ddr_m_axi_bresp     (m_axi_rdma_send_write_payload_store_bresp),
+  .rx_pkt_hndler_ddr_m_axi_bvalid    (m_axi_rdma_send_write_payload_store_bvalid),
+  .rx_pkt_hndler_ddr_m_axi_bready    (m_axi_rdma_send_write_payload_store_bready),
+  .rx_pkt_hndler_ddr_m_axi_arid      (m_axi_rdma_send_write_payload_store_arid),
+  .rx_pkt_hndler_ddr_m_axi_araddr    (m_axi_rdma_send_write_payload_store_araddr),
+  .rx_pkt_hndler_ddr_m_axi_arlen     (m_axi_rdma_send_write_payload_store_arlen),
+  .rx_pkt_hndler_ddr_m_axi_arsize    (m_axi_rdma_send_write_payload_store_arsize),
+  .rx_pkt_hndler_ddr_m_axi_arburst   (m_axi_rdma_send_write_payload_store_arburst),
+  .rx_pkt_hndler_ddr_m_axi_arcache   (m_axi_rdma_send_write_payload_store_arcache),
+  .rx_pkt_hndler_ddr_m_axi_arprot    (m_axi_rdma_send_write_payload_store_arprot),
+  .rx_pkt_hndler_ddr_m_axi_arvalid   (m_axi_rdma_send_write_payload_store_arvalid),
+  .rx_pkt_hndler_ddr_m_axi_arready   (m_axi_rdma_send_write_payload_store_arready),
+  .rx_pkt_hndler_ddr_m_axi_rid       (m_axi_rdma_send_write_payload_store_rid),
+  .rx_pkt_hndler_ddr_m_axi_rdata     (m_axi_rdma_send_write_payload_store_rdata),
+  .rx_pkt_hndler_ddr_m_axi_rresp     (m_axi_rdma_send_write_payload_store_rresp),
+  .rx_pkt_hndler_ddr_m_axi_rlast     (m_axi_rdma_send_write_payload_store_rlast),
+  .rx_pkt_hndler_ddr_m_axi_rvalid    (m_axi_rdma_send_write_payload_store_rvalid),
+  .rx_pkt_hndler_ddr_m_axi_rready    (m_axi_rdma_send_write_payload_store_rready),
+  .rx_pkt_hndler_ddr_m_axi_arlock    (m_axi_rdma_send_write_payload_store_arlock),
+
+  // RDMA AXI MM interface used to store payload from RDMA Read response operation
+  .rx_pkt_hndler_rdrsp_m_axi_awid    (m_axi_rdma_rsp_payload_awid),
+  .rx_pkt_hndler_rdrsp_m_axi_awaddr  (m_axi_rdma_rsp_payload_awaddr),
+  .rx_pkt_hndler_rdrsp_m_axi_awlen   (m_axi_rdma_rsp_payload_awlen),
+  .rx_pkt_hndler_rdrsp_m_axi_awsize  (m_axi_rdma_rsp_payload_awsize),
+  .rx_pkt_hndler_rdrsp_m_axi_awburst (m_axi_rdma_rsp_payload_awburst),
+  .rx_pkt_hndler_rdrsp_m_axi_awcache (m_axi_rdma_rsp_payload_awcache),
+  .rx_pkt_hndler_rdrsp_m_axi_awprot  (m_axi_rdma_rsp_payload_awprot),
+  .rx_pkt_hndler_rdrsp_m_axi_awvalid (m_axi_rdma_rsp_payload_awvalid),
+  .rx_pkt_hndler_rdrsp_m_axi_awready (m_axi_rdma_rsp_payload_awready),
+  .rx_pkt_hndler_rdrsp_m_axi_wdata   (m_axi_rdma_rsp_payload_wdata),
+  .rx_pkt_hndler_rdrsp_m_axi_wstrb   (m_axi_rdma_rsp_payload_wstrb),
+  .rx_pkt_hndler_rdrsp_m_axi_wlast   (m_axi_rdma_rsp_payload_wlast),
+  .rx_pkt_hndler_rdrsp_m_axi_wvalid  (m_axi_rdma_rsp_payload_wvalid),
+  .rx_pkt_hndler_rdrsp_m_axi_wready  (m_axi_rdma_rsp_payload_wready),
+  .rx_pkt_hndler_rdrsp_m_axi_awlock  (m_axi_rdma_rsp_payload_awlock),
+  .rx_pkt_hndler_rdrsp_m_axi_bid     (m_axi_rdma_rsp_payload_bid),
+  .rx_pkt_hndler_rdrsp_m_axi_bresp   (m_axi_rdma_rsp_payload_bresp),
+  .rx_pkt_hndler_rdrsp_m_axi_bvalid  (m_axi_rdma_rsp_payload_bvalid),
+  .rx_pkt_hndler_rdrsp_m_axi_bready  (m_axi_rdma_rsp_payload_bready),
+  .rx_pkt_hndler_rdrsp_m_axi_arid    (m_axi_rdma_rsp_payload_arid),
+  .rx_pkt_hndler_rdrsp_m_axi_araddr  (m_axi_rdma_rsp_payload_araddr),
+  .rx_pkt_hndler_rdrsp_m_axi_arlen   (m_axi_rdma_rsp_payload_arlen),
+  .rx_pkt_hndler_rdrsp_m_axi_arsize  (m_axi_rdma_rsp_payload_arsize),
+  .rx_pkt_hndler_rdrsp_m_axi_arburst (m_axi_rdma_rsp_payload_arburst),
+  .rx_pkt_hndler_rdrsp_m_axi_arcache (m_axi_rdma_rsp_payload_arcache),
+  .rx_pkt_hndler_rdrsp_m_axi_arprot  (m_axi_rdma_rsp_payload_arprot),
+  .rx_pkt_hndler_rdrsp_m_axi_arvalid (m_axi_rdma_rsp_payload_arvalid),
+  .rx_pkt_hndler_rdrsp_m_axi_arready (m_axi_rdma_rsp_payload_arready),
+  .rx_pkt_hndler_rdrsp_m_axi_rid     (m_axi_rdma_rsp_payload_rid),
+  .rx_pkt_hndler_rdrsp_m_axi_rdata   (m_axi_rdma_rsp_payload_rdata),
+  .rx_pkt_hndler_rdrsp_m_axi_rresp   (m_axi_rdma_rsp_payload_rresp),
+  .rx_pkt_hndler_rdrsp_m_axi_rlast   (m_axi_rdma_rsp_payload_rlast),
+  .rx_pkt_hndler_rdrsp_m_axi_rvalid  (m_axi_rdma_rsp_payload_rvalid),
+  .rx_pkt_hndler_rdrsp_m_axi_rready  (m_axi_rdma_rsp_payload_rready),
+  .rx_pkt_hndler_rdrsp_m_axi_arlock  (m_axi_rdma_rsp_payload_arlock),
+
+  // RDMA AXI MM interface used to fetch WQE entries in the send queue from DDR by the QP manage
+  .qp_mgr_m_axi_awid                 (m_axi_qp_get_wqe_awid),
+  .qp_mgr_m_axi_awaddr               (m_axi_qp_get_wqe_awaddr),
+  .qp_mgr_m_axi_awlen                (m_axi_qp_get_wqe_awlen),
+  .qp_mgr_m_axi_awsize               (m_axi_qp_get_wqe_awsize),
+  .qp_mgr_m_axi_awburst              (m_axi_qp_get_wqe_awburst),
+  .qp_mgr_m_axi_awcache              (m_axi_qp_get_wqe_awcache),
+  .qp_mgr_m_axi_awprot               (m_axi_qp_get_wqe_awprot),
+  .qp_mgr_m_axi_awvalid              (m_axi_qp_get_wqe_awvalid),
+  .qp_mgr_m_axi_awready              (m_axi_qp_get_wqe_awready),
+  .qp_mgr_m_axi_wdata                (m_axi_qp_get_wqe_wdata),
+  .qp_mgr_m_axi_wstrb                (m_axi_qp_get_wqe_wstrb),
+  .qp_mgr_m_axi_wlast                (m_axi_qp_get_wqe_wlast),
+  .qp_mgr_m_axi_wvalid               (m_axi_qp_get_wqe_wvalid),
+  .qp_mgr_m_axi_wready               (m_axi_qp_get_wqe_wready),
+  .qp_mgr_m_axi_awlock               (m_axi_qp_get_wqe_awlock),
+  .qp_mgr_m_axi_bid                  (m_axi_qp_get_wqe_bid),
+  .qp_mgr_m_axi_bresp                (m_axi_qp_get_wqe_bresp),
+  .qp_mgr_m_axi_bvalid               (m_axi_qp_get_wqe_bvalid),
+  .qp_mgr_m_axi_bready               (m_axi_qp_get_wqe_bready),
+  .qp_mgr_m_axi_arid                 (m_axi_qp_get_wqe_arid),
+  .qp_mgr_m_axi_araddr               (m_axi_qp_get_wqe_araddr),
+  .qp_mgr_m_axi_arlen                (m_axi_qp_get_wqe_arlen),
+  .qp_mgr_m_axi_arsize               (m_axi_qp_get_wqe_arsize),
+  .qp_mgr_m_axi_arburst              (m_axi_qp_get_wqe_arburst),
+  .qp_mgr_m_axi_arcache              (m_axi_qp_get_wqe_arcache),
+  .qp_mgr_m_axi_arprot               (m_axi_qp_get_wqe_arprot),
+  .qp_mgr_m_axi_arvalid              (m_axi_qp_get_wqe_arvalid),
+  .qp_mgr_m_axi_arready              (m_axi_qp_get_wqe_arready),
+  .qp_mgr_m_axi_rid                  (m_axi_qp_get_wqe_rid),
+  .qp_mgr_m_axi_rdata                (m_axi_qp_get_wqe_rdata),
+  .qp_mgr_m_axi_rresp                (m_axi_qp_get_wqe_rresp),
+  .qp_mgr_m_axi_rlast                (m_axi_qp_get_wqe_rlast),
+  .qp_mgr_m_axi_rvalid               (m_axi_qp_get_wqe_rvalid),
+  .qp_mgr_m_axi_rready               (m_axi_qp_get_wqe_rready),
+  .qp_mgr_m_axi_arlock               (m_axi_qp_get_wqe_arlock),
+
+  // RDMA TX interface to CMAC TX path in AXIS format
+  .cmac_m_axis_tdata                 (m_rdma2cmac_axis_tdata),
+  .cmac_m_axis_tkeep                 (m_rdma2cmac_axis_tkeep),
+  .cmac_m_axis_tvalid                (m_rdma2cmac_axis_tvalid),
+  .cmac_m_axis_tlast                 (m_rdma2cmac_axis_tlast),
+  .cmac_m_axis_tready                (m_rdma2cmac_axis_tready),
+
+  // store payload of an outgoing RDMA write packet to a retry buffer
+  // .wqe_proc_wr_ddr_m_axi_awid        (m_axi_payload_to_retry_buf_awid),
+  // .wqe_proc_wr_ddr_m_axi_awaddr      (m_axi_payload_to_retry_buf_awaddr),
+  // .wqe_proc_wr_ddr_m_axi_awlen       (m_axi_payload_to_retry_buf_awlen),
+  // .wqe_proc_wr_ddr_m_axi_awsize      (m_axi_payload_to_retry_buf_awsize),
+  // .wqe_proc_wr_ddr_m_axi_awburst     (m_axi_payload_to_retry_buf_awburst),
+  // .wqe_proc_wr_ddr_m_axi_awcache     (m_axi_payload_to_retry_buf_awcache),
+  // .wqe_proc_wr_ddr_m_axi_awprot      (m_axi_payload_to_retry_buf_awprot),
+  // .wqe_proc_wr_ddr_m_axi_awvalid     (m_axi_payload_to_retry_buf_awvalid),
+  // .wqe_proc_wr_ddr_m_axi_awready     (m_axi_payload_to_retry_buf_awready),
+  // .wqe_proc_wr_ddr_m_axi_wdata       (m_axi_payload_to_retry_buf_wdata),
+  // .wqe_proc_wr_ddr_m_axi_wstrb       (m_axi_payload_to_retry_buf_wstrb),
+  // .wqe_proc_wr_ddr_m_axi_wlast       (m_axi_payload_to_retry_buf_wlast),
+  // .wqe_proc_wr_ddr_m_axi_wvalid      (m_axi_payload_to_retry_buf_wvalid),
+  // .wqe_proc_wr_ddr_m_axi_wready      (m_axi_payload_to_retry_buf_wready),
+  // .wqe_proc_wr_ddr_m_axi_awlock      (m_axi_payload_to_retry_buf_awlock),
+  // .wqe_proc_wr_ddr_m_axi_bid         (m_axi_payload_to_retry_buf_bid),
+  // .wqe_proc_wr_ddr_m_axi_bresp       (m_axi_payload_to_retry_buf_bresp),
+  // .wqe_proc_wr_ddr_m_axi_bvalid      (m_axi_payload_to_retry_buf_bvalid),
+  // .wqe_proc_wr_ddr_m_axi_bready      (m_axi_payload_to_retry_buf_bready),
+  // .wqe_proc_wr_ddr_m_axi_arid        (m_axi_payload_to_retry_buf_arid),
+  // .wqe_proc_wr_ddr_m_axi_araddr      (m_axi_payload_to_retry_buf_araddr),
+  // .wqe_proc_wr_ddr_m_axi_arlen       (m_axi_payload_to_retry_buf_arlen),
+  // .wqe_proc_wr_ddr_m_axi_arsize      (m_axi_payload_to_retry_buf_arsize),
+  // .wqe_proc_wr_ddr_m_axi_arburst     (m_axi_payload_to_retry_buf_arburst),
+  // .wqe_proc_wr_ddr_m_axi_arcache     (m_axi_payload_to_retry_buf_arcache),
+  // .wqe_proc_wr_ddr_m_axi_arprot      (m_axi_payload_to_retry_buf_arprot),
+  // .wqe_proc_wr_ddr_m_axi_arvalid     (m_axi_payload_to_retry_buf_arvalid),
+  // .wqe_proc_wr_ddr_m_axi_arready     (m_axi_payload_to_retry_buf_arready),
+  // .wqe_proc_wr_ddr_m_axi_rid         (m_axi_payload_to_retry_buf_rid),
+  // .wqe_proc_wr_ddr_m_axi_rdata       (m_axi_payload_to_retry_buf_rdata),
+  // .wqe_proc_wr_ddr_m_axi_rresp       (m_axi_payload_to_retry_buf_rresp),
+  // .wqe_proc_wr_ddr_m_axi_rlast       (m_axi_payload_to_retry_buf_rlast),
+  // .wqe_proc_wr_ddr_m_axi_rvalid      (m_axi_payload_to_retry_buf_rvalid),
+  // .wqe_proc_wr_ddr_m_axi_rready      (m_axi_payload_to_retry_buf_rready),
+  // .wqe_proc_wr_ddr_m_axi_arlock      (m_axi_payload_to_retry_buf_arlock),
+
+  // Acquire payload data for RDMA send/write/read response packet generation
+  .wqe_proc_top_m_axi_awid           (m_axi_pktgen_get_payload_awid),
+  .wqe_proc_top_m_axi_awaddr         (m_axi_pktgen_get_payload_awaddr),
+  .wqe_proc_top_m_axi_awlen          (m_axi_pktgen_get_payload_awlen),
+  .wqe_proc_top_m_axi_awsize         (m_axi_pktgen_get_payload_awsize),
+  .wqe_proc_top_m_axi_awburst        (m_axi_pktgen_get_payload_awburst),
+  .wqe_proc_top_m_axi_awcache        (m_axi_pktgen_get_payload_awcache),
+  .wqe_proc_top_m_axi_awprot         (m_axi_pktgen_get_payload_awprot),
+  .wqe_proc_top_m_axi_awvalid        (m_axi_pktgen_get_payload_awvalid),
+  .wqe_proc_top_m_axi_awready        (m_axi_pktgen_get_payload_awready),
+  .wqe_proc_top_m_axi_wdata          (m_axi_pktgen_get_payload_wdata),
+  .wqe_proc_top_m_axi_wstrb          (m_axi_pktgen_get_payload_wstrb),
+  .wqe_proc_top_m_axi_wlast          (m_axi_pktgen_get_payload_wlast),
+  .wqe_proc_top_m_axi_wvalid         (m_axi_pktgen_get_payload_wvalid),
+  .wqe_proc_top_m_axi_wready         (m_axi_pktgen_get_payload_wready),
+  .wqe_proc_top_m_axi_awlock         (m_axi_pktgen_get_payload_awlock),
+  .wqe_proc_top_m_axi_bid            (m_axi_pktgen_get_payload_bid),
+  .wqe_proc_top_m_axi_bresp          (m_axi_pktgen_get_payload_bresp),
+  .wqe_proc_top_m_axi_bvalid         (m_axi_pktgen_get_payload_bvalid),
+  .wqe_proc_top_m_axi_bready         (m_axi_pktgen_get_payload_bready),
+  .wqe_proc_top_m_axi_arid           (m_axi_pktgen_get_payload_arid),
+  .wqe_proc_top_m_axi_araddr         (m_axi_pktgen_get_payload_araddr),
+  .wqe_proc_top_m_axi_arlen          (m_axi_pktgen_get_payload_arlen),
+  .wqe_proc_top_m_axi_arsize         (m_axi_pktgen_get_payload_arsize),
+  .wqe_proc_top_m_axi_arburst        (m_axi_pktgen_get_payload_arburst),
+  .wqe_proc_top_m_axi_arcache        (m_axi_pktgen_get_payload_arcache),
+  .wqe_proc_top_m_axi_arprot         (m_axi_pktgen_get_payload_arprot),
+  .wqe_proc_top_m_axi_arvalid        (m_axi_pktgen_get_payload_arvalid),
+  .wqe_proc_top_m_axi_arready        (m_axi_pktgen_get_payload_arready),
+  .wqe_proc_top_m_axi_rid            (m_axi_pktgen_get_payload_rid),
+  .wqe_proc_top_m_axi_rdata          (m_axi_pktgen_get_payload_rdata),
+  .wqe_proc_top_m_axi_rresp          (m_axi_pktgen_get_payload_rresp),
+  .wqe_proc_top_m_axi_rlast          (m_axi_pktgen_get_payload_rlast),
+  .wqe_proc_top_m_axi_rvalid         (m_axi_pktgen_get_payload_rvalid),
+  .wqe_proc_top_m_axi_rready         (m_axi_pktgen_get_payload_rready),
+  .wqe_proc_top_m_axi_arlock         (m_axi_pktgen_get_payload_arlock),
+
+  // RDMA AXI MM interface used to write completion entries to a completion queue in the DDR
+  .resp_hndler_m_axi_awid            (m_axi_write_completion_awid),
+  .resp_hndler_m_axi_awaddr          (m_axi_write_completion_awaddr),
+  .resp_hndler_m_axi_awlen           (m_axi_write_completion_awlen),
+  .resp_hndler_m_axi_awsize          (m_axi_write_completion_awsize),
+  .resp_hndler_m_axi_awburst         (m_axi_write_completion_awburst),
+  .resp_hndler_m_axi_awcache         (m_axi_write_completion_awcache),
+  .resp_hndler_m_axi_awprot          (m_axi_write_completion_awprot),
+  .resp_hndler_m_axi_awvalid         (m_axi_write_completion_awvalid),
+  .resp_hndler_m_axi_awready         (m_axi_write_completion_awready),
+  .resp_hndler_m_axi_wdata           (m_axi_write_completion_wdata),
+  .resp_hndler_m_axi_wstrb           (m_axi_write_completion_wstrb),
+  .resp_hndler_m_axi_wlast           (m_axi_write_completion_wlast),
+  .resp_hndler_m_axi_wvalid          (m_axi_write_completion_wvalid),
+  .resp_hndler_m_axi_wready          (m_axi_write_completion_wready),
+  .resp_hndler_m_axi_awlock          (m_axi_write_completion_awlock),
+  .resp_hndler_m_axi_bid             (m_axi_write_completion_bid),
+  .resp_hndler_m_axi_bresp           (m_axi_write_completion_bresp),
+  .resp_hndler_m_axi_bvalid          (m_axi_write_completion_bvalid),
+  .resp_hndler_m_axi_bready          (m_axi_write_completion_bready),
+  .resp_hndler_m_axi_arid            (m_axi_write_completion_arid),
+  .resp_hndler_m_axi_araddr          (m_axi_write_completion_araddr),
+  .resp_hndler_m_axi_arlen           (m_axi_write_completion_arlen),
+  .resp_hndler_m_axi_arsize          (m_axi_write_completion_arsize),
+  .resp_hndler_m_axi_arburst         (m_axi_write_completion_arburst),
+  .resp_hndler_m_axi_arcache         (m_axi_write_completion_arcache),
+  .resp_hndler_m_axi_arprot          (m_axi_write_completion_arprot),
+  .resp_hndler_m_axi_arvalid         (m_axi_write_completion_arvalid),
+  .resp_hndler_m_axi_arready         (m_axi_write_completion_arready),
+  .resp_hndler_m_axi_rid             (m_axi_write_completion_rid),
+  .resp_hndler_m_axi_rdata           (m_axi_write_completion_rdata),
+  .resp_hndler_m_axi_rresp           (m_axi_write_completion_rresp),
+  .resp_hndler_m_axi_rlast           (m_axi_write_completion_rlast),
+  .resp_hndler_m_axi_rvalid          (m_axi_write_completion_rvalid),
+  .resp_hndler_m_axi_rready          (m_axi_write_completion_rready),
+  .resp_hndler_m_axi_arlock          (m_axi_write_completion_arlock),
+
+  // Send WQE completion queue doorbell
+  .resp_hndler_o_send_cq_db_cnt_valid(resp_hndler_o_send_cq_db_cnt_valid),
+  .resp_hndler_o_send_cq_db_addr     (resp_hndler_o_send_cq_db_addr),
+  .resp_hndler_o_send_cq_db_cnt      (resp_hndler_o_send_cq_db_cnt),
+  .resp_hndler_i_send_cq_db_rdy      (resp_hndler_i_send_cq_db_rdy),
+
+  // RDMA-Send consumer index doorbell
+  .i_qp_rq_cidb_hndshk               (i_qp_rq_cidb_hndshk),
+  .i_qp_rq_cidb_wr_addr_hndshk       (i_qp_rq_cidb_wr_addr_hndshk),
+  .i_qp_rq_cidb_wr_valid_hndshk      (i_qp_rq_cidb_wr_valid_hndshk),
+  .o_qp_rq_cidb_wr_rdy               (o_qp_rq_cidb_wr_rdy),
+
+  // Send WQE producer index doorbell
+  .i_qp_sq_pidb_hndshk               (i_qp_sq_pidb_hndshk),
+  .i_qp_sq_pidb_wr_addr_hndshk       (i_qp_sq_pidb_wr_addr_hndshk),
+  .i_qp_sq_pidb_wr_valid_hndshk      (i_qp_sq_pidb_wr_valid_hndshk),
+  .o_qp_sq_pidb_wr_rdy               (o_qp_sq_pidb_wr_rdy),
+
+  // RDMA-Send producer index doorbell
+  .rx_pkt_hndler_o_rq_db_data        (rx_pkt_hndler_o_rq_db_data),
+  .rx_pkt_hndler_o_rq_db_addr        (rx_pkt_hndler_o_rq_db_addr),
+  .rx_pkt_hndler_o_rq_db_data_valid  (rx_pkt_hndler_o_rq_db_data_valid),
+  .rx_pkt_hndler_i_rq_db_rdy         (rx_pkt_hndler_i_rq_db_rdy),
+
+  // RDMA RX interface from CMAC RX path in AXIS format
+  .roce_cmac_s_axis_tvalid           (s_cmac2rdma_roce_axis_tvalid),
+  .roce_cmac_s_axis_tdata            (s_cmac2rdma_roce_axis_tdata),
+  .roce_cmac_s_axis_tkeep            (s_cmac2rdma_roce_axis_tkeep),
+  .roce_cmac_s_axis_tlast            (s_cmac2rdma_roce_axis_tlast),
+  .roce_cmac_s_axis_tuser            (s_cmac2rdma_roce_axis_tuser),
+
+  // Non-RDMA packets from CMAC RX path in AXIS format
+  .non_roce_cmac_s_axis_tvalid       (s_cmac2rdma_non_roce_axis_tvalid),
+  .non_roce_cmac_s_axis_tdata        (s_cmac2rdma_non_roce_axis_tdata),
+  .non_roce_cmac_s_axis_tkeep        (s_cmac2rdma_non_roce_axis_tkeep),
+  .non_roce_cmac_s_axis_tlast        (s_cmac2rdma_non_roce_axis_tlast),
+  .non_roce_cmac_s_axis_tuser        (s_cmac2rdma_non_roce_axis_tuser),
+
+  // Non-RDMA packets from QDMA TX path in AXIS format bypassing RDMA core
+  .non_roce_dma_s_axis_tvalid        (s_qdma2rdma_non_roce_axis_tvalid),
+  .non_roce_dma_s_axis_tdata         (s_qdma2rdma_non_roce_axis_tdata),
+  .non_roce_dma_s_axis_tkeep         (s_qdma2rdma_non_roce_axis_tkeep),
+  .non_roce_dma_s_axis_tlast         (s_qdma2rdma_non_roce_axis_tlast),
+  .non_roce_dma_s_axis_tready        (s_qdma2rdma_non_roce_axis_tready),
+
+  // Non-RDMA packets in AXIS format from CMAC RX path bypassing RDMA core to QDMA RX
+  .non_roce_dma_m_axis_tvalid        (m_rdma2qdma_non_roce_axis_tvalid),
+  .non_roce_dma_m_axis_tdata         (m_rdma2qdma_non_roce_axis_tdata),
+  .non_roce_dma_m_axis_tkeep         (m_rdma2qdma_non_roce_axis_tkeep),
+  .non_roce_dma_m_axis_tlast         (m_rdma2qdma_non_roce_axis_tlast),
+  .non_roce_dma_m_axis_tready        (m_rdma2qdma_non_roce_axis_tready),
+
+  // invalidate or immediate data from roce IETH/IMMDT header
+  .ieth_immdt_axis_tvalid            (m_rdma2user_ieth_immdt_axis_tvalid),
+  .ieth_immdt_axis_tlast             (m_rdma2user_ieth_immdt_axis_tlast),
+  .ieth_immdt_axis_tdata             (m_rdma2user_ieth_immdt_axis_tdata),
+  .ieth_immdt_axis_trdy              (m_rdma2user_ieth_immdt_axis_trdy),
+
+  .rnic_intr                         (rnic_intr),
+  .stat_rx_pause_req                 (stat_rx_pause_req),
+  .ctl_tx_pause_req                  (ctl_tx_pause_req),
+  .ctl_tx_resend_pause               (ctl_tx_resend_pause),
+  .o_global_dbg_cnt_en               (o_global_dbg_cnt_en),
+  .o_global_dbg_cnt_clr              (o_global_dbg_cnt_clr)
+);
+
+endmodule : rdma_subsystem
diff --git a/src/rdma_subsystem/rdma_subsystem_wrapper.sv b/src/rdma_subsystem/rdma_subsystem_wrapper.sv
new file mode 100644
index 0000000..a927ab4
--- /dev/null
+++ b/src/rdma_subsystem/rdma_subsystem_wrapper.sv
@@ -0,0 +1,701 @@
+// *************************************************************************
+//
+// Copyright 2022 Xilinx, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// *************************************************************************
+//
+// rdma_subsystem_wrapper
+// -- wrapper for the rdma subsystem
+// -- retry buffer and doorbell update from user logic are disabled at the
+//    moment. We will add these features in the future version
+//
+// *************************************************************************
+`timescale 1ns/1ps
+
+module rdma_subsystem_wrapper #(
+  parameter C_AXIS_DATA_WIDTH  = 512,
+  parameter C_AXIS_KEEP_WIDTH  = 64,
+  parameter C_AXIS_IMMDT_WIDTH = 64
+) (
+  // AXIL interface for RDMA control register
+  (* mark_debug = "true" *) input  [31:0] s_axil_awaddr,
+  (* mark_debug = "true" *) input         s_axil_awvalid,
+  (* mark_debug = "true" *) output        s_axil_awready,
+  (* mark_debug = "true" *) input  [31:0] s_axil_wdata,
+  (* mark_debug = "true" *) input   [3:0] s_axil_wstrb,
+  (* mark_debug = "true" *) input         s_axil_wvalid,
+  (* mark_debug = "true" *) output        s_axil_wready,
+  (* mark_debug = "true" *) input  [31:0] s_axil_araddr,
+  (* mark_debug = "true" *) input         s_axil_arvalid,
+  (* mark_debug = "true" *) output        s_axil_arready,
+  (* mark_debug = "true" *) output [31:0] s_axil_rdata,
+  (* mark_debug = "true" *) output        s_axil_rvalid,
+  (* mark_debug = "true" *) output  [1:0] s_axil_rresp,
+  (* mark_debug = "true" *) input         s_axil_rready,
+  (* mark_debug = "true" *) output  [1:0] s_axil_bresp,
+  (* mark_debug = "true" *) output        s_axil_bvalid,
+  (* mark_debug = "true" *) input         s_axil_bready,
+
+  // RDMA TX interface (including roce and non-roce packets) to CMAC TX path
+  output [C_AXIS_DATA_WIDTH-1:0] m_rdma2cmac_axis_tdata,
+  output [C_AXIS_KEEP_WIDTH-1:0] m_rdma2cmac_axis_tkeep,
+  output                         m_rdma2cmac_axis_tvalid,
+  output                         m_rdma2cmac_axis_tlast,
+  input                          m_rdma2cmac_axis_tready,
+
+  // Non-RDMA packets from QDMA TX bypassing RDMA TX
+  input  [C_AXIS_DATA_WIDTH-1:0] s_qdma2rdma_non_roce_axis_tdata,
+  input  [C_AXIS_KEEP_WIDTH-1:0] s_qdma2rdma_non_roce_axis_tkeep,
+  input                          s_qdma2rdma_non_roce_axis_tvalid,
+  input                          s_qdma2rdma_non_roce_axis_tlast,
+  output                         s_qdma2rdma_non_roce_axis_tready,
+
+  // RDMA RX interface from CMAC RX, no rx backpressure
+  input  [C_AXIS_DATA_WIDTH-1:0] s_cmac2rdma_roce_axis_tdata,
+  input  [C_AXIS_KEEP_WIDTH-1:0] s_cmac2rdma_roce_axis_tkeep,
+  input                          s_cmac2rdma_roce_axis_tvalid,
+  input                          s_cmac2rdma_roce_axis_tlast,
+  input                          s_cmac2rdma_roce_axis_tuser,
+
+  // Non-RDMA packets from CMAC RX bypassing RDMA, no rx backpressure
+  input  [C_AXIS_DATA_WIDTH-1:0] s_cmac2rdma_non_roce_axis_tdata,
+  input  [C_AXIS_KEEP_WIDTH-1:0] s_cmac2rdma_non_roce_axis_tkeep,
+  input                          s_cmac2rdma_non_roce_axis_tvalid,
+  input                          s_cmac2rdma_non_roce_axis_tlast,
+  input                          s_cmac2rdma_non_roce_axis_tuser,
+
+  // Non-RDMA packets bypassing RDMA to QDMA RX
+  output [C_AXIS_DATA_WIDTH-1:0] m_rdma2qdma_non_roce_axis_tdata,
+  output [C_AXIS_KEEP_WIDTH-1:0] m_rdma2qdma_non_roce_axis_tkeep,
+  output                         m_rdma2qdma_non_roce_axis_tvalid,
+  output                         m_rdma2qdma_non_roce_axis_tlast,
+  input                          m_rdma2qdma_non_roce_axis_tready,
+
+  // invalidate or immediate data from roce IETH/IMMDT header
+  output [C_AXIS_IMMDT_WIDTH-1:0] m_rdma2user_ieth_immdt_axis_tdata,
+  output                          m_rdma2user_ieth_immdt_axis_tlast,
+  output                          m_rdma2user_ieth_immdt_axis_tvalid,
+  input                           m_rdma2user_ieth_immdt_axis_trdy,
+
+  // RDMA AXI MM interface used to store payload from RDMA MAD, Send or Write operation
+  output           m_axi_rdma_send_write_payload_store_awid,
+  output  [63 : 0] m_axi_rdma_send_write_payload_store_awaddr,
+  output  [31 : 0] m_axi_rdma_send_write_payload_store_awuser,
+  output   [7 : 0] m_axi_rdma_send_write_payload_store_awlen,
+  output   [2 : 0] m_axi_rdma_send_write_payload_store_awsize,
+  output   [1 : 0] m_axi_rdma_send_write_payload_store_awburst,
+  output   [3 : 0] m_axi_rdma_send_write_payload_store_awcache,
+  output   [2 : 0] m_axi_rdma_send_write_payload_store_awprot,
+  output           m_axi_rdma_send_write_payload_store_awvalid,
+  input            m_axi_rdma_send_write_payload_store_awready,
+  output [511 : 0] m_axi_rdma_send_write_payload_store_wdata,
+  output  [63 : 0] m_axi_rdma_send_write_payload_store_wstrb,
+  output           m_axi_rdma_send_write_payload_store_wlast,
+  output           m_axi_rdma_send_write_payload_store_wvalid,
+  input            m_axi_rdma_send_write_payload_store_wready,
+  output           m_axi_rdma_send_write_payload_store_awlock,
+  input            m_axi_rdma_send_write_payload_store_bid,
+  input    [1 : 0] m_axi_rdma_send_write_payload_store_bresp,
+  input            m_axi_rdma_send_write_payload_store_bvalid,
+  output           m_axi_rdma_send_write_payload_store_bready,
+  output           m_axi_rdma_send_write_payload_store_arid,
+  output  [63 : 0] m_axi_rdma_send_write_payload_store_araddr,
+  output   [7 : 0] m_axi_rdma_send_write_payload_store_arlen,
+  output   [2 : 0] m_axi_rdma_send_write_payload_store_arsize,
+  output   [1 : 0] m_axi_rdma_send_write_payload_store_arburst,
+  output   [3 : 0] m_axi_rdma_send_write_payload_store_arcache,
+  output   [2 : 0] m_axi_rdma_send_write_payload_store_arprot,
+  output           m_axi_rdma_send_write_payload_store_arvalid,
+  input            m_axi_rdma_send_write_payload_store_arready,
+  input            m_axi_rdma_send_write_payload_store_rid,
+  input  [511 : 0] m_axi_rdma_send_write_payload_store_rdata,
+  input    [1 : 0] m_axi_rdma_send_write_payload_store_rresp,
+  input            m_axi_rdma_send_write_payload_store_rlast,
+  input            m_axi_rdma_send_write_payload_store_rvalid,
+  output           m_axi_rdma_send_write_payload_store_rready,
+  output           m_axi_rdma_send_write_payload_store_arlock,
+
+  // RDMA AXI MM interface used to store payload from RDMA Read response operation
+  output           m_axi_rdma_rsp_payload_awid,
+  output  [63 : 0] m_axi_rdma_rsp_payload_awaddr,
+  output   [7 : 0] m_axi_rdma_rsp_payload_awlen,
+  output   [2 : 0] m_axi_rdma_rsp_payload_awsize,
+  output   [1 : 0] m_axi_rdma_rsp_payload_awburst,
+  output   [3 : 0] m_axi_rdma_rsp_payload_awcache,
+  output   [2 : 0] m_axi_rdma_rsp_payload_awprot,
+  output           m_axi_rdma_rsp_payload_awvalid,
+  input            m_axi_rdma_rsp_payload_awready,
+  output [511 : 0] m_axi_rdma_rsp_payload_wdata,
+  output  [63 : 0] m_axi_rdma_rsp_payload_wstrb,
+  output           m_axi_rdma_rsp_payload_wlast,
+  output           m_axi_rdma_rsp_payload_wvalid,
+  input            m_axi_rdma_rsp_payload_wready,
+  output           m_axi_rdma_rsp_payload_awlock,
+  input            m_axi_rdma_rsp_payload_bid,
+  input    [1 : 0] m_axi_rdma_rsp_payload_bresp,
+  input            m_axi_rdma_rsp_payload_bvalid,
+  output           m_axi_rdma_rsp_payload_bready,
+  output           m_axi_rdma_rsp_payload_arid,
+  output  [63 : 0] m_axi_rdma_rsp_payload_araddr,
+  output   [7 : 0] m_axi_rdma_rsp_payload_arlen,
+  output   [2 : 0] m_axi_rdma_rsp_payload_arsize,
+  output   [1 : 0] m_axi_rdma_rsp_payload_arburst,
+  output   [3 : 0] m_axi_rdma_rsp_payload_arcache,
+  output   [2 : 0] m_axi_rdma_rsp_payload_arprot,
+  output           m_axi_rdma_rsp_payload_arvalid,
+  input            m_axi_rdma_rsp_payload_arready,
+  input            m_axi_rdma_rsp_payload_rid,
+  input  [511 : 0] m_axi_rdma_rsp_payload_rdata,
+  input    [1 : 0] m_axi_rdma_rsp_payload_rresp,
+  input            m_axi_rdma_rsp_payload_rlast,
+  input            m_axi_rdma_rsp_payload_rvalid,
+  output           m_axi_rdma_rsp_payload_rready,
+  output           m_axi_rdma_rsp_payload_arlock,
+
+  // RDMA AXI MM interface used to fetch WQE entries in the senq queue from DDR by the QP manager
+  output           m_axi_qp_get_wqe_awid,
+  output  [63 : 0] m_axi_qp_get_wqe_awaddr,
+  output   [7 : 0] m_axi_qp_get_wqe_awlen,
+  output   [2 : 0] m_axi_qp_get_wqe_awsize,
+  output   [1 : 0] m_axi_qp_get_wqe_awburst,
+  output   [3 : 0] m_axi_qp_get_wqe_awcache,
+  output   [2 : 0] m_axi_qp_get_wqe_awprot,
+  output           m_axi_qp_get_wqe_awvalid,
+  input            m_axi_qp_get_wqe_awready,
+  output [511 : 0] m_axi_qp_get_wqe_wdata,
+  output  [63 : 0] m_axi_qp_get_wqe_wstrb,
+  output           m_axi_qp_get_wqe_wlast,
+  output           m_axi_qp_get_wqe_wvalid,
+  input            m_axi_qp_get_wqe_wready,
+  output           m_axi_qp_get_wqe_awlock,
+  input            m_axi_qp_get_wqe_bid,
+  input    [1 : 0] m_axi_qp_get_wqe_bresp,
+  input            m_axi_qp_get_wqe_bvalid,
+  output           m_axi_qp_get_wqe_bready,
+  output           m_axi_qp_get_wqe_arid,
+  output  [63 : 0] m_axi_qp_get_wqe_araddr,
+  output   [7 : 0] m_axi_qp_get_wqe_arlen,
+  output   [2 : 0] m_axi_qp_get_wqe_arsize,
+  output   [1 : 0] m_axi_qp_get_wqe_arburst,
+  output   [3 : 0] m_axi_qp_get_wqe_arcache,
+  output   [2 : 0] m_axi_qp_get_wqe_arprot,
+  output           m_axi_qp_get_wqe_arvalid,
+  input            m_axi_qp_get_wqe_arready,
+  input            m_axi_qp_get_wqe_rid,
+  input  [511 : 0] m_axi_qp_get_wqe_rdata,
+  input    [1 : 0] m_axi_qp_get_wqe_rresp,
+  input            m_axi_qp_get_wqe_rlast,
+  input            m_axi_qp_get_wqe_rvalid,
+  output           m_axi_qp_get_wqe_rready,
+  output           m_axi_qp_get_wqe_arlock,
+
+  // TODO: In the current implementation, we do not consider retry buffer
+  // RDMA AXI MM interface used to store payload of an outgoing RDMA write packet to a retry buffer
+  output           m_axi_payload_to_retry_buf_awid,
+  output  [63 : 0] m_axi_payload_to_retry_buf_awaddr,
+  output   [7 : 0] m_axi_payload_to_retry_buf_awlen,
+  output   [2 : 0] m_axi_payload_to_retry_buf_awsize,
+  output   [1 : 0] m_axi_payload_to_retry_buf_awburst,
+  output   [3 : 0] m_axi_payload_to_retry_buf_awcache,
+  output   [2 : 0] m_axi_payload_to_retry_buf_awprot,
+  output           m_axi_payload_to_retry_buf_awvalid,
+  input            m_axi_payload_to_retry_buf_awready,
+  output [511 : 0] m_axi_payload_to_retry_buf_wdata,
+  output  [63 : 0] m_axi_payload_to_retry_buf_wstrb,
+  output           m_axi_payload_to_retry_buf_wlast,
+  output           m_axi_payload_to_retry_buf_wvalid,
+  input            m_axi_payload_to_retry_buf_wready,
+  output           m_axi_payload_to_retry_buf_awlock,
+  input            m_axi_payload_to_retry_buf_bid,
+  input    [1 : 0] m_axi_payload_to_retry_buf_bresp,
+  input            m_axi_payload_to_retry_buf_bvalid,
+  output           m_axi_payload_to_retry_buf_bready,
+  output           m_axi_payload_to_retry_buf_arid,
+  output  [63 : 0] m_axi_payload_to_retry_buf_araddr,
+  output   [7 : 0] m_axi_payload_to_retry_buf_arlen,
+  output   [2 : 0] m_axi_payload_to_retry_buf_arsize,
+  output   [1 : 0] m_axi_payload_to_retry_buf_arburst,
+  output   [3 : 0] m_axi_payload_to_retry_buf_arcache,
+  output   [2 : 0] m_axi_payload_to_retry_buf_arprot,
+  output           m_axi_payload_to_retry_buf_arvalid,
+  input            m_axi_payload_to_retry_buf_arready,
+  input            m_axi_payload_to_retry_buf_rid,
+  input  [511 : 0] m_axi_payload_to_retry_buf_rdata,
+  input    [1 : 0] m_axi_payload_to_retry_buf_rresp,
+  input            m_axi_payload_to_retry_buf_rlast,
+  input            m_axi_payload_to_retry_buf_rvalid,
+  output           m_axi_payload_to_retry_buf_rready,
+  output           m_axi_payload_to_retry_buf_arlock,
+
+  // RDMA AXI MM interface used to get payload of an outgoing RDMA send/write and read response packets
+  output           m_axi_pktgen_get_payload_awid,
+  output  [63 : 0] m_axi_pktgen_get_payload_awaddr,
+  output   [7 : 0] m_axi_pktgen_get_payload_awlen,
+  output   [2 : 0] m_axi_pktgen_get_payload_awsize,
+  output   [1 : 0] m_axi_pktgen_get_payload_awburst,
+  output   [3 : 0] m_axi_pktgen_get_payload_awcache,
+  output   [2 : 0] m_axi_pktgen_get_payload_awprot,
+  output           m_axi_pktgen_get_payload_awvalid,
+  input            m_axi_pktgen_get_payload_awready,
+  output [511 : 0] m_axi_pktgen_get_payload_wdata,
+  output  [63 : 0] m_axi_pktgen_get_payload_wstrb,
+  output           m_axi_pktgen_get_payload_wlast,
+  output           m_axi_pktgen_get_payload_wvalid,
+  input            m_axi_pktgen_get_payload_wready,
+  output           m_axi_pktgen_get_payload_awlock,
+  input            m_axi_pktgen_get_payload_bid,
+  input    [1 : 0] m_axi_pktgen_get_payload_bresp,
+  input            m_axi_pktgen_get_payload_bvalid,
+  output           m_axi_pktgen_get_payload_bready,
+  output           m_axi_pktgen_get_payload_arid,
+  output  [63 : 0] m_axi_pktgen_get_payload_araddr,
+  output   [7 : 0] m_axi_pktgen_get_payload_arlen,
+  output   [2 : 0] m_axi_pktgen_get_payload_arsize,
+  output   [1 : 0] m_axi_pktgen_get_payload_arburst,
+  output   [3 : 0] m_axi_pktgen_get_payload_arcache,
+  output   [2 : 0] m_axi_pktgen_get_payload_arprot,
+  output           m_axi_pktgen_get_payload_arvalid,
+  input            m_axi_pktgen_get_payload_arready,
+  input            m_axi_pktgen_get_payload_rid,
+  input  [511 : 0] m_axi_pktgen_get_payload_rdata,
+  input    [1 : 0] m_axi_pktgen_get_payload_rresp,
+  input            m_axi_pktgen_get_payload_rlast,
+  input            m_axi_pktgen_get_payload_rvalid,
+  output           m_axi_pktgen_get_payload_rready,
+  output           m_axi_pktgen_get_payload_arlock,
+
+  // RDMA AXI MM interface used to write completion entries to a completion queue in the DDR
+  output           m_axi_write_completion_awid,
+  output  [63 : 0] m_axi_write_completion_awaddr,
+  output   [7 : 0] m_axi_write_completion_awlen,
+  output   [2 : 0] m_axi_write_completion_awsize,
+  output   [1 : 0] m_axi_write_completion_awburst,
+  output   [3 : 0] m_axi_write_completion_awcache,
+  output   [2 : 0] m_axi_write_completion_awprot,
+  output           m_axi_write_completion_awvalid,
+  input            m_axi_write_completion_awready,
+  output [511 : 0] m_axi_write_completion_wdata,
+  output  [63 : 0] m_axi_write_completion_wstrb,
+  output           m_axi_write_completion_wlast,
+  output           m_axi_write_completion_wvalid,
+  input            m_axi_write_completion_wready,
+  output           m_axi_write_completion_awlock,
+  input            m_axi_write_completion_bid,
+  input    [1 : 0] m_axi_write_completion_bresp,
+  input            m_axi_write_completion_bvalid,
+  output           m_axi_write_completion_bready,
+  output           m_axi_write_completion_arid,
+  output  [63 : 0] m_axi_write_completion_araddr,
+  output   [7 : 0] m_axi_write_completion_arlen,
+  output   [2 : 0] m_axi_write_completion_arsize,
+  output   [1 : 0] m_axi_write_completion_arburst,
+  output   [3 : 0] m_axi_write_completion_arcache,
+  output   [2 : 0] m_axi_write_completion_arprot,
+  output           m_axi_write_completion_arvalid,
+  input            m_axi_write_completion_arready,
+  input            m_axi_write_completion_rid,
+  input  [511 : 0] m_axi_write_completion_rdata,
+  input    [1 : 0] m_axi_write_completion_rresp,
+  input            m_axi_write_completion_rlast,
+  input            m_axi_write_completion_rvalid,
+  output           m_axi_write_completion_rready,
+  output           m_axi_write_completion_arlock,
+
+  // TODO: In the current implementation, we do not consider hardware handshaking from user logic
+  // Send WQE completion queue doorbell
+  output           resp_hndler_o_send_cq_db_cnt_valid,
+  output     [9:0] resp_hndler_o_send_cq_db_addr,
+  output    [31:0] resp_hndler_o_send_cq_db_cnt,
+  input            resp_hndler_i_send_cq_db_rdy,
+
+  // Send WQE producer index doorbell
+  input     [15:0] i_qp_sq_pidb_hndshk,
+  input     [31:0] i_qp_sq_pidb_wr_addr_hndshk,
+  input            i_qp_sq_pidb_wr_valid_hndshk,
+  output           o_qp_sq_pidb_wr_rdy,
+
+  // RDMA-Send consumer index doorbell
+  input     [15:0] i_qp_rq_cidb_hndshk,
+  input     [31:0] i_qp_rq_cidb_wr_addr_hndshk,
+  input            i_qp_rq_cidb_wr_valid_hndshk,
+  output           o_qp_rq_cidb_wr_rdy,
+
+  // RDMA-Send producer index doorbell
+  output    [31:0] rx_pkt_hndler_o_rq_db_data,
+  output     [9:0] rx_pkt_hndler_o_rq_db_addr,
+  output           rx_pkt_hndler_o_rq_db_data_valid,
+  input            rx_pkt_hndler_i_rq_db_rdy,
+
+  output           rnic_intr,
+
+  input  mod_rstn,
+  output mod_rst_done,
+  output rdma_resetn_done,
+  input  axil_clk,
+  input  axis_clk
+);
+
+logic axil_rstn;
+logic axis_rstn;
+
+logic [8:0] stat_rx_pause_req;
+logic [8:0] ctl_tx_pause_req;
+logic       ctl_tx_resend_pause;
+
+logic o_global_dbg_cnt_en;
+logic o_global_dbg_cnt_clr;
+
+generic_reset #(
+  .NUM_INPUT_CLK  (2),
+  .RESET_DURATION (100)
+) reset_inst (
+  .mod_rstn     (mod_rstn),
+  .mod_rst_done (mod_rst_done),
+  .clk          ({axis_clk, axil_clk}),
+  .rstn         ({axis_rstn, axil_rstn})
+);
+
+rdma_subsystem #(
+  .C_AXIS_DATA_WIDTH (C_AXIS_DATA_WIDTH),
+  .C_AXIS_KEEP_WIDTH (C_AXIS_KEEP_WIDTH),
+  .C_AXIS_IMMDT_WIDTH(C_AXIS_IMMDT_WIDTH)
+) rdma_subsystem_inst (
+  // AXIL interface for RDMA control register
+  .s_axil_awaddr     (s_axil_awaddr),
+  .s_axil_awvalid    (s_axil_awvalid),
+  .s_axil_awready    (s_axil_awready),
+  .s_axil_wdata      (s_axil_wdata),
+  .s_axil_wstrb      (s_axil_wstrb),
+  .s_axil_wvalid     (s_axil_wvalid),
+  .s_axil_wready     (s_axil_wready),
+  .s_axil_araddr     (s_axil_araddr),
+  .s_axil_arvalid    (s_axil_arvalid),
+  .s_axil_arready    (s_axil_arready),
+  .s_axil_rdata      (s_axil_rdata),
+  .s_axil_rvalid     (s_axil_rvalid),
+  .s_axil_rresp      (s_axil_rresp),
+  .s_axil_rready     (s_axil_rready),
+  .s_axil_bresp      (s_axil_bresp),
+  .s_axil_bvalid     (s_axil_bvalid),
+  .s_axil_bready     (s_axil_bready),
+
+  // RDMA TX interface (including roce and non-roce packets) to CMAC TX path
+  .m_rdma2cmac_axis_tdata  (m_rdma2cmac_axis_tdata),
+  .m_rdma2cmac_axis_tkeep  (m_rdma2cmac_axis_tkeep),
+  .m_rdma2cmac_axis_tvalid (m_rdma2cmac_axis_tvalid),
+  .m_rdma2cmac_axis_tlast  (m_rdma2cmac_axis_tlast),
+  .m_rdma2cmac_axis_tready (m_rdma2cmac_axis_tready),
+
+  // Non-RDMA packets from QDMA TX bypassing RDMA TX
+  .s_qdma2rdma_non_roce_axis_tdata  (s_qdma2rdma_non_roce_axis_tdata),
+  .s_qdma2rdma_non_roce_axis_tkeep  (s_qdma2rdma_non_roce_axis_tkeep),
+  .s_qdma2rdma_non_roce_axis_tvalid (s_qdma2rdma_non_roce_axis_tvalid),
+  .s_qdma2rdma_non_roce_axis_tlast  (s_qdma2rdma_non_roce_axis_tlast),
+  .s_qdma2rdma_non_roce_axis_tready (s_qdma2rdma_non_roce_axis_tready),
+
+  // RDMA RX interface from CMAC RX, no rx backpressure
+  .s_cmac2rdma_roce_axis_tdata   (s_cmac2rdma_roce_axis_tdata),
+  .s_cmac2rdma_roce_axis_tkeep   (s_cmac2rdma_roce_axis_tkeep),
+  .s_cmac2rdma_roce_axis_tvalid  (s_cmac2rdma_roce_axis_tvalid),
+  .s_cmac2rdma_roce_axis_tlast   (s_cmac2rdma_roce_axis_tlast),
+  .s_cmac2rdma_roce_axis_tuser   (s_cmac2rdma_roce_axis_tuser),
+
+  // Non-RDMA packets from CMAC RX bypassing RDMA, no rx backpressure
+  .s_cmac2rdma_non_roce_axis_tdata  (s_cmac2rdma_non_roce_axis_tdata),
+  .s_cmac2rdma_non_roce_axis_tkeep  (s_cmac2rdma_non_roce_axis_tkeep),
+  .s_cmac2rdma_non_roce_axis_tvalid (s_cmac2rdma_non_roce_axis_tvalid),
+  .s_cmac2rdma_non_roce_axis_tlast  (s_cmac2rdma_non_roce_axis_tlast),
+  .s_cmac2rdma_non_roce_axis_tuser  (s_cmac2rdma_non_roce_axis_tuser),
+
+  // Non-RDMA packets bypassing RDMA to QDMA RX
+  .m_rdma2qdma_non_roce_axis_tdata   (m_rdma2qdma_non_roce_axis_tdata),
+  .m_rdma2qdma_non_roce_axis_tkeep   (m_rdma2qdma_non_roce_axis_tkeep),
+  .m_rdma2qdma_non_roce_axis_tvalid  (m_rdma2qdma_non_roce_axis_tvalid),
+  .m_rdma2qdma_non_roce_axis_tlast   (m_rdma2qdma_non_roce_axis_tlast),
+  .m_rdma2qdma_non_roce_axis_tready  (m_rdma2qdma_non_roce_axis_tready),
+
+  // invalidate or immediate data from roce IETH/IMMDT header
+  .m_rdma2user_ieth_immdt_axis_tdata   (m_rdma2user_ieth_immdt_axis_tdata),
+  .m_rdma2user_ieth_immdt_axis_tlast   (m_rdma2user_ieth_immdt_axis_tlast),
+  .m_rdma2user_ieth_immdt_axis_tvalid  (m_rdma2user_ieth_immdt_axis_tvalid),
+  .m_rdma2user_ieth_immdt_axis_trdy    (m_rdma2user_ieth_immdt_axis_trdy),
+
+  // RDMA AXI MM interface used to store payload from RDMA MAD, Send or Write operation
+  .m_axi_rdma_send_write_payload_store_awid        (m_axi_rdma_send_write_payload_store_awid),
+  .m_axi_rdma_send_write_payload_store_awaddr      (m_axi_rdma_send_write_payload_store_awaddr),
+  .m_axi_rdma_send_write_payload_store_awuser      (m_axi_rdma_send_write_payload_store_awuser),
+  .m_axi_rdma_send_write_payload_store_awlen       (m_axi_rdma_send_write_payload_store_awlen),
+  .m_axi_rdma_send_write_payload_store_awsize      (m_axi_rdma_send_write_payload_store_awsize),
+  .m_axi_rdma_send_write_payload_store_awburst     (m_axi_rdma_send_write_payload_store_awburst),
+  .m_axi_rdma_send_write_payload_store_awcache     (m_axi_rdma_send_write_payload_store_awcache),
+  .m_axi_rdma_send_write_payload_store_awprot      (m_axi_rdma_send_write_payload_store_awprot),
+  .m_axi_rdma_send_write_payload_store_awvalid     (m_axi_rdma_send_write_payload_store_awvalid),
+  .m_axi_rdma_send_write_payload_store_awready     (m_axi_rdma_send_write_payload_store_awready),
+  .m_axi_rdma_send_write_payload_store_wdata       (m_axi_rdma_send_write_payload_store_wdata),
+  .m_axi_rdma_send_write_payload_store_wstrb       (m_axi_rdma_send_write_payload_store_wstrb),
+  .m_axi_rdma_send_write_payload_store_wlast       (m_axi_rdma_send_write_payload_store_wlast),
+  .m_axi_rdma_send_write_payload_store_wvalid      (m_axi_rdma_send_write_payload_store_wvalid),
+  .m_axi_rdma_send_write_payload_store_wready      (m_axi_rdma_send_write_payload_store_wready),
+  .m_axi_rdma_send_write_payload_store_awlock      (m_axi_rdma_send_write_payload_store_awlock),
+  .m_axi_rdma_send_write_payload_store_bid         (m_axi_rdma_send_write_payload_store_bid),
+  .m_axi_rdma_send_write_payload_store_bresp       (m_axi_rdma_send_write_payload_store_bresp),
+  .m_axi_rdma_send_write_payload_store_bvalid      (m_axi_rdma_send_write_payload_store_bvalid),
+  .m_axi_rdma_send_write_payload_store_bready      (m_axi_rdma_send_write_payload_store_bready),
+  .m_axi_rdma_send_write_payload_store_arid        (m_axi_rdma_send_write_payload_store_arid),
+  .m_axi_rdma_send_write_payload_store_araddr      (m_axi_rdma_send_write_payload_store_araddr),
+  .m_axi_rdma_send_write_payload_store_arlen       (m_axi_rdma_send_write_payload_store_arlen),
+  .m_axi_rdma_send_write_payload_store_arsize      (m_axi_rdma_send_write_payload_store_arsize),
+  .m_axi_rdma_send_write_payload_store_arburst     (m_axi_rdma_send_write_payload_store_arburst),
+  .m_axi_rdma_send_write_payload_store_arcache     (m_axi_rdma_send_write_payload_store_arcache),
+  .m_axi_rdma_send_write_payload_store_arprot      (m_axi_rdma_send_write_payload_store_arprot),
+  .m_axi_rdma_send_write_payload_store_arvalid     (m_axi_rdma_send_write_payload_store_arvalid),
+  .m_axi_rdma_send_write_payload_store_arready     (m_axi_rdma_send_write_payload_store_arready),
+  .m_axi_rdma_send_write_payload_store_rid         (m_axi_rdma_send_write_payload_store_rid),
+  .m_axi_rdma_send_write_payload_store_rdata       (m_axi_rdma_send_write_payload_store_rdata),
+  .m_axi_rdma_send_write_payload_store_rresp       (m_axi_rdma_send_write_payload_store_rresp),
+  .m_axi_rdma_send_write_payload_store_rlast       (m_axi_rdma_send_write_payload_store_rlast),
+  .m_axi_rdma_send_write_payload_store_rvalid      (m_axi_rdma_send_write_payload_store_rvalid),
+  .m_axi_rdma_send_write_payload_store_rready      (m_axi_rdma_send_write_payload_store_rready),
+  .m_axi_rdma_send_write_payload_store_arlock      (m_axi_rdma_send_write_payload_store_arlock),
+
+  // RDMA AXI MM interface used to store payload from RDMA Read response operation
+  .m_axi_rdma_rsp_payload_awid                (m_axi_rdma_rsp_payload_awid),
+  .m_axi_rdma_rsp_payload_awaddr              (m_axi_rdma_rsp_payload_awaddr),
+  .m_axi_rdma_rsp_payload_awlen               (m_axi_rdma_rsp_payload_awlen),
+  .m_axi_rdma_rsp_payload_awsize              (m_axi_rdma_rsp_payload_awsize),
+  .m_axi_rdma_rsp_payload_awburst             (m_axi_rdma_rsp_payload_awburst),
+  .m_axi_rdma_rsp_payload_awcache             (m_axi_rdma_rsp_payload_awcache),
+  .m_axi_rdma_rsp_payload_awprot              (m_axi_rdma_rsp_payload_awprot),
+  .m_axi_rdma_rsp_payload_awvalid             (m_axi_rdma_rsp_payload_awvalid),
+  .m_axi_rdma_rsp_payload_awready             (m_axi_rdma_rsp_payload_awready),
+  .m_axi_rdma_rsp_payload_wdata               (m_axi_rdma_rsp_payload_wdata),
+  .m_axi_rdma_rsp_payload_wstrb               (m_axi_rdma_rsp_payload_wstrb),
+  .m_axi_rdma_rsp_payload_wlast               (m_axi_rdma_rsp_payload_wlast),
+  .m_axi_rdma_rsp_payload_wvalid              (m_axi_rdma_rsp_payload_wvalid),
+  .m_axi_rdma_rsp_payload_wready              (m_axi_rdma_rsp_payload_wready),
+  .m_axi_rdma_rsp_payload_awlock              (m_axi_rdma_rsp_payload_awlock),
+  .m_axi_rdma_rsp_payload_bid                 (m_axi_rdma_rsp_payload_bid),
+  .m_axi_rdma_rsp_payload_bresp               (m_axi_rdma_rsp_payload_bresp),
+  .m_axi_rdma_rsp_payload_bvalid              (m_axi_rdma_rsp_payload_bvalid),
+  .m_axi_rdma_rsp_payload_bready              (m_axi_rdma_rsp_payload_bready),
+  .m_axi_rdma_rsp_payload_arid                (m_axi_rdma_rsp_payload_arid),
+  .m_axi_rdma_rsp_payload_araddr              (m_axi_rdma_rsp_payload_araddr),
+  .m_axi_rdma_rsp_payload_arlen               (m_axi_rdma_rsp_payload_arlen),
+  .m_axi_rdma_rsp_payload_arsize              (m_axi_rdma_rsp_payload_arsize),
+  .m_axi_rdma_rsp_payload_arburst             (m_axi_rdma_rsp_payload_arburst),
+  .m_axi_rdma_rsp_payload_arcache             (m_axi_rdma_rsp_payload_arcache),
+  .m_axi_rdma_rsp_payload_arprot              (m_axi_rdma_rsp_payload_arprot),
+  .m_axi_rdma_rsp_payload_arvalid             (m_axi_rdma_rsp_payload_arvalid),
+  .m_axi_rdma_rsp_payload_arready             (m_axi_rdma_rsp_payload_arready),
+  .m_axi_rdma_rsp_payload_rid                 (m_axi_rdma_rsp_payload_rid),
+  .m_axi_rdma_rsp_payload_rdata               (m_axi_rdma_rsp_payload_rdata),
+  .m_axi_rdma_rsp_payload_rresp               (m_axi_rdma_rsp_payload_rresp),
+  .m_axi_rdma_rsp_payload_rlast               (m_axi_rdma_rsp_payload_rlast),
+  .m_axi_rdma_rsp_payload_rvalid              (m_axi_rdma_rsp_payload_rvalid),
+  .m_axi_rdma_rsp_payload_rready              (m_axi_rdma_rsp_payload_rready),
+  .m_axi_rdma_rsp_payload_arlock              (m_axi_rdma_rsp_payload_arlock),
+
+  // RDMA AXI MM interface used to fetch WQE entries in the senq queue from DDR by the QP manager
+  .m_axi_qp_get_wqe_awid                (m_axi_qp_get_wqe_awid),
+  .m_axi_qp_get_wqe_awaddr              (m_axi_qp_get_wqe_awaddr),
+  .m_axi_qp_get_wqe_awlen               (m_axi_qp_get_wqe_awlen),
+  .m_axi_qp_get_wqe_awsize              (m_axi_qp_get_wqe_awsize),
+  .m_axi_qp_get_wqe_awburst             (m_axi_qp_get_wqe_awburst),
+  .m_axi_qp_get_wqe_awcache             (m_axi_qp_get_wqe_awcache),
+  .m_axi_qp_get_wqe_awprot              (m_axi_qp_get_wqe_awprot),
+  .m_axi_qp_get_wqe_awvalid             (m_axi_qp_get_wqe_awvalid),
+  .m_axi_qp_get_wqe_awready             (m_axi_qp_get_wqe_awready),
+  .m_axi_qp_get_wqe_wdata               (m_axi_qp_get_wqe_wdata),
+  .m_axi_qp_get_wqe_wstrb               (m_axi_qp_get_wqe_wstrb),
+  .m_axi_qp_get_wqe_wlast               (m_axi_qp_get_wqe_wlast),
+  .m_axi_qp_get_wqe_wvalid              (m_axi_qp_get_wqe_wvalid),
+  .m_axi_qp_get_wqe_wready              (m_axi_qp_get_wqe_wready),
+  .m_axi_qp_get_wqe_awlock              (m_axi_qp_get_wqe_awlock),
+  .m_axi_qp_get_wqe_bid                 (m_axi_qp_get_wqe_bid),
+  .m_axi_qp_get_wqe_bresp               (m_axi_qp_get_wqe_bresp),
+  .m_axi_qp_get_wqe_bvalid              (m_axi_qp_get_wqe_bvalid),
+  .m_axi_qp_get_wqe_bready              (m_axi_qp_get_wqe_bready),
+  .m_axi_qp_get_wqe_arid                (m_axi_qp_get_wqe_arid),
+  .m_axi_qp_get_wqe_araddr              (m_axi_qp_get_wqe_araddr),
+  .m_axi_qp_get_wqe_arlen               (m_axi_qp_get_wqe_arlen),
+  .m_axi_qp_get_wqe_arsize              (m_axi_qp_get_wqe_arsize),
+  .m_axi_qp_get_wqe_arburst             (m_axi_qp_get_wqe_arburst),
+  .m_axi_qp_get_wqe_arcache             (m_axi_qp_get_wqe_arcache),
+  .m_axi_qp_get_wqe_arprot              (m_axi_qp_get_wqe_arprot),
+  .m_axi_qp_get_wqe_arvalid             (m_axi_qp_get_wqe_arvalid),
+  .m_axi_qp_get_wqe_arready             (m_axi_qp_get_wqe_arready),
+  .m_axi_qp_get_wqe_rid                 (m_axi_qp_get_wqe_rid),
+  .m_axi_qp_get_wqe_rdata               (m_axi_qp_get_wqe_rdata),
+  .m_axi_qp_get_wqe_rresp               (m_axi_qp_get_wqe_rresp),
+  .m_axi_qp_get_wqe_rlast               (m_axi_qp_get_wqe_rlast),
+  .m_axi_qp_get_wqe_rvalid              (m_axi_qp_get_wqe_rvalid),
+  .m_axi_qp_get_wqe_rready              (m_axi_qp_get_wqe_rready),
+  .m_axi_qp_get_wqe_arlock              (m_axi_qp_get_wqe_arlock),
+
+  // TODO: In the current implementation, we do not consider retry buffer
+  // RDMA AXI MM interface used to store payload of an outgoing RDMA write packet to a retry buffer
+  .m_axi_payload_to_retry_buf_awid       (m_axi_payload_to_retry_buf_awid),
+  .m_axi_payload_to_retry_buf_awaddr     (m_axi_payload_to_retry_buf_awaddr),
+  .m_axi_payload_to_retry_buf_awlen      (m_axi_payload_to_retry_buf_awlen),
+  .m_axi_payload_to_retry_buf_awsize     (m_axi_payload_to_retry_buf_awsize),
+  .m_axi_payload_to_retry_buf_awburst    (m_axi_payload_to_retry_buf_awburst),
+  .m_axi_payload_to_retry_buf_awcache    (m_axi_payload_to_retry_buf_awcache),
+  .m_axi_payload_to_retry_buf_awprot     (m_axi_payload_to_retry_buf_awprot),
+  .m_axi_payload_to_retry_buf_awvalid    (m_axi_payload_to_retry_buf_awvalid),
+  .m_axi_payload_to_retry_buf_awready    (m_axi_payload_to_retry_buf_awready),
+  .m_axi_payload_to_retry_buf_wdata      (m_axi_payload_to_retry_buf_wdata),
+  .m_axi_payload_to_retry_buf_wstrb      (m_axi_payload_to_retry_buf_wstrb),
+  .m_axi_payload_to_retry_buf_wlast      (m_axi_payload_to_retry_buf_wlast),
+  .m_axi_payload_to_retry_buf_wvalid     (m_axi_payload_to_retry_buf_wvalid),
+  .m_axi_payload_to_retry_buf_wready     (m_axi_payload_to_retry_buf_wready),
+  .m_axi_payload_to_retry_buf_awlock     (m_axi_payload_to_retry_buf_awlock),
+  .m_axi_payload_to_retry_buf_bid        (m_axi_payload_to_retry_buf_bid),
+  .m_axi_payload_to_retry_buf_bresp      (m_axi_payload_to_retry_buf_bresp),
+  .m_axi_payload_to_retry_buf_bvalid     (m_axi_payload_to_retry_buf_bvalid),
+  .m_axi_payload_to_retry_buf_bready     (m_axi_payload_to_retry_buf_bready),
+  .m_axi_payload_to_retry_buf_arid       (m_axi_payload_to_retry_buf_arid),
+  .m_axi_payload_to_retry_buf_araddr     (m_axi_payload_to_retry_buf_araddr),
+  .m_axi_payload_to_retry_buf_arlen      (m_axi_payload_to_retry_buf_arlen),
+  .m_axi_payload_to_retry_buf_arsize     (m_axi_payload_to_retry_buf_arsize),
+  .m_axi_payload_to_retry_buf_arburst    (m_axi_payload_to_retry_buf_arburst),
+  .m_axi_payload_to_retry_buf_arcache    (m_axi_payload_to_retry_buf_arcache),
+  .m_axi_payload_to_retry_buf_arprot     (m_axi_payload_to_retry_buf_arprot),
+  .m_axi_payload_to_retry_buf_arvalid    (m_axi_payload_to_retry_buf_arvalid),
+  .m_axi_payload_to_retry_buf_arready    (m_axi_payload_to_retry_buf_arready),
+  .m_axi_payload_to_retry_buf_rid        (m_axi_payload_to_retry_buf_rid),
+  .m_axi_payload_to_retry_buf_rdata      (m_axi_payload_to_retry_buf_rdata),
+  .m_axi_payload_to_retry_buf_rresp      (m_axi_payload_to_retry_buf_rresp),
+  .m_axi_payload_to_retry_buf_rlast      (m_axi_payload_to_retry_buf_rlast),
+  .m_axi_payload_to_retry_buf_rvalid     (m_axi_payload_to_retry_buf_rvalid),
+  .m_axi_payload_to_retry_buf_rready     (m_axi_payload_to_retry_buf_rready),
+  .m_axi_payload_to_retry_buf_arlock     (m_axi_payload_to_retry_buf_arlock),
+
+  // RDMA AXI MM interface used to get payload of an outgoing RDMA send/write and read response packets
+  .m_axi_pktgen_get_payload_awid          (m_axi_pktgen_get_payload_awid),
+  .m_axi_pktgen_get_payload_awaddr        (m_axi_pktgen_get_payload_awaddr),
+  .m_axi_pktgen_get_payload_awlen         (m_axi_pktgen_get_payload_awlen),
+  .m_axi_pktgen_get_payload_awsize        (m_axi_pktgen_get_payload_awsize),
+  .m_axi_pktgen_get_payload_awburst       (m_axi_pktgen_get_payload_awburst),
+  .m_axi_pktgen_get_payload_awcache       (m_axi_pktgen_get_payload_awcache),
+  .m_axi_pktgen_get_payload_awprot        (m_axi_pktgen_get_payload_awprot),
+  .m_axi_pktgen_get_payload_awvalid       (m_axi_pktgen_get_payload_awvalid),
+  .m_axi_pktgen_get_payload_awready       (m_axi_pktgen_get_payload_awready),
+  .m_axi_pktgen_get_payload_wdata         (m_axi_pktgen_get_payload_wdata),
+  .m_axi_pktgen_get_payload_wstrb         (m_axi_pktgen_get_payload_wstrb),
+  .m_axi_pktgen_get_payload_wlast         (m_axi_pktgen_get_payload_wlast),
+  .m_axi_pktgen_get_payload_wvalid        (m_axi_pktgen_get_payload_wvalid),
+  .m_axi_pktgen_get_payload_wready        (m_axi_pktgen_get_payload_wready),
+  .m_axi_pktgen_get_payload_awlock        (m_axi_pktgen_get_payload_awlock),
+  .m_axi_pktgen_get_payload_bid           (m_axi_pktgen_get_payload_bid),
+  .m_axi_pktgen_get_payload_bresp         (m_axi_pktgen_get_payload_bresp),
+  .m_axi_pktgen_get_payload_bvalid        (m_axi_pktgen_get_payload_bvalid),
+  .m_axi_pktgen_get_payload_bready        (m_axi_pktgen_get_payload_bready),
+  .m_axi_pktgen_get_payload_arid          (m_axi_pktgen_get_payload_arid),
+  .m_axi_pktgen_get_payload_araddr        (m_axi_pktgen_get_payload_araddr),
+  .m_axi_pktgen_get_payload_arlen         (m_axi_pktgen_get_payload_arlen),
+  .m_axi_pktgen_get_payload_arsize        (m_axi_pktgen_get_payload_arsize),
+  .m_axi_pktgen_get_payload_arburst       (m_axi_pktgen_get_payload_arburst),
+  .m_axi_pktgen_get_payload_arcache       (m_axi_pktgen_get_payload_arcache),
+  .m_axi_pktgen_get_payload_arprot        (m_axi_pktgen_get_payload_arprot),
+  .m_axi_pktgen_get_payload_arvalid       (m_axi_pktgen_get_payload_arvalid),
+  .m_axi_pktgen_get_payload_arready       (m_axi_pktgen_get_payload_arready),
+  .m_axi_pktgen_get_payload_rid           (m_axi_pktgen_get_payload_rid),
+  .m_axi_pktgen_get_payload_rdata         (m_axi_pktgen_get_payload_rdata),
+  .m_axi_pktgen_get_payload_rresp         (m_axi_pktgen_get_payload_rresp),
+  .m_axi_pktgen_get_payload_rlast         (m_axi_pktgen_get_payload_rlast),
+  .m_axi_pktgen_get_payload_rvalid        (m_axi_pktgen_get_payload_rvalid),
+  .m_axi_pktgen_get_payload_rready        (m_axi_pktgen_get_payload_rready),
+  .m_axi_pktgen_get_payload_arlock        (m_axi_pktgen_get_payload_arlock),
+
+  // RDMA AXI MM interface used to write completion entries to a completion queue in the DDR
+  .m_axi_write_completion_awid       (m_axi_write_completion_awid),
+  .m_axi_write_completion_awaddr     (m_axi_write_completion_awaddr),
+  .m_axi_write_completion_awlen      (m_axi_write_completion_awlen),
+  .m_axi_write_completion_awsize     (m_axi_write_completion_awsize),
+  .m_axi_write_completion_awburst    (m_axi_write_completion_awburst),
+  .m_axi_write_completion_awcache    (m_axi_write_completion_awcache),
+  .m_axi_write_completion_awprot     (m_axi_write_completion_awprot),
+  .m_axi_write_completion_awvalid    (m_axi_write_completion_awvalid),
+  .m_axi_write_completion_awready    (m_axi_write_completion_awready),
+  .m_axi_write_completion_wdata      (m_axi_write_completion_wdata),
+  .m_axi_write_completion_wstrb      (m_axi_write_completion_wstrb),
+  .m_axi_write_completion_wlast      (m_axi_write_completion_wlast),
+  .m_axi_write_completion_wvalid     (m_axi_write_completion_wvalid),
+  .m_axi_write_completion_wready     (m_axi_write_completion_wready),
+  .m_axi_write_completion_awlock     (m_axi_write_completion_awlock),
+  .m_axi_write_completion_bid        (m_axi_write_completion_bid),
+  .m_axi_write_completion_bresp      (m_axi_write_completion_bresp),
+  .m_axi_write_completion_bvalid     (m_axi_write_completion_bvalid),
+  .m_axi_write_completion_bready     (m_axi_write_completion_bready),
+  .m_axi_write_completion_arid       (m_axi_write_completion_arid),
+  .m_axi_write_completion_araddr     (m_axi_write_completion_araddr),
+  .m_axi_write_completion_arlen      (m_axi_write_completion_arlen),
+  .m_axi_write_completion_arsize     (m_axi_write_completion_arsize),
+  .m_axi_write_completion_arburst    (m_axi_write_completion_arburst),
+  .m_axi_write_completion_arcache    (m_axi_write_completion_arcache),
+  .m_axi_write_completion_arprot     (m_axi_write_completion_arprot),
+  .m_axi_write_completion_arvalid    (m_axi_write_completion_arvalid),
+  .m_axi_write_completion_arready    (m_axi_write_completion_arready),
+  .m_axi_write_completion_rid        (m_axi_write_completion_rid),
+  .m_axi_write_completion_rdata      (m_axi_write_completion_rdata),
+  .m_axi_write_completion_rresp      (m_axi_write_completion_rresp),
+  .m_axi_write_completion_rlast      (m_axi_write_completion_rlast),
+  .m_axi_write_completion_rvalid     (m_axi_write_completion_rvalid),
+  .m_axi_write_completion_rready     (m_axi_write_completion_rready),
+  .m_axi_write_completion_arlock     (m_axi_write_completion_arlock),
+
+  // TODO: In the current implementation, we do not consider hardware handshaking from user logic
+  // HW handshaking from user logic: Send WQE completion queue doorbell
+  .resp_hndler_o_send_cq_db_cnt_valid (resp_hndler_o_send_cq_db_cnt_valid),
+  .resp_hndler_o_send_cq_db_addr      (resp_hndler_o_send_cq_db_addr),
+  .resp_hndler_o_send_cq_db_cnt       (resp_hndler_o_send_cq_db_cnt),
+  .resp_hndler_i_send_cq_db_rdy       (resp_hndler_i_send_cq_db_rdy),
+
+  // HW handshaking from user logic: Send WQE producer index doorbell
+  .i_qp_sq_pidb_hndshk           (i_qp_sq_pidb_hndshk),
+  .i_qp_sq_pidb_wr_addr_hndshk   (i_qp_sq_pidb_wr_addr_hndshk),
+  .i_qp_sq_pidb_wr_valid_hndshk  (i_qp_sq_pidb_wr_valid_hndshk),
+  .o_qp_sq_pidb_wr_rdy           (o_qp_sq_pidb_wr_rdy),
+
+  // HW handshaking from user logic: RDMA-Send consumer index doorbell
+  .i_qp_rq_cidb_hndshk           (i_qp_rq_cidb_hndshk),
+  .i_qp_rq_cidb_wr_addr_hndshk   (i_qp_rq_cidb_wr_addr_hndshk),
+  .i_qp_rq_cidb_wr_valid_hndshk  (i_qp_rq_cidb_wr_valid_hndshk),
+  .o_qp_rq_cidb_wr_rdy           (o_qp_rq_cidb_wr_rdy),
+
+  // HW handshaking from user logic: RDMA-Send producer index doorbell
+  .rx_pkt_hndler_o_rq_db_data        (rx_pkt_hndler_o_rq_db_data),
+  .rx_pkt_hndler_o_rq_db_addr        (rx_pkt_hndler_o_rq_db_addr),
+  .rx_pkt_hndler_o_rq_db_data_valid  (rx_pkt_hndler_o_rq_db_data_valid),
+  .rx_pkt_hndler_i_rq_db_rdy         (rx_pkt_hndler_i_rq_db_rdy),
+
+  .rnic_intr             (rnic_intr),
+  .stat_rx_pause_req     (stat_rx_pause_req),
+  .ctl_tx_pause_req      (ctl_tx_pause_req),
+  .ctl_tx_resend_pause   (ctl_tx_resend_pause),
+
+  .o_global_dbg_cnt_en   (o_global_dbg_cnt_en),
+  .o_global_dbg_cnt_clr  (o_global_dbg_cnt_clr),
+
+  .axil_rstn (axil_rstn),
+  .axis_rstn (axis_rstn),
+  .axil_clk (axil_clk),
+  .axis_clk (axis_clk),
+  .rdma_resetn_done (rdma_resetn_done)
+);
+
+assign stat_rx_pause_req = 9'd0;
+
+endmodule : rdma_subsystem_wrapper
diff --git a/src/rdma_subsystem/vivado_ip/rdma_core.tcl b/src/rdma_subsystem/vivado_ip/rdma_core.tcl
new file mode 100644
index 0000000..7b9abfd
--- /dev/null
+++ b/src/rdma_subsystem/vivado_ip/rdma_core.tcl
@@ -0,0 +1,28 @@
+# *************************************************************************
+#
+# Copyright 2022 Xilinx, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# *************************************************************************
+set rdma rdma_core
+create_ip -name ernic -vendor xilinx.com -library ip -module_name $rdma -dir ${ip_build_dir}
+
+set_property -dict {
+    CONFIG.C_NUM_QP {32}
+    CONFIG.C_S_AXI_LITE_ADDR_WIDTH {32}
+    CONFIG.C_M_AXI_ADDR_WIDTH {64}
+    CONFIG.C_EN_DEBUG_PORTS {1}
+    CONFIG.C_MAX_WR_RETRY_DATA_BUF_DEPTH {2048}
+    CONFIG.C_EN_INITIATOR_LITE {1}
+} [get_ips $rdma]
diff --git a/src/rdma_subsystem/vivado_ip/vivado_ip.tcl b/src/rdma_subsystem/vivado_ip/vivado_ip.tcl
new file mode 100644
index 0000000..bf49e61
--- /dev/null
+++ b/src/rdma_subsystem/vivado_ip/vivado_ip.tcl
@@ -0,0 +1,20 @@
+# *************************************************************************
+#
+# Copyright 2022 Xilinx, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# *************************************************************************
+set ips {
+  rdma_core
+}
\ No newline at end of file
diff --git a/src/system_config/system_config.sv b/src/system_config/system_config.sv
index d4a14e9..da833f0 100644
--- a/src/system_config/system_config.sv
+++ b/src/system_config/system_config.sv
@@ -54,6 +54,23 @@ module system_config #(
   input                   [1:0] m_axil_qdma_rresp,
   output                        m_axil_qdma_rready,
 
+  output                        m_axil_qdma_csr_awvalid,
+  output                 [31:0] m_axil_qdma_csr_awaddr,
+  input                         m_axil_qdma_csr_awready,
+  output                        m_axil_qdma_csr_wvalid,
+  output                 [31:0] m_axil_qdma_csr_wdata,
+  input                         m_axil_qdma_csr_wready,
+  input                         m_axil_qdma_csr_bvalid,
+  input                   [1:0] m_axil_qdma_csr_bresp,
+  output                        m_axil_qdma_csr_bready,
+  output                        m_axil_qdma_csr_arvalid,
+  output                 [31:0] m_axil_qdma_csr_araddr,
+  input                         m_axil_qdma_csr_arready,
+  input                         m_axil_qdma_csr_rvalid,
+  input                  [31:0] m_axil_qdma_csr_rdata,
+  input                   [1:0] m_axil_qdma_csr_rresp,
+  output                        m_axil_qdma_csr_rready,
+
   output    [NUM_CMAC_PORT-1:0] m_axil_adap_awvalid,
   output [32*NUM_CMAC_PORT-1:0] m_axil_adap_awaddr,
   input     [NUM_CMAC_PORT-1:0] m_axil_adap_awready,
@@ -88,6 +105,23 @@ module system_config #(
   input   [2*NUM_CMAC_PORT-1:0] m_axil_cmac_rresp,
   output    [NUM_CMAC_PORT-1:0] m_axil_cmac_rready,
 
+  output                        m_axil_rdma_awvalid,
+  output                 [31:0] m_axil_rdma_awaddr,
+  input                         m_axil_rdma_awready,
+  output                        m_axil_rdma_wvalid,
+  output                 [31:0] m_axil_rdma_wdata,
+  input                         m_axil_rdma_wready,
+  input                         m_axil_rdma_bvalid,
+  input                   [1:0] m_axil_rdma_bresp,
+  output                        m_axil_rdma_bready,
+  output                        m_axil_rdma_arvalid,
+  output                 [31:0] m_axil_rdma_araddr,
+  input                         m_axil_rdma_arready,
+  input                         m_axil_rdma_rvalid,
+  input                  [31:0] m_axil_rdma_rdata,
+  input                   [1:0] m_axil_rdma_rresp,
+  output                        m_axil_rdma_rready,
+
   output                        m_axil_box0_awvalid,
   output                 [31:0] m_axil_box0_awaddr,
   input                         m_axil_box0_awready,
@@ -226,6 +260,23 @@ module system_config #(
     .m_axil_qdma_rresp   (m_axil_qdma_rresp),
     .m_axil_qdma_rready  (m_axil_qdma_rready),
 
+    .m_axil_qdma_csr_awvalid (m_axil_qdma_csr_awvalid),
+    .m_axil_qdma_csr_awaddr  (m_axil_qdma_csr_awaddr),
+    .m_axil_qdma_csr_awready (m_axil_qdma_csr_awready),
+    .m_axil_qdma_csr_wvalid  (m_axil_qdma_csr_wvalid),
+    .m_axil_qdma_csr_wdata   (m_axil_qdma_csr_wdata),
+    .m_axil_qdma_csr_wready  (m_axil_qdma_csr_wready),
+    .m_axil_qdma_csr_bvalid  (m_axil_qdma_csr_bvalid),
+    .m_axil_qdma_csr_bresp   (m_axil_qdma_csr_bresp),
+    .m_axil_qdma_csr_bready  (m_axil_qdma_csr_bready),
+    .m_axil_qdma_csr_arvalid (m_axil_qdma_csr_arvalid),
+    .m_axil_qdma_csr_araddr  (m_axil_qdma_csr_araddr),
+    .m_axil_qdma_csr_arready (m_axil_qdma_csr_arready),
+    .m_axil_qdma_csr_rvalid  (m_axil_qdma_csr_rvalid),
+    .m_axil_qdma_csr_rdata   (m_axil_qdma_csr_rdata),
+    .m_axil_qdma_csr_rresp   (m_axil_qdma_csr_rresp),
+    .m_axil_qdma_csr_rready  (m_axil_qdma_csr_rready),
+
     .m_axil_adap_awvalid (m_axil_adap_awvalid),
     .m_axil_adap_awaddr  (m_axil_adap_awaddr),
     .m_axil_adap_awready (m_axil_adap_awready),
@@ -276,7 +327,24 @@ module system_config #(
     .m_axil_smon_rdata   (axil_smon_rdata),
     .m_axil_smon_rresp   (axil_smon_rresp),
     .m_axil_smon_rready  (axil_smon_rready),
-			   
+
+    .m_axil_rdma_awvalid (m_axil_rdma_awvalid),
+    .m_axil_rdma_awaddr  (m_axil_rdma_awaddr),
+    .m_axil_rdma_awready (m_axil_rdma_awready),
+    .m_axil_rdma_wvalid  (m_axil_rdma_wvalid),
+    .m_axil_rdma_wdata   (m_axil_rdma_wdata),
+    .m_axil_rdma_wready  (m_axil_rdma_wready),
+    .m_axil_rdma_bvalid  (m_axil_rdma_bvalid),
+    .m_axil_rdma_bresp   (m_axil_rdma_bresp),
+    .m_axil_rdma_bready  (m_axil_rdma_bready),
+    .m_axil_rdma_arvalid (m_axil_rdma_arvalid),
+    .m_axil_rdma_araddr  (m_axil_rdma_araddr),
+    .m_axil_rdma_arready (m_axil_rdma_arready),
+    .m_axil_rdma_rvalid  (m_axil_rdma_rvalid),
+    .m_axil_rdma_rdata   (m_axil_rdma_rdata),
+    .m_axil_rdma_rresp   (m_axil_rdma_rresp),
+    .m_axil_rdma_rready  (m_axil_rdma_rready),
+
     .m_axil_box0_awvalid (m_axil_box0_awvalid),
     .m_axil_box0_awaddr  (m_axil_box0_awaddr),
     .m_axil_box0_awready (m_axil_box0_awready),
@@ -346,26 +414,29 @@ module system_config #(
 
    system_management_wiz
    system_management_wiz_inst (
-     .s_axi_aclk      (aclk),                    
-     .s_axi_aresetn   (aresetn),                    
- 
-     .s_axi_awaddr    (axil_smon_awaddr),                    
-     .s_axi_awvalid   (axil_smon_awvalid),                    
-     .s_axi_awready   (axil_smon_awready),                    
-     .s_axi_wdata     (axil_smon_wdata),                    
-     .s_axi_wstrb     (4'hF),                    
-     .s_axi_wvalid    (axil_smon_wvalid),                    
-     .s_axi_wready    (axil_smon_wready),                    
-     .s_axi_bresp     (axil_smon_bresp),                    
-     .s_axi_bvalid    (axil_smon_bvalid),                    
-     .s_axi_bready    (axil_smon_bready),                    
-     .s_axi_araddr    (axil_smon_araddr),                    
-     .s_axi_arvalid   (axil_smon_arvalid),                    
-     .s_axi_arready   (axil_smon_arready),                    
-     .s_axi_rdata     (axil_smon_rdata),                    
-     .s_axi_rresp     (axil_smon_rresp),                    
-     .s_axi_rvalid    (axil_smon_rvalid),                    
-     .s_axi_rready    (axil_smon_rready)
+     .s_axi_aclk      (aclk),
+     .s_axi_aresetn   (aresetn),
+
+     .s_axi_awaddr    (axil_smon_awaddr),
+     .s_axi_awvalid   (axil_smon_awvalid),
+     .s_axi_awready   (axil_smon_awready),
+     .s_axi_wdata     (axil_smon_wdata),
+     .s_axi_wstrb     (4'hF),
+     .s_axi_wvalid    (axil_smon_wvalid),
+     .s_axi_wready    (axil_smon_wready),
+     .s_axi_bresp     (axil_smon_bresp),
+     .s_axi_bvalid    (axil_smon_bvalid),
+     .s_axi_bready    (axil_smon_bready),
+     .s_axi_araddr    (axil_smon_araddr),
+     .s_axi_arvalid   (axil_smon_arvalid),
+     .s_axi_arready   (axil_smon_arready),
+     .s_axi_rdata     (axil_smon_rdata),
+     .s_axi_rresp     (axil_smon_rresp),
+     .s_axi_rvalid    (axil_smon_rvalid),
+     .s_axi_rready    (axil_smon_rready),
+
+     .vp              (1'b0),
+     .vn              (1'b0)
   );
 
 endmodule: system_config
diff --git a/src/system_config/system_config_address_map.sv b/src/system_config/system_config_address_map.sv
index 11ae7a5..171712d 100644
--- a/src/system_config/system_config_address_map.sv
+++ b/src/system_config/system_config_address_map.sv
@@ -34,6 +34,10 @@
 // --------------------------------------------------
 //    0x10000  |  0x11FFF  |  Sysmon block
 // --------------------------------------------------
+//    0x14000  |  0x16FFF  |  QDMA AXI Bridge CSR
+// --------------------------------------------------
+//    0x40000  |  0x6FFFF  |  RDMA subsystem
+// --------------------------------------------------
 //   0x100000  |  0x1FFFFF |  Box0 @ 250MHz
 // --------------------------------------------------
 //   0x200000  |  0x2FFFFF |  Box1 @ 322MHz
@@ -95,6 +99,23 @@ module system_config_address_map #(
   input                   [1:0] m_axil_qdma_rresp,
   output                        m_axil_qdma_rready,
 
+  output                        m_axil_qdma_csr_awvalid,
+  output                 [31:0] m_axil_qdma_csr_awaddr,
+  input                         m_axil_qdma_csr_awready,
+  output                        m_axil_qdma_csr_wvalid,
+  output                 [31:0] m_axil_qdma_csr_wdata,
+  input                         m_axil_qdma_csr_wready,
+  input                         m_axil_qdma_csr_bvalid,
+  input                   [1:0] m_axil_qdma_csr_bresp,
+  output                        m_axil_qdma_csr_bready,
+  output                        m_axil_qdma_csr_arvalid,
+  output                 [31:0] m_axil_qdma_csr_araddr,
+  input                         m_axil_qdma_csr_arready,
+  input                         m_axil_qdma_csr_rvalid,
+  input                  [31:0] m_axil_qdma_csr_rdata,
+  input                   [1:0] m_axil_qdma_csr_rresp,
+  output                        m_axil_qdma_csr_rready,
+
   output    [NUM_CMAC_PORT-1:0] m_axil_adap_awvalid,
   output [32*NUM_CMAC_PORT-1:0] m_axil_adap_awaddr,
   input     [NUM_CMAC_PORT-1:0] m_axil_adap_awready,
@@ -129,6 +150,23 @@ module system_config_address_map #(
   input   [2*NUM_CMAC_PORT-1:0] m_axil_cmac_rresp,
   output    [NUM_CMAC_PORT-1:0] m_axil_cmac_rready,
 
+  output                        m_axil_rdma_awvalid,
+  output                 [31:0] m_axil_rdma_awaddr,
+  input                         m_axil_rdma_awready,
+  output                        m_axil_rdma_wvalid,
+  output                 [31:0] m_axil_rdma_wdata,
+  input                         m_axil_rdma_wready,
+  input                         m_axil_rdma_bvalid,
+  input                   [1:0] m_axil_rdma_bresp,
+  output                        m_axil_rdma_bready,
+  output                        m_axil_rdma_arvalid,
+  output                 [31:0] m_axil_rdma_araddr,
+  input                         m_axil_rdma_arready,
+  input                         m_axil_rdma_rvalid,
+  input                  [31:0] m_axil_rdma_rdata,
+  input                   [1:0] m_axil_rdma_rresp,
+  output                        m_axil_rdma_rready,
+
   output                        m_axil_box0_awvalid,
   output                 [31:0] m_axil_box0_awaddr,
   input                         m_axil_box0_awready,
@@ -184,7 +222,7 @@ module system_config_address_map #(
   input                         aresetn
 );
 
-  localparam C_NUM_SLAVES  = 9;
+  localparam C_NUM_SLAVES  = 11;
 
   localparam C_SCFG_INDEX  = 0;
   localparam C_QDMA_INDEX  = 1;
@@ -193,8 +231,10 @@ module system_config_address_map #(
   localparam C_CMAC1_INDEX = 4;
   localparam C_ADAP1_INDEX = 5;
   localparam C_SMON_INDEX  = 6;
-  localparam C_BOX1_INDEX  = 7;
-  localparam C_BOX0_INDEX  = 8;
+  localparam C_QCSR_INDEX  = 7;
+  localparam C_RDMA_INDEX  = 8;
+  localparam C_BOX1_INDEX  = 9;
+  localparam C_BOX0_INDEX  = 10;
 
   localparam C_SCFG_BASE_ADDR  = 32'h0;
   localparam C_QDMA_BASE_ADDR  = 32'h01000;
@@ -203,6 +243,8 @@ module system_config_address_map #(
   localparam C_CMAC1_BASE_ADDR = 32'h0C000;
   localparam C_ADAP1_BASE_ADDR = 32'h0F000;
   localparam C_SMON_BASE_ADDR  = 32'h10000;  // 14 bits
+  localparam C_QCSR_BASE_ADDR  = 32'h14000;  // 14 bits
+  localparam C_RDMA_BASE_ADDR  = 32'h40000;  // 18 bits
   localparam C_BOX1_BASE_ADDR  = 32'h200000; // 20 bits
   localparam C_BOX0_BASE_ADDR  = 32'h100000; // 20 bits
 
@@ -224,6 +266,10 @@ module system_config_address_map #(
   wire                [31:0] axil_box0_araddr;
   wire                [31:0] axil_smon_awaddr;
   wire                [31:0] axil_smon_araddr;
+  wire                [31:0] axil_qcsr_awaddr;
+  wire                [31:0] axil_qcsr_araddr;
+  wire                [31:0] axil_rdma_awaddr;
+  wire                [31:0] axil_rdma_araddr;
 
   wire  [1*C_NUM_SLAVES-1:0] axil_awvalid;
   wire [32*C_NUM_SLAVES-1:0] axil_awaddr;
@@ -247,6 +293,8 @@ module system_config_address_map #(
   assign axil_scfg_araddr                      = axil_araddr[`getvec(32, C_SCFG_INDEX)] - C_SCFG_BASE_ADDR;
   assign axil_qdma_awaddr                      = axil_awaddr[`getvec(32, C_QDMA_INDEX)] - C_QDMA_BASE_ADDR;
   assign axil_qdma_araddr                      = axil_araddr[`getvec(32, C_QDMA_INDEX)] - C_QDMA_BASE_ADDR;
+  assign axil_qcsr_awaddr                      = axil_awaddr[`getvec(32, C_QCSR_INDEX)] - C_QCSR_BASE_ADDR;
+  assign axil_qcsr_araddr                      = axil_araddr[`getvec(32, C_QCSR_INDEX)] - C_QCSR_BASE_ADDR;
   assign axil_cmac0_awaddr                     = axil_awaddr[`getvec(32, C_CMAC0_INDEX)] - C_CMAC0_BASE_ADDR;
   assign axil_cmac0_araddr                     = axil_araddr[`getvec(32, C_CMAC0_INDEX)] - C_CMAC0_BASE_ADDR;
   assign axil_adap0_awaddr                     = axil_awaddr[`getvec(32, C_ADAP0_INDEX)] - C_ADAP0_BASE_ADDR;
@@ -255,8 +303,10 @@ module system_config_address_map #(
   assign axil_cmac1_araddr                     = axil_araddr[`getvec(32, C_CMAC1_INDEX)] - C_CMAC1_BASE_ADDR;
   assign axil_adap1_awaddr                     = axil_awaddr[`getvec(32, C_ADAP1_INDEX)] - C_ADAP1_BASE_ADDR;
   assign axil_adap1_araddr                     = axil_araddr[`getvec(32, C_ADAP1_INDEX)] - C_ADAP1_BASE_ADDR;
-  assign axil_smon_awddr                       = axil_awaddr[`getvec(32, C_SMON_INDEX)]  - C_SMON_BASE_ADDR;
+  assign axil_smon_awaddr                      = axil_awaddr[`getvec(32, C_SMON_INDEX)]  - C_SMON_BASE_ADDR;
   assign axil_smon_araddr                      = axil_araddr[`getvec(32, C_SMON_INDEX)] - C_SMON_BASE_ADDR;
+  assign axil_rdma_awaddr                      = axil_awaddr[`getvec(32, C_RDMA_INDEX)] - C_RDMA_BASE_ADDR;
+  assign axil_rdma_araddr                      = axil_araddr[`getvec(32, C_RDMA_INDEX)] - C_RDMA_BASE_ADDR;
   assign axil_box1_awaddr                      = axil_awaddr[`getvec(32, C_BOX1_INDEX)] - C_BOX1_BASE_ADDR;
   assign axil_box1_araddr                      = axil_araddr[`getvec(32, C_BOX1_INDEX)] - C_BOX1_BASE_ADDR;
   assign axil_box0_awaddr                      = axil_awaddr[`getvec(32, C_BOX0_INDEX)] - C_BOX0_BASE_ADDR;
@@ -296,6 +346,23 @@ module system_config_address_map #(
   assign axil_rresp[`getvec(2, C_QDMA_INDEX)]  = m_axil_qdma_rresp;
   assign m_axil_qdma_rready                    = axil_rready[C_QDMA_INDEX];
 
+  assign m_axil_qdma_csr_awvalid               = axil_awvalid[C_QCSR_INDEX];
+  assign m_axil_qdma_csr_awaddr                = axil_qcsr_awaddr;
+  assign axil_awready[C_QCSR_INDEX]            = m_axil_qdma_csr_awready;
+  assign m_axil_qdma_csr_wvalid                = axil_wvalid[C_QCSR_INDEX];
+  assign m_axil_qdma_csr_wdata                 = axil_wdata[`getvec(32, C_QCSR_INDEX)];
+  assign axil_wready[C_QCSR_INDEX]             = m_axil_qdma_csr_wready;
+  assign axil_bvalid[C_QCSR_INDEX]             = m_axil_qdma_csr_bvalid;
+  assign axil_bresp[`getvec(2, C_QCSR_INDEX)]  = m_axil_qdma_csr_bresp;
+  assign m_axil_qdma_csr_bready                = axil_bready[C_QCSR_INDEX];
+  assign m_axil_qdma_csr_arvalid               = axil_arvalid[C_QCSR_INDEX];
+  assign m_axil_qdma_csr_araddr                = axil_qcsr_araddr;
+  assign axil_arready[C_QCSR_INDEX]            = m_axil_qdma_csr_arready;
+  assign axil_rvalid[C_QCSR_INDEX]             = m_axil_qdma_csr_rvalid;
+  assign axil_rdata[`getvec(32, C_QCSR_INDEX)] = m_axil_qdma_csr_rdata;
+  assign axil_rresp[`getvec(2, C_QCSR_INDEX)]  = m_axil_qdma_csr_rresp;
+  assign m_axil_qdma_csr_rready                = axil_rready[C_QCSR_INDEX];
+
   if (NUM_CMAC_PORT == 1) begin
     assign m_axil_cmac_awvalid                    = axil_awvalid[C_CMAC0_INDEX];
     assign m_axil_cmac_awaddr                     = axil_cmac0_awaddr;
@@ -504,6 +571,23 @@ module system_config_address_map #(
   assign axil_rresp[`getvec(2, C_SMON_INDEX)]  = m_axil_smon_rresp;
   assign m_axil_smon_rready                    = axil_rready[C_SMON_INDEX];
 
+  assign m_axil_rdma_awvalid                   = axil_awvalid[C_RDMA_INDEX];
+  assign m_axil_rdma_awaddr                    = axil_rdma_awaddr;
+  assign axil_awready[C_RDMA_INDEX]            = m_axil_rdma_awready;
+  assign m_axil_rdma_wvalid                    = axil_wvalid[C_RDMA_INDEX];
+  assign m_axil_rdma_wdata                     = axil_wdata[`getvec(32, C_RDMA_INDEX)];
+  assign axil_wready[C_RDMA_INDEX]             = m_axil_rdma_wready;
+  assign axil_bvalid[C_RDMA_INDEX]             = m_axil_rdma_bvalid;
+  assign axil_bresp[`getvec(2, C_RDMA_INDEX)]  = m_axil_rdma_bresp;
+  assign m_axil_rdma_bready                    = axil_bready[C_RDMA_INDEX];
+  assign m_axil_rdma_arvalid                   = axil_arvalid[C_RDMA_INDEX];
+  assign m_axil_rdma_araddr                    = axil_rdma_araddr;
+  assign axil_arready[C_RDMA_INDEX]            = m_axil_rdma_arready;
+  assign axil_rvalid[C_RDMA_INDEX]             = m_axil_rdma_rvalid;
+  assign axil_rdata[`getvec(32, C_RDMA_INDEX)] = m_axil_rdma_rdata;
+  assign axil_rresp[`getvec(2, C_RDMA_INDEX)]  = m_axil_rdma_rresp;
+  assign m_axil_rdma_rready                    = axil_rready[C_RDMA_INDEX];
+
   system_config_axi_crossbar xbar_inst (
     .s_axi_awaddr  (s_axil_awaddr),
     .s_axi_awprot  (0),
diff --git a/src/system_config/system_config_register.v b/src/system_config/system_config_register.v
index 36e7774..d41510f 100644
--- a/src/system_config/system_config_register.v
+++ b/src/system_config/system_config_register.v
@@ -104,7 +104,7 @@ module system_config_register #(
     .DATA_W        (32)
   ) axil_reg_inst (
     .s_axil_awvalid (s_axil_awvalid),
-    .s_axil_awaddr  (s_axil_awaddr),
+    .s_axil_awaddr  (s_axil_awaddr[C_ADDR_W-1:0]),
     .s_axil_awready (s_axil_awready),
     .s_axil_wvalid  (s_axil_wvalid),
     .s_axil_wdata   (s_axil_wdata),
@@ -113,7 +113,7 @@ module system_config_register #(
     .s_axil_bresp   (s_axil_bresp),
     .s_axil_bready  (s_axil_bready),
     .s_axil_arvalid (s_axil_arvalid),
-    .s_axil_araddr  (s_axil_araddr),
+    .s_axil_araddr  (s_axil_araddr[C_ADDR_W-1:0]),
     .s_axil_arready (s_axil_arready),
     .s_axil_rvalid  (s_axil_rvalid),
     .s_axil_rdata   (s_axil_rdata),
@@ -201,11 +201,15 @@ module system_config_register #(
 
   // Shell reset register (write-only)
   //
-  // 31:3  - reserved
-  // 2     - reset for the CMAC subsystem CMAC1
-  // 1     - reset for the CMAC subsystem CMAC0
+  // 31:10 - reserved
+  // 9     - reset for the adapter of CMAC1
+  // 8     - reset for the CMAC subsystem CMAC1
+  // 7:6   - reserved
+  // 5     - reset for the adapter of CMAC0
+  // 4     - reset for the CMAC subsystem CMAC0
+  // 3:2   - reserved
+  // 1     - reset for the RDMA subsystem
   // 0     - reset for the QDMA subsystem
-  // 
   // Writing 1 to a bit of this register initiates a submodule-level reset in
   // the shell logic, which lasts until the corresponding submodule is out of
   // reset.  Mapping between bits and submodules are as follows.
diff --git a/src/system_config/vivado_ip/system_config_axi_crossbar.tcl b/src/system_config/vivado_ip/system_config_axi_crossbar.tcl
index 603d9c9..0b02c76 100644
--- a/src/system_config/vivado_ip/system_config_axi_crossbar.tcl
+++ b/src/system_config/vivado_ip/system_config_axi_crossbar.tcl
@@ -17,9 +17,9 @@
 # *************************************************************************
 set axi_crossbar system_config_axi_crossbar
 create_ip -name axi_crossbar -vendor xilinx.com -library ip -module_name $axi_crossbar -dir ${ip_build_dir}
-set_property -dict { 
+set_property -dict {
     CONFIG.ADDR_RANGES {3}
-    CONFIG.NUM_MI {9}
+    CONFIG.NUM_MI {11}
     CONFIG.PROTOCOL {AXI4LITE}
     CONFIG.CONNECTIVITY_MODE {SASD}
     CONFIG.R_REGISTER {1}
@@ -98,8 +98,10 @@ set_property -dict {
     CONFIG.M04_A01_BASE_ADDR {0x000000000000E000}
     CONFIG.M05_A00_BASE_ADDR {0x000000000000F000}
     CONFIG.M06_A00_BASE_ADDR {0x0000000000010000}
-    CONFIG.M07_A00_BASE_ADDR {0x0000000000200000}
-    CONFIG.M08_A00_BASE_ADDR {0x0000000000100000}
+    CONFIG.M07_A00_BASE_ADDR {0x0000000000014000}
+    CONFIG.M08_A00_BASE_ADDR {0x0000000000040000}
+    CONFIG.M09_A00_BASE_ADDR {0x0000000000200000}
+    CONFIG.M10_A00_BASE_ADDR {0x0000000000100000}
     CONFIG.M01_A00_ADDR_WIDTH {12}
     CONFIG.M01_A01_ADDR_WIDTH {13}
     CONFIG.M01_A02_ADDR_WIDTH {13}
@@ -110,6 +112,8 @@ set_property -dict {
     CONFIG.M04_A01_ADDR_WIDTH {12}
     CONFIG.M05_A00_ADDR_WIDTH {12}
     CONFIG.M06_A00_ADDR_WIDTH {13}
-    CONFIG.M07_A00_ADDR_WIDTH {20}
-    CONFIG.M08_A00_ADDR_WIDTH {20}
+    CONFIG.M07_A00_ADDR_WIDTH {14}
+    CONFIG.M08_A00_ADDR_WIDTH {18}
+    CONFIG.M09_A00_ADDR_WIDTH {20}
+    CONFIG.M10_A00_ADDR_WIDTH {20}
 } [get_ips $axi_crossbar]
diff --git a/src/system_config/vivado_ip/system_management_wiz.tcl b/src/system_config/vivado_ip/system_management_wiz.tcl
index 8e92afe..efe4669 100644
--- a/src/system_config/vivado_ip/system_management_wiz.tcl
+++ b/src/system_config/vivado_ip/system_management_wiz.tcl
@@ -20,22 +20,22 @@ create_ip -name system_management_wiz -vendor xilinx.com -library ip -module_nam
 set_property -dict {
     CONFIG.INTERFACE_SELECTION {Enable_AXI}
     CONFIG.ENABLE_RESET {false}
-    CONFIG.OT_ALARM {false} 
-    CONFIG.USER_TEMP_ALARM {false} 
-    CONFIG.VCCINT_ALARM {false} 
-    CONFIG.VCCAUX_ALARM {false} 
-    CONFIG.ENABLE_VBRAM_ALARM {false} 
-    CONFIG.CHANNEL_ENABLE_VP_VN {true} 
-    CONFIG.AVERAGE_ENABLE_VBRAM {true} 
-    CONFIG.AVERAGE_ENABLE_TEMPERATURE {true} 
-    CONFIG.AVERAGE_ENABLE_VCCINT {true} 
-    CONFIG.AVERAGE_ENABLE_VCCAUX {true} 
-    CONFIG.AVERAGE_ENABLE_TEMPERATURE_SLAVE0_SSIT {true} 
-    CONFIG.AVERAGE_ENABLE_TEMPERATURE_SLAVE1_SSIT {true} 
-    CONFIG.CHANNEL_ENABLE_VUSER0_SLAVE0_SSIT {true} 
-    CONFIG.AVERAGE_ENABLE_VUSER0_SLAVE0_SSIT {true} 
-    CONFIG.CHANNEL_ENABLE_VUSER0_SLAVE1_SSIT {true} 
-    CONFIG.AVERAGE_ENABLE_VUSER0_SLAVE1_SSIT {true} 
-    CONFIG.Enable_Slave0 {true} 
+    CONFIG.OT_ALARM {false}
+    CONFIG.USER_TEMP_ALARM {false}
+    CONFIG.VCCINT_ALARM {false}
+    CONFIG.VCCAUX_ALARM {false}
+    CONFIG.ENABLE_VBRAM_ALARM {false}
+    CONFIG.CHANNEL_ENABLE_VP_VN {true}
+    CONFIG.AVERAGE_ENABLE_VBRAM {true}
+    CONFIG.AVERAGE_ENABLE_TEMPERATURE {true}
+    CONFIG.AVERAGE_ENABLE_VCCINT {true}
+    CONFIG.AVERAGE_ENABLE_VCCAUX {true}
+    CONFIG.AVERAGE_ENABLE_TEMPERATURE_SLAVE0_SSIT {true}
+    CONFIG.AVERAGE_ENABLE_TEMPERATURE_SLAVE1_SSIT {true}
+    CONFIG.CHANNEL_ENABLE_VUSER0_SLAVE0_SSIT {true}
+    CONFIG.AVERAGE_ENABLE_VUSER0_SLAVE0_SSIT {true}
+    CONFIG.CHANNEL_ENABLE_VUSER0_SLAVE1_SSIT {true}
+    CONFIG.AVERAGE_ENABLE_VUSER0_SLAVE1_SSIT {true}
+    CONFIG.Enable_Slave0 {true}
     CONFIG.Enable_Slave1 {true}
 } [get_ips $system_management_wiz]
diff --git a/src/utility/axi_3to1_interconnect_to_dev_mem.sv b/src/utility/axi_3to1_interconnect_to_dev_mem.sv
new file mode 100755
index 0000000..afcc02e
--- /dev/null
+++ b/src/utility/axi_3to1_interconnect_to_dev_mem.sv
@@ -0,0 +1,431 @@
+// *************************************************************************
+//
+// Copyright 2022 Xilinx, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// *************************************************************************
+`timescale 1ns/1ps
+
+module axi_3to1_interconnect_to_dev_mem #(
+  parameter C_AXI_DATA_WIDTH = 512,
+  parameter C_AXI_ADDR_WIDTH = 64
+) (
+
+  input     [4 : 0] s_axi_qdma_mm_awid,
+  input    [63 : 0] s_axi_qdma_mm_awaddr,
+  input     [3 : 0] s_axi_qdma_mm_awqos,
+  input     [7 : 0] s_axi_qdma_mm_awlen,
+  input     [2 : 0] s_axi_qdma_mm_awsize,
+  input     [1 : 0] s_axi_qdma_mm_awburst,
+  input     [3 : 0] s_axi_qdma_mm_awcache,
+  input     [2 : 0] s_axi_qdma_mm_awprot,
+  input             s_axi_qdma_mm_awvalid,
+  output            s_axi_qdma_mm_awready,
+  input   [511 : 0] s_axi_qdma_mm_wdata,
+  input    [63 : 0] s_axi_qdma_mm_wstrb,
+  input             s_axi_qdma_mm_wlast,
+  input             s_axi_qdma_mm_wvalid,
+  output            s_axi_qdma_mm_wready,
+  input             s_axi_qdma_mm_awlock,
+  output    [4 : 0] s_axi_qdma_mm_bid,
+  output    [1 : 0] s_axi_qdma_mm_bresp,
+  output            s_axi_qdma_mm_bvalid,
+  input             s_axi_qdma_mm_bready,
+  input     [4 : 0] s_axi_qdma_mm_arid,
+  input    [63 : 0] s_axi_qdma_mm_araddr,
+  input     [7 : 0] s_axi_qdma_mm_arlen,
+  input     [2 : 0] s_axi_qdma_mm_arsize,
+  input     [1 : 0] s_axi_qdma_mm_arburst,
+  input     [3 : 0] s_axi_qdma_mm_arcache,
+  input     [2 : 0] s_axi_qdma_mm_arprot,
+  input             s_axi_qdma_mm_arvalid,
+  output            s_axi_qdma_mm_arready,
+  output    [4 : 0] s_axi_qdma_mm_rid,
+  output  [511 : 0] s_axi_qdma_mm_rdata,
+  output    [1 : 0] s_axi_qdma_mm_rresp,
+  output            s_axi_qdma_mm_rlast,
+  output            s_axi_qdma_mm_rvalid,
+  input             s_axi_qdma_mm_rready,
+  input             s_axi_qdma_mm_arlock,
+  input     [3 : 0] s_axi_qdma_mm_arqos,
+
+  input             s_axi_compute_logic_awid,
+  input    [63 : 0] s_axi_compute_logic_awaddr,
+  input     [3 : 0] s_axi_compute_logic_awqos,
+  input     [7 : 0] s_axi_compute_logic_awlen,
+  input     [2 : 0] s_axi_compute_logic_awsize,
+  input     [1 : 0] s_axi_compute_logic_awburst,
+  input     [3 : 0] s_axi_compute_logic_awcache,
+  input     [2 : 0] s_axi_compute_logic_awprot,
+  input             s_axi_compute_logic_awvalid,
+  output            s_axi_compute_logic_awready,
+  input   [511 : 0] s_axi_compute_logic_wdata,
+  input    [63 : 0] s_axi_compute_logic_wstrb,
+  input             s_axi_compute_logic_wlast,
+  input             s_axi_compute_logic_wvalid,
+  output            s_axi_compute_logic_wready,
+  input             s_axi_compute_logic_awlock,
+  output            s_axi_compute_logic_bid,
+  output    [1 : 0] s_axi_compute_logic_bresp,
+  output            s_axi_compute_logic_bvalid,
+  input             s_axi_compute_logic_bready,
+  input             s_axi_compute_logic_arid,
+  input    [63 : 0] s_axi_compute_logic_araddr,
+  input     [7 : 0] s_axi_compute_logic_arlen,
+  input     [2 : 0] s_axi_compute_logic_arsize,
+  input     [1 : 0] s_axi_compute_logic_arburst,
+  input     [3 : 0] s_axi_compute_logic_arcache,
+  input     [2 : 0] s_axi_compute_logic_arprot,
+  input             s_axi_compute_logic_arvalid,
+  output            s_axi_compute_logic_arready,
+  output            s_axi_compute_logic_rid,
+  output  [511 : 0] s_axi_compute_logic_rdata,
+  output    [1 : 0] s_axi_compute_logic_rresp,
+  output            s_axi_compute_logic_rlast,
+  output            s_axi_compute_logic_rvalid,
+  input             s_axi_compute_logic_rready,
+  input             s_axi_compute_logic_arlock,
+  input     [3 : 0] s_axi_compute_logic_arqos,
+
+  input     [4 : 0] s_axi_from_sys_crossbar_awid,
+  input    [63 : 0] s_axi_from_sys_crossbar_awaddr,
+  input     [3 : 0] s_axi_from_sys_crossbar_awqos,
+  input     [7 : 0] s_axi_from_sys_crossbar_awlen,
+  input     [2 : 0] s_axi_from_sys_crossbar_awsize,
+  input     [1 : 0] s_axi_from_sys_crossbar_awburst,
+  input     [3 : 0] s_axi_from_sys_crossbar_awcache,
+  input     [2 : 0] s_axi_from_sys_crossbar_awprot,
+  input             s_axi_from_sys_crossbar_awvalid,
+  output            s_axi_from_sys_crossbar_awready,
+  input   [511 : 0] s_axi_from_sys_crossbar_wdata,
+  input    [63 : 0] s_axi_from_sys_crossbar_wstrb,
+  input             s_axi_from_sys_crossbar_wlast,
+  input             s_axi_from_sys_crossbar_wvalid,
+  output            s_axi_from_sys_crossbar_wready,
+  input             s_axi_from_sys_crossbar_awlock,
+  output    [4 : 0] s_axi_from_sys_crossbar_bid,
+  output    [1 : 0] s_axi_from_sys_crossbar_bresp,
+  output            s_axi_from_sys_crossbar_bvalid,
+  input             s_axi_from_sys_crossbar_bready,
+  input     [4 : 0] s_axi_from_sys_crossbar_arid,
+  input    [63 : 0] s_axi_from_sys_crossbar_araddr,
+  input     [7 : 0] s_axi_from_sys_crossbar_arlen,
+  input     [2 : 0] s_axi_from_sys_crossbar_arsize,
+  input     [1 : 0] s_axi_from_sys_crossbar_arburst,
+  input     [3 : 0] s_axi_from_sys_crossbar_arcache,
+  input     [2 : 0] s_axi_from_sys_crossbar_arprot,
+  input             s_axi_from_sys_crossbar_arvalid,
+  output            s_axi_from_sys_crossbar_arready,
+  output    [4 : 0] s_axi_from_sys_crossbar_rid,
+  output  [511 : 0] s_axi_from_sys_crossbar_rdata,
+  output    [1 : 0] s_axi_from_sys_crossbar_rresp,
+  output            s_axi_from_sys_crossbar_rlast,
+  output            s_axi_from_sys_crossbar_rvalid,
+  input             s_axi_from_sys_crossbar_rready,
+  input             s_axi_from_sys_crossbar_arlock,
+  input     [3 : 0] s_axi_from_sys_crossbar_arqos,
+
+  output    [4 : 0] m_axi_dev_mem_awid,
+  output   [63 : 0] m_axi_dev_mem_awaddr,
+  output    [7 : 0] m_axi_dev_mem_awlen,
+  output    [2 : 0] m_axi_dev_mem_awsize,
+  output    [1 : 0] m_axi_dev_mem_awburst,
+  output            m_axi_dev_mem_awlock,
+  output    [3 : 0] m_axi_dev_mem_awqos,
+  output    [3 : 0] m_axi_dev_mem_awregion,
+  output    [3 : 0] m_axi_dev_mem_awcache,
+  output    [2 : 0] m_axi_dev_mem_awprot,
+  output            m_axi_dev_mem_awvalid,
+  input             m_axi_dev_mem_awready,
+  output  [511 : 0] m_axi_dev_mem_wdata,
+  output   [63 : 0] m_axi_dev_mem_wstrb,
+  output            m_axi_dev_mem_wlast,
+  output            m_axi_dev_mem_wvalid,
+  input             m_axi_dev_mem_wready,
+  input     [4 : 0] m_axi_dev_mem_bid,
+  input     [1 : 0] m_axi_dev_mem_bresp,
+  input             m_axi_dev_mem_bvalid,
+  output            m_axi_dev_mem_bready,
+  output    [4 : 0] m_axi_dev_mem_arid,
+  output   [63 : 0] m_axi_dev_mem_araddr,
+  output    [7 : 0] m_axi_dev_mem_arlen,
+  output    [2 : 0] m_axi_dev_mem_arsize,
+  output    [1 : 0] m_axi_dev_mem_arburst,
+  output            m_axi_dev_mem_arlock,
+  output    [3 : 0] m_axi_dev_mem_arqos,
+  output    [3 : 0] m_axi_dev_mem_arregion,
+  output    [3 : 0] m_axi_dev_mem_arcache,
+  output    [2 : 0] m_axi_dev_mem_arprot,
+  output            m_axi_dev_mem_arvalid,
+  input             m_axi_dev_mem_arready,
+  input     [4 : 0] m_axi_dev_mem_rid,
+  input   [511 : 0] m_axi_dev_mem_rdata,
+  input     [1 : 0] m_axi_dev_mem_rresp,
+  input             m_axi_dev_mem_rlast,
+  input             m_axi_dev_mem_rvalid,
+  output            m_axi_dev_mem_rready,
+
+  input             axis_aclk,
+  input             axis_arestn
+);
+
+localparam C_NUM_MASTERS = 3;
+
+localparam C_QDMA_MM_IDX          = 0;
+localparam C_COMPUTE_LOGIC_IDX    = 1;
+localparam C_FROM_SYS_CROSSBAR_IDX  = 2;
+
+logic   [C_NUM_MASTERS*5-1 : 0] axi_awid;
+logic  [C_NUM_MASTERS*64-1 : 0] axi_awaddr;
+logic   [C_NUM_MASTERS*8-1 : 0] axi_awlen;
+logic   [C_NUM_MASTERS*3-1 : 0] axi_awsize;
+logic   [C_NUM_MASTERS*2-1 : 0] axi_awburst;
+logic     [C_NUM_MASTERS-1 : 0] axi_awlock;
+logic   [C_NUM_MASTERS*4-1 : 0] axi_awcache;
+logic   [C_NUM_MASTERS*3-1 : 0] axi_awprot;
+logic   [C_NUM_MASTERS*4-1 : 0] axi_awqos;
+logic     [C_NUM_MASTERS-1 : 0] axi_awvalid;
+logic     [C_NUM_MASTERS-1 : 0] axi_awready;
+logic [C_NUM_MASTERS*512-1 : 0] axi_wdata;
+logic  [C_NUM_MASTERS*64-1 : 0] axi_wstrb;
+logic     [C_NUM_MASTERS-1 : 0] axi_wlast;
+logic     [C_NUM_MASTERS-1 : 0] axi_wvalid;
+logic     [C_NUM_MASTERS-1 : 0] axi_wready;
+logic   [C_NUM_MASTERS*5-1 : 0] axi_bid;
+logic   [C_NUM_MASTERS*2-1 : 0] axi_bresp;
+logic     [C_NUM_MASTERS-1 : 0] axi_bvalid;
+logic     [C_NUM_MASTERS-1 : 0] axi_bready;
+logic   [C_NUM_MASTERS*5-1 : 0] axi_arid;
+logic  [C_NUM_MASTERS*64-1 : 0] axi_araddr;
+logic   [C_NUM_MASTERS*8-1 : 0] axi_arlen;
+logic   [C_NUM_MASTERS*3-1 : 0] axi_arsize;
+logic   [C_NUM_MASTERS*2-1 : 0] axi_arburst;
+logic     [C_NUM_MASTERS-1 : 0] axi_arlock;
+logic   [C_NUM_MASTERS*4-1 : 0] axi_arcache;
+logic   [C_NUM_MASTERS*3-1 : 0] axi_arprot;
+logic   [C_NUM_MASTERS*4-1 : 0] axi_arqos;
+logic     [C_NUM_MASTERS-1 : 0] axi_arvalid;
+logic     [C_NUM_MASTERS-1 : 0] axi_arready;
+logic   [C_NUM_MASTERS*5-1 : 0] axi_rid;
+logic [C_NUM_MASTERS*512-1 : 0] axi_rdata;
+logic   [C_NUM_MASTERS*2-1 : 0] axi_rresp;
+logic     [C_NUM_MASTERS-1 : 0] axi_rlast;
+logic     [C_NUM_MASTERS-1 : 0] axi_rvalid;
+logic     [C_NUM_MASTERS-1 : 0] axi_rready;
+
+
+// AXI slave signals for data access from qdma mm channel
+assign axi_awid   [C_QDMA_MM_IDX*5 +: 5]                = s_axi_qdma_mm_awvalid ? {1'b1,s_axi_qdma_mm_awid[3:0]} : 5'd0;
+assign axi_awaddr [C_QDMA_MM_IDX *64 +: 64]             = s_axi_qdma_mm_awaddr;
+assign axi_awqos  [C_QDMA_MM_IDX *4 +: 4]               = s_axi_qdma_mm_awqos;
+assign axi_awlen  [C_QDMA_MM_IDX *8 +: 8]               = s_axi_qdma_mm_awlen;
+assign axi_awsize [C_QDMA_MM_IDX *3 +: 3]               = s_axi_qdma_mm_awsize;
+assign axi_awburst[C_QDMA_MM_IDX *2 +: 2]               = s_axi_qdma_mm_awburst;
+assign axi_awcache[C_QDMA_MM_IDX *4 +: 4]               = s_axi_qdma_mm_awcache;
+assign axi_awprot [C_QDMA_MM_IDX *3 +: 3]               = s_axi_qdma_mm_awprot;
+assign axi_awvalid[C_QDMA_MM_IDX *1 +: 1]               = s_axi_qdma_mm_awvalid;
+assign s_axi_qdma_mm_awready                            = axi_awready[C_QDMA_MM_IDX *1 +: 1];
+assign axi_wdata  [C_QDMA_MM_IDX *512 +: 512]           = s_axi_qdma_mm_wdata;
+assign axi_wstrb  [C_QDMA_MM_IDX *64 +: 64]             = s_axi_qdma_mm_wstrb;
+assign axi_wlast  [C_QDMA_MM_IDX *1 +: 1]               = s_axi_qdma_mm_wlast;
+assign axi_wvalid [C_QDMA_MM_IDX *1 +: 1]               = s_axi_qdma_mm_wvalid;
+assign s_axi_qdma_mm_wready                             = axi_wready[C_QDMA_MM_IDX *1 +: 1];
+assign axi_awlock [C_QDMA_MM_IDX *1 +: 1]               = s_axi_qdma_mm_awlock;
+assign s_axi_qdma_mm_bid                                = axi_bid[C_QDMA_MM_IDX *5 +: 4];
+assign s_axi_qdma_mm_bresp                              = axi_bresp[C_QDMA_MM_IDX *2 +: 2];
+assign s_axi_qdma_mm_bvalid                             = axi_bvalid[C_QDMA_MM_IDX *1 +: 1];
+assign axi_bready [C_QDMA_MM_IDX *1 +: 1]               = s_axi_qdma_mm_bready;
+assign axi_arid   [C_QDMA_MM_IDX *5 +: 5]               = s_axi_qdma_mm_arvalid ? {1'b1,s_axi_qdma_mm_arid[3:0]} : 5'd0;
+assign axi_araddr [C_QDMA_MM_IDX *64 +: 64]             = s_axi_qdma_mm_araddr;
+assign axi_arlen  [C_QDMA_MM_IDX *8  +: 8]              = s_axi_qdma_mm_arlen;
+assign axi_arsize [C_QDMA_MM_IDX *3  +: 3]              = s_axi_qdma_mm_arsize;
+assign axi_arburst[C_QDMA_MM_IDX *2  +: 2]              = s_axi_qdma_mm_arburst;
+assign axi_arcache[C_QDMA_MM_IDX *4  +: 4]              = s_axi_qdma_mm_arcache;
+assign axi_arprot [C_QDMA_MM_IDX *3  +: 3]              = s_axi_qdma_mm_arprot;
+assign axi_arvalid[C_QDMA_MM_IDX *1  +: 1]              = s_axi_qdma_mm_arvalid;
+assign s_axi_qdma_mm_arready                            = axi_arready[C_QDMA_MM_IDX *1 +: 1];
+assign s_axi_qdma_mm_rid                                = axi_rid[C_QDMA_MM_IDX *5 +: 4];
+assign s_axi_qdma_mm_rdata                              = axi_rdata[C_QDMA_MM_IDX *512 +: 512];
+assign s_axi_qdma_mm_rresp                              = axi_rresp[C_QDMA_MM_IDX *2 +: 2];
+assign s_axi_qdma_mm_rlast                              = axi_rlast[C_QDMA_MM_IDX *1 +: 1];
+assign s_axi_qdma_mm_rvalid                             = axi_rvalid[C_QDMA_MM_IDX *1 +: 1];
+assign axi_rready [C_QDMA_MM_IDX *1 +: 1]               = s_axi_qdma_mm_rready;
+assign axi_arlock [C_QDMA_MM_IDX *1 +: 1]               = s_axi_qdma_mm_arlock;
+assign axi_arqos  [C_QDMA_MM_IDX *4 +: 4]               = s_axi_qdma_mm_arqos;
+
+// AXI slave signals for data access from compute logic
+//assign axi_awid   [C_COMPUTE_LOGIC_IDX *2 +: 2]      = {1'b0, s_axi_compute_logic_awid};
+assign axi_awid   [C_COMPUTE_LOGIC_IDX *5 +: 5]      = s_axi_compute_logic_awvalid ? 5'd8 : 5'd0;
+assign axi_awaddr [C_COMPUTE_LOGIC_IDX *64 +: 64]    = s_axi_compute_logic_awaddr;
+assign axi_awqos  [C_COMPUTE_LOGIC_IDX *4 +: 4]      = s_axi_compute_logic_awqos;
+assign axi_awlen  [C_COMPUTE_LOGIC_IDX *8 +: 8]      = s_axi_compute_logic_awlen;
+assign axi_awsize [C_COMPUTE_LOGIC_IDX *3 +: 3]      = s_axi_compute_logic_awsize;
+assign axi_awburst[C_COMPUTE_LOGIC_IDX *2 +: 2]      = s_axi_compute_logic_awburst;
+assign axi_awcache[C_COMPUTE_LOGIC_IDX *4 +: 4]      = s_axi_compute_logic_awcache;
+assign axi_awprot [C_COMPUTE_LOGIC_IDX *3 +: 3]      = s_axi_compute_logic_awprot;
+assign axi_awvalid[C_COMPUTE_LOGIC_IDX *1 +: 1]      = s_axi_compute_logic_awvalid;
+assign s_axi_compute_logic_awready                   = axi_awready[C_COMPUTE_LOGIC_IDX *1 +: 1];
+assign axi_wdata  [C_COMPUTE_LOGIC_IDX *512 +: 512]  = s_axi_compute_logic_wdata;
+assign axi_wstrb  [C_COMPUTE_LOGIC_IDX *64 +: 64]    = s_axi_compute_logic_wstrb;
+assign axi_wlast  [C_COMPUTE_LOGIC_IDX *1 +: 1]      = s_axi_compute_logic_wlast;
+assign axi_wvalid [C_COMPUTE_LOGIC_IDX *1 +: 1]      = s_axi_compute_logic_wvalid;
+assign s_axi_compute_logic_wready                    = axi_wready[C_COMPUTE_LOGIC_IDX *1 +: 1];
+assign axi_awlock [C_COMPUTE_LOGIC_IDX *1 +: 1]      = s_axi_compute_logic_awlock;
+assign s_axi_compute_logic_bid                       = axi_bid[C_COMPUTE_LOGIC_IDX *5 +: 1];
+assign s_axi_compute_logic_bresp                     = axi_bresp[C_COMPUTE_LOGIC_IDX *2 +: 2];
+assign s_axi_compute_logic_bvalid                    = axi_bvalid[C_COMPUTE_LOGIC_IDX *1 +: 1];
+assign axi_bready [C_COMPUTE_LOGIC_IDX *1 +: 1]      = s_axi_compute_logic_bready;
+assign axi_arid   [C_COMPUTE_LOGIC_IDX *5 +: 5]      = s_axi_compute_logic_arvalid ? 5'd8 : 5'd4;
+assign axi_araddr [C_COMPUTE_LOGIC_IDX *64 +: 64]    = s_axi_compute_logic_araddr;
+assign axi_arlen  [C_COMPUTE_LOGIC_IDX *8  +: 8]     = s_axi_compute_logic_arlen;
+assign axi_arsize [C_COMPUTE_LOGIC_IDX *3  +: 3]     = s_axi_compute_logic_arsize;
+assign axi_arburst[C_COMPUTE_LOGIC_IDX *2  +: 2]     = s_axi_compute_logic_arburst;
+assign axi_arcache[C_COMPUTE_LOGIC_IDX *4  +: 4]     = s_axi_compute_logic_arcache;
+assign axi_arprot [C_COMPUTE_LOGIC_IDX *3  +: 3]     = s_axi_compute_logic_arprot;
+assign axi_arvalid[C_COMPUTE_LOGIC_IDX *1  +: 1]     = s_axi_compute_logic_arvalid;
+assign s_axi_compute_logic_arready                   = axi_arready[C_COMPUTE_LOGIC_IDX *1 +: 1];
+assign s_axi_compute_logic_rid                       = axi_rid[C_COMPUTE_LOGIC_IDX *5 +: 1];
+assign s_axi_compute_logic_rdata                     = axi_rdata[C_COMPUTE_LOGIC_IDX *512 +: 512];
+assign s_axi_compute_logic_rresp                     = axi_rresp[C_COMPUTE_LOGIC_IDX *2 +: 2];
+assign s_axi_compute_logic_rlast                     = axi_rlast[C_COMPUTE_LOGIC_IDX *1 +: 1];
+assign s_axi_compute_logic_rvalid                    = axi_rvalid[C_COMPUTE_LOGIC_IDX *1 +: 1];
+assign axi_rready [C_COMPUTE_LOGIC_IDX *1 +: 1]      = s_axi_compute_logic_rready;
+assign axi_arlock [C_COMPUTE_LOGIC_IDX *1 +: 1]      = s_axi_compute_logic_arlock;
+assign axi_arqos  [C_COMPUTE_LOGIC_IDX *4 +: 4]      = s_axi_compute_logic_arqos;
+
+//s_axi_from_sys_crossbar_awid
+assign axi_awid   [C_FROM_SYS_CROSSBAR_IDX *5 +: 5]      = s_axi_from_sys_crossbar_awvalid ? s_axi_from_sys_crossbar_awid : 5'd0;
+assign axi_awaddr [C_FROM_SYS_CROSSBAR_IDX *64 +: 64]    = s_axi_from_sys_crossbar_awaddr;
+assign axi_awqos  [C_FROM_SYS_CROSSBAR_IDX *4 +: 4]      = s_axi_from_sys_crossbar_awqos;
+assign axi_awlen  [C_FROM_SYS_CROSSBAR_IDX *8 +: 8]      = s_axi_from_sys_crossbar_awlen;
+assign axi_awsize [C_FROM_SYS_CROSSBAR_IDX *3 +: 3]      = s_axi_from_sys_crossbar_awsize;
+assign axi_awburst[C_FROM_SYS_CROSSBAR_IDX *2 +: 2]      = s_axi_from_sys_crossbar_awburst;
+assign axi_awcache[C_FROM_SYS_CROSSBAR_IDX *4 +: 4]      = s_axi_from_sys_crossbar_awcache;
+assign axi_awprot [C_FROM_SYS_CROSSBAR_IDX *3 +: 3]      = s_axi_from_sys_crossbar_awprot;
+assign axi_awvalid[C_FROM_SYS_CROSSBAR_IDX *1 +: 1]      = s_axi_from_sys_crossbar_awvalid;
+assign s_axi_from_sys_crossbar_awready                   = axi_awready[C_FROM_SYS_CROSSBAR_IDX *1 +: 1];
+assign axi_wdata  [C_FROM_SYS_CROSSBAR_IDX *512 +: 512]  = s_axi_from_sys_crossbar_wdata;
+assign axi_wstrb  [C_FROM_SYS_CROSSBAR_IDX *64 +: 64]    = s_axi_from_sys_crossbar_wstrb;
+assign axi_wlast  [C_FROM_SYS_CROSSBAR_IDX *1 +: 1]      = s_axi_from_sys_crossbar_wlast;
+assign axi_wvalid [C_FROM_SYS_CROSSBAR_IDX *1 +: 1]      = s_axi_from_sys_crossbar_wvalid;
+assign s_axi_from_sys_crossbar_wready                    = axi_wready[C_FROM_SYS_CROSSBAR_IDX *1 +: 1];
+assign axi_awlock [C_FROM_SYS_CROSSBAR_IDX *1 +: 1]      = s_axi_from_sys_crossbar_awlock;
+assign s_axi_from_sys_crossbar_bid                       = axi_bid[C_FROM_SYS_CROSSBAR_IDX *5 +: 5];
+assign s_axi_from_sys_crossbar_bresp                     = axi_bresp[C_FROM_SYS_CROSSBAR_IDX *2 +: 2];
+assign s_axi_from_sys_crossbar_bvalid                    = axi_bvalid[C_FROM_SYS_CROSSBAR_IDX *1 +: 1];
+assign axi_bready [C_FROM_SYS_CROSSBAR_IDX *1 +: 1]      = s_axi_from_sys_crossbar_bready;
+assign axi_arid   [C_FROM_SYS_CROSSBAR_IDX *5 +: 5]      = s_axi_from_sys_crossbar_arvalid ? s_axi_from_sys_crossbar_arid : 5'd0;
+assign axi_araddr [C_FROM_SYS_CROSSBAR_IDX *64 +: 64]    = s_axi_from_sys_crossbar_araddr;
+assign axi_arlen  [C_FROM_SYS_CROSSBAR_IDX *8  +: 8]     = s_axi_from_sys_crossbar_arlen;
+assign axi_arsize [C_FROM_SYS_CROSSBAR_IDX *3  +: 3]     = s_axi_from_sys_crossbar_arsize;
+assign axi_arburst[C_FROM_SYS_CROSSBAR_IDX *2  +: 2]     = s_axi_from_sys_crossbar_arburst;
+assign axi_arcache[C_FROM_SYS_CROSSBAR_IDX *4  +: 4]     = s_axi_from_sys_crossbar_arcache;
+assign axi_arprot [C_FROM_SYS_CROSSBAR_IDX *3  +: 3]     = s_axi_from_sys_crossbar_arprot;
+assign axi_arvalid[C_FROM_SYS_CROSSBAR_IDX *1  +: 1]     = s_axi_from_sys_crossbar_arvalid;
+assign s_axi_from_sys_crossbar_arready                   = axi_arready[C_FROM_SYS_CROSSBAR_IDX *1 +: 1];
+assign s_axi_from_sys_crossbar_rid                       = axi_rid[C_FROM_SYS_CROSSBAR_IDX *5 +: 5];
+assign s_axi_from_sys_crossbar_rdata                     = axi_rdata[C_FROM_SYS_CROSSBAR_IDX *512 +: 512];
+assign s_axi_from_sys_crossbar_rresp                     = axi_rresp[C_FROM_SYS_CROSSBAR_IDX *2 +: 2];
+assign s_axi_from_sys_crossbar_rlast                     = axi_rlast[C_FROM_SYS_CROSSBAR_IDX *1 +: 1];
+assign s_axi_from_sys_crossbar_rvalid                    = axi_rvalid[C_FROM_SYS_CROSSBAR_IDX *1 +: 1];
+assign axi_rready [C_FROM_SYS_CROSSBAR_IDX *1 +: 1]      = s_axi_from_sys_crossbar_rready;
+assign axi_arlock [C_FROM_SYS_CROSSBAR_IDX *1 +: 1]      = s_axi_from_sys_crossbar_arlock;
+assign axi_arqos  [C_FROM_SYS_CROSSBAR_IDX *4 +: 4]      = s_axi_from_sys_crossbar_arqos;
+
+dev_mem_3to1_axi_crossbar dev_mem_3to1_axi_crossbar_inst (
+  // Master interface only has 4-bit ID width
+  .m_axi_awaddr    (m_axi_dev_mem_awaddr),
+  .m_axi_awprot    (m_axi_dev_mem_awprot),
+  .m_axi_awvalid   (m_axi_dev_mem_awvalid),
+  .m_axi_awready   (m_axi_dev_mem_awready),
+  .m_axi_awsize    (m_axi_dev_mem_awsize),
+  .m_axi_awburst   (m_axi_dev_mem_awburst),
+  .m_axi_awcache   (m_axi_dev_mem_awcache),
+  .m_axi_awlen     (m_axi_dev_mem_awlen),
+  .m_axi_awlock    (m_axi_dev_mem_awlock),
+  .m_axi_awqos     (m_axi_dev_mem_awqos),
+  .m_axi_awregion  (m_axi_dev_mem_awregion),
+  .m_axi_awid      (m_axi_dev_mem_awid),
+  .m_axi_wdata     (m_axi_dev_mem_wdata),
+  .m_axi_wstrb     (m_axi_dev_mem_wstrb),
+  .m_axi_wvalid    (m_axi_dev_mem_wvalid),
+  .m_axi_wready    (m_axi_dev_mem_wready),
+  .m_axi_wlast     (m_axi_dev_mem_wlast),
+  .m_axi_bresp     (m_axi_dev_mem_bresp),
+  .m_axi_bvalid    (m_axi_dev_mem_bvalid),
+  .m_axi_bready    (m_axi_dev_mem_bready),
+  .m_axi_bid       (m_axi_dev_mem_bid),
+  .m_axi_araddr    (m_axi_dev_mem_araddr),
+  .m_axi_arprot    (m_axi_dev_mem_arprot),
+  .m_axi_arvalid   (m_axi_dev_mem_arvalid),
+  .m_axi_arready   (m_axi_dev_mem_arready),
+  .m_axi_arsize    (m_axi_dev_mem_arsize),
+  .m_axi_arburst   (m_axi_dev_mem_arburst),
+  .m_axi_arcache   (m_axi_dev_mem_arcache),
+  .m_axi_arlock    (m_axi_dev_mem_arlock),
+  .m_axi_arlen     (m_axi_dev_mem_arlen),
+  .m_axi_arqos     (m_axi_dev_mem_arqos),
+  .m_axi_arregion  (m_axi_dev_mem_arregion),
+  .m_axi_arid      (m_axi_dev_mem_arid),
+  .m_axi_rdata     (m_axi_dev_mem_rdata),
+  .m_axi_rresp     (m_axi_dev_mem_rresp),
+  .m_axi_rvalid    (m_axi_dev_mem_rvalid),
+  .m_axi_rready    (m_axi_dev_mem_rready),
+  .m_axi_rlast     (m_axi_dev_mem_rlast),
+  .m_axi_rid       (m_axi_dev_mem_rid),
+
+  // Slave interface has 12-bit ID width
+  .s_axi_awid      (axi_awid),
+  .s_axi_awaddr    (axi_awaddr),
+  .s_axi_awqos     (axi_awqos),
+  .s_axi_awlen     (axi_awlen),
+  .s_axi_awsize    (axi_awsize),
+  .s_axi_awburst   (axi_awburst),
+  .s_axi_awcache   (axi_awcache),
+  .s_axi_awprot    (axi_awprot),
+  .s_axi_awvalid   (axi_awvalid),
+  .s_axi_awready   (axi_awready),
+  .s_axi_wdata     (axi_wdata),
+  .s_axi_wstrb     (axi_wstrb),
+  .s_axi_wlast     (axi_wlast),
+  .s_axi_wvalid    (axi_wvalid),
+  .s_axi_wready    (axi_wready),
+  .s_axi_awlock    (axi_awlock),
+  .s_axi_bid       (axi_bid),
+  .s_axi_bresp     (axi_bresp),
+  .s_axi_bvalid    (axi_bvalid),
+  .s_axi_bready    (axi_bready),
+  .s_axi_arid      (axi_arid),
+  .s_axi_araddr    (axi_araddr),
+  .s_axi_arlen     (axi_arlen),
+  .s_axi_arsize    (axi_arsize),
+  .s_axi_arburst   (axi_arburst),
+  .s_axi_arcache   (axi_arcache),
+  .s_axi_arprot    (axi_arprot),
+  .s_axi_arvalid   (axi_arvalid),
+  .s_axi_arready   (axi_arready),
+  .s_axi_rid       (axi_rid),
+  .s_axi_rdata     (axi_rdata),
+  .s_axi_rresp     (axi_rresp),
+  .s_axi_rlast     (axi_rlast),
+  .s_axi_rvalid    (axi_rvalid),
+  .s_axi_rready    (axi_rready),
+  .s_axi_arlock    (axi_arlock),
+  .s_axi_arqos     (axi_arqos),
+
+  .aclk   (axis_aclk),
+  .aresetn(axis_arestn)
+);
+
+endmodule: axi_3to1_interconnect_to_dev_mem
\ No newline at end of file
diff --git a/src/utility/axi_5to2_interconnect_to_sys_mem.sv b/src/utility/axi_5to2_interconnect_to_sys_mem.sv
new file mode 100755
index 0000000..9da1907
--- /dev/null
+++ b/src/utility/axi_5to2_interconnect_to_sys_mem.sv
@@ -0,0 +1,756 @@
+// *************************************************************************
+//
+// Copyright 2022 Xilinx, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// *************************************************************************
+`timescale 1ns/1ps
+
+module axi_5to2_interconnect_to_sys_mem #(
+  parameter C_AXI_DATA_WIDTH = 512,
+  parameter C_AXI_ADDR_WIDTH = 64
+) (
+  input             s_axi_rdma_get_wqe_awid,
+  input    [63 : 0] s_axi_rdma_get_wqe_awaddr,
+  input     [3 : 0] s_axi_rdma_get_wqe_awqos,
+  input     [7 : 0] s_axi_rdma_get_wqe_awlen,
+  input     [2 : 0] s_axi_rdma_get_wqe_awsize,
+  input     [1 : 0] s_axi_rdma_get_wqe_awburst,
+  input     [3 : 0] s_axi_rdma_get_wqe_awcache,
+  input     [2 : 0] s_axi_rdma_get_wqe_awprot,
+  input             s_axi_rdma_get_wqe_awvalid,
+  output            s_axi_rdma_get_wqe_awready,
+  input   [511 : 0] s_axi_rdma_get_wqe_wdata,
+  input    [63 : 0] s_axi_rdma_get_wqe_wstrb,
+  input             s_axi_rdma_get_wqe_wlast,
+  input             s_axi_rdma_get_wqe_wvalid,
+  output            s_axi_rdma_get_wqe_wready,
+  input             s_axi_rdma_get_wqe_awlock,
+  output            s_axi_rdma_get_wqe_bid,
+  output    [1 : 0] s_axi_rdma_get_wqe_bresp,
+  output            s_axi_rdma_get_wqe_bvalid,
+  input             s_axi_rdma_get_wqe_bready,
+  input             s_axi_rdma_get_wqe_arid,
+  input    [63 : 0] s_axi_rdma_get_wqe_araddr,
+  input     [7 : 0] s_axi_rdma_get_wqe_arlen,
+  input     [2 : 0] s_axi_rdma_get_wqe_arsize,
+  input     [1 : 0] s_axi_rdma_get_wqe_arburst,
+  input     [3 : 0] s_axi_rdma_get_wqe_arcache,
+  input     [2 : 0] s_axi_rdma_get_wqe_arprot,
+  input             s_axi_rdma_get_wqe_arvalid,
+  output            s_axi_rdma_get_wqe_arready,
+  output            s_axi_rdma_get_wqe_rid,
+  output  [511 : 0] s_axi_rdma_get_wqe_rdata,
+  output    [1 : 0] s_axi_rdma_get_wqe_rresp,
+  output            s_axi_rdma_get_wqe_rlast,
+  output            s_axi_rdma_get_wqe_rvalid,
+  input             s_axi_rdma_get_wqe_rready,
+  input             s_axi_rdma_get_wqe_arlock,
+  input     [3 : 0] s_axi_rdma_get_wqe_arqos,
+
+  input             s_axi_rdma_get_payload_awid,
+  input    [63 : 0] s_axi_rdma_get_payload_awaddr,
+  input     [3 : 0] s_axi_rdma_get_payload_awqos,
+  input     [7 : 0] s_axi_rdma_get_payload_awlen,
+  input     [2 : 0] s_axi_rdma_get_payload_awsize,
+  input     [1 : 0] s_axi_rdma_get_payload_awburst,
+  input     [3 : 0] s_axi_rdma_get_payload_awcache,
+  input     [2 : 0] s_axi_rdma_get_payload_awprot,
+  input             s_axi_rdma_get_payload_awvalid,
+  output            s_axi_rdma_get_payload_awready,
+  input   [511 : 0] s_axi_rdma_get_payload_wdata,
+  input    [63 : 0] s_axi_rdma_get_payload_wstrb,
+  input             s_axi_rdma_get_payload_wlast,
+  input             s_axi_rdma_get_payload_wvalid,
+  output            s_axi_rdma_get_payload_wready,
+  input             s_axi_rdma_get_payload_awlock,
+  output            s_axi_rdma_get_payload_bid,
+  output    [1 : 0] s_axi_rdma_get_payload_bresp,
+  output            s_axi_rdma_get_payload_bvalid,
+  input             s_axi_rdma_get_payload_bready,
+  input             s_axi_rdma_get_payload_arid,
+  input    [63 : 0] s_axi_rdma_get_payload_araddr,
+  input     [7 : 0] s_axi_rdma_get_payload_arlen,
+  input     [2 : 0] s_axi_rdma_get_payload_arsize,
+  input     [1 : 0] s_axi_rdma_get_payload_arburst,
+  input     [3 : 0] s_axi_rdma_get_payload_arcache,
+  input     [2 : 0] s_axi_rdma_get_payload_arprot,
+  input             s_axi_rdma_get_payload_arvalid,
+  output            s_axi_rdma_get_payload_arready,
+  output            s_axi_rdma_get_payload_rid,
+  output  [511 : 0] s_axi_rdma_get_payload_rdata,
+  output    [1 : 0] s_axi_rdma_get_payload_rresp,
+  output            s_axi_rdma_get_payload_rlast,
+  output            s_axi_rdma_get_payload_rvalid,
+  input             s_axi_rdma_get_payload_rready,
+  input             s_axi_rdma_get_payload_arlock,
+  input     [3 : 0] s_axi_rdma_get_payload_arqos,
+
+  input             s_axi_rdma_completion_awid,
+  input    [63 : 0] s_axi_rdma_completion_awaddr,
+  input     [3 : 0] s_axi_rdma_completion_awqos,
+  input     [7 : 0] s_axi_rdma_completion_awlen,
+  input     [2 : 0] s_axi_rdma_completion_awsize,
+  input     [1 : 0] s_axi_rdma_completion_awburst,
+  input     [3 : 0] s_axi_rdma_completion_awcache,
+  input     [2 : 0] s_axi_rdma_completion_awprot,
+  input             s_axi_rdma_completion_awvalid,
+  output            s_axi_rdma_completion_awready,
+  input   [511 : 0] s_axi_rdma_completion_wdata,
+  input    [63 : 0] s_axi_rdma_completion_wstrb,
+  input             s_axi_rdma_completion_wlast,
+  input             s_axi_rdma_completion_wvalid,
+  output            s_axi_rdma_completion_wready,
+  input             s_axi_rdma_completion_awlock,
+  output            s_axi_rdma_completion_bid,
+  output    [1 : 0] s_axi_rdma_completion_bresp,
+  output            s_axi_rdma_completion_bvalid,
+  input             s_axi_rdma_completion_bready,
+  input             s_axi_rdma_completion_arid,
+  input    [63 : 0] s_axi_rdma_completion_araddr,
+  input     [7 : 0] s_axi_rdma_completion_arlen,
+  input     [2 : 0] s_axi_rdma_completion_arsize,
+  input     [1 : 0] s_axi_rdma_completion_arburst,
+  input     [3 : 0] s_axi_rdma_completion_arcache,
+  input     [2 : 0] s_axi_rdma_completion_arprot,
+  input             s_axi_rdma_completion_arvalid,
+  output            s_axi_rdma_completion_arready,
+  output            s_axi_rdma_completion_rid,
+  output  [511 : 0] s_axi_rdma_completion_rdata,
+  output    [1 : 0] s_axi_rdma_completion_rresp,
+  output            s_axi_rdma_completion_rlast,
+  output            s_axi_rdma_completion_rvalid,
+  input             s_axi_rdma_completion_rready,
+  input             s_axi_rdma_completion_arlock,
+  input     [3 : 0] s_axi_rdma_completion_arqos,
+
+  input             s_axi_rdma_send_write_payload_awid,
+  input    [63 : 0] s_axi_rdma_send_write_payload_awaddr,
+  input     [3 : 0] s_axi_rdma_send_write_payload_awqos,
+  input     [7 : 0] s_axi_rdma_send_write_payload_awlen,
+  input     [2 : 0] s_axi_rdma_send_write_payload_awsize,
+  input     [1 : 0] s_axi_rdma_send_write_payload_awburst,
+  input     [3 : 0] s_axi_rdma_send_write_payload_awcache,
+  input     [2 : 0] s_axi_rdma_send_write_payload_awprot,
+  input             s_axi_rdma_send_write_payload_awvalid,
+  output            s_axi_rdma_send_write_payload_awready,
+  input   [511 : 0] s_axi_rdma_send_write_payload_wdata,
+  input    [63 : 0] s_axi_rdma_send_write_payload_wstrb,
+  input             s_axi_rdma_send_write_payload_wlast,
+  input             s_axi_rdma_send_write_payload_wvalid,
+  output            s_axi_rdma_send_write_payload_wready,
+  input             s_axi_rdma_send_write_payload_awlock,
+  output            s_axi_rdma_send_write_payload_bid,
+  output    [1 : 0] s_axi_rdma_send_write_payload_bresp,
+  output            s_axi_rdma_send_write_payload_bvalid,
+  input             s_axi_rdma_send_write_payload_bready,
+  input             s_axi_rdma_send_write_payload_arid,
+  input    [63 : 0] s_axi_rdma_send_write_payload_araddr,
+  input     [7 : 0] s_axi_rdma_send_write_payload_arlen,
+  input     [2 : 0] s_axi_rdma_send_write_payload_arsize,
+  input     [1 : 0] s_axi_rdma_send_write_payload_arburst,
+  input     [3 : 0] s_axi_rdma_send_write_payload_arcache,
+  input     [2 : 0] s_axi_rdma_send_write_payload_arprot,
+  input             s_axi_rdma_send_write_payload_arvalid,
+  output            s_axi_rdma_send_write_payload_arready,
+  output            s_axi_rdma_send_write_payload_rid,
+  output  [511 : 0] s_axi_rdma_send_write_payload_rdata,
+  output    [1 : 0] s_axi_rdma_send_write_payload_rresp,
+  output            s_axi_rdma_send_write_payload_rlast,
+  output            s_axi_rdma_send_write_payload_rvalid,
+  input             s_axi_rdma_send_write_payload_rready,
+  input             s_axi_rdma_send_write_payload_arlock,
+  input     [3 : 0] s_axi_rdma_send_write_payload_arqos,
+
+  input             s_axi_rdma_rsp_payload_awid,
+  input    [63 : 0] s_axi_rdma_rsp_payload_awaddr,
+  input     [3 : 0] s_axi_rdma_rsp_payload_awqos,
+  input     [7 : 0] s_axi_rdma_rsp_payload_awlen,
+  input     [2 : 0] s_axi_rdma_rsp_payload_awsize,
+  input     [1 : 0] s_axi_rdma_rsp_payload_awburst,
+  input     [3 : 0] s_axi_rdma_rsp_payload_awcache,
+  input     [2 : 0] s_axi_rdma_rsp_payload_awprot,
+  input             s_axi_rdma_rsp_payload_awvalid,
+  output            s_axi_rdma_rsp_payload_awready,
+  input   [511 : 0] s_axi_rdma_rsp_payload_wdata,
+  input    [63 : 0] s_axi_rdma_rsp_payload_wstrb,
+  input             s_axi_rdma_rsp_payload_wlast,
+  input             s_axi_rdma_rsp_payload_wvalid,
+  output            s_axi_rdma_rsp_payload_wready,
+  input             s_axi_rdma_rsp_payload_awlock,
+  output            s_axi_rdma_rsp_payload_bid,
+  output    [1 : 0] s_axi_rdma_rsp_payload_bresp,
+  output            s_axi_rdma_rsp_payload_bvalid,
+  input             s_axi_rdma_rsp_payload_bready,
+  input             s_axi_rdma_rsp_payload_arid,
+  input    [63 : 0] s_axi_rdma_rsp_payload_araddr,
+  input     [7 : 0] s_axi_rdma_rsp_payload_arlen,
+  input     [2 : 0] s_axi_rdma_rsp_payload_arsize,
+  input     [1 : 0] s_axi_rdma_rsp_payload_arburst,
+  input     [3 : 0] s_axi_rdma_rsp_payload_arcache,
+  input     [2 : 0] s_axi_rdma_rsp_payload_arprot,
+  input             s_axi_rdma_rsp_payload_arvalid,
+  output            s_axi_rdma_rsp_payload_arready,
+  output            s_axi_rdma_rsp_payload_rid,
+  output  [511 : 0] s_axi_rdma_rsp_payload_rdata,
+  output    [1 : 0] s_axi_rdma_rsp_payload_rresp,
+  output            s_axi_rdma_rsp_payload_rlast,
+  output            s_axi_rdma_rsp_payload_rvalid,
+  input             s_axi_rdma_rsp_payload_rready,
+  input             s_axi_rdma_rsp_payload_arlock,
+  input     [3 : 0] s_axi_rdma_rsp_payload_arqos,
+
+  output      [2:0] m_axi_sys_mem_awid,
+  output     [63:0] m_axi_sys_mem_awaddr,
+  output      [7:0] m_axi_sys_mem_awlen,
+  output      [2:0] m_axi_sys_mem_awsize,
+  output      [1:0] m_axi_sys_mem_awburst,
+  output            m_axi_sys_mem_awlock,
+  output      [3:0] m_axi_sys_mem_awqos,
+  output      [3:0] m_axi_sys_mem_awregion,
+  output      [3:0] m_axi_sys_mem_awcache,
+  output      [2:0] m_axi_sys_mem_awprot,
+  output            m_axi_sys_mem_awvalid,
+  input             m_axi_sys_mem_awready,
+  output    [511:0] m_axi_sys_mem_wdata,
+  output     [63:0] m_axi_sys_mem_wstrb,
+  output            m_axi_sys_mem_wlast,
+  output            m_axi_sys_mem_wvalid,
+  input             m_axi_sys_mem_wready,
+  input       [2:0] m_axi_sys_mem_bid,
+  input       [1:0] m_axi_sys_mem_bresp,
+  input             m_axi_sys_mem_bvalid,
+  output            m_axi_sys_mem_bready,
+  output      [2:0] m_axi_sys_mem_arid,
+  output     [63:0] m_axi_sys_mem_araddr,
+  output      [7:0] m_axi_sys_mem_arlen,
+  output      [2:0] m_axi_sys_mem_arsize,
+  output      [1:0] m_axi_sys_mem_arburst,
+  output            m_axi_sys_mem_arlock,
+  output      [3:0] m_axi_sys_mem_arqos,
+  output      [3:0] m_axi_sys_mem_arregion,
+  output      [3:0] m_axi_sys_mem_arcache,
+  output      [2:0] m_axi_sys_mem_arprot,
+  output            m_axi_sys_mem_arvalid,
+  input             m_axi_sys_mem_arready,
+  input       [2:0] m_axi_sys_mem_rid,
+  input     [511:0] m_axi_sys_mem_rdata,
+  input       [1:0] m_axi_sys_mem_rresp,
+  input             m_axi_sys_mem_rlast,
+  input             m_axi_sys_mem_rvalid,
+  output            m_axi_sys_mem_rready,
+
+  output      [2:0] m_axi_sys_to_dev_crossbar_awid,
+  output     [63:0] m_axi_sys_to_dev_crossbar_awaddr,
+  output      [7:0] m_axi_sys_to_dev_crossbar_awlen,
+  output      [2:0] m_axi_sys_to_dev_crossbar_awsize,
+  output      [1:0] m_axi_sys_to_dev_crossbar_awburst,
+  output            m_axi_sys_to_dev_crossbar_awlock,
+  output      [3:0] m_axi_sys_to_dev_crossbar_awqos,
+  output      [3:0] m_axi_sys_to_dev_crossbar_awregion,
+  output      [3:0] m_axi_sys_to_dev_crossbar_awcache,
+  output      [2:0] m_axi_sys_to_dev_crossbar_awprot,
+  output            m_axi_sys_to_dev_crossbar_awvalid,
+  input             m_axi_sys_to_dev_crossbar_awready,
+  output    [511:0] m_axi_sys_to_dev_crossbar_wdata,
+  output     [63:0] m_axi_sys_to_dev_crossbar_wstrb,
+  output            m_axi_sys_to_dev_crossbar_wlast,
+  output            m_axi_sys_to_dev_crossbar_wvalid,
+  input             m_axi_sys_to_dev_crossbar_wready,
+  input       [2:0]  m_axi_sys_to_dev_crossbar_bid,
+  input       [1:0] m_axi_sys_to_dev_crossbar_bresp,
+  input             m_axi_sys_to_dev_crossbar_bvalid,
+  output            m_axi_sys_to_dev_crossbar_bready,
+  output      [2:0]   m_axi_sys_to_dev_crossbar_arid,
+  output     [63:0] m_axi_sys_to_dev_crossbar_araddr,
+  output      [7:0] m_axi_sys_to_dev_crossbar_arlen,
+  output      [2:0] m_axi_sys_to_dev_crossbar_arsize,
+  output      [1:0] m_axi_sys_to_dev_crossbar_arburst,
+  output            m_axi_sys_to_dev_crossbar_arlock,
+  output      [3:0] m_axi_sys_to_dev_crossbar_arqos,
+  output      [3:0] m_axi_sys_to_dev_crossbar_arregion,
+  output      [3:0] m_axi_sys_to_dev_crossbar_arcache,
+  output      [2:0] m_axi_sys_to_dev_crossbar_arprot,
+  output            m_axi_sys_to_dev_crossbar_arvalid,
+  input             m_axi_sys_to_dev_crossbar_arready,
+  input       [2:0] m_axi_sys_to_dev_crossbar_rid,
+  input     [511:0] m_axi_sys_to_dev_crossbar_rdata,
+  input       [1:0] m_axi_sys_to_dev_crossbar_rresp,
+  input             m_axi_sys_to_dev_crossbar_rlast,
+  input             m_axi_sys_to_dev_crossbar_rvalid,
+  output            m_axi_sys_to_dev_crossbar_rready,
+
+  input axis_aclk,
+  input axis_arestn
+);
+
+localparam C_NUM_MASTERS = 5;
+localparam C_NUM_SLAVES = 2;
+
+
+localparam C_RDMA_GET_WQE_IDX     = 0;
+localparam C_RDMA_GET_PAYLOAD_IDX = 1;
+localparam C_RDMA_COMPLETION_IDX  = 2;
+localparam C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX = 3;
+localparam C_RDMA_RSP_PAYLOAD_IDX = 4;
+
+localparam C_SYS_MEM_IDX     = 0;
+localparam C_SYS_TO_DEV_CROSSBAR_IDX = 1;
+
+logic   [C_NUM_MASTERS*3-1 : 0] s_axi_awid;
+logic  [C_NUM_MASTERS*64-1 : 0] s_axi_awaddr;
+logic   [C_NUM_MASTERS*8-1 : 0] s_axi_awlen;
+logic   [C_NUM_MASTERS*3-1 : 0] s_axi_awsize;
+logic   [C_NUM_MASTERS*2-1 : 0] s_axi_awburst;
+logic     [C_NUM_MASTERS-1 : 0] s_axi_awlock;
+logic   [C_NUM_MASTERS*4-1 : 0] s_axi_awcache;
+logic   [C_NUM_MASTERS*3-1 : 0] s_axi_awprot;
+logic   [C_NUM_MASTERS*4-1 : 0] s_axi_awqos;
+logic     [C_NUM_MASTERS-1 : 0] s_axi_awvalid;
+logic     [C_NUM_MASTERS-1 : 0] s_axi_awready;
+logic [C_NUM_MASTERS*512-1 : 0] s_axi_wdata;
+logic  [C_NUM_MASTERS*64-1 : 0] s_axi_wstrb;
+logic     [C_NUM_MASTERS-1 : 0] s_axi_wlast;
+logic     [C_NUM_MASTERS-1 : 0] s_axi_wvalid;
+logic     [C_NUM_MASTERS-1 : 0] s_axi_wready;
+logic   [C_NUM_MASTERS*3-1 : 0] s_axi_bid;
+logic   [C_NUM_MASTERS*2-1 : 0] s_axi_bresp;
+logic     [C_NUM_MASTERS-1 : 0] s_axi_bvalid;
+logic     [C_NUM_MASTERS-1 : 0] s_axi_bready;
+logic   [C_NUM_MASTERS*3-1 : 0] s_axi_arid;
+logic  [C_NUM_MASTERS*64-1 : 0] s_axi_araddr;
+logic   [C_NUM_MASTERS*8-1 : 0] s_axi_arlen;
+logic   [C_NUM_MASTERS*3-1 : 0] s_axi_arsize;
+logic   [C_NUM_MASTERS*2-1 : 0] s_axi_arburst;
+logic     [C_NUM_MASTERS-1 : 0] s_axi_arlock;
+logic   [C_NUM_MASTERS*4-1 : 0] s_axi_arcache;
+logic   [C_NUM_MASTERS*3-1 : 0] s_axi_arprot;
+logic   [C_NUM_MASTERS*4-1 : 0] s_axi_arqos;
+logic     [C_NUM_MASTERS-1 : 0] s_axi_arvalid;
+logic     [C_NUM_MASTERS-1 : 0] s_axi_arready;
+logic   [C_NUM_MASTERS*3-1 : 0] s_axi_rid;
+logic [C_NUM_MASTERS*512-1 : 0] s_axi_rdata;
+logic   [C_NUM_MASTERS*2-1 : 0] s_axi_rresp;
+logic     [C_NUM_MASTERS-1 : 0] s_axi_rlast;
+logic     [C_NUM_MASTERS-1 : 0] s_axi_rvalid;
+logic     [C_NUM_MASTERS-1 : 0] s_axi_rready;
+
+logic   [C_NUM_SLAVES*3-1 : 0] m_axi_awid;
+logic  [C_NUM_SLAVES*64-1 : 0] m_axi_awaddr;
+logic   [C_NUM_SLAVES*8-1 : 0] m_axi_awlen;
+logic   [C_NUM_SLAVES*3-1 : 0] m_axi_awsize;
+logic   [C_NUM_SLAVES*2-1 : 0] m_axi_awburst;
+logic     [C_NUM_SLAVES-1 : 0] m_axi_awlock;
+logic   [C_NUM_SLAVES*4-1 : 0] m_axi_awcache;
+logic   [C_NUM_SLAVES*3-1 : 0] m_axi_awprot;
+logic   [C_NUM_SLAVES*4-1 : 0] m_axi_awqos;
+logic     [C_NUM_SLAVES-1 : 0] m_axi_awvalid;
+logic     [C_NUM_SLAVES-1 : 0] m_axi_awready;
+logic [C_NUM_SLAVES*512-1 : 0] m_axi_wdata;
+logic  [C_NUM_SLAVES*64-1 : 0] m_axi_wstrb;
+logic     [C_NUM_SLAVES-1 : 0] m_axi_wlast;
+logic     [C_NUM_SLAVES-1 : 0] m_axi_wvalid;
+logic     [C_NUM_SLAVES-1 : 0] m_axi_wready;
+logic   [C_NUM_SLAVES*3-1 : 0] m_axi_bid;
+logic   [C_NUM_SLAVES*2-1 : 0] m_axi_bresp;
+logic     [C_NUM_SLAVES-1 : 0] m_axi_bvalid;
+logic     [C_NUM_SLAVES-1 : 0] m_axi_bready;
+logic   [C_NUM_SLAVES*3-1 : 0] m_axi_arid;
+logic  [C_NUM_SLAVES*64-1 : 0] m_axi_araddr;
+logic   [C_NUM_SLAVES*8-1 : 0] m_axi_arlen;
+logic   [C_NUM_SLAVES*3-1 : 0] m_axi_arsize;
+logic   [C_NUM_SLAVES*2-1 : 0] m_axi_arburst;
+logic     [C_NUM_SLAVES-1 : 0] m_axi_arlock;
+logic   [C_NUM_SLAVES*4-1 : 0] m_axi_arcache;
+logic   [C_NUM_SLAVES*3-1 : 0] m_axi_arprot;
+logic   [C_NUM_SLAVES*4-1 : 0] m_axi_arqos;
+logic     [C_NUM_SLAVES-1 : 0] m_axi_arvalid;
+logic     [C_NUM_SLAVES-1 : 0] m_axi_arready;
+logic   [C_NUM_SLAVES*3-1 : 0] m_axi_rid;
+logic [C_NUM_SLAVES*512-1 : 0] m_axi_rdata;
+logic   [C_NUM_SLAVES*2-1 : 0] m_axi_rresp;
+logic     [C_NUM_SLAVES-1 : 0] m_axi_rlast;
+logic     [C_NUM_SLAVES-1 : 0] m_axi_rvalid;
+logic     [C_NUM_SLAVES-1 : 0] m_axi_rready;
+
+// AXI slave signals for getting wqe from system memory
+//assign s_axi_awid   [C_RDMA_GET_WQE_IDX *2 +: 2]         = {1'b0, s_axi_rdma_get_wqe_awid};
+assign s_axi_awid   [C_RDMA_GET_WQE_IDX *3 +: 3]         = s_axi_rdma_get_wqe_awvalid ? 3'd0 : 3'd0;
+assign s_axi_awaddr [C_RDMA_GET_WQE_IDX *64 +: 64]       = s_axi_rdma_get_wqe_awaddr;
+assign s_axi_awqos  [C_RDMA_GET_WQE_IDX *4 +: 4]         = s_axi_rdma_get_wqe_awqos;
+assign s_axi_awlen  [C_RDMA_GET_WQE_IDX *8 +: 8]         = s_axi_rdma_get_wqe_awlen;
+assign s_axi_awsize [C_RDMA_GET_WQE_IDX *3 +: 3]         = s_axi_rdma_get_wqe_awsize;
+assign s_axi_awburst[C_RDMA_GET_WQE_IDX *2 +: 2]         = s_axi_rdma_get_wqe_awburst;
+assign s_axi_awcache[C_RDMA_GET_WQE_IDX *4 +: 4]         = s_axi_rdma_get_wqe_awcache;
+assign s_axi_awprot [C_RDMA_GET_WQE_IDX *3 +: 3]         = s_axi_rdma_get_wqe_awprot;
+assign s_axi_awvalid[C_RDMA_GET_WQE_IDX *1 +: 1]         = s_axi_rdma_get_wqe_awvalid;
+assign s_axi_rdma_get_wqe_awready                        = s_axi_awready[C_RDMA_GET_WQE_IDX *1 +: 1];
+assign s_axi_wdata  [C_RDMA_GET_WQE_IDX *512 +: 512]     = s_axi_rdma_get_wqe_wdata;
+assign s_axi_wstrb  [C_RDMA_GET_WQE_IDX *64 +: 64]       = s_axi_rdma_get_wqe_wstrb;
+assign s_axi_wlast  [C_RDMA_GET_WQE_IDX *1 +: 1]         = s_axi_rdma_get_wqe_wlast;
+assign s_axi_wvalid [C_RDMA_GET_WQE_IDX *1 +: 1]         = s_axi_rdma_get_wqe_wvalid;
+assign s_axi_rdma_get_wqe_wready                         = s_axi_wready[C_RDMA_GET_WQE_IDX *1 +: 1];
+assign s_axi_awlock [C_RDMA_GET_WQE_IDX *1 +: 1]         = s_axi_rdma_get_wqe_awlock;
+assign s_axi_rdma_get_wqe_bid                            = s_axi_bid[C_RDMA_GET_WQE_IDX *3 +: 1];
+assign s_axi_rdma_get_wqe_bresp                          = s_axi_bresp[C_RDMA_GET_WQE_IDX *2 +: 2];
+assign s_axi_rdma_get_wqe_bvalid                         = s_axi_bvalid[C_RDMA_GET_WQE_IDX *1 +: 1];
+assign s_axi_bready [C_RDMA_GET_WQE_IDX *1 +: 1]         = s_axi_rdma_get_wqe_bready;
+//assign s_axi_arid   [C_RDMA_GET_WQE_IDX *2 +: 2]         = {1'b0, s_axi_rdma_get_wqe_arid};
+assign s_axi_arid   [C_RDMA_GET_WQE_IDX *3 +: 3]         = s_axi_rdma_get_wqe_arvalid ? 3'd0 : 3'd0;
+assign s_axi_araddr [C_RDMA_GET_WQE_IDX *64 +: 64]       = s_axi_rdma_get_wqe_araddr;
+assign s_axi_arlen  [C_RDMA_GET_WQE_IDX *8  +: 8]        = s_axi_rdma_get_wqe_arlen;
+assign s_axi_arsize [C_RDMA_GET_WQE_IDX *3  +: 3]        = s_axi_rdma_get_wqe_arsize;
+assign s_axi_arburst[C_RDMA_GET_WQE_IDX *2  +: 2]        = s_axi_rdma_get_wqe_arburst;
+assign s_axi_arcache[C_RDMA_GET_WQE_IDX *4  +: 4]        = s_axi_rdma_get_wqe_arcache;
+assign s_axi_arprot [C_RDMA_GET_WQE_IDX *3  +: 3]        = s_axi_rdma_get_wqe_arprot;
+assign s_axi_arvalid[C_RDMA_GET_WQE_IDX *1  +: 1]        = s_axi_rdma_get_wqe_arvalid;
+assign s_axi_rdma_get_wqe_arready                        = s_axi_arready[C_RDMA_GET_WQE_IDX *1 +: 1];
+assign s_axi_rdma_get_wqe_rid                            = s_axi_rid[C_RDMA_GET_WQE_IDX *3 +: 1];
+assign s_axi_rdma_get_wqe_rdata                          = s_axi_rdata[C_RDMA_GET_WQE_IDX *512 +: 512];
+assign s_axi_rdma_get_wqe_rresp                          = s_axi_rresp[C_RDMA_GET_WQE_IDX *2 +: 2];
+assign s_axi_rdma_get_wqe_rlast                          = s_axi_rlast[C_RDMA_GET_WQE_IDX *1 +: 1];
+assign s_axi_rdma_get_wqe_rvalid                         = s_axi_rvalid[C_RDMA_GET_WQE_IDX *1 +: 1];
+assign s_axi_rready [C_RDMA_GET_WQE_IDX *1 +: 1]         = s_axi_rdma_get_wqe_rready;
+assign s_axi_arlock [C_RDMA_GET_WQE_IDX *1 +: 1]         = s_axi_rdma_get_wqe_arlock;
+assign s_axi_arqos  [C_RDMA_GET_WQE_IDX *4 +: 4]         = s_axi_rdma_get_wqe_arqos;
+
+// AXI slave signals for getting payload from system memory
+//assign axi_awid   [C_RDMA_GET_PAYLOAD_IDX*2 +: 2]      = {1'b0, s_axi_rdma_get_payload_awid};
+assign s_axi_awid   [C_RDMA_GET_PAYLOAD_IDX*3 +: 3]      = s_axi_rdma_get_payload_awvalid ? 3'd1 : 3'd0;
+assign s_axi_awaddr [C_RDMA_GET_PAYLOAD_IDX *64 +: 64]   = s_axi_rdma_get_payload_awaddr;
+assign s_axi_awqos  [C_RDMA_GET_PAYLOAD_IDX *4 +: 4]     = s_axi_rdma_get_payload_awqos;
+assign s_axi_awlen  [C_RDMA_GET_PAYLOAD_IDX *8 +: 8]     = s_axi_rdma_get_payload_awlen;
+assign s_axi_awsize [C_RDMA_GET_PAYLOAD_IDX *3 +: 3]     = s_axi_rdma_get_payload_awsize;
+assign s_axi_awburst[C_RDMA_GET_PAYLOAD_IDX *2 +: 2]     = s_axi_rdma_get_payload_awburst;
+assign s_axi_awcache[C_RDMA_GET_PAYLOAD_IDX *4 +: 4]     = s_axi_rdma_get_payload_awcache;
+assign s_axi_awprot [C_RDMA_GET_PAYLOAD_IDX *3 +: 3]     = s_axi_rdma_get_payload_awprot;
+assign s_axi_awvalid[C_RDMA_GET_PAYLOAD_IDX *1 +: 1]     = s_axi_rdma_get_payload_awvalid;
+assign s_axi_rdma_get_payload_awready                    = s_axi_awready[C_RDMA_GET_PAYLOAD_IDX *1 +: 1];
+assign s_axi_wdata  [C_RDMA_GET_PAYLOAD_IDX *512 +: 512] = s_axi_rdma_get_payload_wdata;
+assign s_axi_wstrb  [C_RDMA_GET_PAYLOAD_IDX *64 +: 64]   = s_axi_rdma_get_payload_wstrb;
+assign s_axi_wlast  [C_RDMA_GET_PAYLOAD_IDX *1 +: 1]     = s_axi_rdma_get_payload_wlast;
+assign s_axi_wvalid [C_RDMA_GET_PAYLOAD_IDX *1 +: 1]     = s_axi_rdma_get_payload_wvalid;
+assign s_axi_rdma_get_payload_wready                     = s_axi_wready[C_RDMA_GET_PAYLOAD_IDX *1 +: 1];
+assign s_axi_awlock [C_RDMA_GET_PAYLOAD_IDX *1 +: 1]     = s_axi_rdma_get_payload_awlock;
+assign s_axi_rdma_get_payload_bid                        = s_axi_bid[C_RDMA_GET_PAYLOAD_IDX *3 +: 1];
+assign s_axi_rdma_get_payload_bresp                      = s_axi_bresp[C_RDMA_GET_PAYLOAD_IDX *2 +: 2];
+assign s_axi_rdma_get_payload_bvalid                     = s_axi_bvalid[C_RDMA_GET_PAYLOAD_IDX *1 +: 1];
+assign s_axi_bready [C_RDMA_GET_PAYLOAD_IDX *1 +: 1]     = s_axi_rdma_get_payload_bready;
+//assign s_axi_arid   [C_RDMA_GET_PAYLOAD_IDX *2 +: 2]     = {1'b0, s_axi_rdma_get_payload_arid};
+assign s_axi_arid   [C_RDMA_GET_PAYLOAD_IDX *3 +: 3]     = s_axi_rdma_get_payload_arvalid ? 3'd1: 3'd0;
+assign s_axi_araddr [C_RDMA_GET_PAYLOAD_IDX *64 +: 64]   = s_axi_rdma_get_payload_araddr;
+assign s_axi_arlen  [C_RDMA_GET_PAYLOAD_IDX *8  +: 8]    = s_axi_rdma_get_payload_arlen;
+assign s_axi_arsize [C_RDMA_GET_PAYLOAD_IDX *3  +: 3]    = s_axi_rdma_get_payload_arsize;
+assign s_axi_arburst[C_RDMA_GET_PAYLOAD_IDX *2  +: 2]    = s_axi_rdma_get_payload_arburst;
+assign s_axi_arcache[C_RDMA_GET_PAYLOAD_IDX *4  +: 4]    = s_axi_rdma_get_payload_arcache;
+assign s_axi_arprot [C_RDMA_GET_PAYLOAD_IDX *3  +: 3]    = s_axi_rdma_get_payload_arprot;
+assign s_axi_arvalid[C_RDMA_GET_PAYLOAD_IDX *1  +: 1]    = s_axi_rdma_get_payload_arvalid;
+assign s_axi_rdma_get_payload_arready                    = s_axi_arready[C_RDMA_GET_PAYLOAD_IDX *1 +: 1];
+assign s_axi_rdma_get_payload_rid                        = s_axi_rid[C_RDMA_GET_PAYLOAD_IDX *3 +: 1];
+assign s_axi_rdma_get_payload_rdata                      = s_axi_rdata[C_RDMA_GET_PAYLOAD_IDX *512 +: 512];
+assign s_axi_rdma_get_payload_rresp                      = s_axi_rresp[C_RDMA_GET_PAYLOAD_IDX *2 +: 2];
+assign s_axi_rdma_get_payload_rlast                      = s_axi_rlast[C_RDMA_GET_PAYLOAD_IDX *1 +: 1];
+assign s_axi_rdma_get_payload_rvalid                     = s_axi_rvalid[C_RDMA_GET_PAYLOAD_IDX *1 +: 1];
+assign s_axi_rready [C_RDMA_GET_PAYLOAD_IDX *1 +: 1]     = s_axi_rdma_get_payload_rready;
+assign s_axi_arlock [C_RDMA_GET_PAYLOAD_IDX *1 +: 1]     = s_axi_rdma_get_payload_arlock;
+assign s_axi_arqos  [C_RDMA_GET_PAYLOAD_IDX *4 +: 4]     = s_axi_rdma_get_payload_arqos;
+
+// AXI slave signals for data access from qdma mm channel
+//assign axi_awid   [C_RDMA_COMPLETION_IDX*2 +: 2]       = {1'b0, s_axi_rdma_completion_awid};
+assign s_axi_awid   [C_RDMA_COMPLETION_IDX*3 +: 3]       = s_axi_rdma_completion_awvalid ? 3'd2 : 3'd0;
+assign s_axi_awaddr [C_RDMA_COMPLETION_IDX *64 +: 64]    = s_axi_rdma_completion_awaddr;
+assign s_axi_awqos  [C_RDMA_COMPLETION_IDX *4 +: 4]      = s_axi_rdma_completion_awqos;
+assign s_axi_awlen  [C_RDMA_COMPLETION_IDX *8 +: 8]      = s_axi_rdma_completion_awlen;
+assign s_axi_awsize [C_RDMA_COMPLETION_IDX *3 +: 3]      = s_axi_rdma_completion_awsize;
+assign s_axi_awburst[C_RDMA_COMPLETION_IDX *2 +: 2]      = s_axi_rdma_completion_awburst;
+assign s_axi_awcache[C_RDMA_COMPLETION_IDX *4 +: 4]      = s_axi_rdma_completion_awcache;
+assign s_axi_awprot [C_RDMA_COMPLETION_IDX *3 +: 3]      = s_axi_rdma_completion_awprot;
+assign s_axi_awvalid[C_RDMA_COMPLETION_IDX *1 +: 1]      = s_axi_rdma_completion_awvalid;
+assign s_axi_rdma_completion_awready                     = s_axi_awready[C_RDMA_COMPLETION_IDX *1 +: 1];
+assign s_axi_wdata  [C_RDMA_COMPLETION_IDX *512 +: 512]  = s_axi_rdma_completion_wdata;
+assign s_axi_wstrb  [C_RDMA_COMPLETION_IDX *64 +: 64]    = s_axi_rdma_completion_wstrb;
+assign s_axi_wlast  [C_RDMA_COMPLETION_IDX *1 +: 1]      = s_axi_rdma_completion_wlast;
+assign s_axi_wvalid [C_RDMA_COMPLETION_IDX *1 +: 1]      = s_axi_rdma_completion_wvalid;
+assign s_axi_rdma_completion_wready                      = s_axi_wready[C_RDMA_COMPLETION_IDX *1 +: 1];
+assign s_axi_awlock [C_RDMA_COMPLETION_IDX *1 +: 1]      = s_axi_rdma_completion_awlock;
+assign s_axi_rdma_completion_bid                         = s_axi_bid[C_RDMA_COMPLETION_IDX *3 +: 1];
+assign s_axi_rdma_completion_bresp                       = s_axi_bresp[C_RDMA_COMPLETION_IDX *2 +: 2];
+assign s_axi_rdma_completion_bvalid                      = s_axi_bvalid[C_RDMA_COMPLETION_IDX *1 +: 1];
+assign s_axi_bready [C_RDMA_COMPLETION_IDX *1 +: 1]      = s_axi_rdma_completion_bready;
+//assign s_axi_arid   [C_RDMA_COMPLETION_IDX *2 +: 2]      = {1'b0, s_axi_rdma_completion_arid};
+assign s_axi_arid   [C_RDMA_COMPLETION_IDX *3 +: 3]      = s_axi_rdma_completion_arvalid ? 3'd2 : 3'd0;
+assign s_axi_araddr [C_RDMA_COMPLETION_IDX *64 +: 64]    = s_axi_rdma_completion_araddr;
+assign s_axi_arlen  [C_RDMA_COMPLETION_IDX *8  +: 8]     = s_axi_rdma_completion_arlen;
+assign s_axi_arsize [C_RDMA_COMPLETION_IDX *3  +: 3]     = s_axi_rdma_completion_arsize;
+assign s_axi_arburst[C_RDMA_COMPLETION_IDX *2  +: 2]     = s_axi_rdma_completion_arburst;
+assign s_axi_arcache[C_RDMA_COMPLETION_IDX *4  +: 4]     = s_axi_rdma_completion_arcache;
+assign s_axi_arprot [C_RDMA_COMPLETION_IDX *3  +: 3]     = s_axi_rdma_completion_arprot;
+assign s_axi_arvalid[C_RDMA_COMPLETION_IDX *1  +: 1]     = s_axi_rdma_completion_arvalid;
+assign s_axi_rdma_completion_arready                     = s_axi_arready[C_RDMA_COMPLETION_IDX *1 +: 1];
+assign s_axi_rdma_completion_rid                         = s_axi_rid[C_RDMA_COMPLETION_IDX *3 +: 1];
+assign s_axi_rdma_completion_rdata                       = s_axi_rdata[C_RDMA_COMPLETION_IDX *512 +: 512];
+assign s_axi_rdma_completion_rresp                       = s_axi_rresp[C_RDMA_COMPLETION_IDX *2 +: 2];
+assign s_axi_rdma_completion_rlast                       = s_axi_rlast[C_RDMA_COMPLETION_IDX *1 +: 1];
+assign s_axi_rdma_completion_rvalid                      = s_axi_rvalid[C_RDMA_COMPLETION_IDX *1 +: 1];
+assign s_axi_rready [C_RDMA_COMPLETION_IDX *1 +: 1]      = s_axi_rdma_completion_rready;
+assign s_axi_arlock [C_RDMA_COMPLETION_IDX *1 +: 1]      = s_axi_rdma_completion_arlock;
+assign s_axi_arqos  [C_RDMA_COMPLETION_IDX *4 +: 4]      = s_axi_rdma_completion_arqos;
+
+// AXI slave signals for storing payload from RDMA send or write
+//assign axi_awid   [C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX *2 +: 2]         = {1'b0, s_axi_rdma_send_write_payload_awid};
+assign s_axi_awid   [C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX *3 +: 3]         = s_axi_rdma_send_write_payload_awvalid ? 3'd4 : 3'd0;
+assign s_axi_awaddr [C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX *64 +: 64]       = s_axi_rdma_send_write_payload_awaddr;
+assign s_axi_awqos  [C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX *4 +: 4]         = s_axi_rdma_send_write_payload_awqos;
+assign s_axi_awlen  [C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX *8 +: 8]         = s_axi_rdma_send_write_payload_awlen;
+assign s_axi_awsize [C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX *3 +: 3]         = s_axi_rdma_send_write_payload_awsize;
+assign s_axi_awburst[C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX *2 +: 2]         = s_axi_rdma_send_write_payload_awburst;
+assign s_axi_awcache[C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX *4 +: 4]         = s_axi_rdma_send_write_payload_awcache;
+assign s_axi_awprot [C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX *3 +: 3]         = s_axi_rdma_send_write_payload_awprot;
+assign s_axi_awvalid[C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX *1 +: 1]         = s_axi_rdma_send_write_payload_awvalid;
+assign s_axi_rdma_send_write_payload_awready                            = s_axi_awready[C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX *1 +: 1];
+assign s_axi_wdata  [C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX *512 +: 512]     = s_axi_rdma_send_write_payload_wdata;
+assign s_axi_wstrb  [C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX *64 +: 64]       = s_axi_rdma_send_write_payload_wstrb;
+assign s_axi_wlast  [C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX *1 +: 1]         = s_axi_rdma_send_write_payload_wlast;
+assign s_axi_wvalid [C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX *1 +: 1]         = s_axi_rdma_send_write_payload_wvalid;
+assign s_axi_rdma_send_write_payload_wready                             = s_axi_wready[C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX *1 +: 1];
+assign s_axi_awlock [C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX *1 +: 1]         = s_axi_rdma_send_write_payload_awlock;
+assign s_axi_rdma_send_write_payload_bid                                = s_axi_bid[C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX *3 +: 1];
+assign s_axi_rdma_send_write_payload_bresp                              = s_axi_bresp[C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX *2 +: 2];
+assign s_axi_rdma_send_write_payload_bvalid                             = s_axi_bvalid[C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX *1 +: 1];
+assign s_axi_bready [C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX *1 +: 1]         = s_axi_rdma_send_write_payload_bready;
+//assign s_axi_arid   [C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX *2 +: 2]         = {1'b0, s_axi_rdma_send_write_payload_arid};
+assign s_axi_arid   [C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX *3 +: 3]         = s_axi_rdma_send_write_payload_arvalid ? 3'd4 : 3'd0;
+assign s_axi_araddr [C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX *64 +: 64]       = s_axi_rdma_send_write_payload_araddr;
+assign s_axi_arlen  [C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX *8  +: 8]        = s_axi_rdma_send_write_payload_arlen;
+assign s_axi_arsize [C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX *3  +: 3]        = s_axi_rdma_send_write_payload_arsize;
+assign s_axi_arburst[C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX *2  +: 2]        = s_axi_rdma_send_write_payload_arburst;
+assign s_axi_arcache[C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX *4  +: 4]        = s_axi_rdma_send_write_payload_arcache;
+assign s_axi_arprot [C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX *3  +: 3]        = s_axi_rdma_send_write_payload_arprot;
+assign s_axi_arvalid[C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX *1  +: 1]        = s_axi_rdma_send_write_payload_arvalid;
+assign s_axi_rdma_send_write_payload_arready                            = s_axi_arready[C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX *1 +: 1];
+assign s_axi_rdma_send_write_payload_rid                                = s_axi_rid[C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX *3 +: 1];
+assign s_axi_rdma_send_write_payload_rdata                              = s_axi_rdata[C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX *512 +: 512];
+assign s_axi_rdma_send_write_payload_rresp                              = s_axi_rresp[C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX *2 +: 2];
+assign s_axi_rdma_send_write_payload_rlast                              = s_axi_rlast[C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX *1 +: 1];
+assign s_axi_rdma_send_write_payload_rvalid                             = s_axi_rvalid[C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX *1 +: 1];
+assign s_axi_rready [C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX *1 +: 1]         = s_axi_rdma_send_write_payload_rready;
+assign s_axi_arlock [C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX *1 +: 1]         = s_axi_rdma_send_write_payload_arlock;
+assign s_axi_arqos  [C_RDMA_GET_SEND_WRITE_PAYLOAD_IDX *4 +: 4]         = s_axi_rdma_send_write_payload_arqos;
+
+// AXI slave signals for storing payload from RDMA read response
+//assign axi_awid   [C_RDMA_RSP_PAYLOAD_IDX*2 +: 2]       = {1'b0, s_axi_rdma_rsp_payload_awid};
+assign s_axi_awid   [C_RDMA_RSP_PAYLOAD_IDX*3 +: 3]       = s_axi_rdma_rsp_payload_awvalid ? 3'd3 : 3'd0;
+assign s_axi_awaddr [C_RDMA_RSP_PAYLOAD_IDX *64 +: 64]    = s_axi_rdma_rsp_payload_awaddr;
+assign s_axi_awqos  [C_RDMA_RSP_PAYLOAD_IDX *4 +: 4]      = s_axi_rdma_rsp_payload_awqos;
+assign s_axi_awlen  [C_RDMA_RSP_PAYLOAD_IDX *8 +: 8]      = s_axi_rdma_rsp_payload_awlen;
+assign s_axi_awsize [C_RDMA_RSP_PAYLOAD_IDX *3 +: 3]      = s_axi_rdma_rsp_payload_awsize;
+assign s_axi_awburst[C_RDMA_RSP_PAYLOAD_IDX *2 +: 2]      = s_axi_rdma_rsp_payload_awburst;
+assign s_axi_awcache[C_RDMA_RSP_PAYLOAD_IDX *4 +: 4]      = s_axi_rdma_rsp_payload_awcache;
+assign s_axi_awprot [C_RDMA_RSP_PAYLOAD_IDX *3 +: 3]      = s_axi_rdma_rsp_payload_awprot;
+assign s_axi_awvalid[C_RDMA_RSP_PAYLOAD_IDX *1 +: 1]      = s_axi_rdma_rsp_payload_awvalid;
+assign s_axi_rdma_rsp_payload_awready                     = s_axi_awready[C_RDMA_RSP_PAYLOAD_IDX *1 +: 1];
+assign s_axi_wdata  [C_RDMA_RSP_PAYLOAD_IDX *512 +: 512]  = s_axi_rdma_rsp_payload_wdata;
+assign s_axi_wstrb  [C_RDMA_RSP_PAYLOAD_IDX *64 +: 64]    = s_axi_rdma_rsp_payload_wstrb;
+assign s_axi_wlast  [C_RDMA_RSP_PAYLOAD_IDX *1 +: 1]      = s_axi_rdma_rsp_payload_wlast;
+assign s_axi_wvalid [C_RDMA_RSP_PAYLOAD_IDX *1 +: 1]      = s_axi_rdma_rsp_payload_wvalid;
+assign s_axi_rdma_rsp_payload_wready                      = s_axi_wready[C_RDMA_RSP_PAYLOAD_IDX *1 +: 1];
+assign s_axi_awlock [C_RDMA_RSP_PAYLOAD_IDX *1 +: 1]      = s_axi_rdma_rsp_payload_awlock;
+assign s_axi_rdma_rsp_payload_bid                         = s_axi_bid[C_RDMA_RSP_PAYLOAD_IDX *3 +: 1];
+assign s_axi_rdma_rsp_payload_bresp                       = s_axi_bresp[C_RDMA_RSP_PAYLOAD_IDX *2 +: 2];
+assign s_axi_rdma_rsp_payload_bvalid                      = s_axi_bvalid[C_RDMA_RSP_PAYLOAD_IDX *1 +: 1];
+assign s_axi_bready [C_RDMA_RSP_PAYLOAD_IDX *1 +: 1]      = s_axi_rdma_rsp_payload_bready;
+//assign axi_arid   [C_RDMA_RSP_PAYLOAD_IDX *2 +: 2]      = {1'b0, s_axi_rdma_rsp_payload_arid};
+assign s_axi_arid   [C_RDMA_RSP_PAYLOAD_IDX *3 +: 3]      = s_axi_rdma_rsp_payload_arvalid ? 3'd3 : 3'd0;
+assign s_axi_araddr [C_RDMA_RSP_PAYLOAD_IDX *64 +: 64]    = s_axi_rdma_rsp_payload_araddr;
+assign s_axi_arlen  [C_RDMA_RSP_PAYLOAD_IDX *8  +: 8]     = s_axi_rdma_rsp_payload_arlen;
+assign s_axi_arsize [C_RDMA_RSP_PAYLOAD_IDX *3  +: 3]     = s_axi_rdma_rsp_payload_arsize;
+assign s_axi_arburst[C_RDMA_RSP_PAYLOAD_IDX *2  +: 2]     = s_axi_rdma_rsp_payload_arburst;
+assign s_axi_arcache[C_RDMA_RSP_PAYLOAD_IDX *4  +: 4]     = s_axi_rdma_rsp_payload_arcache;
+assign s_axi_arprot [C_RDMA_RSP_PAYLOAD_IDX *3  +: 3]     = s_axi_rdma_rsp_payload_arprot;
+assign s_axi_arvalid[C_RDMA_RSP_PAYLOAD_IDX *1  +: 1]     = s_axi_rdma_rsp_payload_arvalid;
+assign s_axi_rdma_rsp_payload_arready                     = s_axi_arready[C_RDMA_RSP_PAYLOAD_IDX *1 +: 1];
+assign s_axi_rdma_rsp_payload_rid                         = s_axi_rid[C_RDMA_RSP_PAYLOAD_IDX *3 +: 1];
+assign s_axi_rdma_rsp_payload_rdata                       = s_axi_rdata[C_RDMA_RSP_PAYLOAD_IDX *512 +: 512];
+assign s_axi_rdma_rsp_payload_rresp                       = s_axi_rresp[C_RDMA_RSP_PAYLOAD_IDX *2 +: 2];
+assign s_axi_rdma_rsp_payload_rlast                       = s_axi_rlast[C_RDMA_RSP_PAYLOAD_IDX *1 +: 1];
+assign s_axi_rdma_rsp_payload_rvalid                      = s_axi_rvalid[C_RDMA_RSP_PAYLOAD_IDX *1 +: 1];
+assign s_axi_rready [C_RDMA_RSP_PAYLOAD_IDX *1 +: 1]      = s_axi_rdma_rsp_payload_rready;
+assign s_axi_arlock [C_RDMA_RSP_PAYLOAD_IDX *1 +: 1]      = s_axi_rdma_rsp_payload_arlock;
+assign s_axi_arqos  [C_RDMA_RSP_PAYLOAD_IDX *4 +: 4]      = s_axi_rdma_rsp_payload_arqos;
+
+//AXI signals to system memory
+assign m_axi_sys_mem_awid                     = m_axi_awid   [C_SYS_MEM_IDX *3 +: 3];
+assign m_axi_sys_mem_awaddr                   = m_axi_awaddr [C_SYS_MEM_IDX *64 +: 64];
+assign m_axi_sys_mem_awqos                    = m_axi_awqos  [C_SYS_MEM_IDX *4 +: 4];
+assign m_axi_sys_mem_awlen                    = m_axi_awlen  [C_SYS_MEM_IDX *8 +: 8];
+assign m_axi_sys_mem_awsize                   = m_axi_awsize [C_SYS_MEM_IDX *3 +: 3];
+assign m_axi_sys_mem_awburst                  = m_axi_awburst[C_SYS_MEM_IDX *2 +: 2];
+assign m_axi_sys_mem_awcache                  = m_axi_awcache[C_SYS_MEM_IDX *4 +: 4];
+assign m_axi_sys_mem_awprot                   = m_axi_awprot [C_SYS_MEM_IDX *3 +: 3];
+assign m_axi_sys_mem_awvalid                  = m_axi_awvalid[C_SYS_MEM_IDX *1 +: 1];
+assign m_axi_awready[C_SYS_MEM_IDX *1 +: 1]   = m_axi_sys_mem_awready;
+assign m_axi_sys_mem_wdata                    = m_axi_wdata  [C_SYS_MEM_IDX *512 +: 512];
+assign m_axi_sys_mem_wstrb                    = m_axi_wstrb  [C_SYS_MEM_IDX *64 +: 64];
+assign m_axi_sys_mem_wlast                    = m_axi_wlast  [C_SYS_MEM_IDX *1 +: 1];
+assign m_axi_sys_mem_wvalid                   = m_axi_wvalid [C_SYS_MEM_IDX *1 +: 1];
+assign m_axi_wready[C_SYS_MEM_IDX *1 +: 1]    = m_axi_sys_mem_wready;
+assign m_axi_sys_mem_awlock                   = m_axi_awlock [C_SYS_MEM_IDX *1 +: 1];
+assign m_axi_bid[C_SYS_MEM_IDX *3 +: 3]       = m_axi_sys_mem_bid;
+assign m_axi_bresp[C_SYS_MEM_IDX *2 +: 2]     = m_axi_sys_mem_bresp;
+assign m_axi_bvalid[C_SYS_MEM_IDX *1 +: 1]    = m_axi_sys_mem_bvalid;
+assign m_axi_sys_mem_bready                   = m_axi_bready [C_SYS_MEM_IDX *1 +: 1];
+//assign m_axi_sys_mem_arid                   = m_axi_arid   [C_SYS_MEM_IDX *2 +: 2];
+assign m_axi_sys_mem_arid                     = m_axi_arid   [C_SYS_MEM_IDX *3 +: 3];
+assign m_axi_sys_mem_araddr                   = m_axi_araddr [C_SYS_MEM_IDX *64 +: 64];
+assign m_axi_sys_mem_arlen                    = m_axi_arlen  [C_SYS_MEM_IDX *8  +: 8];
+assign m_axi_sys_mem_arsize                   = m_axi_arsize [C_SYS_MEM_IDX *3  +: 3];
+assign m_axi_sys_mem_arburst                  = m_axi_arburst[C_SYS_MEM_IDX *2  +: 2];
+assign m_axi_sys_mem_arcache                  = m_axi_arcache[C_SYS_MEM_IDX *4  +: 4];
+assign m_axi_sys_mem_arprot                   = m_axi_arprot [C_SYS_MEM_IDX *3  +: 3];
+assign m_axi_sys_mem_arvalid                  = m_axi_arvalid[C_SYS_MEM_IDX *1  +: 1];
+assign m_axi_arready[C_SYS_MEM_IDX *1 +: 1]   = m_axi_sys_mem_arready;
+assign m_axi_rid[C_SYS_MEM_IDX *3 +: 3]       = m_axi_sys_mem_rid;
+assign m_axi_rdata[C_SYS_MEM_IDX *512 +: 512] = m_axi_sys_mem_rdata;
+assign m_axi_rresp[C_SYS_MEM_IDX *2 +: 2]     = m_axi_sys_mem_rresp;
+assign m_axi_rlast[C_SYS_MEM_IDX *1 +: 1]     = m_axi_sys_mem_rlast;
+assign m_axi_rvalid[C_SYS_MEM_IDX *1 +: 1]    = m_axi_sys_mem_rvalid;
+assign m_axi_sys_mem_rready                   = m_axi_rready [C_SYS_MEM_IDX *1 +: 1];
+assign m_axi_sys_mem_arlock                   = m_axi_arlock [C_SYS_MEM_IDX *1 +: 1];
+assign m_axi_sys_mem_arqos                    = m_axi_arqos  [C_SYS_MEM_IDX *4 +: 4];
+
+//AXI signals to device memory
+//assign m_axi_awid   [C_SYS_TO_DEV_CROSSBAR_IDX *2 +: 2]         = {1'b0, m_axi_sys_to_dev_crossbar_awid};
+assign m_axi_sys_to_dev_crossbar_awid         = m_axi_awid   [C_SYS_TO_DEV_CROSSBAR_IDX *3 +: 3];
+assign m_axi_sys_to_dev_crossbar_awaddr       = m_axi_awaddr [C_SYS_TO_DEV_CROSSBAR_IDX *64 +: 64];
+assign m_axi_sys_to_dev_crossbar_awqos        = m_axi_awqos  [C_SYS_TO_DEV_CROSSBAR_IDX *4 +: 4];
+assign m_axi_sys_to_dev_crossbar_awlen        = m_axi_awlen  [C_SYS_TO_DEV_CROSSBAR_IDX *8 +: 8];
+assign m_axi_sys_to_dev_crossbar_awsize       = m_axi_awsize [C_SYS_TO_DEV_CROSSBAR_IDX *3 +: 3];
+assign m_axi_sys_to_dev_crossbar_awburst      = m_axi_awburst[C_SYS_TO_DEV_CROSSBAR_IDX *2 +: 2];
+assign m_axi_sys_to_dev_crossbar_awcache      = m_axi_awcache[C_SYS_TO_DEV_CROSSBAR_IDX *4 +: 4];
+assign m_axi_sys_to_dev_crossbar_awprot       = m_axi_awprot [C_SYS_TO_DEV_CROSSBAR_IDX *3 +: 3];
+assign m_axi_sys_to_dev_crossbar_awvalid      = m_axi_awvalid[C_SYS_TO_DEV_CROSSBAR_IDX *1 +: 1];
+assign m_axi_awready[C_SYS_TO_DEV_CROSSBAR_IDX *1 +: 1]          = m_axi_sys_to_dev_crossbar_awready;
+assign m_axi_sys_to_dev_crossbar_wdata        = m_axi_wdata  [C_SYS_TO_DEV_CROSSBAR_IDX *512 +: 512];
+assign m_axi_sys_to_dev_crossbar_wstrb        = m_axi_wstrb  [C_SYS_TO_DEV_CROSSBAR_IDX *64 +: 64];
+assign m_axi_sys_to_dev_crossbar_wlast        = m_axi_wlast  [C_SYS_TO_DEV_CROSSBAR_IDX *1 +: 1];
+assign m_axi_sys_to_dev_crossbar_wvalid       = m_axi_wvalid [C_SYS_TO_DEV_CROSSBAR_IDX *1 +: 1];
+assign m_axi_wready[C_SYS_TO_DEV_CROSSBAR_IDX *1 +: 1]           = m_axi_sys_to_dev_crossbar_wready;
+assign m_axi_sys_to_dev_crossbar_awlock       = m_axi_awlock [C_SYS_TO_DEV_CROSSBAR_IDX *1 +: 1];
+assign m_axi_bid[C_SYS_TO_DEV_CROSSBAR_IDX *3 +: 3]              = m_axi_sys_to_dev_crossbar_bid;
+assign m_axi_bresp[C_SYS_TO_DEV_CROSSBAR_IDX *2 +: 2]            = m_axi_sys_to_dev_crossbar_bresp;
+assign m_axi_bvalid[C_SYS_TO_DEV_CROSSBAR_IDX *1 +: 1]           = m_axi_sys_to_dev_crossbar_bvalid;
+assign m_axi_sys_to_dev_crossbar_bready       = m_axi_bready [C_SYS_TO_DEV_CROSSBAR_IDX *1 +: 1];
+//assign m_axi_sys_to_dev_crossbar_arid         = m_axi_arid   [C_SYS_TO_DEV_CROSSBAR_IDX *2 +: 2];
+assign m_axi_sys_to_dev_crossbar_arid         = m_axi_arid   [C_SYS_TO_DEV_CROSSBAR_IDX *3 +: 3];
+assign m_axi_sys_to_dev_crossbar_araddr       = m_axi_araddr [C_SYS_TO_DEV_CROSSBAR_IDX *64 +: 64];
+assign m_axi_sys_to_dev_crossbar_arlen        = m_axi_arlen  [C_SYS_TO_DEV_CROSSBAR_IDX *8  +: 8];
+assign m_axi_sys_to_dev_crossbar_arsize       = m_axi_arsize [C_SYS_TO_DEV_CROSSBAR_IDX *3  +: 3];
+assign m_axi_sys_to_dev_crossbar_arburst      = m_axi_arburst[C_SYS_TO_DEV_CROSSBAR_IDX *2  +: 2];
+assign m_axi_sys_to_dev_crossbar_arcache      = m_axi_arcache[C_SYS_TO_DEV_CROSSBAR_IDX *4  +: 4];
+assign m_axi_sys_to_dev_crossbar_arprot       = m_axi_arprot [C_SYS_TO_DEV_CROSSBAR_IDX *3  +: 3];
+assign m_axi_sys_to_dev_crossbar_arvalid      = m_axi_arvalid[C_SYS_TO_DEV_CROSSBAR_IDX *1  +: 1];
+assign m_axi_arready[C_SYS_TO_DEV_CROSSBAR_IDX *1 +: 1]          = m_axi_sys_to_dev_crossbar_arready;
+assign m_axi_rid[C_SYS_TO_DEV_CROSSBAR_IDX *3 +: 3]              = m_axi_sys_to_dev_crossbar_rid;
+assign m_axi_rdata[C_SYS_TO_DEV_CROSSBAR_IDX *512 +: 512]        = m_axi_sys_to_dev_crossbar_rdata;
+assign m_axi_rresp[C_SYS_TO_DEV_CROSSBAR_IDX *2 +: 2]            = m_axi_sys_to_dev_crossbar_rresp;
+assign m_axi_rlast[C_SYS_TO_DEV_CROSSBAR_IDX *1 +: 1]            = m_axi_sys_to_dev_crossbar_rlast;
+assign m_axi_rvalid[C_SYS_TO_DEV_CROSSBAR_IDX *1 +: 1]           = m_axi_sys_to_dev_crossbar_rvalid;
+assign m_axi_sys_to_dev_crossbar_rready       = m_axi_rready [C_SYS_TO_DEV_CROSSBAR_IDX *1 +: 1];
+assign m_axi_sys_to_dev_crossbar_arlock       = m_axi_arlock [C_SYS_TO_DEV_CROSSBAR_IDX *1 +: 1];
+assign m_axi_sys_to_dev_crossbar_arqos        = m_axi_arqos  [C_SYS_TO_DEV_CROSSBAR_IDX *4 +: 4];
+
+sys_mem_5to2_axi_crossbar sys_mem_5to2_axi_crossbar_inst (
+  .m_axi_awaddr    (m_axi_awaddr),
+  .m_axi_awprot    (m_axi_awprot),
+  .m_axi_awvalid   (m_axi_awvalid),
+  .m_axi_awready   (m_axi_awready),
+  .m_axi_awsize    (m_axi_awsize),
+  .m_axi_awburst   (m_axi_awburst),
+  .m_axi_awcache   (m_axi_awcache),
+  .m_axi_awlen     (m_axi_awlen),
+  .m_axi_awlock    (m_axi_awlock),
+  .m_axi_awqos     (m_axi_awqos),
+  .m_axi_awregion  (m_axi_awregion),
+  .m_axi_awid      (m_axi_awid),
+  .m_axi_wdata     (m_axi_wdata),
+  .m_axi_wstrb     (m_axi_wstrb),
+  .m_axi_wvalid    (m_axi_wvalid),
+  .m_axi_wready    (m_axi_wready),
+  .m_axi_wlast     (m_axi_wlast),
+  .m_axi_bresp     (m_axi_bresp),
+  .m_axi_bvalid    (m_axi_bvalid),
+  .m_axi_bready    (m_axi_bready),
+  .m_axi_bid       (m_axi_bid),
+  .m_axi_araddr    (m_axi_araddr),
+  .m_axi_arprot    (m_axi_arprot),
+  .m_axi_arvalid   (m_axi_arvalid),
+  .m_axi_arready   (m_axi_arready),
+  .m_axi_arsize    (m_axi_arsize),
+  .m_axi_arburst   (m_axi_arburst),
+  .m_axi_arcache   (m_axi_arcache),
+  .m_axi_arlock    (m_axi_arlock),
+  .m_axi_arlen     (m_axi_arlen),
+  .m_axi_arqos     (m_axi_arqos),
+  .m_axi_arregion  (m_axi_arregion),
+  .m_axi_arid      (m_axi_arid),
+  .m_axi_rdata     (m_axi_rdata),
+  .m_axi_rresp     (m_axi_rresp),
+  .m_axi_rvalid    (m_axi_rvalid),
+  .m_axi_rready    (m_axi_rready),
+  .m_axi_rlast     (m_axi_rlast),
+  .m_axi_rid       (m_axi_rid),
+
+  .s_axi_awid      (s_axi_awid),
+  .s_axi_awaddr    (s_axi_awaddr),
+  .s_axi_awqos     (s_axi_awqos),
+  .s_axi_awlen     (s_axi_awlen),
+  .s_axi_awsize    (s_axi_awsize),
+  .s_axi_awburst   (s_axi_awburst),
+  .s_axi_awcache   (s_axi_awcache),
+  .s_axi_awprot    (s_axi_awprot),
+  .s_axi_awvalid   (s_axi_awvalid),
+  .s_axi_awready   (s_axi_awready),
+  .s_axi_wdata     (s_axi_wdata),
+  .s_axi_wstrb     (s_axi_wstrb),
+  .s_axi_wlast     (s_axi_wlast),
+  .s_axi_wvalid    (s_axi_wvalid),
+  .s_axi_wready    (s_axi_wready),
+  .s_axi_awlock    (s_axi_awlock),
+  .s_axi_bid       (s_axi_bid),
+  .s_axi_bresp     (s_axi_bresp),
+  .s_axi_bvalid    (s_axi_bvalid),
+  .s_axi_bready    (s_axi_bready),
+  .s_axi_arid      (s_axi_arid),
+  .s_axi_araddr    (s_axi_araddr),
+  .s_axi_arlen     (s_axi_arlen),
+  .s_axi_arsize    (s_axi_arsize),
+  .s_axi_arburst   (s_axi_arburst),
+  .s_axi_arcache   (s_axi_arcache),
+  .s_axi_arprot    (s_axi_arprot),
+  .s_axi_arvalid   (s_axi_arvalid),
+  .s_axi_arready   (s_axi_arready),
+  .s_axi_rid       (s_axi_rid),
+  .s_axi_rdata     (s_axi_rdata),
+  .s_axi_rresp     (s_axi_rresp),
+  .s_axi_rlast     (s_axi_rlast),
+  .s_axi_rvalid    (s_axi_rvalid),
+  .s_axi_rready    (s_axi_rready),
+  .s_axi_arlock    (s_axi_arlock),
+  .s_axi_arqos     (s_axi_arqos),
+
+  .aclk   (axis_aclk),
+  .aresetn(axis_arestn)
+);
+
+endmodule: axi_5to2_interconnect_to_sys_mem
\ No newline at end of file
diff --git a/src/utility/axi_interconnect_to_dev_mem.sv b/src/utility/axi_interconnect_to_dev_mem.sv
new file mode 100644
index 0000000..ea87ade
--- /dev/null
+++ b/src/utility/axi_interconnect_to_dev_mem.sv
@@ -0,0 +1,514 @@
+// *************************************************************************
+//
+// Copyright 2022 Xilinx, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// *************************************************************************
+`timescale 1ns/1ps
+
+module axi_interconnect_to_dev_mem #(
+  parameter C_AXI_DATA_WIDTH = 512,
+  parameter C_AXI_ADDR_WIDTH = 64
+) (
+  input             s_axi_rdma_send_write_payload_awid,
+  input    [63 : 0] s_axi_rdma_send_write_payload_awaddr,
+  input     [3 : 0] s_axi_rdma_send_write_payload_awqos,
+  input     [7 : 0] s_axi_rdma_send_write_payload_awlen,
+  input     [2 : 0] s_axi_rdma_send_write_payload_awsize,
+  input     [1 : 0] s_axi_rdma_send_write_payload_awburst,
+  input     [3 : 0] s_axi_rdma_send_write_payload_awcache,
+  input     [2 : 0] s_axi_rdma_send_write_payload_awprot,
+  input             s_axi_rdma_send_write_payload_awvalid,
+  output            s_axi_rdma_send_write_payload_awready,
+  input   [511 : 0] s_axi_rdma_send_write_payload_wdata,
+  input    [63 : 0] s_axi_rdma_send_write_payload_wstrb,
+  input             s_axi_rdma_send_write_payload_wlast,
+  input             s_axi_rdma_send_write_payload_wvalid,
+  output            s_axi_rdma_send_write_payload_wready,
+  input             s_axi_rdma_send_write_payload_awlock,
+  output            s_axi_rdma_send_write_payload_bid,
+  output    [1 : 0] s_axi_rdma_send_write_payload_bresp,
+  output            s_axi_rdma_send_write_payload_bvalid,
+  input             s_axi_rdma_send_write_payload_bready,
+  input             s_axi_rdma_send_write_payload_arid,
+  input    [63 : 0] s_axi_rdma_send_write_payload_araddr,
+  input     [7 : 0] s_axi_rdma_send_write_payload_arlen,
+  input     [2 : 0] s_axi_rdma_send_write_payload_arsize,
+  input     [1 : 0] s_axi_rdma_send_write_payload_arburst,
+  input     [3 : 0] s_axi_rdma_send_write_payload_arcache,
+  input     [2 : 0] s_axi_rdma_send_write_payload_arprot,
+  input             s_axi_rdma_send_write_payload_arvalid,
+  output            s_axi_rdma_send_write_payload_arready,
+  output            s_axi_rdma_send_write_payload_rid,
+  output  [511 : 0] s_axi_rdma_send_write_payload_rdata,
+  output    [1 : 0] s_axi_rdma_send_write_payload_rresp,
+  output            s_axi_rdma_send_write_payload_rlast,
+  output            s_axi_rdma_send_write_payload_rvalid,
+  input             s_axi_rdma_send_write_payload_rready,
+  input             s_axi_rdma_send_write_payload_arlock,
+  input       [3:0] s_axi_rdma_send_write_payload_arqos,
+
+  input             s_axi_rdma_rsp_payload_awid,
+  input    [63 : 0] s_axi_rdma_rsp_payload_awaddr,
+  input     [3 : 0] s_axi_rdma_rsp_payload_awqos,
+  input     [7 : 0] s_axi_rdma_rsp_payload_awlen,
+  input     [2 : 0] s_axi_rdma_rsp_payload_awsize,
+  input     [1 : 0] s_axi_rdma_rsp_payload_awburst,
+  input     [3 : 0] s_axi_rdma_rsp_payload_awcache,
+  input     [2 : 0] s_axi_rdma_rsp_payload_awprot,
+  input             s_axi_rdma_rsp_payload_awvalid,
+  output            s_axi_rdma_rsp_payload_awready,
+  input   [511 : 0] s_axi_rdma_rsp_payload_wdata,
+  input    [63 : 0] s_axi_rdma_rsp_payload_wstrb,
+  input             s_axi_rdma_rsp_payload_wlast,
+  input             s_axi_rdma_rsp_payload_wvalid,
+  output            s_axi_rdma_rsp_payload_wready,
+  input             s_axi_rdma_rsp_payload_awlock,
+  output            s_axi_rdma_rsp_payload_bid,
+  output    [1 : 0] s_axi_rdma_rsp_payload_bresp,
+  output            s_axi_rdma_rsp_payload_bvalid,
+  input             s_axi_rdma_rsp_payload_bready,
+  input             s_axi_rdma_rsp_payload_arid,
+  input    [63 : 0] s_axi_rdma_rsp_payload_araddr,
+  input     [7 : 0] s_axi_rdma_rsp_payload_arlen,
+  input     [2 : 0] s_axi_rdma_rsp_payload_arsize,
+  input     [1 : 0] s_axi_rdma_rsp_payload_arburst,
+  input     [3 : 0] s_axi_rdma_rsp_payload_arcache,
+  input     [2 : 0] s_axi_rdma_rsp_payload_arprot,
+  input             s_axi_rdma_rsp_payload_arvalid,
+  output            s_axi_rdma_rsp_payload_arready,
+  output            s_axi_rdma_rsp_payload_rid,
+  output  [511 : 0] s_axi_rdma_rsp_payload_rdata,
+  output    [1 : 0] s_axi_rdma_rsp_payload_rresp,
+  output            s_axi_rdma_rsp_payload_rlast,
+  output            s_axi_rdma_rsp_payload_rvalid,
+  input             s_axi_rdma_rsp_payload_rready,
+  input             s_axi_rdma_rsp_payload_arlock,
+  input       [3:0] s_axi_rdma_rsp_payload_arqos,
+
+  input     [3 : 0] s_axi_qdma_mm_awid,
+  input    [63 : 0] s_axi_qdma_mm_awaddr,
+  input     [3 : 0] s_axi_qdma_mm_awqos,
+  input     [7 : 0] s_axi_qdma_mm_awlen,
+  input     [2 : 0] s_axi_qdma_mm_awsize,
+  input     [1 : 0] s_axi_qdma_mm_awburst,
+  input     [3 : 0] s_axi_qdma_mm_awcache,
+  input     [2 : 0] s_axi_qdma_mm_awprot,
+  input             s_axi_qdma_mm_awvalid,
+  output            s_axi_qdma_mm_awready,
+  input   [511 : 0] s_axi_qdma_mm_wdata,
+  input    [63 : 0] s_axi_qdma_mm_wstrb,
+  input             s_axi_qdma_mm_wlast,
+  input             s_axi_qdma_mm_wvalid,
+  output            s_axi_qdma_mm_wready,
+  input             s_axi_qdma_mm_awlock,
+  output    [3 : 0] s_axi_qdma_mm_bid,
+  output    [1 : 0] s_axi_qdma_mm_bresp,
+  output            s_axi_qdma_mm_bvalid,
+  input             s_axi_qdma_mm_bready,
+  input     [3 : 0] s_axi_qdma_mm_arid,
+  input    [63 : 0] s_axi_qdma_mm_araddr,
+  input     [7 : 0] s_axi_qdma_mm_arlen,
+  input     [2 : 0] s_axi_qdma_mm_arsize,
+  input     [1 : 0] s_axi_qdma_mm_arburst,
+  input     [3 : 0] s_axi_qdma_mm_arcache,
+  input     [2 : 0] s_axi_qdma_mm_arprot,
+  input             s_axi_qdma_mm_arvalid,
+  output            s_axi_qdma_mm_arready,
+  output    [3 : 0] s_axi_qdma_mm_rid,
+  output  [511 : 0] s_axi_qdma_mm_rdata,
+  output    [1 : 0] s_axi_qdma_mm_rresp,
+  output            s_axi_qdma_mm_rlast,
+  output            s_axi_qdma_mm_rvalid,
+  input             s_axi_qdma_mm_rready,
+  input             s_axi_qdma_mm_arlock,
+  input       [3:0] s_axi_qdma_mm_arqos,
+
+  input             s_axi_compute_logic_awid,
+  input    [63 : 0] s_axi_compute_logic_awaddr,
+  input     [3 : 0] s_axi_compute_logic_awqos,
+  input     [7 : 0] s_axi_compute_logic_awlen,
+  input     [2 : 0] s_axi_compute_logic_awsize,
+  input     [1 : 0] s_axi_compute_logic_awburst,
+  input     [3 : 0] s_axi_compute_logic_awcache,
+  input     [2 : 0] s_axi_compute_logic_awprot,
+  input             s_axi_compute_logic_awvalid,
+  output            s_axi_compute_logic_awready,
+  input   [511 : 0] s_axi_compute_logic_wdata,
+  input    [63 : 0] s_axi_compute_logic_wstrb,
+  input             s_axi_compute_logic_wlast,
+  input             s_axi_compute_logic_wvalid,
+  output            s_axi_compute_logic_wready,
+  input             s_axi_compute_logic_awlock,
+  output            s_axi_compute_logic_bid,
+  output    [1 : 0] s_axi_compute_logic_bresp,
+  output            s_axi_compute_logic_bvalid,
+  input             s_axi_compute_logic_bready,
+  input             s_axi_compute_logic_arid,
+  input    [63 : 0] s_axi_compute_logic_araddr,
+  input     [7 : 0] s_axi_compute_logic_arlen,
+  input     [2 : 0] s_axi_compute_logic_arsize,
+  input     [1 : 0] s_axi_compute_logic_arburst,
+  input     [3 : 0] s_axi_compute_logic_arcache,
+  input     [2 : 0] s_axi_compute_logic_arprot,
+  input             s_axi_compute_logic_arvalid,
+  output            s_axi_compute_logic_arready,
+  output            s_axi_compute_logic_rid,
+  output  [511 : 0] s_axi_compute_logic_rdata,
+  output    [1 : 0] s_axi_compute_logic_rresp,
+  output            s_axi_compute_logic_rlast,
+  output            s_axi_compute_logic_rvalid,
+  input             s_axi_compute_logic_rready,
+  input             s_axi_compute_logic_arlock,
+  input      [3:0]  s_axi_compute_logic_arqos,
+
+  output      [1:0] m_axi_dev_mem_awid,
+  output     [63:0] m_axi_dev_mem_awaddr,
+  output      [7:0] m_axi_dev_mem_awlen,
+  output      [2:0] m_axi_dev_mem_awsize,
+  output      [1:0] m_axi_dev_mem_awburst,
+  output            m_axi_dev_mem_awlock,
+  output      [3:0] m_axi_dev_mem_awqos,
+  output      [3:0] m_axi_dev_mem_awregion,
+  output      [3:0] m_axi_dev_mem_awcache,
+  output      [2:0] m_axi_dev_mem_awprot,
+  output            m_axi_dev_mem_awvalid,
+  input             m_axi_dev_mem_awready,
+  output    [511:0] m_axi_dev_mem_wdata,
+  output     [63:0] m_axi_dev_mem_wstrb,
+  output            m_axi_dev_mem_wlast,
+  output            m_axi_dev_mem_wvalid,
+  input             m_axi_dev_mem_wready,
+  input       [1:0] m_axi_dev_mem_bid,
+  input       [1:0] m_axi_dev_mem_bresp,
+  input             m_axi_dev_mem_bvalid,
+  output            m_axi_dev_mem_bready,
+  output      [1:0] m_axi_dev_mem_arid,
+  output     [63:0] m_axi_dev_mem_araddr,
+  output      [7:0] m_axi_dev_mem_arlen,
+  output      [2:0] m_axi_dev_mem_arsize,
+  output      [1:0] m_axi_dev_mem_arburst,
+  output            m_axi_dev_mem_arlock,
+  output      [3:0] m_axi_dev_mem_arqos,
+  output      [3:0] m_axi_dev_mem_arregion,
+  output      [3:0] m_axi_dev_mem_arcache,
+  output      [2:0] m_axi_dev_mem_arprot,
+  output            m_axi_dev_mem_arvalid,
+  input             m_axi_dev_mem_arready,
+  input       [1:0] m_axi_dev_mem_rid,
+  input     [511:0] m_axi_dev_mem_rdata,
+  input       [1:0] m_axi_dev_mem_rresp,
+  input             m_axi_dev_mem_rlast,
+  input             m_axi_dev_mem_rvalid,
+  output            m_axi_dev_mem_rready,
+
+  input axis_aclk,
+  input axis_arestn
+);
+
+localparam C_NUM_MASTERS = 4;
+
+localparam C_RDMA_SW_PAYLOAD_IDX  = 0;
+localparam C_RDMA_RSP_PAYLOAD_IDX = 1;
+localparam C_QDMA_MM_IDX          = 2;
+localparam C_COMPUTE_LOGIC_IDX    = 3;
+
+logic   [C_NUM_MASTERS*2-1 : 0] axi_awid;
+logic  [C_NUM_MASTERS*64-1 : 0] axi_awaddr;
+logic   [C_NUM_MASTERS*8-1 : 0] axi_awlen;
+logic   [C_NUM_MASTERS*3-1 : 0] axi_awsize;
+logic   [C_NUM_MASTERS*2-1 : 0] axi_awburst;
+logic     [C_NUM_MASTERS-1 : 0] axi_awlock;
+logic   [C_NUM_MASTERS*4-1 : 0] axi_awcache;
+logic   [C_NUM_MASTERS*3-1 : 0] axi_awprot;
+logic   [C_NUM_MASTERS*4-1 : 0] axi_awqos;
+logic     [C_NUM_MASTERS-1 : 0] axi_awvalid;
+logic     [C_NUM_MASTERS-1 : 0] axi_awready;
+logic [C_NUM_MASTERS*512-1 : 0] axi_wdata;
+logic  [C_NUM_MASTERS*64-1 : 0] axi_wstrb;
+logic     [C_NUM_MASTERS-1 : 0] axi_wlast;
+logic     [C_NUM_MASTERS-1 : 0] axi_wvalid;
+logic     [C_NUM_MASTERS-1 : 0] axi_wready;
+logic   [C_NUM_MASTERS*2-1 : 0] axi_bid;
+logic   [C_NUM_MASTERS*2-1 : 0] axi_bresp;
+logic     [C_NUM_MASTERS-1 : 0] axi_bvalid;
+logic     [C_NUM_MASTERS-1 : 0] axi_bready;
+logic   [C_NUM_MASTERS*2-1 : 0] axi_arid;
+logic  [C_NUM_MASTERS*64-1 : 0] axi_araddr;
+logic   [C_NUM_MASTERS*8-1 : 0] axi_arlen;
+logic   [C_NUM_MASTERS*3-1 : 0] axi_arsize;
+logic   [C_NUM_MASTERS*2-1 : 0] axi_arburst;
+logic     [C_NUM_MASTERS-1 : 0] axi_arlock;
+logic   [C_NUM_MASTERS*4-1 : 0] axi_arcache;
+logic   [C_NUM_MASTERS*3-1 : 0] axi_arprot;
+logic   [C_NUM_MASTERS*4-1 : 0] axi_arqos;
+logic     [C_NUM_MASTERS-1 : 0] axi_arvalid;
+logic     [C_NUM_MASTERS-1 : 0] axi_arready;
+logic   [C_NUM_MASTERS*2-1 : 0] axi_rid;
+logic [C_NUM_MASTERS*512-1 : 0] axi_rdata;
+logic   [C_NUM_MASTERS*2-1 : 0] axi_rresp;
+logic     [C_NUM_MASTERS-1 : 0] axi_rlast;
+logic     [C_NUM_MASTERS-1 : 0] axi_rvalid;
+logic     [C_NUM_MASTERS-1 : 0] axi_rready;
+
+// AXI slave signals for storing payload from RDMA send or write
+//assign axi_awid   [C_RDMA_SW_PAYLOAD_IDX *2 +: 2]      = {1'b0, s_axi_rdma_send_write_payload_awid};
+assign axi_awid   [C_RDMA_SW_PAYLOAD_IDX *2 +: 2]      = s_axi_rdma_send_write_payload_awvalid ? 2'd0 : 2'd0;
+assign axi_awaddr [C_RDMA_SW_PAYLOAD_IDX *64 +: 64]    = s_axi_rdma_send_write_payload_awaddr;
+assign axi_awqos  [C_RDMA_SW_PAYLOAD_IDX *4 +: 4]      = s_axi_rdma_send_write_payload_awqos;
+assign axi_awlen  [C_RDMA_SW_PAYLOAD_IDX *8 +: 8]      = s_axi_rdma_send_write_payload_awlen;
+assign axi_awsize [C_RDMA_SW_PAYLOAD_IDX *3 +: 3]      = s_axi_rdma_send_write_payload_awsize;
+assign axi_awburst[C_RDMA_SW_PAYLOAD_IDX *2 +: 2]      = s_axi_rdma_send_write_payload_awburst;
+assign axi_awcache[C_RDMA_SW_PAYLOAD_IDX *4 +: 4]      = s_axi_rdma_send_write_payload_awcache;
+assign axi_awprot [C_RDMA_SW_PAYLOAD_IDX *3 +: 3]      = s_axi_rdma_send_write_payload_awprot;
+assign axi_awvalid[C_RDMA_SW_PAYLOAD_IDX *1 +: 1]      = s_axi_rdma_send_write_payload_awvalid;
+assign s_axi_rdma_send_write_payload_awready           = axi_awready[C_RDMA_SW_PAYLOAD_IDX *1 +: 1];
+assign axi_wdata  [C_RDMA_SW_PAYLOAD_IDX *512 +: 512]  = s_axi_rdma_send_write_payload_wdata;
+assign axi_wstrb  [C_RDMA_SW_PAYLOAD_IDX *64 +: 64]    = s_axi_rdma_send_write_payload_wstrb;
+assign axi_wlast  [C_RDMA_SW_PAYLOAD_IDX *1 +: 1]      = s_axi_rdma_send_write_payload_wlast;
+assign axi_wvalid [C_RDMA_SW_PAYLOAD_IDX *1 +: 1]      = s_axi_rdma_send_write_payload_wvalid;
+assign s_axi_rdma_send_write_payload_wready            = axi_wready[C_RDMA_SW_PAYLOAD_IDX *1 +: 1];
+assign axi_awlock [C_RDMA_SW_PAYLOAD_IDX *1 +: 1]      = s_axi_rdma_send_write_payload_awlock;
+assign s_axi_rdma_send_write_payload_bid               = axi_bid[C_RDMA_SW_PAYLOAD_IDX *2 +: 1];
+assign s_axi_rdma_send_write_payload_bresp             = axi_bresp[C_RDMA_SW_PAYLOAD_IDX *2 +: 2];
+assign s_axi_rdma_send_write_payload_bvalid            = axi_bvalid[C_RDMA_SW_PAYLOAD_IDX *1 +: 1];
+assign axi_bready [C_RDMA_SW_PAYLOAD_IDX *1 +: 1]      = s_axi_rdma_send_write_payload_bready;
+//assign axi_arid   [C_RDMA_SW_PAYLOAD_IDX *2 +: 2]      = {1'b0, s_axi_rdma_send_write_payload_arid};
+assign axi_arid   [C_RDMA_SW_PAYLOAD_IDX *2 +: 2]      = s_axi_rdma_send_write_payload_arvalid ? 2'd0 : 2'd0;
+assign axi_araddr [C_RDMA_SW_PAYLOAD_IDX *64 +: 64]    = s_axi_rdma_send_write_payload_araddr;
+assign axi_arlen  [C_RDMA_SW_PAYLOAD_IDX *8  +: 8]     = s_axi_rdma_send_write_payload_arlen;
+assign axi_arsize [C_RDMA_SW_PAYLOAD_IDX *3  +: 3]     = s_axi_rdma_send_write_payload_arsize;
+assign axi_arburst[C_RDMA_SW_PAYLOAD_IDX *2  +: 2]     = s_axi_rdma_send_write_payload_arburst;
+assign axi_arcache[C_RDMA_SW_PAYLOAD_IDX *4  +: 4]     = s_axi_rdma_send_write_payload_arcache;
+assign axi_arprot [C_RDMA_SW_PAYLOAD_IDX *3  +: 3]     = s_axi_rdma_send_write_payload_arprot;
+assign axi_arvalid[C_RDMA_SW_PAYLOAD_IDX *1  +: 1]     = s_axi_rdma_send_write_payload_arvalid;
+assign s_axi_rdma_send_write_payload_arready           = axi_arready[C_RDMA_SW_PAYLOAD_IDX *1 +: 1];
+assign s_axi_rdma_send_write_payload_rid               = axi_rid[C_RDMA_SW_PAYLOAD_IDX *2 +: 1];
+assign s_axi_rdma_send_write_payload_rdata             = axi_rdata[C_RDMA_SW_PAYLOAD_IDX *512 +: 512];
+assign s_axi_rdma_send_write_payload_rresp             = axi_rresp[C_RDMA_SW_PAYLOAD_IDX *2 +: 2];
+assign s_axi_rdma_send_write_payload_rlast             = axi_rlast[C_RDMA_SW_PAYLOAD_IDX *1 +: 1];
+assign s_axi_rdma_send_write_payload_rvalid            = axi_rvalid[C_RDMA_SW_PAYLOAD_IDX *1 +: 1];
+assign axi_rready [C_RDMA_SW_PAYLOAD_IDX *1 +: 1]      = s_axi_rdma_send_write_payload_rready;
+assign axi_arlock [C_RDMA_SW_PAYLOAD_IDX *1 +: 1]      = s_axi_rdma_send_write_payload_arlock;
+assign axi_arqos  [C_RDMA_SW_PAYLOAD_IDX *4 +: 4]      = s_axi_rdma_send_write_payload_arqos;
+
+// AXI slave signals for storing payload from RDMA read response
+//assign axi_awid   [C_RDMA_RSP_PAYLOAD_IDX*2 +: 2]       = {1'b0, s_axi_rdma_rsp_payload_awid};
+assign axi_awid   [C_RDMA_RSP_PAYLOAD_IDX*2 +: 2]       = s_axi_rdma_rsp_payload_awvalid ? 2'd1 : 2'd0;
+assign axi_awaddr [C_RDMA_RSP_PAYLOAD_IDX *64 +: 64]    = s_axi_rdma_rsp_payload_awaddr;
+assign axi_awqos  [C_RDMA_RSP_PAYLOAD_IDX *4 +: 4]      = s_axi_rdma_rsp_payload_awqos;
+assign axi_awlen  [C_RDMA_RSP_PAYLOAD_IDX *8 +: 8]      = s_axi_rdma_rsp_payload_awlen;
+assign axi_awsize [C_RDMA_RSP_PAYLOAD_IDX *3 +: 3]      = s_axi_rdma_rsp_payload_awsize;
+assign axi_awburst[C_RDMA_RSP_PAYLOAD_IDX *2 +: 2]      = s_axi_rdma_rsp_payload_awburst;
+assign axi_awcache[C_RDMA_RSP_PAYLOAD_IDX *4 +: 4]      = s_axi_rdma_rsp_payload_awcache;
+assign axi_awprot [C_RDMA_RSP_PAYLOAD_IDX *3 +: 3]      = s_axi_rdma_rsp_payload_awprot;
+assign axi_awvalid[C_RDMA_RSP_PAYLOAD_IDX *1 +: 1]      = s_axi_rdma_rsp_payload_awvalid;
+assign s_axi_rdma_rsp_payload_awready                   = axi_awready[C_RDMA_RSP_PAYLOAD_IDX *1 +: 1];
+assign axi_wdata  [C_RDMA_RSP_PAYLOAD_IDX *512 +: 512]  = s_axi_rdma_rsp_payload_wdata;
+assign axi_wstrb  [C_RDMA_RSP_PAYLOAD_IDX *64 +: 64]    = s_axi_rdma_rsp_payload_wstrb;
+assign axi_wlast  [C_RDMA_RSP_PAYLOAD_IDX *1 +: 1]      = s_axi_rdma_rsp_payload_wlast;
+assign axi_wvalid [C_RDMA_RSP_PAYLOAD_IDX *1 +: 1]      = s_axi_rdma_rsp_payload_wvalid;
+assign s_axi_rdma_rsp_payload_wready                    = axi_wready[C_RDMA_RSP_PAYLOAD_IDX *1 +: 1];
+assign axi_awlock [C_RDMA_RSP_PAYLOAD_IDX *1 +: 1]      = s_axi_rdma_rsp_payload_awlock;
+assign s_axi_rdma_rsp_payload_bid                       = axi_bid[C_RDMA_RSP_PAYLOAD_IDX *2 +: 1];
+assign s_axi_rdma_rsp_payload_bresp                     = axi_bresp[C_RDMA_RSP_PAYLOAD_IDX *2 +: 2];
+assign s_axi_rdma_rsp_payload_bvalid                    = axi_bvalid[C_RDMA_RSP_PAYLOAD_IDX *1 +: 1];
+assign axi_bready [C_RDMA_RSP_PAYLOAD_IDX *1 +: 1]      = s_axi_rdma_rsp_payload_bready;
+//assign axi_arid   [C_RDMA_RSP_PAYLOAD_IDX *2 +: 2]      = {1'b0, s_axi_rdma_rsp_payload_arid};
+assign axi_arid   [C_RDMA_RSP_PAYLOAD_IDX *2 +: 2]      = s_axi_rdma_rsp_payload_arvalid ? 2'd1 : 2'd0;
+assign axi_araddr [C_RDMA_RSP_PAYLOAD_IDX *64 +: 64]    = s_axi_rdma_rsp_payload_araddr;
+assign axi_arlen  [C_RDMA_RSP_PAYLOAD_IDX *8  +: 8]     = s_axi_rdma_rsp_payload_arlen;
+assign axi_arsize [C_RDMA_RSP_PAYLOAD_IDX *3  +: 3]     = s_axi_rdma_rsp_payload_arsize;
+assign axi_arburst[C_RDMA_RSP_PAYLOAD_IDX *2  +: 2]     = s_axi_rdma_rsp_payload_arburst;
+assign axi_arcache[C_RDMA_RSP_PAYLOAD_IDX *4  +: 4]     = s_axi_rdma_rsp_payload_arcache;
+assign axi_arprot [C_RDMA_RSP_PAYLOAD_IDX *3  +: 3]     = s_axi_rdma_rsp_payload_arprot;
+assign axi_arvalid[C_RDMA_RSP_PAYLOAD_IDX *1  +: 1]     = s_axi_rdma_rsp_payload_arvalid;
+assign s_axi_rdma_rsp_payload_arready                   = axi_arready[C_RDMA_RSP_PAYLOAD_IDX *1 +: 1];
+assign s_axi_rdma_rsp_payload_rid                       = axi_rid[C_RDMA_RSP_PAYLOAD_IDX *2 +: 1];
+assign s_axi_rdma_rsp_payload_rdata                     = axi_rdata[C_RDMA_RSP_PAYLOAD_IDX *512 +: 512];
+assign s_axi_rdma_rsp_payload_rresp                     = axi_rresp[C_RDMA_RSP_PAYLOAD_IDX *2 +: 2];
+assign s_axi_rdma_rsp_payload_rlast                     = axi_rlast[C_RDMA_RSP_PAYLOAD_IDX *1 +: 1];
+assign s_axi_rdma_rsp_payload_rvalid                    = axi_rvalid[C_RDMA_RSP_PAYLOAD_IDX *1 +: 1];
+assign axi_rready [C_RDMA_RSP_PAYLOAD_IDX *1 +: 1]      = s_axi_rdma_rsp_payload_rready;
+assign axi_arlock [C_RDMA_RSP_PAYLOAD_IDX *1 +: 1]      = s_axi_rdma_rsp_payload_arlock;
+assign axi_arqos  [C_RDMA_RSP_PAYLOAD_IDX *4 +: 4]      = s_axi_rdma_rsp_payload_arqos;
+
+// AXI slave signals for data access from qdma mm channel
+//assign axi_awid   [C_QDMA_MM_IDX*2 +: 2]                = s_axi_qdma_mm_awid[1:0];
+assign axi_awid   [C_QDMA_MM_IDX*2 +: 2]                = s_axi_qdma_mm_awvalid ? 2'd2 : 2'd0;
+assign axi_awaddr [C_QDMA_MM_IDX *64 +: 64]             = s_axi_qdma_mm_awaddr;
+assign axi_awqos  [C_QDMA_MM_IDX *4 +: 4]               = s_axi_qdma_mm_awqos;
+assign axi_awlen  [C_QDMA_MM_IDX *8 +: 8]               = s_axi_qdma_mm_awlen;
+assign axi_awsize [C_QDMA_MM_IDX *3 +: 3]               = s_axi_qdma_mm_awsize;
+assign axi_awburst[C_QDMA_MM_IDX *2 +: 2]               = s_axi_qdma_mm_awburst;
+assign axi_awcache[C_QDMA_MM_IDX *4 +: 4]               = s_axi_qdma_mm_awcache;
+assign axi_awprot [C_QDMA_MM_IDX *3 +: 3]               = s_axi_qdma_mm_awprot;
+assign axi_awvalid[C_QDMA_MM_IDX *1 +: 1]               = s_axi_qdma_mm_awvalid;
+assign s_axi_qdma_mm_awready                            = axi_awready[C_QDMA_MM_IDX *1 +: 1];
+assign axi_wdata  [C_QDMA_MM_IDX *512 +: 512]           = s_axi_qdma_mm_wdata;
+assign axi_wstrb  [C_QDMA_MM_IDX *64 +: 64]             = s_axi_qdma_mm_wstrb;
+assign axi_wlast  [C_QDMA_MM_IDX *1 +: 1]               = s_axi_qdma_mm_wlast;
+assign axi_wvalid [C_QDMA_MM_IDX *1 +: 1]               = s_axi_qdma_mm_wvalid;
+assign s_axi_qdma_mm_wready                             = axi_wready[C_QDMA_MM_IDX *1 +: 1];
+assign axi_awlock [C_QDMA_MM_IDX *1 +: 1]               = s_axi_qdma_mm_awlock;
+assign s_axi_qdma_mm_bid                                = {2'd0, axi_bid[C_QDMA_MM_IDX *2 +: 2]};
+assign s_axi_qdma_mm_bresp                              = axi_bresp[C_QDMA_MM_IDX *2 +: 2];
+assign s_axi_qdma_mm_bvalid                             = axi_bvalid[C_QDMA_MM_IDX *1 +: 1];
+assign axi_bready [C_QDMA_MM_IDX *1 +: 1]               = s_axi_qdma_mm_bready;
+//assign axi_arid   [C_QDMA_MM_IDX *2 +: 2]               = s_axi_qdma_mm_arid[1:0];
+assign axi_arid   [C_QDMA_MM_IDX *2 +: 2]               = s_axi_qdma_mm_arvalid ? 2'd2 : 2'd0;
+assign axi_araddr [C_QDMA_MM_IDX *64 +: 64]             = s_axi_qdma_mm_araddr;
+assign axi_arlen  [C_QDMA_MM_IDX *8  +: 8]              = s_axi_qdma_mm_arlen;
+assign axi_arsize [C_QDMA_MM_IDX *3  +: 3]              = s_axi_qdma_mm_arsize;
+assign axi_arburst[C_QDMA_MM_IDX *2  +: 2]              = s_axi_qdma_mm_arburst;
+assign axi_arcache[C_QDMA_MM_IDX *4  +: 4]              = s_axi_qdma_mm_arcache;
+assign axi_arprot [C_QDMA_MM_IDX *3  +: 3]              = s_axi_qdma_mm_arprot;
+assign axi_arvalid[C_QDMA_MM_IDX *1  +: 1]              = s_axi_qdma_mm_arvalid;
+assign s_axi_qdma_mm_arready                            = axi_arready[C_QDMA_MM_IDX *1 +: 1];
+assign s_axi_qdma_mm_rid                                = {2'd0, axi_rid[C_QDMA_MM_IDX *2 +: 2]};
+assign s_axi_qdma_mm_rdata                              = axi_rdata[C_QDMA_MM_IDX *512 +: 512];
+assign s_axi_qdma_mm_rresp                              = axi_rresp[C_QDMA_MM_IDX *2 +: 2];
+assign s_axi_qdma_mm_rlast                              = axi_rlast[C_QDMA_MM_IDX *1 +: 1];
+assign s_axi_qdma_mm_rvalid                             = axi_rvalid[C_QDMA_MM_IDX *1 +: 1];
+assign axi_rready [C_QDMA_MM_IDX *1 +: 1]               = s_axi_qdma_mm_rready;
+assign axi_arlock [C_QDMA_MM_IDX *1 +: 1]               = s_axi_qdma_mm_arlock;
+assign axi_arqos  [C_QDMA_MM_IDX *4 +: 4]               = s_axi_qdma_mm_arqos;
+
+// AXI slave signals for data access from compute logic
+//assign axi_awid   [C_COMPUTE_LOGIC_IDX *2 +: 2]      = {1'b0, s_axi_compute_logic_awid};
+assign axi_awid   [C_COMPUTE_LOGIC_IDX *2 +: 2]      = s_axi_compute_logic_awvalid ? 2'd3 : 2'd0;
+assign axi_awaddr [C_COMPUTE_LOGIC_IDX *64 +: 64]    = s_axi_compute_logic_awaddr;
+assign axi_awqos  [C_COMPUTE_LOGIC_IDX *4 +: 4]      = s_axi_compute_logic_awqos;
+assign axi_awlen  [C_COMPUTE_LOGIC_IDX *8 +: 8]      = s_axi_compute_logic_awlen;
+assign axi_awsize [C_COMPUTE_LOGIC_IDX *3 +: 3]      = s_axi_compute_logic_awsize;
+assign axi_awburst[C_COMPUTE_LOGIC_IDX *2 +: 2]      = s_axi_compute_logic_awburst;
+assign axi_awcache[C_COMPUTE_LOGIC_IDX *4 +: 4]      = s_axi_compute_logic_awcache;
+assign axi_awprot [C_COMPUTE_LOGIC_IDX *3 +: 3]      = s_axi_compute_logic_awprot;
+assign axi_awvalid[C_COMPUTE_LOGIC_IDX *1 +: 1]      = s_axi_compute_logic_awvalid;
+assign s_axi_compute_logic_awready                   = axi_awready[C_COMPUTE_LOGIC_IDX *1 +: 1];
+assign axi_wdata  [C_COMPUTE_LOGIC_IDX *512 +: 512]  = s_axi_compute_logic_wdata;
+assign axi_wstrb  [C_COMPUTE_LOGIC_IDX *64 +: 64]    = s_axi_compute_logic_wstrb;
+assign axi_wlast  [C_COMPUTE_LOGIC_IDX *1 +: 1]      = s_axi_compute_logic_wlast;
+assign axi_wvalid [C_COMPUTE_LOGIC_IDX *1 +: 1]      = s_axi_compute_logic_wvalid;
+assign s_axi_compute_logic_wready                    = axi_wready[C_COMPUTE_LOGIC_IDX *1 +: 1];
+assign axi_awlock [C_COMPUTE_LOGIC_IDX *1 +: 1]      = s_axi_compute_logic_awlock;
+assign s_axi_compute_logic_bid                       = axi_bid[C_COMPUTE_LOGIC_IDX *2 +: 1];
+assign s_axi_compute_logic_bresp                     = axi_bresp[C_COMPUTE_LOGIC_IDX *2 +: 2];
+assign s_axi_compute_logic_bvalid                    = axi_bvalid[C_COMPUTE_LOGIC_IDX *1 +: 1];
+assign axi_bready [C_COMPUTE_LOGIC_IDX *1 +: 1]      = s_axi_compute_logic_bready;
+//assign axi_arid   [C_COMPUTE_LOGIC_IDX *2 +: 2]      = {1'b0, s_axi_compute_logic_arid};
+assign axi_arid   [C_COMPUTE_LOGIC_IDX *2 +: 2]      = s_axi_compute_logic_arvalid ? 2'd3 : 2'd0;
+assign axi_araddr [C_COMPUTE_LOGIC_IDX *64 +: 64]    = s_axi_compute_logic_araddr;
+assign axi_arlen  [C_COMPUTE_LOGIC_IDX *8  +: 8]     = s_axi_compute_logic_arlen;
+assign axi_arsize [C_COMPUTE_LOGIC_IDX *3  +: 3]     = s_axi_compute_logic_arsize;
+assign axi_arburst[C_COMPUTE_LOGIC_IDX *2  +: 2]     = s_axi_compute_logic_arburst;
+assign axi_arcache[C_COMPUTE_LOGIC_IDX *4  +: 4]     = s_axi_compute_logic_arcache;
+assign axi_arprot [C_COMPUTE_LOGIC_IDX *3  +: 3]     = s_axi_compute_logic_arprot;
+assign axi_arvalid[C_COMPUTE_LOGIC_IDX *1  +: 1]     = s_axi_compute_logic_arvalid;
+assign s_axi_compute_logic_arready                   = axi_arready[C_COMPUTE_LOGIC_IDX *1 +: 1];
+assign s_axi_compute_logic_rid                       = axi_rid[C_COMPUTE_LOGIC_IDX *2 +: 1];
+assign s_axi_compute_logic_rdata                     = axi_rdata[C_COMPUTE_LOGIC_IDX *512 +: 512];
+assign s_axi_compute_logic_rresp                     = axi_rresp[C_COMPUTE_LOGIC_IDX *2 +: 2];
+assign s_axi_compute_logic_rlast                     = axi_rlast[C_COMPUTE_LOGIC_IDX *1 +: 1];
+assign s_axi_compute_logic_rvalid                    = axi_rvalid[C_COMPUTE_LOGIC_IDX *1 +: 1];
+assign axi_rready [C_COMPUTE_LOGIC_IDX *1 +: 1]      = s_axi_compute_logic_rready;
+assign axi_arlock [C_COMPUTE_LOGIC_IDX *1 +: 1]      = s_axi_compute_logic_arlock;
+assign axi_arqos  [C_COMPUTE_LOGIC_IDX *4 +: 4]      = s_axi_compute_logic_arqos;
+
+dev_mem_axi_crossbar dev_mem_axi_crossbar_inst (
+  // Master interface only has 2-bit ID width
+  .m_axi_awaddr    (m_axi_dev_mem_awaddr),
+  .m_axi_awprot    (m_axi_dev_mem_awprot),
+  .m_axi_awvalid   (m_axi_dev_mem_awvalid),
+  .m_axi_awready   (m_axi_dev_mem_awready),
+  .m_axi_awsize    (m_axi_dev_mem_awsize),
+  .m_axi_awburst   (m_axi_dev_mem_awburst),
+  .m_axi_awcache   (m_axi_dev_mem_awcache),
+  .m_axi_awlen     (m_axi_dev_mem_awlen),
+  .m_axi_awlock    (m_axi_dev_mem_awlock),
+  .m_axi_awqos     (m_axi_dev_mem_awqos),
+  .m_axi_awregion  (m_axi_dev_mem_awregion),
+  .m_axi_awid      (m_axi_dev_mem_awid),
+  .m_axi_wdata     (m_axi_dev_mem_wdata),
+  .m_axi_wstrb     (m_axi_dev_mem_wstrb),
+  .m_axi_wvalid    (m_axi_dev_mem_wvalid),
+  .m_axi_wready    (m_axi_dev_mem_wready),
+  .m_axi_wlast     (m_axi_dev_mem_wlast),
+  .m_axi_bresp     (m_axi_dev_mem_bresp),
+  .m_axi_bvalid    (m_axi_dev_mem_bvalid),
+  .m_axi_bready    (m_axi_dev_mem_bready),
+  .m_axi_bid       (m_axi_dev_mem_bid),
+  .m_axi_araddr    (m_axi_dev_mem_araddr),
+  .m_axi_arprot    (m_axi_dev_mem_arprot),
+  .m_axi_arvalid   (m_axi_dev_mem_arvalid),
+  .m_axi_arready   (m_axi_dev_mem_arready),
+  .m_axi_arsize    (m_axi_dev_mem_arsize),
+  .m_axi_arburst   (m_axi_dev_mem_arburst),
+  .m_axi_arcache   (m_axi_dev_mem_arcache),
+  .m_axi_arlock    (m_axi_dev_mem_arlock),
+  .m_axi_arlen     (m_axi_dev_mem_arlen),
+  .m_axi_arqos     (m_axi_dev_mem_arqos),
+  .m_axi_arregion  (m_axi_dev_mem_arregion),
+  .m_axi_arid      (m_axi_dev_mem_arid),
+  .m_axi_rdata     (m_axi_dev_mem_rdata),
+  .m_axi_rresp     (m_axi_dev_mem_rresp),
+  .m_axi_rvalid    (m_axi_dev_mem_rvalid),
+  .m_axi_rready    (m_axi_dev_mem_rready),
+  .m_axi_rlast     (m_axi_dev_mem_rlast),
+  .m_axi_rid       (m_axi_dev_mem_rid),
+
+  // Slave interface has 8-bit ID width
+  .s_axi_awid      (axi_awid),
+  .s_axi_awaddr    (axi_awaddr),
+  .s_axi_awqos     (axi_awqos),
+  .s_axi_awlen     (axi_awlen),
+  .s_axi_awsize    (axi_awsize),
+  .s_axi_awburst   (axi_awburst),
+  .s_axi_awcache   (axi_awcache),
+  .s_axi_awprot    (axi_awprot),
+  .s_axi_awvalid   (axi_awvalid),
+  .s_axi_awready   (axi_awready),
+  .s_axi_wdata     (axi_wdata),
+  .s_axi_wstrb     (axi_wstrb),
+  .s_axi_wlast     (axi_wlast),
+  .s_axi_wvalid    (axi_wvalid),
+  .s_axi_wready    (axi_wready),
+  .s_axi_awlock    (axi_awlock),
+  .s_axi_bid       (axi_bid),
+  .s_axi_bresp     (axi_bresp),
+  .s_axi_bvalid    (axi_bvalid),
+  .s_axi_bready    (axi_bready),
+  .s_axi_arid      (axi_arid),
+  .s_axi_araddr    (axi_araddr),
+  .s_axi_arlen     (axi_arlen),
+  .s_axi_arsize    (axi_arsize),
+  .s_axi_arburst   (axi_arburst),
+  .s_axi_arcache   (axi_arcache),
+  .s_axi_arprot    (axi_arprot),
+  .s_axi_arvalid   (axi_arvalid),
+  .s_axi_arready   (axi_arready),
+  .s_axi_rid       (axi_rid),
+  .s_axi_rdata     (axi_rdata),
+  .s_axi_rresp     (axi_rresp),
+  .s_axi_rlast     (axi_rlast),
+  .s_axi_rvalid    (axi_rvalid),
+  .s_axi_rready    (axi_rready),
+  .s_axi_arlock    (axi_arlock),
+  .s_axi_arqos     (axi_arqos),
+
+  .aclk   (axis_aclk),
+  .aresetn(axis_arestn)
+);
+
+endmodule: axi_interconnect_to_dev_mem
\ No newline at end of file
diff --git a/src/utility/axi_interconnect_to_sys_mem.sv b/src/utility/axi_interconnect_to_sys_mem.sv
new file mode 100644
index 0000000..2cc991c
--- /dev/null
+++ b/src/utility/axi_interconnect_to_sys_mem.sv
@@ -0,0 +1,432 @@
+// *************************************************************************
+//
+// Copyright 2022 Xilinx, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// *************************************************************************
+`timescale 1ns/1ps
+
+module axi_interconnect_to_sys_mem #(
+  parameter C_AXI_DATA_WIDTH = 512,
+  parameter C_AXI_ADDR_WIDTH = 64
+) (
+  input             s_axi_rdma_get_wqe_awid,
+  input    [63 : 0] s_axi_rdma_get_wqe_awaddr,
+  input     [3 : 0] s_axi_rdma_get_wqe_awqos,
+  input     [7 : 0] s_axi_rdma_get_wqe_awlen,
+  input     [2 : 0] s_axi_rdma_get_wqe_awsize,
+  input     [1 : 0] s_axi_rdma_get_wqe_awburst,
+  input     [3 : 0] s_axi_rdma_get_wqe_awcache,
+  input     [2 : 0] s_axi_rdma_get_wqe_awprot,
+  input             s_axi_rdma_get_wqe_awvalid,
+  output            s_axi_rdma_get_wqe_awready,
+  input   [511 : 0] s_axi_rdma_get_wqe_wdata,
+  input    [63 : 0] s_axi_rdma_get_wqe_wstrb,
+  input             s_axi_rdma_get_wqe_wlast,
+  input             s_axi_rdma_get_wqe_wvalid,
+  output            s_axi_rdma_get_wqe_wready,
+  input             s_axi_rdma_get_wqe_awlock,
+  output            s_axi_rdma_get_wqe_bid,
+  output    [1 : 0] s_axi_rdma_get_wqe_bresp,
+  output            s_axi_rdma_get_wqe_bvalid,
+  input             s_axi_rdma_get_wqe_bready,
+  input             s_axi_rdma_get_wqe_arid,
+  input    [63 : 0] s_axi_rdma_get_wqe_araddr,
+  input     [7 : 0] s_axi_rdma_get_wqe_arlen,
+  input     [2 : 0] s_axi_rdma_get_wqe_arsize,
+  input     [1 : 0] s_axi_rdma_get_wqe_arburst,
+  input     [3 : 0] s_axi_rdma_get_wqe_arcache,
+  input     [2 : 0] s_axi_rdma_get_wqe_arprot,
+  input             s_axi_rdma_get_wqe_arvalid,
+  output            s_axi_rdma_get_wqe_arready,
+  output            s_axi_rdma_get_wqe_rid,
+  output  [511 : 0] s_axi_rdma_get_wqe_rdata,
+  output    [1 : 0] s_axi_rdma_get_wqe_rresp,
+  output            s_axi_rdma_get_wqe_rlast,
+  output            s_axi_rdma_get_wqe_rvalid,
+  input             s_axi_rdma_get_wqe_rready,
+  input             s_axi_rdma_get_wqe_arlock,
+  input       [3:0] s_axi_rdma_get_wqe_arqos,
+
+  input     [3 : 0] s_axi_rdma_get_payload_awid,
+  input    [63 : 0] s_axi_rdma_get_payload_awaddr,
+  input     [3 : 0] s_axi_rdma_get_payload_awqos,
+  input     [7 : 0] s_axi_rdma_get_payload_awlen,
+  input     [2 : 0] s_axi_rdma_get_payload_awsize,
+  input     [1 : 0] s_axi_rdma_get_payload_awburst,
+  input     [3 : 0] s_axi_rdma_get_payload_awcache,
+  input     [2 : 0] s_axi_rdma_get_payload_awprot,
+  input             s_axi_rdma_get_payload_awvalid,
+  output            s_axi_rdma_get_payload_awready,
+  input   [511 : 0] s_axi_rdma_get_payload_wdata,
+  input    [63 : 0] s_axi_rdma_get_payload_wstrb,
+  input             s_axi_rdma_get_payload_wlast,
+  input             s_axi_rdma_get_payload_wvalid,
+  output            s_axi_rdma_get_payload_wready,
+  input             s_axi_rdma_get_payload_awlock,
+  output    [3 : 0] s_axi_rdma_get_payload_bid,
+  output    [1 : 0] s_axi_rdma_get_payload_bresp,
+  output            s_axi_rdma_get_payload_bvalid,
+  input             s_axi_rdma_get_payload_bready,
+  input     [3 : 0] s_axi_rdma_get_payload_arid,
+  input    [63 : 0] s_axi_rdma_get_payload_araddr,
+  input     [7 : 0] s_axi_rdma_get_payload_arlen,
+  input     [2 : 0] s_axi_rdma_get_payload_arsize,
+  input     [1 : 0] s_axi_rdma_get_payload_arburst,
+  input     [3 : 0] s_axi_rdma_get_payload_arcache,
+  input     [2 : 0] s_axi_rdma_get_payload_arprot,
+  input             s_axi_rdma_get_payload_arvalid,
+  output            s_axi_rdma_get_payload_arready,
+  output    [3 : 0] s_axi_rdma_get_payload_rid,
+  output  [511 : 0] s_axi_rdma_get_payload_rdata,
+  output    [1 : 0] s_axi_rdma_get_payload_rresp,
+  output            s_axi_rdma_get_payload_rlast,
+  output            s_axi_rdma_get_payload_rvalid,
+  input             s_axi_rdma_get_payload_rready,
+  input             s_axi_rdma_get_payload_arlock,
+  input       [3:0] s_axi_rdma_get_payload_arqos,
+
+  input             s_axi_rdma_completion_awid,
+  input    [63 : 0] s_axi_rdma_completion_awaddr,
+  input     [3 : 0] s_axi_rdma_completion_awqos,
+  input     [7 : 0] s_axi_rdma_completion_awlen,
+  input     [2 : 0] s_axi_rdma_completion_awsize,
+  input     [1 : 0] s_axi_rdma_completion_awburst,
+  input     [3 : 0] s_axi_rdma_completion_awcache,
+  input     [2 : 0] s_axi_rdma_completion_awprot,
+  input             s_axi_rdma_completion_awvalid,
+  output            s_axi_rdma_completion_awready,
+  input   [511 : 0] s_axi_rdma_completion_wdata,
+  input    [63 : 0] s_axi_rdma_completion_wstrb,
+  input             s_axi_rdma_completion_wlast,
+  input             s_axi_rdma_completion_wvalid,
+  output            s_axi_rdma_completion_wready,
+  input             s_axi_rdma_completion_awlock,
+  output            s_axi_rdma_completion_bid,
+  output    [1 : 0] s_axi_rdma_completion_bresp,
+  output            s_axi_rdma_completion_bvalid,
+  input             s_axi_rdma_completion_bready,
+  input             s_axi_rdma_completion_arid,
+  input    [63 : 0] s_axi_rdma_completion_araddr,
+  input     [7 : 0] s_axi_rdma_completion_arlen,
+  input     [2 : 0] s_axi_rdma_completion_arsize,
+  input     [1 : 0] s_axi_rdma_completion_arburst,
+  input     [3 : 0] s_axi_rdma_completion_arcache,
+  input     [2 : 0] s_axi_rdma_completion_arprot,
+  input             s_axi_rdma_completion_arvalid,
+  output            s_axi_rdma_completion_arready,
+  output            s_axi_rdma_completion_rid,
+  output  [511 : 0] s_axi_rdma_completion_rdata,
+  output    [1 : 0] s_axi_rdma_completion_rresp,
+  output            s_axi_rdma_completion_rlast,
+  output            s_axi_rdma_completion_rvalid,
+  input             s_axi_rdma_completion_rready,
+  input             s_axi_rdma_completion_arlock,
+  input      [3:0]  s_axi_rdma_completion_arqos,
+
+  output      [1:0] m_axi_sys_mem_awid,
+  output     [63:0] m_axi_sys_mem_awaddr,
+  output      [7:0] m_axi_sys_mem_awlen,
+  output      [2:0] m_axi_sys_mem_awsize,
+  output      [1:0] m_axi_sys_mem_awburst,
+  output            m_axi_sys_mem_awlock,
+  output      [3:0] m_axi_sys_mem_awqos,
+  output      [3:0] m_axi_sys_mem_awregion,
+  output      [3:0] m_axi_sys_mem_awcache,
+  output      [2:0] m_axi_sys_mem_awprot,
+  output            m_axi_sys_mem_awvalid,
+  input             m_axi_sys_mem_awready,
+  output    [511:0] m_axi_sys_mem_wdata,
+  output     [63:0] m_axi_sys_mem_wstrb,
+  output            m_axi_sys_mem_wlast,
+  output            m_axi_sys_mem_wvalid,
+  input             m_axi_sys_mem_wready,
+  input       [1:0] m_axi_sys_mem_bid,
+  input       [1:0] m_axi_sys_mem_bresp,
+  input             m_axi_sys_mem_bvalid,
+  output            m_axi_sys_mem_bready,
+  output      [1:0] m_axi_sys_mem_arid,
+  output     [63:0] m_axi_sys_mem_araddr,
+  output      [7:0] m_axi_sys_mem_arlen,
+  output      [2:0] m_axi_sys_mem_arsize,
+  output      [1:0] m_axi_sys_mem_arburst,
+  output            m_axi_sys_mem_arlock,
+  output      [3:0] m_axi_sys_mem_arqos,
+  output      [3:0] m_axi_sys_mem_arregion,
+  output      [3:0] m_axi_sys_mem_arcache,
+  output      [2:0] m_axi_sys_mem_arprot,
+  output            m_axi_sys_mem_arvalid,
+  input             m_axi_sys_mem_arready,
+  input       [1:0] m_axi_sys_mem_rid,
+  input     [511:0] m_axi_sys_mem_rdata,
+  input       [1:0] m_axi_sys_mem_rresp,
+  input             m_axi_sys_mem_rlast,
+  input             m_axi_sys_mem_rvalid,
+  output            m_axi_sys_mem_rready,
+
+  input axis_aclk,
+  input axis_arestn
+);
+
+localparam C_NUM_MASTERS = 3;
+
+localparam C_RDMA_GET_WQE_IDX     = 0;
+localparam C_RDMA_GET_PAYLOAD_IDX = 1;
+localparam C_RDMA_COMPLETION_IDX  = 2;
+
+logic   [C_NUM_MASTERS*2-1 : 0] axi_awid;
+logic  [C_NUM_MASTERS*64-1 : 0] axi_awaddr;
+logic   [C_NUM_MASTERS*8-1 : 0] axi_awlen;
+logic   [C_NUM_MASTERS*3-1 : 0] axi_awsize;
+logic   [C_NUM_MASTERS*2-1 : 0] axi_awburst;
+logic     [C_NUM_MASTERS-1 : 0] axi_awlock;
+logic   [C_NUM_MASTERS*4-1 : 0] axi_awcache;
+logic   [C_NUM_MASTERS*3-1 : 0] axi_awprot;
+logic   [C_NUM_MASTERS*4-1 : 0] axi_awqos;
+logic     [C_NUM_MASTERS-1 : 0] axi_awvalid;
+logic     [C_NUM_MASTERS-1 : 0] axi_awready;
+logic [C_NUM_MASTERS*512-1 : 0] axi_wdata;
+logic  [C_NUM_MASTERS*64-1 : 0] axi_wstrb;
+logic     [C_NUM_MASTERS-1 : 0] axi_wlast;
+logic     [C_NUM_MASTERS-1 : 0] axi_wvalid;
+logic     [C_NUM_MASTERS-1 : 0] axi_wready;
+logic   [C_NUM_MASTERS*2-1 : 0] axi_bid;
+logic   [C_NUM_MASTERS*2-1 : 0] axi_bresp;
+logic     [C_NUM_MASTERS-1 : 0] axi_bvalid;
+logic     [C_NUM_MASTERS-1 : 0] axi_bready;
+logic   [C_NUM_MASTERS*2-1 : 0] axi_arid;
+logic  [C_NUM_MASTERS*64-1 : 0] axi_araddr;
+logic   [C_NUM_MASTERS*8-1 : 0] axi_arlen;
+logic   [C_NUM_MASTERS*3-1 : 0] axi_arsize;
+logic   [C_NUM_MASTERS*2-1 : 0] axi_arburst;
+logic     [C_NUM_MASTERS-1 : 0] axi_arlock;
+logic   [C_NUM_MASTERS*4-1 : 0] axi_arcache;
+logic   [C_NUM_MASTERS*3-1 : 0] axi_arprot;
+logic   [C_NUM_MASTERS*4-1 : 0] axi_arqos;
+logic     [C_NUM_MASTERS-1 : 0] axi_arvalid;
+logic     [C_NUM_MASTERS-1 : 0] axi_arready;
+logic   [C_NUM_MASTERS*2-1 : 0] axi_rid;
+logic [C_NUM_MASTERS*512-1 : 0] axi_rdata;
+logic   [C_NUM_MASTERS*2-1 : 0] axi_rresp;
+logic     [C_NUM_MASTERS-1 : 0] axi_rlast;
+logic     [C_NUM_MASTERS-1 : 0] axi_rvalid;
+logic     [C_NUM_MASTERS-1 : 0] axi_rready;
+
+// AXI slave signals for getting wqe from system memory
+//assign axi_awid   [C_RDMA_GET_WQE_IDX *2 +: 2]         = {1'b0, s_axi_rdma_get_wqe_awid};
+assign axi_awid   [C_RDMA_GET_WQE_IDX *2 +: 2]         = s_axi_rdma_get_wqe_awvalid ? 2'd0 : 2'd0;
+assign axi_awaddr [C_RDMA_GET_WQE_IDX *64 +: 64]       = s_axi_rdma_get_wqe_awaddr;
+assign axi_awqos  [C_RDMA_GET_WQE_IDX *4 +: 4]         = s_axi_rdma_get_wqe_awqos;
+assign axi_awlen  [C_RDMA_GET_WQE_IDX *8 +: 8]         = s_axi_rdma_get_wqe_awlen;
+assign axi_awsize [C_RDMA_GET_WQE_IDX *3 +: 3]         = s_axi_rdma_get_wqe_awsize;
+assign axi_awburst[C_RDMA_GET_WQE_IDX *2 +: 2]         = s_axi_rdma_get_wqe_awburst;
+assign axi_awcache[C_RDMA_GET_WQE_IDX *4 +: 4]         = s_axi_rdma_get_wqe_awcache;
+assign axi_awprot [C_RDMA_GET_WQE_IDX *3 +: 3]         = s_axi_rdma_get_wqe_awprot;
+assign axi_awvalid[C_RDMA_GET_WQE_IDX *1 +: 1]         = s_axi_rdma_get_wqe_awvalid;
+assign s_axi_rdma_get_wqe_awready                      = axi_awready[C_RDMA_GET_WQE_IDX *1 +: 1];
+assign axi_wdata  [C_RDMA_GET_WQE_IDX *512 +: 512]     = s_axi_rdma_get_wqe_wdata;
+assign axi_wstrb  [C_RDMA_GET_WQE_IDX *64 +: 64]       = s_axi_rdma_get_wqe_wstrb;
+assign axi_wlast  [C_RDMA_GET_WQE_IDX *1 +: 1]         = s_axi_rdma_get_wqe_wlast;
+assign axi_wvalid [C_RDMA_GET_WQE_IDX *1 +: 1]         = s_axi_rdma_get_wqe_wvalid;
+assign s_axi_rdma_get_wqe_wready                       = axi_wready[C_RDMA_GET_WQE_IDX *1 +: 1];
+assign axi_awlock [C_RDMA_GET_WQE_IDX *1 +: 1]         = s_axi_rdma_get_wqe_awlock;
+assign s_axi_rdma_get_wqe_bid                          = axi_bid[C_RDMA_GET_WQE_IDX *2 +: 1];
+assign s_axi_rdma_get_wqe_bresp                        = axi_bresp[C_RDMA_GET_WQE_IDX *2 +: 2];
+assign s_axi_rdma_get_wqe_bvalid                       = axi_bvalid[C_RDMA_GET_WQE_IDX *1 +: 1];
+assign axi_bready [C_RDMA_GET_WQE_IDX *1 +: 1]         = s_axi_rdma_get_wqe_bready;
+//assign axi_arid   [C_RDMA_GET_WQE_IDX *2 +: 2]         = {1'b0, s_axi_rdma_get_wqe_arid};
+assign axi_arid   [C_RDMA_GET_WQE_IDX *2 +: 2]         = s_axi_rdma_get_wqe_arvalid ? 2'd0 : 2'd0;
+assign axi_araddr [C_RDMA_GET_WQE_IDX *64 +: 64]       = s_axi_rdma_get_wqe_araddr;
+assign axi_arlen  [C_RDMA_GET_WQE_IDX *8  +: 8]        = s_axi_rdma_get_wqe_arlen;
+assign axi_arsize [C_RDMA_GET_WQE_IDX *3  +: 3]        = s_axi_rdma_get_wqe_arsize;
+assign axi_arburst[C_RDMA_GET_WQE_IDX *2  +: 2]        = s_axi_rdma_get_wqe_arburst;
+assign axi_arcache[C_RDMA_GET_WQE_IDX *4  +: 4]        = s_axi_rdma_get_wqe_arcache;
+assign axi_arprot [C_RDMA_GET_WQE_IDX *3  +: 3]        = s_axi_rdma_get_wqe_arprot;
+assign axi_arvalid[C_RDMA_GET_WQE_IDX *1  +: 1]        = s_axi_rdma_get_wqe_arvalid;
+assign s_axi_rdma_get_wqe_arready                      = axi_arready[C_RDMA_GET_WQE_IDX *1 +: 1];
+assign s_axi_rdma_get_wqe_rid                          = axi_rid[C_RDMA_GET_WQE_IDX *2 +: 1];
+assign s_axi_rdma_get_wqe_rdata                        = axi_rdata[C_RDMA_GET_WQE_IDX *512 +: 512];
+assign s_axi_rdma_get_wqe_rresp                        = axi_rresp[C_RDMA_GET_WQE_IDX *2 +: 2];
+assign s_axi_rdma_get_wqe_rlast                        = axi_rlast[C_RDMA_GET_WQE_IDX *1 +: 1];
+assign s_axi_rdma_get_wqe_rvalid                       = axi_rvalid[C_RDMA_GET_WQE_IDX *1 +: 1];
+assign axi_rready [C_RDMA_GET_WQE_IDX *1 +: 1]         = s_axi_rdma_get_wqe_rready;
+assign axi_arlock [C_RDMA_GET_WQE_IDX *1 +: 1]         = s_axi_rdma_get_wqe_arlock;
+assign axi_arqos  [C_RDMA_GET_WQE_IDX *4 +: 4]         = s_axi_rdma_get_wqe_arqos;
+
+// AXI slave signals for getting payload from system memory
+//assign axi_awid   [C_RDMA_GET_PAYLOAD_IDX*2 +: 2]      = {1'b0, s_axi_rdma_get_payload_awid};
+assign axi_awid   [C_RDMA_GET_PAYLOAD_IDX*2 +: 2]      = s_axi_rdma_get_payload_awvalid ? 2'd1 : 2'd0;
+assign axi_awaddr [C_RDMA_GET_PAYLOAD_IDX *64 +: 64]   = s_axi_rdma_get_payload_awaddr;
+assign axi_awqos  [C_RDMA_GET_PAYLOAD_IDX *4 +: 4]     = s_axi_rdma_get_payload_awqos;
+assign axi_awlen  [C_RDMA_GET_PAYLOAD_IDX *8 +: 8]     = s_axi_rdma_get_payload_awlen;
+assign axi_awsize [C_RDMA_GET_PAYLOAD_IDX *3 +: 3]     = s_axi_rdma_get_payload_awsize;
+assign axi_awburst[C_RDMA_GET_PAYLOAD_IDX *2 +: 2]     = s_axi_rdma_get_payload_awburst;
+assign axi_awcache[C_RDMA_GET_PAYLOAD_IDX *4 +: 4]     = s_axi_rdma_get_payload_awcache;
+assign axi_awprot [C_RDMA_GET_PAYLOAD_IDX *3 +: 3]     = s_axi_rdma_get_payload_awprot;
+assign axi_awvalid[C_RDMA_GET_PAYLOAD_IDX *1 +: 1]     = s_axi_rdma_get_payload_awvalid;
+assign s_axi_rdma_get_payload_awready                  = axi_awready[C_RDMA_GET_PAYLOAD_IDX *1 +: 1];
+assign axi_wdata  [C_RDMA_GET_PAYLOAD_IDX *512 +: 512] = s_axi_rdma_get_payload_wdata;
+assign axi_wstrb  [C_RDMA_GET_PAYLOAD_IDX *64 +: 64]   = s_axi_rdma_get_payload_wstrb;
+assign axi_wlast  [C_RDMA_GET_PAYLOAD_IDX *1 +: 1]     = s_axi_rdma_get_payload_wlast;
+assign axi_wvalid [C_RDMA_GET_PAYLOAD_IDX *1 +: 1]     = s_axi_rdma_get_payload_wvalid;
+assign s_axi_rdma_get_payload_wready                   = axi_wready[C_RDMA_GET_PAYLOAD_IDX *1 +: 1];
+assign axi_awlock [C_RDMA_GET_PAYLOAD_IDX *1 +: 1]     = s_axi_rdma_get_payload_awlock;
+assign s_axi_rdma_get_payload_bid                      = axi_bid[C_RDMA_GET_PAYLOAD_IDX *2 +: 1];
+assign s_axi_rdma_get_payload_bresp                    = axi_bresp[C_RDMA_GET_PAYLOAD_IDX *2 +: 2];
+assign s_axi_rdma_get_payload_bvalid                   = axi_bvalid[C_RDMA_GET_PAYLOAD_IDX *1 +: 1];
+assign axi_bready [C_RDMA_GET_PAYLOAD_IDX *1 +: 1]     = s_axi_rdma_get_payload_bready;
+//assign axi_arid   [C_RDMA_GET_PAYLOAD_IDX *2 +: 2]     = {1'b0, s_axi_rdma_get_payload_arid};
+assign axi_arid   [C_RDMA_GET_PAYLOAD_IDX *2 +: 2]     = s_axi_rdma_get_payload_arvalid ? 2'd1: 2'd0;
+assign axi_araddr [C_RDMA_GET_PAYLOAD_IDX *64 +: 64]   = s_axi_rdma_get_payload_araddr;
+assign axi_arlen  [C_RDMA_GET_PAYLOAD_IDX *8  +: 8]    = s_axi_rdma_get_payload_arlen;
+assign axi_arsize [C_RDMA_GET_PAYLOAD_IDX *3  +: 3]    = s_axi_rdma_get_payload_arsize;
+assign axi_arburst[C_RDMA_GET_PAYLOAD_IDX *2  +: 2]    = s_axi_rdma_get_payload_arburst;
+assign axi_arcache[C_RDMA_GET_PAYLOAD_IDX *4  +: 4]    = s_axi_rdma_get_payload_arcache;
+assign axi_arprot [C_RDMA_GET_PAYLOAD_IDX *3  +: 3]    = s_axi_rdma_get_payload_arprot;
+assign axi_arvalid[C_RDMA_GET_PAYLOAD_IDX *1  +: 1]    = s_axi_rdma_get_payload_arvalid;
+assign s_axi_rdma_get_payload_arready                  = axi_arready[C_RDMA_GET_PAYLOAD_IDX *1 +: 1];
+assign s_axi_rdma_get_payload_rid                      = axi_rid[C_RDMA_GET_PAYLOAD_IDX *2 +: 1];
+assign s_axi_rdma_get_payload_rdata                    = axi_rdata[C_RDMA_GET_PAYLOAD_IDX *512 +: 512];
+assign s_axi_rdma_get_payload_rresp                    = axi_rresp[C_RDMA_GET_PAYLOAD_IDX *2 +: 2];
+assign s_axi_rdma_get_payload_rlast                    = axi_rlast[C_RDMA_GET_PAYLOAD_IDX *1 +: 1];
+assign s_axi_rdma_get_payload_rvalid                   = axi_rvalid[C_RDMA_GET_PAYLOAD_IDX *1 +: 1];
+assign axi_rready [C_RDMA_GET_PAYLOAD_IDX *1 +: 1]     = s_axi_rdma_get_payload_rready;
+assign axi_arlock [C_RDMA_GET_PAYLOAD_IDX *1 +: 1]     = s_axi_rdma_get_payload_arlock;
+assign axi_arqos  [C_RDMA_GET_PAYLOAD_IDX *4 +: 4]     = s_axi_rdma_get_payload_arqos;
+
+// AXI slave signals for data access from qdma mm channel
+//assign axi_awid   [C_RDMA_COMPLETION_IDX*2 +: 2]       = {1'b0, s_axi_rdma_completion_awid};
+assign axi_awid   [C_RDMA_COMPLETION_IDX*2 +: 2]       = s_axi_rdma_completion_awvalid ? 2'd2 : 2'd0;
+assign axi_awaddr [C_RDMA_COMPLETION_IDX *64 +: 64]    = s_axi_rdma_completion_awaddr;
+assign axi_awqos  [C_RDMA_COMPLETION_IDX *4 +: 4]      = s_axi_rdma_completion_awqos;
+assign axi_awlen  [C_RDMA_COMPLETION_IDX *8 +: 8]      = s_axi_rdma_completion_awlen;
+assign axi_awsize [C_RDMA_COMPLETION_IDX *3 +: 3]      = s_axi_rdma_completion_awsize;
+assign axi_awburst[C_RDMA_COMPLETION_IDX *2 +: 2]      = s_axi_rdma_completion_awburst;
+assign axi_awcache[C_RDMA_COMPLETION_IDX *4 +: 4]      = s_axi_rdma_completion_awcache;
+assign axi_awprot [C_RDMA_COMPLETION_IDX *3 +: 3]      = s_axi_rdma_completion_awprot;
+assign axi_awvalid[C_RDMA_COMPLETION_IDX *1 +: 1]      = s_axi_rdma_completion_awvalid;
+assign s_axi_rdma_completion_awready                   = axi_awready[C_RDMA_COMPLETION_IDX *1 +: 1];
+assign axi_wdata  [C_RDMA_COMPLETION_IDX *512 +: 512]  = s_axi_rdma_completion_wdata;
+assign axi_wstrb  [C_RDMA_COMPLETION_IDX *64 +: 64]    = s_axi_rdma_completion_wstrb;
+assign axi_wlast  [C_RDMA_COMPLETION_IDX *1 +: 1]      = s_axi_rdma_completion_wlast;
+assign axi_wvalid [C_RDMA_COMPLETION_IDX *1 +: 1]      = s_axi_rdma_completion_wvalid;
+assign s_axi_rdma_completion_wready                    = axi_wready[C_RDMA_COMPLETION_IDX *1 +: 1];
+assign axi_awlock [C_RDMA_COMPLETION_IDX *1 +: 1]      = s_axi_rdma_completion_awlock;
+assign s_axi_rdma_completion_bid                       = axi_bid[C_RDMA_COMPLETION_IDX *2 +: 1];
+assign s_axi_rdma_completion_bresp                     = axi_bresp[C_RDMA_COMPLETION_IDX *2 +: 2];
+assign s_axi_rdma_completion_bvalid                    = axi_bvalid[C_RDMA_COMPLETION_IDX *1 +: 1];
+assign axi_bready [C_RDMA_COMPLETION_IDX *1 +: 1]      = s_axi_rdma_completion_bready;
+//assign axi_arid   [C_RDMA_COMPLETION_IDX *2 +: 2]      = {1'b0, s_axi_rdma_completion_arid};
+assign axi_arid   [C_RDMA_COMPLETION_IDX *2 +: 2]      = s_axi_rdma_completion_arvalid ? 2'd2 : 2'd0;
+assign axi_araddr [C_RDMA_COMPLETION_IDX *64 +: 64]    = s_axi_rdma_completion_araddr;
+assign axi_arlen  [C_RDMA_COMPLETION_IDX *8  +: 8]     = s_axi_rdma_completion_arlen;
+assign axi_arsize [C_RDMA_COMPLETION_IDX *3  +: 3]     = s_axi_rdma_completion_arsize;
+assign axi_arburst[C_RDMA_COMPLETION_IDX *2  +: 2]     = s_axi_rdma_completion_arburst;
+assign axi_arcache[C_RDMA_COMPLETION_IDX *4  +: 4]     = s_axi_rdma_completion_arcache;
+assign axi_arprot [C_RDMA_COMPLETION_IDX *3  +: 3]     = s_axi_rdma_completion_arprot;
+assign axi_arvalid[C_RDMA_COMPLETION_IDX *1  +: 1]     = s_axi_rdma_completion_arvalid;
+assign s_axi_rdma_completion_arready                   = axi_arready[C_RDMA_COMPLETION_IDX *1 +: 1];
+assign s_axi_rdma_completion_rid                       = axi_rid[C_RDMA_COMPLETION_IDX *2 +: 1];
+assign s_axi_rdma_completion_rdata                     = axi_rdata[C_RDMA_COMPLETION_IDX *512 +: 512];
+assign s_axi_rdma_completion_rresp                     = axi_rresp[C_RDMA_COMPLETION_IDX *2 +: 2];
+assign s_axi_rdma_completion_rlast                     = axi_rlast[C_RDMA_COMPLETION_IDX *1 +: 1];
+assign s_axi_rdma_completion_rvalid                    = axi_rvalid[C_RDMA_COMPLETION_IDX *1 +: 1];
+assign axi_rready [C_RDMA_COMPLETION_IDX *1 +: 1]      = s_axi_rdma_completion_rready;
+assign axi_arlock [C_RDMA_COMPLETION_IDX *1 +: 1]      = s_axi_rdma_completion_arlock;
+assign axi_arqos  [C_RDMA_COMPLETION_IDX *4 +: 4]      = s_axi_rdma_completion_arqos;
+
+dev_mem_axi_crossbar dev_mem_axi_crossbar_inst (
+  .m_axi_awaddr    (m_axi_sys_mem_awaddr),
+  .m_axi_awprot    (m_axi_sys_mem_awprot),
+  .m_axi_awvalid   (m_axi_sys_mem_awvalid),
+  .m_axi_awready   (m_axi_sys_mem_awready),
+  .m_axi_awsize    (m_axi_sys_mem_awsize),
+  .m_axi_awburst   (m_axi_sys_mem_awburst),
+  .m_axi_awcache   (m_axi_sys_mem_awcache),
+  .m_axi_awlen     (m_axi_sys_mem_awlen),
+  .m_axi_awlock    (m_axi_sys_mem_awlock),
+  .m_axi_awqos     (m_axi_sys_mem_awqos),
+  .m_axi_awregion  (m_axi_sys_mem_awregion),
+  .m_axi_awid      (m_axi_sys_mem_awid),
+  .m_axi_wdata     (m_axi_sys_mem_wdata),
+  .m_axi_wstrb     (m_axi_sys_mem_wstrb),
+  .m_axi_wvalid    (m_axi_sys_mem_wvalid),
+  .m_axi_wready    (m_axi_sys_mem_wready),
+  .m_axi_wlast     (m_axi_sys_mem_wlast),
+  .m_axi_bresp     (m_axi_sys_mem_bresp),
+  .m_axi_bvalid    (m_axi_sys_mem_bvalid),
+  .m_axi_bready    (m_axi_sys_mem_bready),
+  .m_axi_bid       (m_axi_sys_mem_bid),
+  .m_axi_araddr    (m_axi_sys_mem_araddr),
+  .m_axi_arprot    (m_axi_sys_mem_arprot),
+  .m_axi_arvalid   (m_axi_sys_mem_arvalid),
+  .m_axi_arready   (m_axi_sys_mem_arready),
+  .m_axi_arsize    (m_axi_sys_mem_arsize),
+  .m_axi_arburst   (m_axi_sys_mem_arburst),
+  .m_axi_arcache   (m_axi_sys_mem_arcache),
+  .m_axi_arlock    (m_axi_sys_mem_arlock),
+  .m_axi_arlen     (m_axi_sys_mem_arlen),
+  .m_axi_arqos     (m_axi_sys_mem_arqos),
+  .m_axi_arregion  (m_axi_sys_mem_arregion),
+  .m_axi_arid      (m_axi_sys_mem_arid),
+  .m_axi_rdata     (m_axi_sys_mem_rdata),
+  .m_axi_rresp     (m_axi_sys_mem_rresp),
+  .m_axi_rvalid    (m_axi_sys_mem_rvalid),
+  .m_axi_rready    (m_axi_sys_mem_rready),
+  .m_axi_rlast     (m_axi_sys_mem_rlast),
+  .m_axi_rid       (m_axi_sys_mem_rid),
+
+  .s_axi_awid      (axi_awid),
+  .s_axi_awaddr    (axi_awaddr),
+  .s_axi_awqos     (axi_awqos),
+  .s_axi_awlen     (axi_awlen),
+  .s_axi_awsize    (axi_awsize),
+  .s_axi_awburst   (axi_awburst),
+  .s_axi_awcache   (axi_awcache),
+  .s_axi_awprot    (axi_awprot),
+  .s_axi_awvalid   (axi_awvalid),
+  .s_axi_awready   (axi_awready),
+  .s_axi_wdata     (axi_wdata),
+  .s_axi_wstrb     (axi_wstrb),
+  .s_axi_wlast     (axi_wlast),
+  .s_axi_wvalid    (axi_wvalid),
+  .s_axi_wready    (axi_wready),
+  .s_axi_awlock    (axi_awlock),
+  .s_axi_bid       (axi_bid),
+  .s_axi_bresp     (axi_bresp),
+  .s_axi_bvalid    (axi_bvalid),
+  .s_axi_bready    (axi_bready),
+  .s_axi_arid      (axi_arid),
+  .s_axi_araddr    (axi_araddr),
+  .s_axi_arlen     (axi_arlen),
+  .s_axi_arsize    (axi_arsize),
+  .s_axi_arburst   (axi_arburst),
+  .s_axi_arcache   (axi_arcache),
+  .s_axi_arprot    (axi_arprot),
+  .s_axi_arvalid   (axi_arvalid),
+  .s_axi_arready   (axi_arready),
+  .s_axi_rid       (axi_rid),
+  .s_axi_rdata     (axi_rdata),
+  .s_axi_rresp     (axi_rresp),
+  .s_axi_rlast     (axi_rlast),
+  .s_axi_rvalid    (axi_rvalid),
+  .s_axi_rready    (axi_rready),
+  .s_axi_arlock    (axi_arlock),
+  .s_axi_arqos     (axi_arqos),
+
+  .aclk   (axis_aclk),
+  .aresetn(axis_arestn)
+);
+
+endmodule: axi_interconnect_to_sys_mem
\ No newline at end of file
diff --git a/src/utility/axi_lite_slave.sv b/src/utility/axi_lite_slave.sv
index 4b63770..c30ef12 100644
--- a/src/utility/axi_lite_slave.sv
+++ b/src/utility/axi_lite_slave.sv
@@ -59,7 +59,7 @@ module axi_lite_slave #(
     .DATA_W        (32)
   ) axil_reg_inst (
     .s_axil_awvalid (s_axil_awvalid),
-    .s_axil_awaddr  (s_axil_awaddr),
+    .s_axil_awaddr  (s_axil_awaddr[REG_ADDR_W-1:0]),
     .s_axil_awready (s_axil_awready),
     .s_axil_wvalid  (s_axil_wvalid),
     .s_axil_wdata   (s_axil_wdata),
@@ -68,7 +68,7 @@ module axi_lite_slave #(
     .s_axil_bresp   (s_axil_bresp),
     .s_axil_bready  (s_axil_bready),
     .s_axil_arvalid (s_axil_arvalid),
-    .s_axil_araddr  (s_axil_araddr),
+    .s_axil_araddr  (s_axil_araddr[REG_ADDR_W-1:0]),
     .s_axil_arready (s_axil_arready),
     .s_axil_rvalid  (s_axil_rvalid),
     .s_axil_rdata   (s_axil_rdata),
diff --git a/src/utility/axi_stream_packet_buffer.sv b/src/utility/axi_stream_packet_buffer.sv
old mode 100644
new mode 100755
index aa33d14..4750d0b
--- a/src/utility/axi_stream_packet_buffer.sv
+++ b/src/utility/axi_stream_packet_buffer.sv
@@ -128,25 +128,13 @@ module axi_stream_packet_buffer #(
 
   // The `drop_busy` signal synchronizes with the packet stream `axis_*`.  When
   // asserted, the corresponding beat is not written into the RAM.
-  assign drop_busy = drop || drop_in_prog;
-
-  always @(posedge s_aclk) begin
-    if (~s_aresetn) begin
-      drop_in_prog <= 1'b0;
-    end
-    else if (s_axis_tvalid && s_axis_tlast && s_axis_tready) begin
-      drop_in_prog <= 1'b0;
-    end
-    else if (drop) begin
-      drop_in_prog <= 1'b1;
-    end
-  end
+  assign drop_busy = drop || dropped;
 
   always @(posedge s_aclk) begin
     if (~s_aresetn) begin
       dropped <= 1'b0;
     end
-    else if (s_axis_tvalid && s_axis_tlast && s_axis_tready && drop_in_prog) begin
+    else if (s_axis_tvalid && s_axis_tlast && s_axis_tready && drop) begin
       dropped <= 1'b1;
     end
     else begin
diff --git a/src/utility/vivado_ip/axi_clock_converter_for_mem_au250.tcl b/src/utility/vivado_ip/axi_clock_converter_for_mem_au250.tcl
new file mode 100755
index 0000000..e2139be
--- /dev/null
+++ b/src/utility/vivado_ip/axi_clock_converter_for_mem_au250.tcl
@@ -0,0 +1,34 @@
+# *************************************************************************
+#
+# Copyright 2023 Xilinx, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# *************************************************************************
+set axi_clock_converter axi_clock_converter_for_mem
+create_ip -name axi_clock_converter -vendor xilinx.com -library ip -module_name $axi_clock_converter -dir ${ip_build_dir}
+set_property -dict {
+    CONFIG.PROTOCOL {AXI4}
+    CONFIG.READ_WRITE_MODE {READ_WRITE}
+    CONFIG.ADDR_WIDTH {34}
+    CONFIG.DATA_WIDTH {512}
+    CONFIG.ID_WIDTH {5}
+    CONFIG.AWUSER_WIDTH {0}
+    CONFIG.ARUSER_WIDTH {0}
+    CONFIG.RUSER_WIDTH {0}
+    CONFIG.WUSER_WIDTH {0}
+    CONFIG.BUSER_WIDTH {0}
+    CONFIG.ACLK_ASYNC {1}
+    CONFIG.SYNCHRONIZATION_STAGES {3}
+    CONFIG.ACLK_RATIO {1:2}
+} [get_ips $axi_clock_converter]
\ No newline at end of file
diff --git a/src/utility/vivado_ip/dev_mem_3to1_axi_crossbar.tcl b/src/utility/vivado_ip/dev_mem_3to1_axi_crossbar.tcl
new file mode 100755
index 0000000..cd11cb6
--- /dev/null
+++ b/src/utility/vivado_ip/dev_mem_3to1_axi_crossbar.tcl
@@ -0,0 +1,42 @@
+# *************************************************************************
+#
+# Copyright 2022 Xilinx, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# *************************************************************************
+set device_memory_axi_crossbar dev_mem_3to1_axi_crossbar
+
+create_ip -name axi_crossbar -vendor xilinx.com -library ip -module_name $device_memory_axi_crossbar -dir ${ip_build_dir}
+
+set_property -dict {
+    CONFIG.ADDR_RANGES {1}
+    CONFIG.NUM_SI {3}
+    CONFIG.NUM_MI {1}
+    CONFIG.ADDR_WIDTH {64}
+    CONFIG.DATA_WIDTH {512}
+    CONFIG.ID_WIDTH {5}
+    CONFIG.S00_THREAD_ID_WIDTH {3}
+    CONFIG.S01_THREAD_ID_WIDTH {3}
+    CONFIG.S02_THREAD_ID_WIDTH {3}
+    CONFIG.S00_WRITE_ACCEPTANCE {8}
+    CONFIG.S01_WRITE_ACCEPTANCE {8}
+    CONFIG.S02_WRITE_ACCEPTANCE {8}
+    CONFIG.S00_READ_ACCEPTANCE {8}
+    CONFIG.S01_READ_ACCEPTANCE {8}
+    CONFIG.S02_READ_ACCEPTANCE {8}
+    CONFIG.M00_WRITE_ISSUING {16}
+    CONFIG.M00_READ_ISSUING {16}
+    CONFIG.S00_SINGLE_THREAD {0}
+    CONFIG.M00_A00_ADDR_WIDTH {64}
+} [get_ips $device_memory_axi_crossbar]
\ No newline at end of file
diff --git a/src/utility/vivado_ip/dev_mem_axi_crossbar.tcl b/src/utility/vivado_ip/dev_mem_axi_crossbar.tcl
new file mode 100644
index 0000000..87ec612
--- /dev/null
+++ b/src/utility/vivado_ip/dev_mem_axi_crossbar.tcl
@@ -0,0 +1,42 @@
+# *************************************************************************
+#
+# Copyright 2022 Xilinx, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# *************************************************************************
+set device_memory_axi_crossbar dev_mem_axi_crossbar
+
+create_ip -name axi_crossbar -vendor xilinx.com -library ip -module_name $device_memory_axi_crossbar -dir ${ip_build_dir}
+
+set_property -dict {
+    CONFIG.ADDR_RANGES {1}
+    CONFIG.NUM_SI {4}
+    CONFIG.NUM_MI {1}
+    CONFIG.ADDR_WIDTH {64}
+    CONFIG.DATA_WIDTH {512}
+    CONFIG.ID_WIDTH {2}
+    CONFIG.S15_THREAD_ID_WIDTH {0}
+    CONFIG.S00_WRITE_ACCEPTANCE {8}
+    CONFIG.S01_WRITE_ACCEPTANCE {8}
+    CONFIG.S02_WRITE_ACCEPTANCE {8}
+    CONFIG.S03_WRITE_ACCEPTANCE {8}
+    CONFIG.S00_READ_ACCEPTANCE {8}
+    CONFIG.S01_READ_ACCEPTANCE {8}
+    CONFIG.S02_READ_ACCEPTANCE {8}
+    CONFIG.S03_READ_ACCEPTANCE {8}
+    CONFIG.M00_WRITE_ISSUING {16}
+    CONFIG.M00_READ_ISSUING {16}
+    CONFIG.S00_SINGLE_THREAD {0}
+    CONFIG.M00_A00_ADDR_WIDTH {64}
+} [get_ips $device_memory_axi_crossbar]
\ No newline at end of file
diff --git a/src/utility/vivado_ip/sys_mem_5to2_axi_crossbar.tcl b/src/utility/vivado_ip/sys_mem_5to2_axi_crossbar.tcl
new file mode 100755
index 0000000..672b459
--- /dev/null
+++ b/src/utility/vivado_ip/sys_mem_5to2_axi_crossbar.tcl
@@ -0,0 +1,49 @@
+# *************************************************************************
+#
+# Copyright 2022 Xilinx, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# *************************************************************************
+set system_memory_axi_crossbar sys_mem_5to2_axi_crossbar
+
+create_ip -name axi_crossbar -vendor xilinx.com -library ip -module_name $system_memory_axi_crossbar -dir ${ip_build_dir}
+
+set_property -dict {
+    CONFIG.ADDR_RANGES {1}
+    CONFIG.NUM_SI {5}
+    CONFIG.NUM_MI {2}
+    CONFIG.ADDR_WIDTH {64}
+    CONFIG.DATA_WIDTH {512}
+    CONFIG.ID_WIDTH {3}
+    CONFIG.S15_THREAD_ID_WIDTH {0}
+    CONFIG.S00_WRITE_ACCEPTANCE {8}
+    CONFIG.S01_WRITE_ACCEPTANCE {8}
+    CONFIG.S02_WRITE_ACCEPTANCE {8}
+    CONFIG.S03_WRITE_ACCEPTANCE {8}
+    CONFIG.S04_WRITE_ACCEPTANCE {8}
+    CONFIG.S00_READ_ACCEPTANCE {8}
+    CONFIG.S01_READ_ACCEPTANCE {8}
+    CONFIG.S02_READ_ACCEPTANCE {8}
+    CONFIG.S03_READ_ACCEPTANCE {8}
+    CONFIG.S04_READ_ACCEPTANCE {8}
+    CONFIG.M00_WRITE_ISSUING {16}
+    CONFIG.M00_READ_ISSUING {16}
+    CONFIG.M01_WRITE_ISSUING {16}
+    CONFIG.M01_READ_ISSUING {16}
+    CONFIG.S00_SINGLE_THREAD {0}
+    CONFIG.M00_A00_ADDR_WIDTH {52}
+    CONFIG.M01_A00_ADDR_WIDTH {36}
+    CONFIG.M00_A00_BASE_ADDR {0x0000000000000000}
+    CONFIG.M01_A00_BASE_ADDR {0xa350000000000000}
+} [get_ips $system_memory_axi_crossbar]
\ No newline at end of file
diff --git a/src/utility/vivado_ip/sys_mem_axi_crossbar.tcl b/src/utility/vivado_ip/sys_mem_axi_crossbar.tcl
new file mode 100644
index 0000000..61c3d41
--- /dev/null
+++ b/src/utility/vivado_ip/sys_mem_axi_crossbar.tcl
@@ -0,0 +1,42 @@
+# *************************************************************************
+#
+# Copyright 2022 Xilinx, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# *************************************************************************
+set system_memory_axi_crossbar sys_mem_axi_crossbar
+
+create_ip -name axi_crossbar -vendor xilinx.com -library ip -module_name $system_memory_axi_crossbar -dir ${ip_build_dir}
+
+set_property -dict {
+    CONFIG.ADDR_RANGES {1}
+    CONFIG.NUM_SI {3}
+    CONFIG.NUM_MI {1}
+    CONFIG.ADDR_WIDTH {64}
+    CONFIG.DATA_WIDTH {512}
+    CONFIG.ID_WIDTH {2}
+    CONFIG.S15_THREAD_ID_WIDTH {0}
+    CONFIG.S00_WRITE_ACCEPTANCE {8}
+    CONFIG.S01_WRITE_ACCEPTANCE {8}
+    CONFIG.S02_WRITE_ACCEPTANCE {8}
+    CONFIG.S03_WRITE_ACCEPTANCE {8}
+    CONFIG.S00_READ_ACCEPTANCE {8}
+    CONFIG.S01_READ_ACCEPTANCE {8}
+    CONFIG.S02_READ_ACCEPTANCE {8}
+    CONFIG.S03_READ_ACCEPTANCE {8}
+    CONFIG.M00_WRITE_ISSUING {16}
+    CONFIG.M00_READ_ISSUING {16}
+    CONFIG.S00_SINGLE_THREAD {0}
+    CONFIG.M00_A00_ADDR_WIDTH {64}
+} [get_ips $system_memory_axi_crossbar]
\ No newline at end of file
diff --git a/src/utility/vivado_ip/vivado_ip.tcl b/src/utility/vivado_ip/vivado_ip.tcl
index 62f583e..76bfc67 100644
--- a/src/utility/vivado_ip/vivado_ip.tcl
+++ b/src/utility/vivado_ip/vivado_ip.tcl
@@ -1,6 +1,6 @@
 # *************************************************************************
 #
-# Copyright 2020 Xilinx, Inc.
+# Copyright 2023 Xilinx, Inc.
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
@@ -18,4 +18,7 @@
 set ips {
     axi_stream_pipeline
     axi_lite_clock_converter
+    dev_mem_3to1_axi_crossbar
+    sys_mem_5to2_axi_crossbar
+    axi_clock_converter_for_mem
 }
